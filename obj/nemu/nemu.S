
nemu:     file format elf32-i386


Disassembly of section .init:

08048904 <_init>:
 8048904:	53                   	push   %ebx
 8048905:	83 ec 08             	sub    $0x8,%esp
 8048908:	e8 93 03 00 00       	call   8048ca0 <__x86.get_pc_thunk.bx>
 804890d:	81 c3 f3 c7 02 00    	add    $0x2c7f3,%ebx
 8048913:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048919:	85 c0                	test   %eax,%eax
 804891b:	74 05                	je     8048922 <_init+0x1e>
 804891d:	e8 4e 01 00 00       	call   8048a70 <__gmon_start__@plt>
 8048922:	83 c4 08             	add    $0x8,%esp
 8048925:	5b                   	pop    %ebx
 8048926:	c3                   	ret    

Disassembly of section .plt:

08048930 <strcmp@plt-0x10>:
 8048930:	ff 35 04 51 07 08    	pushl  0x8075104
 8048936:	ff 25 08 51 07 08    	jmp    *0x8075108
 804893c:	00 00                	add    %al,(%eax)
	...

08048940 <strcmp@plt>:
 8048940:	ff 25 0c 51 07 08    	jmp    *0x807510c
 8048946:	68 00 00 00 00       	push   $0x0
 804894b:	e9 e0 ff ff ff       	jmp    8048930 <_init+0x2c>

08048950 <printf@plt>:
 8048950:	ff 25 10 51 07 08    	jmp    *0x8075110
 8048956:	68 08 00 00 00       	push   $0x8
 804895b:	e9 d0 ff ff ff       	jmp    8048930 <_init+0x2c>

08048960 <fflush@plt>:
 8048960:	ff 25 14 51 07 08    	jmp    *0x8075114
 8048966:	68 10 00 00 00       	push   $0x10
 804896b:	e9 c0 ff ff ff       	jmp    8048930 <_init+0x2c>

08048970 <_setjmp@plt>:
 8048970:	ff 25 18 51 07 08    	jmp    *0x8075118
 8048976:	68 18 00 00 00       	push   $0x18
 804897b:	e9 b0 ff ff ff       	jmp    8048930 <_init+0x2c>

08048980 <free@plt>:
 8048980:	ff 25 1c 51 07 08    	jmp    *0x807511c
 8048986:	68 20 00 00 00       	push   $0x20
 804898b:	e9 a0 ff ff ff       	jmp    8048930 <_init+0x2c>

08048990 <add_history@plt>:
 8048990:	ff 25 20 51 07 08    	jmp    *0x8075120
 8048996:	68 28 00 00 00       	push   $0x28
 804899b:	e9 90 ff ff ff       	jmp    8048930 <_init+0x2c>

080489a0 <memcpy@plt>:
 80489a0:	ff 25 24 51 07 08    	jmp    *0x8075124
 80489a6:	68 30 00 00 00       	push   $0x30
 80489ab:	e9 80 ff ff ff       	jmp    8048930 <_init+0x2c>

080489b0 <fclose@plt>:
 80489b0:	ff 25 28 51 07 08    	jmp    *0x8075128
 80489b6:	68 38 00 00 00       	push   $0x38
 80489bb:	e9 70 ff ff ff       	jmp    8048930 <_init+0x2c>

080489c0 <time@plt>:
 80489c0:	ff 25 2c 51 07 08    	jmp    *0x807512c
 80489c6:	68 40 00 00 00       	push   $0x40
 80489cb:	e9 60 ff ff ff       	jmp    8048930 <_init+0x2c>

080489d0 <memcmp@plt>:
 80489d0:	ff 25 30 51 07 08    	jmp    *0x8075130
 80489d6:	68 48 00 00 00       	push   $0x48
 80489db:	e9 50 ff ff ff       	jmp    8048930 <_init+0x2c>

080489e0 <_IO_putc@plt>:
 80489e0:	ff 25 34 51 07 08    	jmp    *0x8075134
 80489e6:	68 50 00 00 00       	push   $0x50
 80489eb:	e9 40 ff ff ff       	jmp    8048930 <_init+0x2c>

080489f0 <fseek@plt>:
 80489f0:	ff 25 38 51 07 08    	jmp    *0x8075138
 80489f6:	68 58 00 00 00       	push   $0x58
 80489fb:	e9 30 ff ff ff       	jmp    8048930 <_init+0x2c>

08048a00 <readline@plt>:
 8048a00:	ff 25 3c 51 07 08    	jmp    *0x807513c
 8048a06:	68 60 00 00 00       	push   $0x60
 8048a0b:	e9 20 ff ff ff       	jmp    8048930 <_init+0x2c>

08048a10 <fwrite@plt>:
 8048a10:	ff 25 40 51 07 08    	jmp    *0x8075140
 8048a16:	68 68 00 00 00       	push   $0x68
 8048a1b:	e9 10 ff ff ff       	jmp    8048930 <_init+0x2c>

08048a20 <strcat@plt>:
 8048a20:	ff 25 44 51 07 08    	jmp    *0x8075144
 8048a26:	68 70 00 00 00       	push   $0x70
 8048a2b:	e9 00 ff ff ff       	jmp    8048930 <_init+0x2c>

08048a30 <fread@plt>:
 8048a30:	ff 25 48 51 07 08    	jmp    *0x8075148
 8048a36:	68 78 00 00 00       	push   $0x78
 8048a3b:	e9 f0 fe ff ff       	jmp    8048930 <_init+0x2c>

08048a40 <strcpy@plt>:
 8048a40:	ff 25 4c 51 07 08    	jmp    *0x807514c
 8048a46:	68 80 00 00 00       	push   $0x80
 8048a4b:	e9 e0 fe ff ff       	jmp    8048930 <_init+0x2c>

08048a50 <malloc@plt>:
 8048a50:	ff 25 50 51 07 08    	jmp    *0x8075150
 8048a56:	68 88 00 00 00       	push   $0x88
 8048a5b:	e9 d0 fe ff ff       	jmp    8048930 <_init+0x2c>

08048a60 <puts@plt>:
 8048a60:	ff 25 54 51 07 08    	jmp    *0x8075154
 8048a66:	68 90 00 00 00       	push   $0x90
 8048a6b:	e9 c0 fe ff ff       	jmp    8048930 <_init+0x2c>

08048a70 <__gmon_start__@plt>:
 8048a70:	ff 25 58 51 07 08    	jmp    *0x8075158
 8048a76:	68 98 00 00 00       	push   $0x98
 8048a7b:	e9 b0 fe ff ff       	jmp    8048930 <_init+0x2c>

08048a80 <feof@plt>:
 8048a80:	ff 25 5c 51 07 08    	jmp    *0x807515c
 8048a86:	68 a0 00 00 00       	push   $0xa0
 8048a8b:	e9 a0 fe ff ff       	jmp    8048930 <_init+0x2c>

08048a90 <srand@plt>:
 8048a90:	ff 25 60 51 07 08    	jmp    *0x8075160
 8048a96:	68 a8 00 00 00       	push   $0xa8
 8048a9b:	e9 90 fe ff ff       	jmp    8048930 <_init+0x2c>

08048aa0 <strlen@plt>:
 8048aa0:	ff 25 64 51 07 08    	jmp    *0x8075164
 8048aa6:	68 b0 00 00 00       	push   $0xb0
 8048aab:	e9 80 fe ff ff       	jmp    8048930 <_init+0x2c>

08048ab0 <__libc_start_main@plt>:
 8048ab0:	ff 25 68 51 07 08    	jmp    *0x8075168
 8048ab6:	68 b8 00 00 00       	push   $0xb8
 8048abb:	e9 70 fe ff ff       	jmp    8048930 <_init+0x2c>

08048ac0 <fprintf@plt>:
 8048ac0:	ff 25 6c 51 07 08    	jmp    *0x807516c
 8048ac6:	68 c0 00 00 00       	push   $0xc0
 8048acb:	e9 60 fe ff ff       	jmp    8048930 <_init+0x2c>

08048ad0 <ftell@plt>:
 8048ad0:	ff 25 70 51 07 08    	jmp    *0x8075170
 8048ad6:	68 c8 00 00 00       	push   $0xc8
 8048adb:	e9 50 fe ff ff       	jmp    8048930 <_init+0x2c>

08048ae0 <fopen@plt>:
 8048ae0:	ff 25 74 51 07 08    	jmp    *0x8075174
 8048ae6:	68 d0 00 00 00       	push   $0xd0
 8048aeb:	e9 40 fe ff ff       	jmp    8048930 <_init+0x2c>

08048af0 <memset@plt>:
 8048af0:	ff 25 78 51 07 08    	jmp    *0x8075178
 8048af6:	68 d8 00 00 00       	push   $0xd8
 8048afb:	e9 30 fe ff ff       	jmp    8048930 <_init+0x2c>

08048b00 <snprintf@plt>:
 8048b00:	ff 25 7c 51 07 08    	jmp    *0x807517c
 8048b06:	68 e0 00 00 00       	push   $0xe0
 8048b0b:	e9 20 fe ff ff       	jmp    8048930 <_init+0x2c>

08048b10 <putchar@plt>:
 8048b10:	ff 25 80 51 07 08    	jmp    *0x8075180
 8048b16:	68 e8 00 00 00       	push   $0xe8
 8048b1b:	e9 10 fe ff ff       	jmp    8048930 <_init+0x2c>

08048b20 <regerror@plt>:
 8048b20:	ff 25 84 51 07 08    	jmp    *0x8075184
 8048b26:	68 f0 00 00 00       	push   $0xf0
 8048b2b:	e9 00 fe ff ff       	jmp    8048930 <_init+0x2c>

08048b30 <strncpy@plt>:
 8048b30:	ff 25 88 51 07 08    	jmp    *0x8075188
 8048b36:	68 f8 00 00 00       	push   $0xf8
 8048b3b:	e9 f0 fd ff ff       	jmp    8048930 <_init+0x2c>

08048b40 <regexec@plt>:
 8048b40:	ff 25 8c 51 07 08    	jmp    *0x807518c
 8048b46:	68 00 01 00 00       	push   $0x100
 8048b4b:	e9 e0 fd ff ff       	jmp    8048930 <_init+0x2c>

08048b50 <rand@plt>:
 8048b50:	ff 25 90 51 07 08    	jmp    *0x8075190
 8048b56:	68 08 01 00 00       	push   $0x108
 8048b5b:	e9 d0 fd ff ff       	jmp    8048930 <_init+0x2c>

08048b60 <strtok@plt>:
 8048b60:	ff 25 94 51 07 08    	jmp    *0x8075194
 8048b66:	68 10 01 00 00       	push   $0x110
 8048b6b:	e9 c0 fd ff ff       	jmp    8048930 <_init+0x2c>

08048b70 <fputc@plt>:
 8048b70:	ff 25 98 51 07 08    	jmp    *0x8075198
 8048b76:	68 18 01 00 00       	push   $0x118
 8048b7b:	e9 b0 fd ff ff       	jmp    8048930 <_init+0x2c>

08048b80 <regcomp@plt>:
 8048b80:	ff 25 9c 51 07 08    	jmp    *0x807519c
 8048b86:	68 20 01 00 00       	push   $0x120
 8048b8b:	e9 a0 fd ff ff       	jmp    8048930 <_init+0x2c>

08048b90 <sprintf@plt>:
 8048b90:	ff 25 a0 51 07 08    	jmp    *0x80751a0
 8048b96:	68 28 01 00 00       	push   $0x128
 8048b9b:	e9 90 fd ff ff       	jmp    8048930 <_init+0x2c>

08048ba0 <strtol@plt>:
 8048ba0:	ff 25 a4 51 07 08    	jmp    *0x80751a4
 8048ba6:	68 30 01 00 00       	push   $0x130
 8048bab:	e9 80 fd ff ff       	jmp    8048930 <_init+0x2c>

08048bb0 <__assert_fail@plt>:
 8048bb0:	ff 25 a8 51 07 08    	jmp    *0x80751a8
 8048bb6:	68 38 01 00 00       	push   $0x138
 8048bbb:	e9 70 fd ff ff       	jmp    8048930 <_init+0x2c>

Disassembly of section .text:

08048bc0 <check_reg_index.part.0>:

static inline void init_cpu_state() {
	init_cr0();
}

static inline int check_reg_index(int index) {
 8048bc0:	83 ec 0c             	sub    $0xc,%esp
	assert(index >= 0 && index < 8);
 8048bc3:	68 8b f5 05 08       	push   $0x805f58b
 8048bc8:	6a 61                	push   $0x61
 8048bca:	68 1b f3 05 08       	push   $0x805f31b
 8048bcf:	68 32 f3 05 08       	push   $0x805f332
 8048bd4:	e8 d7 ff ff ff       	call   8048bb0 <__assert_fail@plt>

08048bd9 <check_reg_index.part.0>:

static inline void init_cpu_state() {
	init_cr0();
}

static inline int check_reg_index(int index) {
 8048bd9:	83 ec 0c             	sub    $0xc,%esp
	assert(index >= 0 && index < 8);
 8048bdc:	68 19 0b 06 08       	push   $0x8060b19
 8048be1:	6a 61                	push   $0x61
 8048be3:	68 1b f3 05 08       	push   $0x805f31b
 8048be8:	68 32 f3 05 08       	push   $0x805f332
 8048bed:	e8 be ff ff ff       	call   8048bb0 <__assert_fail@plt>

08048bf2 <check_reg_index.part.0>:

static inline void init_cpu_state() {
	init_cr0();
}

static inline int check_reg_index(int index) {
 8048bf2:	83 ec 0c             	sub    $0xc,%esp
	assert(index >= 0 && index < 8);
 8048bf5:	68 a9 0f 06 08       	push   $0x8060fa9
 8048bfa:	6a 61                	push   $0x61
 8048bfc:	68 1b f3 05 08       	push   $0x805f31b
 8048c01:	68 32 f3 05 08       	push   $0x805f332
 8048c06:	e8 a5 ff ff ff       	call   8048bb0 <__assert_fail@plt>

08048c0b <check_reg_index.part.0>:

static inline void init_cpu_state() {
	init_cr0();
}

static inline int check_reg_index(int index) {
 8048c0b:	83 ec 0c             	sub    $0xc,%esp
	assert(index >= 0 && index < 8);
 8048c0e:	68 12 5f 06 08       	push   $0x8065f12
 8048c13:	6a 61                	push   $0x61
 8048c15:	68 1b f3 05 08       	push   $0x805f31b
 8048c1a:	68 32 f3 05 08       	push   $0x805f332
 8048c1f:	e8 8c ff ff ff       	call   8048bb0 <__assert_fail@plt>

08048c24 <check_reg_index.part.0>:

static inline void init_cpu_state() {
	init_cr0();
}

static inline int check_reg_index(int index) {
 8048c24:	83 ec 0c             	sub    $0xc,%esp
	assert(index >= 0 && index < 8);
 8048c27:	68 6e 5f 06 08       	push   $0x8065f6e
 8048c2c:	6a 61                	push   $0x61
 8048c2e:	68 1b f3 05 08       	push   $0x805f31b
 8048c33:	68 32 f3 05 08       	push   $0x805f332
 8048c38:	e8 73 ff ff ff       	call   8048bb0 <__assert_fail@plt>
 8048c3d:	66 90                	xchg   %ax,%ax
 8048c3f:	90                   	nop

08048c40 <main>:
void init_monitor(int, char *[]);
void reg_test();
void restart();
void ui_mainloop();

int main(int argc, char *argv[]) {
 8048c40:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 8048c44:	83 e4 f0             	and    $0xfffffff0,%esp
 8048c47:	ff 71 fc             	pushl  -0x4(%ecx)
 8048c4a:	55                   	push   %ebp
 8048c4b:	89 e5                	mov    %esp,%ebp
 8048c4d:	51                   	push   %ecx
 8048c4e:	83 ec 0c             	sub    $0xc,%esp

	/* Initialize the monitor. */
	init_monitor(argc, argv);
 8048c51:	ff 71 04             	pushl  0x4(%ecx)
 8048c54:	ff 31                	pushl  (%ecx)
 8048c56:	e8 15 01 00 00       	call   8048d70 <init_monitor>

	/* Test the implementation of the ``CPU_state'' structure. */
	reg_test();
 8048c5b:	e8 60 4b 01 00       	call   805d7c0 <reg_test>

	/* Initialize the virtual computer system. */
	restart();
 8048c60:	e8 eb 01 00 00       	call   8048e50 <restart>

	/* Receive commands from user. */
	ui_mainloop();
 8048c65:	e8 d6 0f 00 00       	call   8049c40 <ui_mainloop>

	return 0;
}
 8048c6a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
	restart();

	/* Receive commands from user. */
	ui_mainloop();

	return 0;
 8048c6d:	83 c4 10             	add    $0x10,%esp
}
 8048c70:	31 c0                	xor    %eax,%eax
 8048c72:	c9                   	leave  
 8048c73:	8d 61 fc             	lea    -0x4(%ecx),%esp
 8048c76:	c3                   	ret    

08048c77 <_start>:
 8048c77:	31 ed                	xor    %ebp,%ebp
 8048c79:	5e                   	pop    %esi
 8048c7a:	89 e1                	mov    %esp,%ecx
 8048c7c:	83 e4 f0             	and    $0xfffffff0,%esp
 8048c7f:	50                   	push   %eax
 8048c80:	54                   	push   %esp
 8048c81:	52                   	push   %edx
 8048c82:	68 50 ed 05 08       	push   $0x805ed50
 8048c87:	68 e0 ec 05 08       	push   $0x805ece0
 8048c8c:	51                   	push   %ecx
 8048c8d:	56                   	push   %esi
 8048c8e:	68 40 8c 04 08       	push   $0x8048c40
 8048c93:	e8 18 fe ff ff       	call   8048ab0 <__libc_start_main@plt>
 8048c98:	f4                   	hlt    
 8048c99:	66 90                	xchg   %ax,%ax
 8048c9b:	66 90                	xchg   %ax,%ax
 8048c9d:	66 90                	xchg   %ax,%ax
 8048c9f:	90                   	nop

08048ca0 <__x86.get_pc_thunk.bx>:
 8048ca0:	8b 1c 24             	mov    (%esp),%ebx
 8048ca3:	c3                   	ret    
 8048ca4:	66 90                	xchg   %ax,%ax
 8048ca6:	66 90                	xchg   %ax,%ax
 8048ca8:	66 90                	xchg   %ax,%ax
 8048caa:	66 90                	xchg   %ax,%ax
 8048cac:	66 90                	xchg   %ax,%ax
 8048cae:	66 90                	xchg   %ax,%ax

08048cb0 <deregister_tm_clones>:
 8048cb0:	b8 e3 5b 07 08       	mov    $0x8075be3,%eax
 8048cb5:	2d e0 5b 07 08       	sub    $0x8075be0,%eax
 8048cba:	83 f8 06             	cmp    $0x6,%eax
 8048cbd:	76 1a                	jbe    8048cd9 <deregister_tm_clones+0x29>
 8048cbf:	b8 00 00 00 00       	mov    $0x0,%eax
 8048cc4:	85 c0                	test   %eax,%eax
 8048cc6:	74 11                	je     8048cd9 <deregister_tm_clones+0x29>
 8048cc8:	55                   	push   %ebp
 8048cc9:	89 e5                	mov    %esp,%ebp
 8048ccb:	83 ec 14             	sub    $0x14,%esp
 8048cce:	68 e0 5b 07 08       	push   $0x8075be0
 8048cd3:	ff d0                	call   *%eax
 8048cd5:	83 c4 10             	add    $0x10,%esp
 8048cd8:	c9                   	leave  
 8048cd9:	f3 c3                	repz ret 
 8048cdb:	90                   	nop
 8048cdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08048ce0 <register_tm_clones>:
 8048ce0:	b8 e0 5b 07 08       	mov    $0x8075be0,%eax
 8048ce5:	2d e0 5b 07 08       	sub    $0x8075be0,%eax
 8048cea:	c1 f8 02             	sar    $0x2,%eax
 8048ced:	89 c2                	mov    %eax,%edx
 8048cef:	c1 ea 1f             	shr    $0x1f,%edx
 8048cf2:	01 d0                	add    %edx,%eax
 8048cf4:	d1 f8                	sar    %eax
 8048cf6:	74 1b                	je     8048d13 <register_tm_clones+0x33>
 8048cf8:	ba 00 00 00 00       	mov    $0x0,%edx
 8048cfd:	85 d2                	test   %edx,%edx
 8048cff:	74 12                	je     8048d13 <register_tm_clones+0x33>
 8048d01:	55                   	push   %ebp
 8048d02:	89 e5                	mov    %esp,%ebp
 8048d04:	83 ec 10             	sub    $0x10,%esp
 8048d07:	50                   	push   %eax
 8048d08:	68 e0 5b 07 08       	push   $0x8075be0
 8048d0d:	ff d2                	call   *%edx
 8048d0f:	83 c4 10             	add    $0x10,%esp
 8048d12:	c9                   	leave  
 8048d13:	f3 c3                	repz ret 
 8048d15:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8048d19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08048d20 <__do_global_dtors_aux>:
 8048d20:	80 3d 24 5c 07 08 00 	cmpb   $0x0,0x8075c24
 8048d27:	75 13                	jne    8048d3c <__do_global_dtors_aux+0x1c>
 8048d29:	55                   	push   %ebp
 8048d2a:	89 e5                	mov    %esp,%ebp
 8048d2c:	83 ec 08             	sub    $0x8,%esp
 8048d2f:	e8 7c ff ff ff       	call   8048cb0 <deregister_tm_clones>
 8048d34:	c6 05 24 5c 07 08 01 	movb   $0x1,0x8075c24
 8048d3b:	c9                   	leave  
 8048d3c:	f3 c3                	repz ret 
 8048d3e:	66 90                	xchg   %ax,%ax

08048d40 <frame_dummy>:
 8048d40:	b8 08 50 07 08       	mov    $0x8075008,%eax
 8048d45:	8b 10                	mov    (%eax),%edx
 8048d47:	85 d2                	test   %edx,%edx
 8048d49:	75 05                	jne    8048d50 <frame_dummy+0x10>
 8048d4b:	eb 93                	jmp    8048ce0 <register_tm_clones>
 8048d4d:	8d 76 00             	lea    0x0(%esi),%esi
 8048d50:	ba 00 00 00 00       	mov    $0x0,%edx
 8048d55:	85 d2                	test   %edx,%edx
 8048d57:	74 f2                	je     8048d4b <frame_dummy+0xb>
 8048d59:	55                   	push   %ebp
 8048d5a:	89 e5                	mov    %esp,%ebp
 8048d5c:	83 ec 14             	sub    $0x14,%esp
 8048d5f:	50                   	push   %eax
 8048d60:	ff d2                	call   *%edx
 8048d62:	83 c4 10             	add    $0x10,%esp
 8048d65:	c9                   	leave  
 8048d66:	e9 75 ff ff ff       	jmp    8048ce0 <register_tm_clones>
 8048d6b:	66 90                	xchg   %ax,%ax
 8048d6d:	66 90                	xchg   %ax,%ax
 8048d6f:	90                   	nop

08048d70 <init_monitor>:
static void welcome() {
	printf("Welcome to NEMU!\nThe executable is %s.\nFor help, type \"help\"\n",
			exec_file);
}

void init_monitor(int argc, char *argv[]) {
 8048d70:	56                   	push   %esi
 8048d71:	53                   	push   %ebx
 8048d72:	83 ec 0c             	sub    $0xc,%esp
 8048d75:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 8048d79:	8b 74 24 1c          	mov    0x1c(%esp),%esi
void init_cpu_state();

FILE *log_fp = NULL;

static void init_log() {
	log_fp = fopen("log.txt", "w");
 8048d7d:	68 88 ed 05 08       	push   $0x805ed88
 8048d82:	68 8a ed 05 08       	push   $0x805ed8a
 8048d87:	e8 54 fd ff ff       	call   8048ae0 <fopen@plt>
	Assert(log_fp, "Can not open 'log.txt'");
 8048d8c:	83 c4 10             	add    $0x10,%esp
 8048d8f:	85 c0                	test   %eax,%eax
void init_cpu_state();

FILE *log_fp = NULL;

static void init_log() {
	log_fp = fopen("log.txt", "w");
 8048d91:	a3 28 5c 07 08       	mov    %eax,0x8075c28
	Assert(log_fp, "Can not open 'log.txt'");
 8048d96:	74 38                	je     8048dd0 <init_monitor+0x60>

	/* Open the log file. */
	init_log();

	/* Load the string table and symbol table from the ELF file for future use. */
	load_elf_tables(argc, argv);
 8048d98:	83 ec 08             	sub    $0x8,%esp
 8048d9b:	56                   	push   %esi
 8048d9c:	53                   	push   %ebx
 8048d9d:	e8 2e 03 00 00       	call   80490d0 <load_elf_tables>

	/* Compile the regular expressions. */
	init_regex();
 8048da2:	e8 29 12 00 00       	call   8049fd0 <init_regex>

	/* Initialize the watchpoint link list. */
	init_wp_list();
 8048da7:	e8 54 0f 00 00       	call   8049d00 <init_wp_list>
	log_fp = fopen("log.txt", "w");
	Assert(log_fp, "Can not open 'log.txt'");
}

static void welcome() {
	printf("Welcome to NEMU!\nThe executable is %s.\nFor help, type \"help\"\n",
 8048dac:	a1 2c 5c 07 08       	mov    0x8075c2c,%eax
 8048db1:	c7 44 24 20 48 ee 05 	movl   $0x805ee48,0x20(%esp)
 8048db8:	08 
 8048db9:	89 44 24 24          	mov    %eax,0x24(%esp)
	/* Initialize the watchpoint link list. */
	init_wp_list();

	/* Display welcome message. */
	welcome();
}
 8048dbd:	83 c4 14             	add    $0x14,%esp
 8048dc0:	5b                   	pop    %ebx
 8048dc1:	5e                   	pop    %esi
	log_fp = fopen("log.txt", "w");
	Assert(log_fp, "Can not open 'log.txt'");
}

static void welcome() {
	printf("Welcome to NEMU!\nThe executable is %s.\nFor help, type \"help\"\n",
 8048dc2:	e9 89 fb ff ff       	jmp    8048950 <printf@plt>
 8048dc7:	89 f6                	mov    %esi,%esi
 8048dc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

FILE *log_fp = NULL;

static void init_log() {
	log_fp = fopen("log.txt", "w");
	Assert(log_fp, "Can not open 'log.txt'");
 8048dd0:	83 ec 0c             	sub    $0xc,%esp
 8048dd3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8048dd9:	e8 82 fb ff ff       	call   8048960 <fflush@plt>
 8048dde:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8048de4:	6a 07                	push   $0x7
 8048de6:	6a 01                	push   $0x1
 8048de8:	68 92 ed 05 08       	push   $0x805ed92
 8048ded:	e8 1e fc ff ff       	call   8048a10 <fwrite@plt>
 8048df2:	83 c4 20             	add    $0x20,%esp
 8048df5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8048dfb:	6a 16                	push   $0x16
 8048dfd:	6a 01                	push   $0x1
 8048dff:	68 9a ed 05 08       	push   $0x805ed9a
 8048e04:	e8 07 fc ff ff       	call   8048a10 <fwrite@plt>
 8048e09:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8048e0f:	6a 05                	push   $0x5
 8048e11:	6a 01                	push   $0x1
 8048e13:	68 b1 ed 05 08       	push   $0x805edb1
 8048e18:	e8 f3 fb ff ff       	call   8048a10 <fwrite@plt>
 8048e1d:	a1 28 5c 07 08       	mov    0x8075c28,%eax
 8048e22:	83 c4 20             	add    $0x20,%esp
 8048e25:	85 c0                	test   %eax,%eax
 8048e27:	0f 85 6b ff ff ff    	jne    8048d98 <init_monitor+0x28>
 8048e2d:	68 9e ee 05 08       	push   $0x805ee9e
 8048e32:	6a 15                	push   $0x15
 8048e34:	68 b7 ed 05 08       	push   $0x805edb7
 8048e39:	68 d2 ed 05 08       	push   $0x805edd2
 8048e3e:	e8 6d fd ff ff       	call   8048bb0 <__assert_fail@plt>
 8048e43:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8048e49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08048e50 <restart>:
	ret = fread(hwa_to_va(ENTRY_START), file_size, 1, fp);
	assert(ret == 1);
	fclose(fp);
}

void restart() {
 8048e50:	56                   	push   %esi
 8048e51:	53                   	push   %ebx
 8048e52:	83 ec 0c             	sub    $0xc,%esp

#ifdef USE_RAMDISK
static void init_ramdisk() {
	int ret;
	const int ramdisk_max_size = 0xa0000;
	FILE *fp = fopen(exec_file, "rb");
 8048e55:	68 d9 ed 05 08       	push   $0x805edd9
 8048e5a:	ff 35 2c 5c 07 08    	pushl  0x8075c2c
 8048e60:	e8 7b fc ff ff       	call   8048ae0 <fopen@plt>
	Assert(fp, "Can not open '%s'", exec_file);
 8048e65:	83 c4 10             	add    $0x10,%esp
 8048e68:	85 c0                	test   %eax,%eax

#ifdef USE_RAMDISK
static void init_ramdisk() {
	int ret;
	const int ramdisk_max_size = 0xa0000;
	FILE *fp = fopen(exec_file, "rb");
 8048e6a:	89 c3                	mov    %eax,%ebx
	Assert(fp, "Can not open '%s'", exec_file);
 8048e6c:	0f 84 56 01 00 00    	je     8048fc8 <restart+0x178>

	fseek(fp, 0, SEEK_END);
 8048e72:	83 ec 04             	sub    $0x4,%esp
 8048e75:	6a 02                	push   $0x2
 8048e77:	6a 00                	push   $0x0
 8048e79:	50                   	push   %eax
 8048e7a:	e8 71 fb ff ff       	call   80489f0 <fseek@plt>
	size_t file_size = ftell(fp);
 8048e7f:	89 1c 24             	mov    %ebx,(%esp)
 8048e82:	e8 49 fc ff ff       	call   8048ad0 <ftell@plt>
	Assert(file_size < ramdisk_max_size, "file size(%zd) too large", file_size);
 8048e87:	83 c4 10             	add    $0x10,%esp
 8048e8a:	3d ff ff 09 00       	cmp    $0x9ffff,%eax
	const int ramdisk_max_size = 0xa0000;
	FILE *fp = fopen(exec_file, "rb");
	Assert(fp, "Can not open '%s'", exec_file);

	fseek(fp, 0, SEEK_END);
	size_t file_size = ftell(fp);
 8048e8f:	89 c6                	mov    %eax,%esi
	Assert(file_size < ramdisk_max_size, "file size(%zd) too large", file_size);
 8048e91:	76 6d                	jbe    8048f00 <restart+0xb0>
 8048e93:	83 ec 0c             	sub    $0xc,%esp
 8048e96:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8048e9c:	e8 bf fa ff ff       	call   8048960 <fflush@plt>
 8048ea1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8048ea7:	6a 07                	push   $0x7
 8048ea9:	6a 01                	push   $0x1
 8048eab:	68 92 ed 05 08       	push   $0x805ed92
 8048eb0:	e8 5b fb ff ff       	call   8048a10 <fwrite@plt>
 8048eb5:	83 c4 1c             	add    $0x1c,%esp
 8048eb8:	56                   	push   %esi
 8048eb9:	68 12 ee 05 08       	push   $0x805ee12
 8048ebe:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8048ec4:	e8 f7 fb ff ff       	call   8048ac0 <fprintf@plt>
 8048ec9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8048ecf:	6a 05                	push   $0x5
 8048ed1:	6a 01                	push   $0x1
 8048ed3:	68 b1 ed 05 08       	push   $0x805edb1
 8048ed8:	e8 33 fb ff ff       	call   8048a10 <fwrite@plt>
 8048edd:	83 c4 20             	add    $0x20,%esp
 8048ee0:	68 91 ee 05 08       	push   $0x805ee91
 8048ee5:	6a 39                	push   $0x39
 8048ee7:	68 b7 ed 05 08       	push   $0x805edb7
 8048eec:	68 2b ee 05 08       	push   $0x805ee2b
 8048ef1:	e8 ba fc ff ff       	call   8048bb0 <__assert_fail@plt>
 8048ef6:	8d 76 00             	lea    0x0(%esi),%esi
 8048ef9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

	fseek(fp, 0, SEEK_SET);
 8048f00:	83 ec 04             	sub    $0x4,%esp
 8048f03:	6a 00                	push   $0x0
 8048f05:	6a 00                	push   $0x0
 8048f07:	53                   	push   %ebx
 8048f08:	e8 e3 fa ff ff       	call   80489f0 <fseek@plt>
	ret = fread(hwa_to_va(0), file_size, 1, fp);
 8048f0d:	53                   	push   %ebx
 8048f0e:	6a 01                	push   $0x1
 8048f10:	56                   	push   %esi
 8048f11:	ff 35 c8 51 07 08    	pushl  0x80751c8
 8048f17:	e8 14 fb ff ff       	call   8048a30 <fread@plt>
	assert(ret == 1);
 8048f1c:	83 c4 20             	add    $0x20,%esp
 8048f1f:	83 f8 01             	cmp    $0x1,%eax
 8048f22:	0f 85 6e 01 00 00    	jne    8049096 <restart+0x246>
	fclose(fp);
 8048f28:	83 ec 0c             	sub    $0xc,%esp
 8048f2b:	53                   	push   %ebx
 8048f2c:	e8 7f fa ff ff       	call   80489b0 <fclose@plt>
}
#endif

static void load_entry() {
	int ret;
	FILE *fp = fopen("entry", "rb");
 8048f31:	58                   	pop    %eax
 8048f32:	5a                   	pop    %edx
 8048f33:	68 d9 ed 05 08       	push   $0x805edd9
 8048f38:	68 f7 ed 05 08       	push   $0x805edf7
 8048f3d:	e8 9e fb ff ff       	call   8048ae0 <fopen@plt>
	Assert(fp, "Can not open 'entry'");
 8048f42:	83 c4 10             	add    $0x10,%esp
 8048f45:	85 c0                	test   %eax,%eax
}
#endif

static void load_entry() {
	int ret;
	FILE *fp = fopen("entry", "rb");
 8048f47:	89 c3                	mov    %eax,%ebx
	Assert(fp, "Can not open 'entry'");
 8048f49:	0f 84 e1 00 00 00    	je     8049030 <restart+0x1e0>

	fseek(fp, 0, SEEK_END);
 8048f4f:	83 ec 04             	sub    $0x4,%esp
 8048f52:	6a 02                	push   $0x2
 8048f54:	6a 00                	push   $0x0
 8048f56:	50                   	push   %eax
 8048f57:	e8 94 fa ff ff       	call   80489f0 <fseek@plt>
	size_t file_size = ftell(fp);
 8048f5c:	89 1c 24             	mov    %ebx,(%esp)
 8048f5f:	e8 6c fb ff ff       	call   8048ad0 <ftell@plt>

	fseek(fp, 0, SEEK_SET);
 8048f64:	83 c4 0c             	add    $0xc,%esp
	int ret;
	FILE *fp = fopen("entry", "rb");
	Assert(fp, "Can not open 'entry'");

	fseek(fp, 0, SEEK_END);
	size_t file_size = ftell(fp);
 8048f67:	89 c6                	mov    %eax,%esi

	fseek(fp, 0, SEEK_SET);
 8048f69:	6a 00                	push   $0x0
 8048f6b:	6a 00                	push   $0x0
 8048f6d:	53                   	push   %ebx
 8048f6e:	e8 7d fa ff ff       	call   80489f0 <fseek@plt>
	ret = fread(hwa_to_va(ENTRY_START), file_size, 1, fp);
 8048f73:	a1 c8 51 07 08       	mov    0x80751c8,%eax
 8048f78:	53                   	push   %ebx
 8048f79:	6a 01                	push   $0x1
 8048f7b:	56                   	push   %esi
 8048f7c:	05 00 00 10 00       	add    $0x100000,%eax
 8048f81:	50                   	push   %eax
 8048f82:	e8 a9 fa ff ff       	call   8048a30 <fread@plt>
	assert(ret == 1);
 8048f87:	83 c4 20             	add    $0x20,%esp
 8048f8a:	83 f8 01             	cmp    $0x1,%eax
 8048f8d:	0f 85 19 01 00 00    	jne    80490ac <restart+0x25c>
	fclose(fp);
 8048f93:	83 ec 0c             	sub    $0xc,%esp
 8048f96:	53                   	push   %ebx
 8048f97:	e8 14 fa ff ff       	call   80489b0 <fclose@plt>

	/* Read the entry code into memory. */
	load_entry();

	/* Set the initial instruction pointer. */
	cpu.eip = ENTRY_START;
 8048f9c:	c7 05 e0 ae 8f 14 00 	movl   $0x100000,0x148faee0
 8048fa3:	00 10 00 

	/* Initialize DRAM. */
	init_ddr3();
 8048fa6:	e8 c5 28 00 00       	call   804b870 <init_ddr3>
	init_l1cache();
 8048fab:	e8 10 2b 00 00       	call   804bac0 <init_l1cache>
	init_l2cache();
 8048fb0:	e8 2b 22 00 00       	call   804b1e0 <init_l2cache>
	init_cpu_state();
}
 8048fb5:	83 c4 10             	add    $0x10,%esp
} CPU_state;

extern CPU_state cpu;

static inline void init_cr0() {
	cpu.cr0.protect_enable = 0;
 8048fb8:	80 25 e8 ae 8f 14 fe 	andb   $0xfe,0x148faee8
 8048fbf:	83 c4 04             	add    $0x4,%esp
 8048fc2:	5b                   	pop    %ebx
 8048fc3:	5e                   	pop    %esi
 8048fc4:	c3                   	ret    
 8048fc5:	8d 76 00             	lea    0x0(%esi),%esi
#ifdef USE_RAMDISK
static void init_ramdisk() {
	int ret;
	const int ramdisk_max_size = 0xa0000;
	FILE *fp = fopen(exec_file, "rb");
	Assert(fp, "Can not open '%s'", exec_file);
 8048fc8:	83 ec 0c             	sub    $0xc,%esp
 8048fcb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8048fd1:	e8 8a f9 ff ff       	call   8048960 <fflush@plt>
 8048fd6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8048fdc:	6a 07                	push   $0x7
 8048fde:	6a 01                	push   $0x1
 8048fe0:	68 92 ed 05 08       	push   $0x805ed92
 8048fe5:	e8 26 fa ff ff       	call   8048a10 <fwrite@plt>
 8048fea:	83 c4 1c             	add    $0x1c,%esp
 8048fed:	ff 35 2c 5c 07 08    	pushl  0x8075c2c
 8048ff3:	68 dc ed 05 08       	push   $0x805eddc
 8048ff8:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8048ffe:	e8 bd fa ff ff       	call   8048ac0 <fprintf@plt>
 8049003:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8049009:	6a 05                	push   $0x5
 804900b:	6a 01                	push   $0x1
 804900d:	68 b1 ed 05 08       	push   $0x805edb1
 8049012:	e8 f9 f9 ff ff       	call   8048a10 <fwrite@plt>
 8049017:	83 c4 20             	add    $0x20,%esp
 804901a:	68 91 ee 05 08       	push   $0x805ee91
 804901f:	6a 35                	push   $0x35
 8049021:	68 b7 ed 05 08       	push   $0x805edb7
 8049026:	68 d6 ed 05 08       	push   $0x805edd6
 804902b:	e8 80 fb ff ff       	call   8048bb0 <__assert_fail@plt>
#endif

static void load_entry() {
	int ret;
	FILE *fp = fopen("entry", "rb");
	Assert(fp, "Can not open 'entry'");
 8049030:	83 ec 0c             	sub    $0xc,%esp
 8049033:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8049039:	e8 22 f9 ff ff       	call   8048960 <fflush@plt>
 804903e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8049044:	6a 07                	push   $0x7
 8049046:	6a 01                	push   $0x1
 8049048:	68 92 ed 05 08       	push   $0x805ed92
 804904d:	e8 be f9 ff ff       	call   8048a10 <fwrite@plt>
 8049052:	83 c4 20             	add    $0x20,%esp
 8049055:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804905b:	6a 14                	push   $0x14
 804905d:	6a 01                	push   $0x1
 804905f:	68 fd ed 05 08       	push   $0x805edfd
 8049064:	e8 a7 f9 ff ff       	call   8048a10 <fwrite@plt>
 8049069:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804906f:	6a 05                	push   $0x5
 8049071:	6a 01                	push   $0x1
 8049073:	68 b1 ed 05 08       	push   $0x805edb1
 8049078:	e8 93 f9 ff ff       	call   8048a10 <fwrite@plt>
 804907d:	83 c4 20             	add    $0x20,%esp
 8049080:	68 86 ee 05 08       	push   $0x805ee86
 8049085:	6a 45                	push   $0x45
 8049087:	68 b7 ed 05 08       	push   $0x805edb7
 804908c:	68 d6 ed 05 08       	push   $0x805edd6
 8049091:	e8 1a fb ff ff       	call   8048bb0 <__assert_fail@plt>
	size_t file_size = ftell(fp);
	Assert(file_size < ramdisk_max_size, "file size(%zd) too large", file_size);

	fseek(fp, 0, SEEK_SET);
	ret = fread(hwa_to_va(0), file_size, 1, fp);
	assert(ret == 1);
 8049096:	68 91 ee 05 08       	push   $0x805ee91
 804909b:	6a 3d                	push   $0x3d
 804909d:	68 b7 ed 05 08       	push   $0x805edb7
 80490a2:	68 ee ed 05 08       	push   $0x805edee
 80490a7:	e8 04 fb ff ff       	call   8048bb0 <__assert_fail@plt>
	fseek(fp, 0, SEEK_END);
	size_t file_size = ftell(fp);

	fseek(fp, 0, SEEK_SET);
	ret = fread(hwa_to_va(ENTRY_START), file_size, 1, fp);
	assert(ret == 1);
 80490ac:	68 86 ee 05 08       	push   $0x805ee86
 80490b1:	6a 4c                	push   $0x4c
 80490b3:	68 b7 ed 05 08       	push   $0x805edb7
 80490b8:	68 ee ed 05 08       	push   $0x805edee
 80490bd:	e8 ee fa ff ff       	call   8048bb0 <__assert_fail@plt>
 80490c2:	66 90                	xchg   %ax,%ax
 80490c4:	66 90                	xchg   %ax,%ax
 80490c6:	66 90                	xchg   %ax,%ax
 80490c8:	66 90                	xchg   %ax,%ax
 80490ca:	66 90                	xchg   %ax,%ax
 80490cc:	66 90                	xchg   %ax,%ax
 80490ce:	66 90                	xchg   %ax,%ax

080490d0 <load_elf_tables>:

static char *strtab = NULL;
static Elf32_Sym *symtab = NULL;
static int nr_symtab_entry;

void load_elf_tables(int argc, char *argv[]) {
 80490d0:	55                   	push   %ebp
 80490d1:	57                   	push   %edi
 80490d2:	56                   	push   %esi
 80490d3:	53                   	push   %ebx
 80490d4:	83 ec 5c             	sub    $0x5c,%esp
	int ret;
	Assert(argc == 2, "run NEMU with format 'nemu [program]'");
 80490d7:	83 7c 24 70 02       	cmpl   $0x2,0x70(%esp)
 80490dc:	74 66                	je     8049144 <load_elf_tables+0x74>
 80490de:	83 ec 0c             	sub    $0xc,%esp
 80490e1:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80490e7:	e8 74 f8 ff ff       	call   8048960 <fflush@plt>
 80490ec:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80490f2:	6a 07                	push   $0x7
 80490f4:	6a 01                	push   $0x1
 80490f6:	68 92 ed 05 08       	push   $0x805ed92
 80490fb:	e8 10 f9 ff ff       	call   8048a10 <fwrite@plt>
 8049100:	83 c4 20             	add    $0x20,%esp
 8049103:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8049109:	6a 25                	push   $0x25
 804910b:	6a 01                	push   $0x1
 804910d:	68 6c ef 05 08       	push   $0x805ef6c
 8049112:	e8 f9 f8 ff ff       	call   8048a10 <fwrite@plt>
 8049117:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804911d:	6a 05                	push   $0x5
 804911f:	6a 01                	push   $0x1
 8049121:	68 b1 ed 05 08       	push   $0x805edb1
 8049126:	e8 e5 f8 ff ff       	call   8048a10 <fwrite@plt>
 804912b:	83 c4 20             	add    $0x20,%esp
 804912e:	68 17 f0 05 08       	push   $0x805f017
 8049133:	6a 0d                	push   $0xd
 8049135:	68 a7 ee 05 08       	push   $0x805eea7
 804913a:	68 c4 ee 05 08       	push   $0x805eec4
 804913f:	e8 6c fa ff ff       	call   8048bb0 <__assert_fail@plt>
	exec_file = argv[1];
 8049144:	8b 44 24 74          	mov    0x74(%esp),%eax

	FILE *fp = fopen(exec_file, "rb");
 8049148:	83 ec 08             	sub    $0x8,%esp
static int nr_symtab_entry;

void load_elf_tables(int argc, char *argv[]) {
	int ret;
	Assert(argc == 2, "run NEMU with format 'nemu [program]'");
	exec_file = argv[1];
 804914b:	8b 40 04             	mov    0x4(%eax),%eax

	FILE *fp = fopen(exec_file, "rb");
 804914e:	68 d9 ed 05 08       	push   $0x805edd9
 8049153:	50                   	push   %eax
static int nr_symtab_entry;

void load_elf_tables(int argc, char *argv[]) {
	int ret;
	Assert(argc == 2, "run NEMU with format 'nemu [program]'");
	exec_file = argv[1];
 8049154:	a3 2c 5c 07 08       	mov    %eax,0x8075c2c

	FILE *fp = fopen(exec_file, "rb");
 8049159:	e8 82 f9 ff ff       	call   8048ae0 <fopen@plt>
 804915e:	89 44 24 14          	mov    %eax,0x14(%esp)
	Assert(fp, "Can not open '%s'", exec_file);
 8049162:	83 c4 10             	add    $0x10,%esp
 8049165:	85 c0                	test   %eax,%eax
 8049167:	0f 84 c5 02 00 00    	je     8049432 <load_elf_tables+0x362>

	uint8_t buf[sizeof(Elf32_Ehdr)];
	ret = fread(buf, sizeof(Elf32_Ehdr), 1, fp);
 804916d:	ff 74 24 04          	pushl  0x4(%esp)
 8049171:	6a 01                	push   $0x1
 8049173:	6a 34                	push   $0x34
 8049175:	8d 5c 24 28          	lea    0x28(%esp),%ebx
 8049179:	53                   	push   %ebx
 804917a:	e8 b1 f8 ff ff       	call   8048a30 <fread@plt>
	assert(ret == 1);
 804917f:	83 c4 10             	add    $0x10,%esp
 8049182:	83 f8 01             	cmp    $0x1,%eax
 8049185:	0f 85 2d 04 00 00    	jne    80495b8 <load_elf_tables+0x4e8>

	/* The first several bytes contain the ELF header. */
	Elf32_Ehdr *elf = (void *)buf;
	char magic[] = {ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3};
 804918b:	c6 44 24 18 7f       	movb   $0x7f,0x18(%esp)
 8049190:	c6 44 24 19 45       	movb   $0x45,0x19(%esp)

	/* Check ELF header */
	assert(memcmp(elf->e_ident, magic, 4) == 0);		// magic number
 8049195:	83 ec 04             	sub    $0x4,%esp
	ret = fread(buf, sizeof(Elf32_Ehdr), 1, fp);
	assert(ret == 1);

	/* The first several bytes contain the ELF header. */
	Elf32_Ehdr *elf = (void *)buf;
	char magic[] = {ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3};
 8049198:	c6 44 24 1e 4c       	movb   $0x4c,0x1e(%esp)
 804919d:	c6 44 24 1f 46       	movb   $0x46,0x1f(%esp)

	/* Check ELF header */
	assert(memcmp(elf->e_ident, magic, 4) == 0);		// magic number
 80491a2:	6a 04                	push   $0x4
 80491a4:	8d 44 24 20          	lea    0x20(%esp),%eax
 80491a8:	50                   	push   %eax
 80491a9:	53                   	push   %ebx
 80491aa:	e8 21 f8 ff ff       	call   80489d0 <memcmp@plt>
 80491af:	83 c4 10             	add    $0x10,%esp
 80491b2:	85 c0                	test   %eax,%eax
 80491b4:	0f 85 e8 03 00 00    	jne    80495a2 <load_elf_tables+0x4d2>
	assert(elf->e_ident[EI_CLASS] == ELFCLASS32);		// 32-bit architecture
 80491ba:	80 7c 24 20 01       	cmpb   $0x1,0x20(%esp)
 80491bf:	0f 85 c7 03 00 00    	jne    804958c <load_elf_tables+0x4bc>
	assert(elf->e_ident[EI_DATA] == ELFDATA2LSB);		// littel-endian
 80491c5:	80 7c 24 21 01       	cmpb   $0x1,0x21(%esp)
 80491ca:	0f 85 a6 03 00 00    	jne    8049576 <load_elf_tables+0x4a6>
	assert(elf->e_ident[EI_VERSION] == EV_CURRENT);		// current version
 80491d0:	80 7c 24 22 01       	cmpb   $0x1,0x22(%esp)
 80491d5:	0f 85 85 03 00 00    	jne    8049560 <load_elf_tables+0x490>
	assert(elf->e_ident[EI_OSABI] == ELFOSABI_SYSV || 	// UNIX System V ABI
 80491db:	0f b6 44 24 23       	movzbl 0x23(%esp),%eax
 80491e0:	3c 03                	cmp    $0x3,%al
 80491e2:	74 08                	je     80491ec <load_elf_tables+0x11c>
 80491e4:	84 c0                	test   %al,%al
 80491e6:	0f 85 5e 03 00 00    	jne    804954a <load_elf_tables+0x47a>
			elf->e_ident[EI_OSABI] == ELFOSABI_LINUX); 	// UNIX - GNU
	assert(elf->e_ident[EI_ABIVERSION] == 0);			// should be 0
 80491ec:	80 7c 24 24 00       	cmpb   $0x0,0x24(%esp)
 80491f1:	0f 85 3d 03 00 00    	jne    8049534 <load_elf_tables+0x464>
	assert(elf->e_type == ET_EXEC);						// executable file
 80491f7:	66 83 7c 24 2c 02    	cmpw   $0x2,0x2c(%esp)
 80491fd:	0f 85 1b 03 00 00    	jne    804951e <load_elf_tables+0x44e>
	assert(elf->e_machine == EM_386);					// Intel 80386 architecture
 8049203:	66 83 7c 24 2e 03    	cmpw   $0x3,0x2e(%esp)
 8049209:	0f 85 f9 02 00 00    	jne    8049508 <load_elf_tables+0x438>
	assert(elf->e_version == EV_CURRENT);				// current version
 804920f:	83 7c 24 30 01       	cmpl   $0x1,0x30(%esp)
 8049214:	0f 85 d8 02 00 00    	jne    80494f2 <load_elf_tables+0x422>


	/* Load symbol table and string table for future use */

	/* Load section header table */
	uint32_t sh_size = elf->e_shentsize * elf->e_shnum;
 804921a:	0f b7 5c 24 4a       	movzwl 0x4a(%esp),%ebx
 804921f:	0f b7 44 24 4c       	movzwl 0x4c(%esp),%eax
	Elf32_Shdr *sh = malloc(sh_size);
 8049224:	83 ec 0c             	sub    $0xc,%esp


	/* Load symbol table and string table for future use */

	/* Load section header table */
	uint32_t sh_size = elf->e_shentsize * elf->e_shnum;
 8049227:	0f af d8             	imul   %eax,%ebx
	Elf32_Shdr *sh = malloc(sh_size);
 804922a:	53                   	push   %ebx
 804922b:	e8 20 f8 ff ff       	call   8048a50 <malloc@plt>
 8049230:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	fseek(fp, elf->e_shoff, SEEK_SET);
 8049234:	83 c4 0c             	add    $0xc,%esp

	/* Load symbol table and string table for future use */

	/* Load section header table */
	uint32_t sh_size = elf->e_shentsize * elf->e_shnum;
	Elf32_Shdr *sh = malloc(sh_size);
 8049237:	89 c6                	mov    %eax,%esi
	fseek(fp, elf->e_shoff, SEEK_SET);
 8049239:	6a 00                	push   $0x0
 804923b:	ff 74 24 44          	pushl  0x44(%esp)
 804923f:	8b 7c 24 10          	mov    0x10(%esp),%edi
 8049243:	57                   	push   %edi
 8049244:	e8 a7 f7 ff ff       	call   80489f0 <fseek@plt>
	ret = fread(sh, sh_size, 1, fp);
 8049249:	57                   	push   %edi
 804924a:	6a 01                	push   $0x1
 804924c:	53                   	push   %ebx
 804924d:	56                   	push   %esi
 804924e:	e8 dd f7 ff ff       	call   8048a30 <fread@plt>
	assert(ret == 1);
 8049253:	83 c4 20             	add    $0x20,%esp
 8049256:	83 f8 01             	cmp    $0x1,%eax
 8049259:	0f 85 7d 02 00 00    	jne    80494dc <load_elf_tables+0x40c>

	/* Load section header string table */
	char *shstrtab = malloc(sh[elf->e_shstrndx].sh_size);
 804925f:	0f b7 44 24 4e       	movzwl 0x4e(%esp),%eax
 8049264:	8b 7c 24 0c          	mov    0xc(%esp),%edi
 8049268:	83 ec 0c             	sub    $0xc,%esp
 804926b:	8d 04 80             	lea    (%eax,%eax,4),%eax
 804926e:	8d 1c c7             	lea    (%edi,%eax,8),%ebx
 8049271:	ff 73 14             	pushl  0x14(%ebx)
 8049274:	e8 d7 f7 ff ff       	call   8048a50 <malloc@plt>
 8049279:	89 44 24 18          	mov    %eax,0x18(%esp)
	fseek(fp, sh[elf->e_shstrndx].sh_offset, SEEK_SET);
 804927d:	83 c4 0c             	add    $0xc,%esp
 8049280:	6a 00                	push   $0x0
 8049282:	ff 73 10             	pushl  0x10(%ebx)
 8049285:	8b 74 24 10          	mov    0x10(%esp),%esi
 8049289:	56                   	push   %esi
 804928a:	e8 61 f7 ff ff       	call   80489f0 <fseek@plt>
	ret = fread(shstrtab, sh[elf->e_shstrndx].sh_size, 1, fp);
 804928f:	56                   	push   %esi
 8049290:	6a 01                	push   $0x1
 8049292:	0f b7 44 24 66       	movzwl 0x66(%esp),%eax
 8049297:	8d 04 80             	lea    (%eax,%eax,4),%eax
 804929a:	ff 74 c7 14          	pushl  0x14(%edi,%eax,8)
 804929e:	8b 54 24 24          	mov    0x24(%esp),%edx
 80492a2:	52                   	push   %edx
 80492a3:	89 54 24 28          	mov    %edx,0x28(%esp)
 80492a7:	e8 84 f7 ff ff       	call   8048a30 <fread@plt>
	assert(ret == 1);
 80492ac:	83 c4 20             	add    $0x20,%esp
 80492af:	83 f8 01             	cmp    $0x1,%eax
 80492b2:	0f 85 0e 02 00 00    	jne    80494c6 <load_elf_tables+0x3f6>

	int i;
	for(i = 0; i < elf->e_shnum; i ++) {
 80492b8:	31 ed                	xor    %ebp,%ebp
 80492ba:	66 83 7c 24 4c 00    	cmpw   $0x0,0x4c(%esp)
 80492c0:	8d 5f 14             	lea    0x14(%edi),%ebx
 80492c3:	8b 54 24 08          	mov    0x8(%esp),%edx
 80492c7:	75 23                	jne    80492ec <load_elf_tables+0x21c>
 80492c9:	e9 9a 00 00 00       	jmp    8049368 <load_elf_tables+0x298>
 80492ce:	66 90                	xchg   %ax,%ax
			fseek(fp, sh[i].sh_offset, SEEK_SET);
			ret = fread(symtab, sh[i].sh_size, 1, fp);
			assert(ret == 1);
			nr_symtab_entry = sh[i].sh_size / sizeof(symtab[0]);
		}
		else if(sh[i].sh_type == SHT_STRTAB && 
 80492d0:	83 f8 03             	cmp    $0x3,%eax
 80492d3:	0f 84 e7 00 00 00    	je     80493c0 <load_elf_tables+0x2f0>
	fseek(fp, sh[elf->e_shstrndx].sh_offset, SEEK_SET);
	ret = fread(shstrtab, sh[elf->e_shstrndx].sh_size, 1, fp);
	assert(ret == 1);

	int i;
	for(i = 0; i < elf->e_shnum; i ++) {
 80492d9:	0f b7 44 24 4c       	movzwl 0x4c(%esp),%eax
 80492de:	83 c5 01             	add    $0x1,%ebp
 80492e1:	83 c3 28             	add    $0x28,%ebx
 80492e4:	39 e8                	cmp    %ebp,%eax
 80492e6:	0f 8e 7c 00 00 00    	jle    8049368 <load_elf_tables+0x298>
		if(sh[i].sh_type == SHT_SYMTAB && 
 80492ec:	8b 43 f0             	mov    -0x10(%ebx),%eax
 80492ef:	83 f8 02             	cmp    $0x2,%eax
 80492f2:	75 dc                	jne    80492d0 <load_elf_tables+0x200>
				strcmp(shstrtab + sh[i].sh_name, ".symtab") == 0) {
 80492f4:	8b 73 ec             	mov    -0x14(%ebx),%esi
 80492f7:	bf 5b ef 05 08       	mov    $0x805ef5b,%edi
 80492fc:	b9 08 00 00 00       	mov    $0x8,%ecx
 8049301:	01 d6                	add    %edx,%esi
	ret = fread(shstrtab, sh[elf->e_shstrndx].sh_size, 1, fp);
	assert(ret == 1);

	int i;
	for(i = 0; i < elf->e_shnum; i ++) {
		if(sh[i].sh_type == SHT_SYMTAB && 
 8049303:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
 8049305:	75 d2                	jne    80492d9 <load_elf_tables+0x209>
 8049307:	89 54 24 08          	mov    %edx,0x8(%esp)
				strcmp(shstrtab + sh[i].sh_name, ".symtab") == 0) {
			/* Load symbol table from exec_file */
			symtab = malloc(sh[i].sh_size);
 804930b:	83 ec 0c             	sub    $0xc,%esp
 804930e:	ff 33                	pushl  (%ebx)
 8049310:	e8 3b f7 ff ff       	call   8048a50 <malloc@plt>
			fseek(fp, sh[i].sh_offset, SEEK_SET);
 8049315:	83 c4 0c             	add    $0xc,%esp
	int i;
	for(i = 0; i < elf->e_shnum; i ++) {
		if(sh[i].sh_type == SHT_SYMTAB && 
				strcmp(shstrtab + sh[i].sh_name, ".symtab") == 0) {
			/* Load symbol table from exec_file */
			symtab = malloc(sh[i].sh_size);
 8049318:	a3 34 5c 07 08       	mov    %eax,0x8075c34
			fseek(fp, sh[i].sh_offset, SEEK_SET);
 804931d:	6a 00                	push   $0x0
 804931f:	ff 73 fc             	pushl  -0x4(%ebx)
 8049322:	8b 7c 24 10          	mov    0x10(%esp),%edi
 8049326:	57                   	push   %edi
 8049327:	e8 c4 f6 ff ff       	call   80489f0 <fseek@plt>
			ret = fread(symtab, sh[i].sh_size, 1, fp);
 804932c:	57                   	push   %edi
 804932d:	6a 01                	push   $0x1
 804932f:	ff 33                	pushl  (%ebx)
 8049331:	ff 35 34 5c 07 08    	pushl  0x8075c34
 8049337:	e8 f4 f6 ff ff       	call   8048a30 <fread@plt>
			assert(ret == 1);
 804933c:	83 c4 20             	add    $0x20,%esp
 804933f:	83 f8 01             	cmp    $0x1,%eax
 8049342:	8b 54 24 08          	mov    0x8(%esp),%edx
 8049346:	0f 85 64 01 00 00    	jne    80494b0 <load_elf_tables+0x3e0>
			nr_symtab_entry = sh[i].sh_size / sizeof(symtab[0]);
 804934c:	8b 03                	mov    (%ebx),%eax
	fseek(fp, sh[elf->e_shstrndx].sh_offset, SEEK_SET);
	ret = fread(shstrtab, sh[elf->e_shstrndx].sh_size, 1, fp);
	assert(ret == 1);

	int i;
	for(i = 0; i < elf->e_shnum; i ++) {
 804934e:	83 c5 01             	add    $0x1,%ebp
 8049351:	83 c3 28             	add    $0x28,%ebx
			/* Load symbol table from exec_file */
			symtab = malloc(sh[i].sh_size);
			fseek(fp, sh[i].sh_offset, SEEK_SET);
			ret = fread(symtab, sh[i].sh_size, 1, fp);
			assert(ret == 1);
			nr_symtab_entry = sh[i].sh_size / sizeof(symtab[0]);
 8049354:	c1 e8 04             	shr    $0x4,%eax
 8049357:	a3 30 5c 07 08       	mov    %eax,0x8075c30
	fseek(fp, sh[elf->e_shstrndx].sh_offset, SEEK_SET);
	ret = fread(shstrtab, sh[elf->e_shstrndx].sh_size, 1, fp);
	assert(ret == 1);

	int i;
	for(i = 0; i < elf->e_shnum; i ++) {
 804935c:	0f b7 44 24 4c       	movzwl 0x4c(%esp),%eax
 8049361:	39 e8                	cmp    %ebp,%eax
 8049363:	7f 87                	jg     80492ec <load_elf_tables+0x21c>
 8049365:	8d 76 00             	lea    0x0(%esi),%esi
 8049368:	89 54 24 08          	mov    %edx,0x8(%esp)
			ret = fread(strtab, sh[i].sh_size, 1, fp);
			assert(ret == 1);
		}
	}

	free(sh);
 804936c:	83 ec 0c             	sub    $0xc,%esp
 804936f:	ff 74 24 18          	pushl  0x18(%esp)
 8049373:	e8 08 f6 ff ff       	call   8048980 <free@plt>
	free(shstrtab);
 8049378:	8b 54 24 18          	mov    0x18(%esp),%edx
 804937c:	89 14 24             	mov    %edx,(%esp)
 804937f:	e8 fc f5 ff ff       	call   8048980 <free@plt>

	assert(strtab != NULL && symtab != NULL);
 8049384:	8b 15 38 5c 07 08    	mov    0x8075c38,%edx
 804938a:	83 c4 10             	add    $0x10,%esp
 804938d:	85 d2                	test   %edx,%edx
 804938f:	0f 84 05 01 00 00    	je     804949a <load_elf_tables+0x3ca>
 8049395:	a1 34 5c 07 08       	mov    0x8075c34,%eax
 804939a:	85 c0                	test   %eax,%eax
 804939c:	0f 84 f8 00 00 00    	je     804949a <load_elf_tables+0x3ca>

	fclose(fp);
 80493a2:	83 ec 0c             	sub    $0xc,%esp
 80493a5:	ff 74 24 10          	pushl  0x10(%esp)
 80493a9:	e8 02 f6 ff ff       	call   80489b0 <fclose@plt>
}
 80493ae:	83 c4 10             	add    $0x10,%esp
 80493b1:	83 c4 5c             	add    $0x5c,%esp
 80493b4:	5b                   	pop    %ebx
 80493b5:	5e                   	pop    %esi
 80493b6:	5f                   	pop    %edi
 80493b7:	5d                   	pop    %ebp
 80493b8:	c3                   	ret    
 80493b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			ret = fread(symtab, sh[i].sh_size, 1, fp);
			assert(ret == 1);
			nr_symtab_entry = sh[i].sh_size / sizeof(symtab[0]);
		}
		else if(sh[i].sh_type == SHT_STRTAB && 
				strcmp(shstrtab + sh[i].sh_name, ".strtab") == 0) {
 80493c0:	8b 73 ec             	mov    -0x14(%ebx),%esi
 80493c3:	bf 63 ef 05 08       	mov    $0x805ef63,%edi
 80493c8:	b9 08 00 00 00       	mov    $0x8,%ecx
 80493cd:	01 d6                	add    %edx,%esi
			fseek(fp, sh[i].sh_offset, SEEK_SET);
			ret = fread(symtab, sh[i].sh_size, 1, fp);
			assert(ret == 1);
			nr_symtab_entry = sh[i].sh_size / sizeof(symtab[0]);
		}
		else if(sh[i].sh_type == SHT_STRTAB && 
 80493cf:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
 80493d1:	0f 85 02 ff ff ff    	jne    80492d9 <load_elf_tables+0x209>
 80493d7:	89 54 24 08          	mov    %edx,0x8(%esp)
				strcmp(shstrtab + sh[i].sh_name, ".strtab") == 0) {
			/* Load string table from exec_file */
			strtab = malloc(sh[i].sh_size);
 80493db:	83 ec 0c             	sub    $0xc,%esp
 80493de:	ff 33                	pushl  (%ebx)
 80493e0:	e8 6b f6 ff ff       	call   8048a50 <malloc@plt>
			fseek(fp, sh[i].sh_offset, SEEK_SET);
 80493e5:	83 c4 0c             	add    $0xc,%esp
			nr_symtab_entry = sh[i].sh_size / sizeof(symtab[0]);
		}
		else if(sh[i].sh_type == SHT_STRTAB && 
				strcmp(shstrtab + sh[i].sh_name, ".strtab") == 0) {
			/* Load string table from exec_file */
			strtab = malloc(sh[i].sh_size);
 80493e8:	a3 38 5c 07 08       	mov    %eax,0x8075c38
			fseek(fp, sh[i].sh_offset, SEEK_SET);
 80493ed:	6a 00                	push   $0x0
 80493ef:	ff 73 fc             	pushl  -0x4(%ebx)
 80493f2:	8b 7c 24 10          	mov    0x10(%esp),%edi
 80493f6:	57                   	push   %edi
 80493f7:	e8 f4 f5 ff ff       	call   80489f0 <fseek@plt>
			ret = fread(strtab, sh[i].sh_size, 1, fp);
 80493fc:	57                   	push   %edi
 80493fd:	6a 01                	push   $0x1
 80493ff:	ff 33                	pushl  (%ebx)
 8049401:	ff 35 38 5c 07 08    	pushl  0x8075c38
 8049407:	e8 24 f6 ff ff       	call   8048a30 <fread@plt>
			assert(ret == 1);
 804940c:	83 c4 20             	add    $0x20,%esp
 804940f:	83 f8 01             	cmp    $0x1,%eax
 8049412:	8b 54 24 08          	mov    0x8(%esp),%edx
 8049416:	0f 84 bd fe ff ff    	je     80492d9 <load_elf_tables+0x209>
 804941c:	68 17 f0 05 08       	push   $0x805f017
 8049421:	6a 48                	push   $0x48
 8049423:	68 a7 ee 05 08       	push   $0x805eea7
 8049428:	68 ee ed 05 08       	push   $0x805edee
 804942d:	e8 7e f7 ff ff       	call   8048bb0 <__assert_fail@plt>
	int ret;
	Assert(argc == 2, "run NEMU with format 'nemu [program]'");
	exec_file = argv[1];

	FILE *fp = fopen(exec_file, "rb");
	Assert(fp, "Can not open '%s'", exec_file);
 8049432:	83 ec 0c             	sub    $0xc,%esp
 8049435:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804943b:	e8 20 f5 ff ff       	call   8048960 <fflush@plt>
 8049440:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8049446:	6a 07                	push   $0x7
 8049448:	6a 01                	push   $0x1
 804944a:	68 92 ed 05 08       	push   $0x805ed92
 804944f:	e8 bc f5 ff ff       	call   8048a10 <fwrite@plt>
 8049454:	83 c4 1c             	add    $0x1c,%esp
 8049457:	ff 35 2c 5c 07 08    	pushl  0x8075c2c
 804945d:	68 dc ed 05 08       	push   $0x805eddc
 8049462:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8049468:	e8 53 f6 ff ff       	call   8048ac0 <fprintf@plt>
 804946d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8049473:	6a 05                	push   $0x5
 8049475:	6a 01                	push   $0x1
 8049477:	68 b1 ed 05 08       	push   $0x805edb1
 804947c:	e8 8f f5 ff ff       	call   8048a10 <fwrite@plt>
 8049481:	83 c4 20             	add    $0x20,%esp
 8049484:	68 17 f0 05 08       	push   $0x805f017
 8049489:	6a 11                	push   $0x11
 804948b:	68 a7 ee 05 08       	push   $0x805eea7
 8049490:	68 d6 ed 05 08       	push   $0x805edd6
 8049495:	e8 16 f7 ff ff       	call   8048bb0 <__assert_fail@plt>
	}

	free(sh);
	free(shstrtab);

	assert(strtab != NULL && symtab != NULL);
 804949a:	68 17 f0 05 08       	push   $0x805f017
 804949f:	6a 4f                	push   $0x4f
 80494a1:	68 a7 ee 05 08       	push   $0x805eea7
 80494a6:	68 e8 ef 05 08       	push   $0x805efe8
 80494ab:	e8 00 f7 ff ff       	call   8048bb0 <__assert_fail@plt>
				strcmp(shstrtab + sh[i].sh_name, ".symtab") == 0) {
			/* Load symbol table from exec_file */
			symtab = malloc(sh[i].sh_size);
			fseek(fp, sh[i].sh_offset, SEEK_SET);
			ret = fread(symtab, sh[i].sh_size, 1, fp);
			assert(ret == 1);
 80494b0:	68 17 f0 05 08       	push   $0x805f017
 80494b5:	6a 3f                	push   $0x3f
 80494b7:	68 a7 ee 05 08       	push   $0x805eea7
 80494bc:	68 ee ed 05 08       	push   $0x805edee
 80494c1:	e8 ea f6 ff ff       	call   8048bb0 <__assert_fail@plt>

	/* Load section header string table */
	char *shstrtab = malloc(sh[elf->e_shstrndx].sh_size);
	fseek(fp, sh[elf->e_shstrndx].sh_offset, SEEK_SET);
	ret = fread(shstrtab, sh[elf->e_shstrndx].sh_size, 1, fp);
	assert(ret == 1);
 80494c6:	68 17 f0 05 08       	push   $0x805f017
 80494cb:	6a 35                	push   $0x35
 80494cd:	68 a7 ee 05 08       	push   $0x805eea7
 80494d2:	68 ee ed 05 08       	push   $0x805edee
 80494d7:	e8 d4 f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	/* Load section header table */
	uint32_t sh_size = elf->e_shentsize * elf->e_shnum;
	Elf32_Shdr *sh = malloc(sh_size);
	fseek(fp, elf->e_shoff, SEEK_SET);
	ret = fread(sh, sh_size, 1, fp);
	assert(ret == 1);
 80494dc:	68 17 f0 05 08       	push   $0x805f017
 80494e1:	6a 2f                	push   $0x2f
 80494e3:	68 a7 ee 05 08       	push   $0x805eea7
 80494e8:	68 ee ed 05 08       	push   $0x805edee
 80494ed:	e8 be f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	assert(elf->e_ident[EI_OSABI] == ELFOSABI_SYSV || 	// UNIX System V ABI
			elf->e_ident[EI_OSABI] == ELFOSABI_LINUX); 	// UNIX - GNU
	assert(elf->e_ident[EI_ABIVERSION] == 0);			// should be 0
	assert(elf->e_type == ET_EXEC);						// executable file
	assert(elf->e_machine == EM_386);					// Intel 80386 architecture
	assert(elf->e_version == EV_CURRENT);				// current version
 80494f2:	68 17 f0 05 08       	push   $0x805f017
 80494f7:	6a 25                	push   $0x25
 80494f9:	68 a7 ee 05 08       	push   $0x805eea7
 80494fe:	68 47 ef 05 08       	push   $0x805ef47
 8049503:	e8 a8 f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	assert(elf->e_ident[EI_VERSION] == EV_CURRENT);		// current version
	assert(elf->e_ident[EI_OSABI] == ELFOSABI_SYSV || 	// UNIX System V ABI
			elf->e_ident[EI_OSABI] == ELFOSABI_LINUX); 	// UNIX - GNU
	assert(elf->e_ident[EI_ABIVERSION] == 0);			// should be 0
	assert(elf->e_type == ET_EXEC);						// executable file
	assert(elf->e_machine == EM_386);					// Intel 80386 architecture
 8049508:	68 17 f0 05 08       	push   $0x805f017
 804950d:	6a 24                	push   $0x24
 804950f:	68 a7 ee 05 08       	push   $0x805eea7
 8049514:	68 33 ef 05 08       	push   $0x805ef33
 8049519:	e8 92 f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	assert(elf->e_ident[EI_DATA] == ELFDATA2LSB);		// littel-endian
	assert(elf->e_ident[EI_VERSION] == EV_CURRENT);		// current version
	assert(elf->e_ident[EI_OSABI] == ELFOSABI_SYSV || 	// UNIX System V ABI
			elf->e_ident[EI_OSABI] == ELFOSABI_LINUX); 	// UNIX - GNU
	assert(elf->e_ident[EI_ABIVERSION] == 0);			// should be 0
	assert(elf->e_type == ET_EXEC);						// executable file
 804951e:	68 17 f0 05 08       	push   $0x805f017
 8049523:	6a 23                	push   $0x23
 8049525:	68 a7 ee 05 08       	push   $0x805eea7
 804952a:	68 22 ef 05 08       	push   $0x805ef22
 804952f:	e8 7c f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	assert(elf->e_ident[EI_CLASS] == ELFCLASS32);		// 32-bit architecture
	assert(elf->e_ident[EI_DATA] == ELFDATA2LSB);		// littel-endian
	assert(elf->e_ident[EI_VERSION] == EV_CURRENT);		// current version
	assert(elf->e_ident[EI_OSABI] == ELFOSABI_SYSV || 	// UNIX System V ABI
			elf->e_ident[EI_OSABI] == ELFOSABI_LINUX); 	// UNIX - GNU
	assert(elf->e_ident[EI_ABIVERSION] == 0);			// should be 0
 8049534:	68 17 f0 05 08       	push   $0x805f017
 8049539:	6a 22                	push   $0x22
 804953b:	68 a7 ee 05 08       	push   $0x805eea7
 8049540:	68 0d ef 05 08       	push   $0x805ef0d
 8049545:	e8 66 f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	/* Check ELF header */
	assert(memcmp(elf->e_ident, magic, 4) == 0);		// magic number
	assert(elf->e_ident[EI_CLASS] == ELFCLASS32);		// 32-bit architecture
	assert(elf->e_ident[EI_DATA] == ELFDATA2LSB);		// littel-endian
	assert(elf->e_ident[EI_VERSION] == EV_CURRENT);		// current version
	assert(elf->e_ident[EI_OSABI] == ELFOSABI_SYSV || 	// UNIX System V ABI
 804954a:	68 17 f0 05 08       	push   $0x805f017
 804954f:	6a 21                	push   $0x21
 8049551:	68 a7 ee 05 08       	push   $0x805eea7
 8049556:	68 b8 ef 05 08       	push   $0x805efb8
 804955b:	e8 50 f6 ff ff       	call   8048bb0 <__assert_fail@plt>

	/* Check ELF header */
	assert(memcmp(elf->e_ident, magic, 4) == 0);		// magic number
	assert(elf->e_ident[EI_CLASS] == ELFCLASS32);		// 32-bit architecture
	assert(elf->e_ident[EI_DATA] == ELFDATA2LSB);		// littel-endian
	assert(elf->e_ident[EI_VERSION] == EV_CURRENT);		// current version
 8049560:	68 17 f0 05 08       	push   $0x805f017
 8049565:	6a 1f                	push   $0x1f
 8049567:	68 a7 ee 05 08       	push   $0x805eea7
 804956c:	68 f8 ee 05 08       	push   $0x805eef8
 8049571:	e8 3a f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	char magic[] = {ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3};

	/* Check ELF header */
	assert(memcmp(elf->e_ident, magic, 4) == 0);		// magic number
	assert(elf->e_ident[EI_CLASS] == ELFCLASS32);		// 32-bit architecture
	assert(elf->e_ident[EI_DATA] == ELFDATA2LSB);		// littel-endian
 8049576:	68 17 f0 05 08       	push   $0x805f017
 804957b:	6a 1e                	push   $0x1e
 804957d:	68 a7 ee 05 08       	push   $0x805eea7
 8049582:	68 e3 ee 05 08       	push   $0x805eee3
 8049587:	e8 24 f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	Elf32_Ehdr *elf = (void *)buf;
	char magic[] = {ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3};

	/* Check ELF header */
	assert(memcmp(elf->e_ident, magic, 4) == 0);		// magic number
	assert(elf->e_ident[EI_CLASS] == ELFCLASS32);		// 32-bit architecture
 804958c:	68 17 f0 05 08       	push   $0x805f017
 8049591:	6a 1d                	push   $0x1d
 8049593:	68 a7 ee 05 08       	push   $0x805eea7
 8049598:	68 ce ee 05 08       	push   $0x805eece
 804959d:	e8 0e f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	/* The first several bytes contain the ELF header. */
	Elf32_Ehdr *elf = (void *)buf;
	char magic[] = {ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3};

	/* Check ELF header */
	assert(memcmp(elf->e_ident, magic, 4) == 0);		// magic number
 80495a2:	68 17 f0 05 08       	push   $0x805f017
 80495a7:	6a 1c                	push   $0x1c
 80495a9:	68 a7 ee 05 08       	push   $0x805eea7
 80495ae:	68 94 ef 05 08       	push   $0x805ef94
 80495b3:	e8 f8 f5 ff ff       	call   8048bb0 <__assert_fail@plt>
	FILE *fp = fopen(exec_file, "rb");
	Assert(fp, "Can not open '%s'", exec_file);

	uint8_t buf[sizeof(Elf32_Ehdr)];
	ret = fread(buf, sizeof(Elf32_Ehdr), 1, fp);
	assert(ret == 1);
 80495b8:	68 17 f0 05 08       	push   $0x805f017
 80495bd:	6a 15                	push   $0x15
 80495bf:	68 a7 ee 05 08       	push   $0x805eea7
 80495c4:	68 ee ed 05 08       	push   $0x805edee
 80495c9:	e8 e2 f5 ff ff       	call   8048bb0 <__assert_fail@plt>
 80495ce:	66 90                	xchg   %ax,%ax

080495d0 <read_sym>:
	assert(strtab != NULL && symtab != NULL);

	fclose(fp);
}

uint32_t read_sym(char * str) {
 80495d0:	55                   	push   %ebp
 80495d1:	57                   	push   %edi
 80495d2:	56                   	push   %esi
 80495d3:	53                   	push   %ebx
 80495d4:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 80495d7:	a1 30 5c 07 08       	mov    0x8075c30,%eax
	assert(strtab != NULL && symtab != NULL);

	fclose(fp);
}

uint32_t read_sym(char * str) {
 80495dc:	8b 7c 24 30          	mov    0x30(%esp),%edi
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 80495e0:	85 c0                	test   %eax,%eax
 80495e2:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80495e6:	7e 48                	jle    8049630 <read_sym+0x60>
 80495e8:	8b 2d 38 5c 07 08    	mov    0x8075c38,%ebp
 80495ee:	8b 1d 34 5c 07 08    	mov    0x8075c34,%ebx
 80495f4:	31 f6                	xor    %esi,%esi
 80495f6:	eb 14                	jmp    804960c <read_sym+0x3c>
 80495f8:	90                   	nop
 80495f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049600:	83 c6 01             	add    $0x1,%esi
 8049603:	83 c3 10             	add    $0x10,%ebx
 8049606:	3b 74 24 0c          	cmp    0xc(%esp),%esi
 804960a:	74 24                	je     8049630 <read_sym+0x60>
		if(strcmp(strtab + symtab[i].st_name, str) == 0) {
 804960c:	8b 03                	mov    (%ebx),%eax
 804960e:	83 ec 08             	sub    $0x8,%esp
 8049611:	57                   	push   %edi
 8049612:	01 e8                	add    %ebp,%eax
 8049614:	50                   	push   %eax
 8049615:	e8 26 f3 ff ff       	call   8048940 <strcmp@plt>
 804961a:	83 c4 10             	add    $0x10,%esp
 804961d:	85 c0                	test   %eax,%eax
 804961f:	75 df                	jne    8049600 <read_sym+0x30>
			return symtab[i].st_value;
 8049621:	8b 43 04             	mov    0x4(%ebx),%eax
		}
	}
	return 0;
}
 8049624:	83 c4 1c             	add    $0x1c,%esp
 8049627:	5b                   	pop    %ebx
 8049628:	5e                   	pop    %esi
 8049629:	5f                   	pop    %edi
 804962a:	5d                   	pop    %ebp
 804962b:	c3                   	ret    
 804962c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049630:	83 c4 1c             	add    $0x1c,%esp
	for(i = 0; i < nr_symtab_entry; i ++) {
		if(strcmp(strtab + symtab[i].st_name, str) == 0) {
			return symtab[i].st_value;
		}
	}
	return 0;
 8049633:	31 c0                	xor    %eax,%eax
}
 8049635:	5b                   	pop    %ebx
 8049636:	5e                   	pop    %esi
 8049637:	5f                   	pop    %edi
 8049638:	5d                   	pop    %ebp
 8049639:	c3                   	ret    
 804963a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

08049640 <get_func_name>:

void get_func_name(char * fun_name, swaddr_t addr, int * flag) {
 8049640:	55                   	push   %ebp
 8049641:	57                   	push   %edi
 8049642:	56                   	push   %esi
 8049643:	53                   	push   %ebx
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 8049644:	31 f6                	xor    %esi,%esi
		}
	}
	return 0;
}

void get_func_name(char * fun_name, swaddr_t addr, int * flag) {
 8049646:	83 ec 0c             	sub    $0xc,%esp
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 8049649:	8b 3d 30 5c 07 08    	mov    0x8075c30,%edi
 804964f:	a1 34 5c 07 08       	mov    0x8075c34,%eax
		}
	}
	return 0;
}

void get_func_name(char * fun_name, swaddr_t addr, int * flag) {
 8049654:	8b 6c 24 24          	mov    0x24(%esp),%ebp
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 8049658:	85 ff                	test   %edi,%edi
 804965a:	8d 58 0c             	lea    0xc(%eax),%ebx
 804965d:	7f 13                	jg     8049672 <get_func_name+0x32>
 804965f:	eb 5f                	jmp    80496c0 <get_func_name+0x80>
 8049661:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049668:	83 c6 01             	add    $0x1,%esi
 804966b:	83 c3 10             	add    $0x10,%ebx
 804966e:	39 fe                	cmp    %edi,%esi
 8049670:	74 4e                	je     80496c0 <get_func_name+0x80>
		if((symtab[i].st_info & 0xf) != STT_FUNC) continue;
 8049672:	0f b6 03             	movzbl (%ebx),%eax
 8049675:	83 e0 0f             	and    $0xf,%eax
 8049678:	3c 02                	cmp    $0x2,%al
 804967a:	75 ec                	jne    8049668 <get_func_name+0x28>
		if((symtab[i].st_value <= addr) && 
 804967c:	8b 43 f8             	mov    -0x8(%ebx),%eax
 804967f:	39 e8                	cmp    %ebp,%eax
 8049681:	77 e5                	ja     8049668 <get_func_name+0x28>
				(symtab[i].st_value + symtab[i].st_size >= addr)) {
 8049683:	03 43 fc             	add    -0x4(%ebx),%eax

void get_func_name(char * fun_name, swaddr_t addr, int * flag) {
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
		if((symtab[i].st_info & 0xf) != STT_FUNC) continue;
		if((symtab[i].st_value <= addr) && 
 8049686:	39 c5                	cmp    %eax,%ebp
 8049688:	77 de                	ja     8049668 <get_func_name+0x28>
				(symtab[i].st_value + symtab[i].st_size >= addr)) {
			strcpy(fun_name, strtab + symtab[i].st_name);
 804968a:	8b 43 f4             	mov    -0xc(%ebx),%eax
 804968d:	03 05 38 5c 07 08    	add    0x8075c38,%eax
 8049693:	83 ec 08             	sub    $0x8,%esp
	return 0;
}

void get_func_name(char * fun_name, swaddr_t addr, int * flag) {
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 8049696:	83 c6 01             	add    $0x1,%esi
 8049699:	83 c3 10             	add    $0x10,%ebx
		if((symtab[i].st_info & 0xf) != STT_FUNC) continue;
		if((symtab[i].st_value <= addr) && 
				(symtab[i].st_value + symtab[i].st_size >= addr)) {
			strcpy(fun_name, strtab + symtab[i].st_name);
 804969c:	50                   	push   %eax
 804969d:	ff 74 24 2c          	pushl  0x2c(%esp)
 80496a1:	e8 9a f3 ff ff       	call   8048a40 <strcpy@plt>
			*flag = 1;
 80496a6:	8b 44 24 38          	mov    0x38(%esp),%eax
 80496aa:	83 c4 10             	add    $0x10,%esp
	return 0;
}

void get_func_name(char * fun_name, swaddr_t addr, int * flag) {
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 80496ad:	39 fe                	cmp    %edi,%esi
		if((symtab[i].st_info & 0xf) != STT_FUNC) continue;
		if((symtab[i].st_value <= addr) && 
				(symtab[i].st_value + symtab[i].st_size >= addr)) {
			strcpy(fun_name, strtab + symtab[i].st_name);
			*flag = 1;
 80496af:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	return 0;
}

void get_func_name(char * fun_name, swaddr_t addr, int * flag) {
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 80496b5:	75 bb                	jne    8049672 <get_func_name+0x32>
 80496b7:	89 f6                	mov    %esi,%esi
 80496b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
				(symtab[i].st_value + symtab[i].st_size >= addr)) {
			strcpy(fun_name, strtab + symtab[i].st_name);
			*flag = 1;
		}
	}
}
 80496c0:	83 c4 0c             	add    $0xc,%esp
 80496c3:	5b                   	pop    %ebx
 80496c4:	5e                   	pop    %esi
 80496c5:	5f                   	pop    %edi
 80496c6:	5d                   	pop    %ebp
 80496c7:	c3                   	ret    
 80496c8:	66 90                	xchg   %ax,%ax
 80496ca:	66 90                	xchg   %ax,%ax
 80496cc:	66 90                	xchg   %ax,%ax
 80496ce:	66 90                	xchg   %ax,%ax

080496d0 <cmd_q>:
	return 0;
}

static int cmd_q(char *args) {
	return -1;
}
 80496d0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80496d5:	c3                   	ret    
 80496d6:	8d 76 00             	lea    0x0(%esi),%esi
 80496d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080496e0 <cmd_bt>:
	int no = atoi(args);
	delete_wp(no);
	return 0;
}

static int cmd_bt(char *args) {
 80496e0:	55                   	push   %ebp
 80496e1:	57                   	push   %edi
 80496e2:	56                   	push   %esi
 80496e3:	53                   	push   %ebx
	swaddr_t addr = cpu.eip;
	uint32_t ebp = cpu.ebp;
	char fun_name[32];
	int i, flag, cnt = 0;
	while(ebp) {
 80496e4:	31 f6                	xor    %esi,%esi
	int no = atoi(args);
	delete_wp(no);
	return 0;
}

static int cmd_bt(char *args) {
 80496e6:	83 ec 4c             	sub    $0x4c,%esp
	swaddr_t addr = cpu.eip;
	uint32_t ebp = cpu.ebp;
 80496e9:	8b 1d d4 ae 8f 14    	mov    0x148faed4,%ebx
	delete_wp(no);
	return 0;
}

static int cmd_bt(char *args) {
	swaddr_t addr = cpu.eip;
 80496ef:	a1 e0 ae 8f 14       	mov    0x148faee0,%eax
 80496f4:	8d 6c 24 20          	lea    0x20(%esp),%ebp
	uint32_t ebp = cpu.ebp;
	char fun_name[32];
	int i, flag, cnt = 0;
	while(ebp) {
 80496f8:	85 db                	test   %ebx,%ebx
	delete_wp(no);
	return 0;
}

static int cmd_bt(char *args) {
	swaddr_t addr = cpu.eip;
 80496fa:	89 44 24 08          	mov    %eax,0x8(%esp)
	uint32_t ebp = cpu.ebp;
	char fun_name[32];
	int i, flag, cnt = 0;
	while(ebp) {
 80496fe:	0f 84 dc 00 00 00    	je     80497e0 <cmd_bt+0x100>
 8049704:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		flag = 0;
 8049708:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 804970f:	00 
		get_func_name(fun_name, addr, &flag);
 8049710:	83 ec 04             	sub    $0x4,%esp
 8049713:	8d 44 24 20          	lea    0x20(%esp),%eax
 8049717:	50                   	push   %eax
 8049718:	ff 74 24 10          	pushl  0x10(%esp)
 804971c:	55                   	push   %ebp
 804971d:	e8 1e ff ff ff       	call   8049640 <get_func_name>
		if(!flag) {
 8049722:	83 c4 10             	add    $0x10,%esp
 8049725:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8049729:	85 c0                	test   %eax,%eax
 804972b:	0f 84 9f 00 00 00    	je     80497d0 <cmd_bt+0xf0>
			printf("the program haven't start yet.\n");
			return 0;
		}
		printf("#%d\t0x%x\tin %s()\n", cnt++, addr, fun_name);
 8049731:	8d 46 01             	lea    0x1(%esi),%eax
		if(strcmp(fun_name, "main") != 0) addr = swaddr_read(ebp + 4, 4);
 8049734:	bf b4 f0 05 08       	mov    $0x805f0b4,%edi
		get_func_name(fun_name, addr, &flag);
		if(!flag) {
			printf("the program haven't start yet.\n");
			return 0;
		}
		printf("#%d\t0x%x\tin %s()\n", cnt++, addr, fun_name);
 8049739:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804973d:	55                   	push   %ebp
 804973e:	ff 74 24 0c          	pushl  0xc(%esp)
 8049742:	56                   	push   %esi
		if(strcmp(fun_name, "main") != 0) addr = swaddr_read(ebp + 4, 4);
 8049743:	89 ee                	mov    %ebp,%esi
		get_func_name(fun_name, addr, &flag);
		if(!flag) {
			printf("the program haven't start yet.\n");
			return 0;
		}
		printf("#%d\t0x%x\tin %s()\n", cnt++, addr, fun_name);
 8049745:	68 a2 f0 05 08       	push   $0x805f0a2
 804974a:	e8 01 f2 ff ff       	call   8048950 <printf@plt>
		if(strcmp(fun_name, "main") != 0) addr = swaddr_read(ebp + 4, 4);
 804974f:	b9 05 00 00 00       	mov    $0x5,%ecx
 8049754:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
 8049756:	0f 97 c2             	seta   %dl
 8049759:	0f 92 c0             	setb   %al
 804975c:	83 c4 10             	add    $0x10,%esp
 804975f:	38 c2                	cmp    %al,%dl
 8049761:	75 55                	jne    80497b8 <cmd_bt+0xd8>
		get_func_name(fun_name, addr, &flag);
		if(!flag) {
			printf("the program haven't start yet.\n");
			return 0;
		}
		printf("#%d\t0x%x\tin %s()\n", cnt++, addr, fun_name);
 8049763:	be 02 00 00 00       	mov    $0x2,%esi
		if(strcmp(fun_name, "main") != 0) addr = swaddr_read(ebp + 4, 4);
		for(i = 0; i < 4; i ++) {
			printf("\t0x%08x", swaddr_read(ebp + ((i + 2) << 2), 4));
 8049768:	8d 04 b3             	lea    (%ebx,%esi,4),%eax
 804976b:	83 ec 08             	sub    $0x8,%esp
 804976e:	83 c6 01             	add    $0x1,%esi
 8049771:	6a 04                	push   $0x4
 8049773:	50                   	push   %eax
 8049774:	e8 e7 17 00 00       	call   804af60 <swaddr_read>
 8049779:	59                   	pop    %ecx
 804977a:	5f                   	pop    %edi
 804977b:	50                   	push   %eax
 804977c:	68 b9 f0 05 08       	push   $0x805f0b9
 8049781:	e8 ca f1 ff ff       	call   8048950 <printf@plt>
			printf("the program haven't start yet.\n");
			return 0;
		}
		printf("#%d\t0x%x\tin %s()\n", cnt++, addr, fun_name);
		if(strcmp(fun_name, "main") != 0) addr = swaddr_read(ebp + 4, 4);
		for(i = 0; i < 4; i ++) {
 8049786:	83 c4 10             	add    $0x10,%esp
 8049789:	83 fe 06             	cmp    $0x6,%esi
 804978c:	75 da                	jne    8049768 <cmd_bt+0x88>
			printf("\t0x%08x", swaddr_read(ebp + ((i + 2) << 2), 4));
		}
		printf("\n");
 804978e:	83 ec 0c             	sub    $0xc,%esp
 8049791:	6a 0a                	push   $0xa
 8049793:	e8 78 f3 ff ff       	call   8048b10 <putchar@plt>
		ebp = swaddr_read(ebp, 4);
 8049798:	58                   	pop    %eax
 8049799:	5a                   	pop    %edx
 804979a:	6a 04                	push   $0x4
 804979c:	53                   	push   %ebx
 804979d:	e8 be 17 00 00       	call   804af60 <swaddr_read>
static int cmd_bt(char *args) {
	swaddr_t addr = cpu.eip;
	uint32_t ebp = cpu.ebp;
	char fun_name[32];
	int i, flag, cnt = 0;
	while(ebp) {
 80497a2:	83 c4 10             	add    $0x10,%esp
 80497a5:	85 c0                	test   %eax,%eax
		if(strcmp(fun_name, "main") != 0) addr = swaddr_read(ebp + 4, 4);
		for(i = 0; i < 4; i ++) {
			printf("\t0x%08x", swaddr_read(ebp + ((i + 2) << 2), 4));
		}
		printf("\n");
		ebp = swaddr_read(ebp, 4);
 80497a7:	89 c3                	mov    %eax,%ebx
static int cmd_bt(char *args) {
	swaddr_t addr = cpu.eip;
	uint32_t ebp = cpu.ebp;
	char fun_name[32];
	int i, flag, cnt = 0;
	while(ebp) {
 80497a9:	74 35                	je     80497e0 <cmd_bt+0x100>
		get_func_name(fun_name, addr, &flag);
		if(!flag) {
			printf("the program haven't start yet.\n");
			return 0;
		}
		printf("#%d\t0x%x\tin %s()\n", cnt++, addr, fun_name);
 80497ab:	8b 74 24 0c          	mov    0xc(%esp),%esi
 80497af:	e9 54 ff ff ff       	jmp    8049708 <cmd_bt+0x28>
 80497b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if(strcmp(fun_name, "main") != 0) addr = swaddr_read(ebp + 4, 4);
 80497b8:	8d 43 04             	lea    0x4(%ebx),%eax
 80497bb:	83 ec 08             	sub    $0x8,%esp
 80497be:	6a 04                	push   $0x4
 80497c0:	50                   	push   %eax
 80497c1:	e8 9a 17 00 00       	call   804af60 <swaddr_read>
 80497c6:	89 44 24 18          	mov    %eax,0x18(%esp)
 80497ca:	83 c4 10             	add    $0x10,%esp
 80497cd:	eb 94                	jmp    8049763 <cmd_bt+0x83>
 80497cf:	90                   	nop
	int i, flag, cnt = 0;
	while(ebp) {
		flag = 0;
		get_func_name(fun_name, addr, &flag);
		if(!flag) {
			printf("the program haven't start yet.\n");
 80497d0:	83 ec 0c             	sub    $0xc,%esp
 80497d3:	68 28 f0 05 08       	push   $0x805f028
 80497d8:	e8 83 f2 ff ff       	call   8048a60 <puts@plt>
			return 0;
 80497dd:	83 c4 10             	add    $0x10,%esp
		}
		printf("\n");
		ebp = swaddr_read(ebp, 4);
	}
	return 0;
}
 80497e0:	83 c4 4c             	add    $0x4c,%esp
 80497e3:	31 c0                	xor    %eax,%eax
 80497e5:	5b                   	pop    %ebx
 80497e6:	5e                   	pop    %esi
 80497e7:	5f                   	pop    %edi
 80497e8:	5d                   	pop    %ebp
 80497e9:	c3                   	ret    
 80497ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

080497f0 <cmd_d>:
static int cmd_w(char *args) {
	add_wp(args);
	return 0;
}

static int cmd_d(char *args) {
 80497f0:	83 ec 0c             	sub    $0xc,%esp
 80497f3:	8b 44 24 10          	mov    0x10(%esp),%eax
	if(args == 0) {
 80497f7:	85 c0                	test   %eax,%eax
 80497f9:	74 25                	je     8049820 <cmd_d+0x30>
#ifdef __USE_EXTERN_INLINES
__BEGIN_NAMESPACE_STD
__extern_inline int
__NTH (atoi (const char *__nptr))
{
  return (int) strtol (__nptr, (char **) NULL, 10);
 80497fb:	83 ec 04             	sub    $0x4,%esp
 80497fe:	6a 0a                	push   $0xa
 8049800:	6a 00                	push   $0x0
 8049802:	50                   	push   %eax
 8049803:	e8 98 f3 ff ff       	call   8048ba0 <strtol@plt>
		delete_all_wp();
		return 0;
	}
	int no = atoi(args);
	delete_wp(no);
 8049808:	89 04 24             	mov    %eax,(%esp)
 804980b:	e8 e0 06 00 00       	call   8049ef0 <delete_wp>
	return 0;
 8049810:	83 c4 10             	add    $0x10,%esp
}
 8049813:	31 c0                	xor    %eax,%eax
 8049815:	83 c4 0c             	add    $0xc,%esp
 8049818:	c3                   	ret    
 8049819:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return 0;
}

static int cmd_d(char *args) {
	if(args == 0) {
		delete_all_wp();
 8049820:	e8 7b 07 00 00       	call   8049fa0 <delete_all_wp>
		return 0;
	}
	int no = atoi(args);
	delete_wp(no);
	return 0;
}
 8049825:	31 c0                	xor    %eax,%eax
 8049827:	83 c4 0c             	add    $0xc,%esp
 804982a:	c3                   	ret    
 804982b:	90                   	nop
 804982c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08049830 <cmd_w>:
		return 0;
	}
	return 0;
}

static int cmd_w(char *args) {
 8049830:	83 ec 18             	sub    $0x18,%esp
	add_wp(args);
 8049833:	ff 74 24 1c          	pushl  0x1c(%esp)
 8049837:	e8 64 06 00 00       	call   8049ea0 <add_wp>
	return 0;
}
 804983c:	31 c0                	xor    %eax,%eax
 804983e:	83 c4 1c             	add    $0x1c,%esp
 8049841:	c3                   	ret    
 8049842:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049849:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049850 <cmd_p>:
	}
	printf("\n");
	return 0;
}

static int cmd_p(char *args) {
 8049850:	83 ec 24             	sub    $0x24,%esp
	bool flag = true;
	int n = expr(args, &flag);
 8049853:	8d 44 24 17          	lea    0x17(%esp),%eax
	printf("\n");
	return 0;
}

static int cmd_p(char *args) {
	bool flag = true;
 8049857:	c6 44 24 17 01       	movb   $0x1,0x17(%esp)
	int n = expr(args, &flag);
 804985c:	50                   	push   %eax
 804985d:	ff 74 24 2c          	pushl  0x2c(%esp)
 8049861:	e8 7a 12 00 00       	call   804aae0 <expr>
	if(flag) printf("0x%x\n", n);
 8049866:	83 c4 10             	add    $0x10,%esp
 8049869:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
 804986e:	75 20                	jne    8049890 <cmd_p+0x40>
	else {
		printf("not a correct expression.\n");
 8049870:	83 ec 0c             	sub    $0xc,%esp
 8049873:	68 c7 f0 05 08       	push   $0x805f0c7
 8049878:	e8 e3 f1 ff ff       	call   8048a60 <puts@plt>
		return 0;
 804987d:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
}
 8049880:	31 c0                	xor    %eax,%eax
 8049882:	83 c4 1c             	add    $0x1c,%esp
 8049885:	c3                   	ret    
 8049886:	8d 76 00             	lea    0x0(%esi),%esi
 8049889:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
}

static int cmd_p(char *args) {
	bool flag = true;
	int n = expr(args, &flag);
	if(flag) printf("0x%x\n", n);
 8049890:	83 ec 08             	sub    $0x8,%esp
 8049893:	50                   	push   %eax
 8049894:	68 c1 f0 05 08       	push   $0x805f0c1
 8049899:	e8 b2 f0 ff ff       	call   8048950 <printf@plt>
	else {
		printf("not a correct expression.\n");
		return 0;
	}
	return 0;
 804989e:	83 c4 10             	add    $0x10,%esp
}
 80498a1:	31 c0                	xor    %eax,%eax
 80498a3:	83 c4 1c             	add    $0x1c,%esp
 80498a6:	c3                   	ret    
 80498a7:	89 f6                	mov    %esi,%esi
 80498a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080498b0 <cmd_x>:
		print_wp_info();
	}
	return 0;
}

static int cmd_x(char *args) {
 80498b0:	57                   	push   %edi
 80498b1:	56                   	push   %esi
 80498b2:	53                   	push   %ebx
 80498b3:	83 ec 10             	sub    $0x10,%esp
 80498b6:	8b 74 24 20          	mov    0x20(%esp),%esi
	int i;
	int j = 0, n = 0, m = 0;
	bool flag = true;
 80498ba:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
	while(args[j]!=' ') {
 80498bf:	80 3e 20             	cmpb   $0x20,(%esi)
 80498c2:	0f 84 c1 00 00 00    	je     8049989 <cmd_x+0xd9>
 80498c8:	31 c0                	xor    %eax,%eax
 80498ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		j++;
 80498d0:	83 c0 01             	add    $0x1,%eax

static int cmd_x(char *args) {
	int i;
	int j = 0, n = 0, m = 0;
	bool flag = true;
	while(args[j]!=' ') {
 80498d3:	80 3c 06 20          	cmpb   $0x20,(%esi,%eax,1)
 80498d7:	75 f7                	jne    80498d0 <cmd_x+0x20>
 80498d9:	8d 58 01             	lea    0x1(%eax),%ebx
 80498dc:	83 ec 04             	sub    $0x4,%esp
 80498df:	6a 0a                	push   $0xa
 80498e1:	6a 00                	push   $0x0
 80498e3:	56                   	push   %esi
 80498e4:	e8 b7 f2 ff ff       	call   8048ba0 <strtol@plt>
 80498e9:	89 c7                	mov    %eax,%edi
		j++;
	}
	n = atoi(args);
	m = expr(args + j + 1, &flag);
 80498eb:	58                   	pop    %eax
 80498ec:	5a                   	pop    %edx
 80498ed:	8d 14 1e             	lea    (%esi,%ebx,1),%edx
 80498f0:	8d 44 24 17          	lea    0x17(%esp),%eax
 80498f4:	50                   	push   %eax
 80498f5:	52                   	push   %edx
 80498f6:	e8 e5 11 00 00       	call   804aae0 <expr>
	if(!flag) {
 80498fb:	83 c4 10             	add    $0x10,%esp
 80498fe:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
 8049903:	74 6b                	je     8049970 <cmd_x+0xc0>
		printf("not a correct expression.\n");
		return 0;
	}
	for(i = 0; i < 4 * n; i += 4) {
 8049905:	c1 e7 02             	shl    $0x2,%edi
 8049908:	31 db                	xor    %ebx,%ebx
 804990a:	89 c6                	mov    %eax,%esi
 804990c:	85 ff                	test   %edi,%edi
 804990e:	7f 2d                	jg     804993d <cmd_x+0x8d>
 8049910:	eb 46                	jmp    8049958 <cmd_x+0xa8>
 8049912:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		if((i & 15) == 0) printf("\n0x%08x:", m + i);
		printf(" 0x%08x", hwaddr_read(m + i, 4));
 8049918:	83 ec 08             	sub    $0x8,%esp
	m = expr(args + j + 1, &flag);
	if(!flag) {
		printf("not a correct expression.\n");
		return 0;
	}
	for(i = 0; i < 4 * n; i += 4) {
 804991b:	83 c3 04             	add    $0x4,%ebx
		if((i & 15) == 0) printf("\n0x%08x:", m + i);
		printf(" 0x%08x", hwaddr_read(m + i, 4));
 804991e:	6a 04                	push   $0x4
 8049920:	56                   	push   %esi
 8049921:	83 c6 04             	add    $0x4,%esi
 8049924:	e8 b7 15 00 00       	call   804aee0 <hwaddr_read>
 8049929:	5a                   	pop    %edx
 804992a:	59                   	pop    %ecx
 804992b:	50                   	push   %eax
 804992c:	68 ea f0 05 08       	push   $0x805f0ea
 8049931:	e8 1a f0 ff ff       	call   8048950 <printf@plt>
	m = expr(args + j + 1, &flag);
	if(!flag) {
		printf("not a correct expression.\n");
		return 0;
	}
	for(i = 0; i < 4 * n; i += 4) {
 8049936:	83 c4 10             	add    $0x10,%esp
 8049939:	39 fb                	cmp    %edi,%ebx
 804993b:	7d 1b                	jge    8049958 <cmd_x+0xa8>
		if((i & 15) == 0) printf("\n0x%08x:", m + i);
 804993d:	f6 c3 0f             	test   $0xf,%bl
 8049940:	75 d6                	jne    8049918 <cmd_x+0x68>
 8049942:	83 ec 08             	sub    $0x8,%esp
 8049945:	56                   	push   %esi
 8049946:	68 e1 f0 05 08       	push   $0x805f0e1
 804994b:	e8 00 f0 ff ff       	call   8048950 <printf@plt>
 8049950:	83 c4 10             	add    $0x10,%esp
 8049953:	eb c3                	jmp    8049918 <cmd_x+0x68>
 8049955:	8d 76 00             	lea    0x0(%esi),%esi
		printf(" 0x%08x", hwaddr_read(m + i, 4));
	}
	printf("\n");
 8049958:	83 ec 0c             	sub    $0xc,%esp
 804995b:	6a 0a                	push   $0xa
 804995d:	e8 ae f1 ff ff       	call   8048b10 <putchar@plt>
	return 0;
 8049962:	83 c4 10             	add    $0x10,%esp
}
 8049965:	31 c0                	xor    %eax,%eax
 8049967:	83 c4 10             	add    $0x10,%esp
 804996a:	5b                   	pop    %ebx
 804996b:	5e                   	pop    %esi
 804996c:	5f                   	pop    %edi
 804996d:	c3                   	ret    
 804996e:	66 90                	xchg   %ax,%ax
		j++;
	}
	n = atoi(args);
	m = expr(args + j + 1, &flag);
	if(!flag) {
		printf("not a correct expression.\n");
 8049970:	83 ec 0c             	sub    $0xc,%esp
 8049973:	68 c7 f0 05 08       	push   $0x805f0c7
 8049978:	e8 e3 f0 ff ff       	call   8048a60 <puts@plt>
		return 0;
 804997d:	83 c4 10             	add    $0x10,%esp
		if((i & 15) == 0) printf("\n0x%08x:", m + i);
		printf(" 0x%08x", hwaddr_read(m + i, 4));
	}
	printf("\n");
	return 0;
}
 8049980:	31 c0                	xor    %eax,%eax
 8049982:	83 c4 10             	add    $0x10,%esp
 8049985:	5b                   	pop    %ebx
 8049986:	5e                   	pop    %esi
 8049987:	5f                   	pop    %edi
 8049988:	c3                   	ret    

static int cmd_x(char *args) {
	int i;
	int j = 0, n = 0, m = 0;
	bool flag = true;
	while(args[j]!=' ') {
 8049989:	bb 01 00 00 00       	mov    $0x1,%ebx
 804998e:	e9 49 ff ff ff       	jmp    80498dc <cmd_x+0x2c>
 8049993:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8049999:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080499a0 <cmd_si>:

static int cmd_q(char *args) {
	return -1;
}

static int cmd_si(char *args) {
 80499a0:	83 ec 0c             	sub    $0xc,%esp
 80499a3:	8b 44 24 10          	mov    0x10(%esp),%eax
	if(args == NULL)cpu_exec(1);
 80499a7:	85 c0                	test   %eax,%eax
 80499a9:	74 25                	je     80499d0 <cmd_si+0x30>
 80499ab:	83 ec 04             	sub    $0x4,%esp
 80499ae:	6a 0a                	push   $0xa
 80499b0:	6a 00                	push   $0x0
 80499b2:	50                   	push   %eax
 80499b3:	e8 e8 f1 ff ff       	call   8048ba0 <strtol@plt>
	else cpu_exec(atoi(args));
 80499b8:	89 04 24             	mov    %eax,(%esp)
 80499bb:	e8 90 13 00 00       	call   804ad50 <cpu_exec>
 80499c0:	83 c4 10             	add    $0x10,%esp
	return 0;
}
 80499c3:	31 c0                	xor    %eax,%eax
 80499c5:	83 c4 0c             	add    $0xc,%esp
 80499c8:	c3                   	ret    
 80499c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
static int cmd_q(char *args) {
	return -1;
}

static int cmd_si(char *args) {
	if(args == NULL)cpu_exec(1);
 80499d0:	83 ec 0c             	sub    $0xc,%esp
 80499d3:	6a 01                	push   $0x1
 80499d5:	e8 76 13 00 00       	call   804ad50 <cpu_exec>
 80499da:	83 c4 10             	add    $0x10,%esp
	else cpu_exec(atoi(args));
	return 0;
}
 80499dd:	31 c0                	xor    %eax,%eax
 80499df:	83 c4 0c             	add    $0xc,%esp
 80499e2:	c3                   	ret    
 80499e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80499e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080499f0 <cmd_c>:
	}

	return line_read;
}

static int cmd_c(char *args) {
 80499f0:	83 ec 18             	sub    $0x18,%esp
	cpu_exec(-1);
 80499f3:	6a ff                	push   $0xffffffff
 80499f5:	e8 56 13 00 00       	call   804ad50 <cpu_exec>
	return 0;
}
 80499fa:	31 c0                	xor    %eax,%eax
 80499fc:	83 c4 1c             	add    $0x1c,%esp
 80499ff:	c3                   	ret    

08049a00 <cmd_help>:

};

#define NR_CMD (sizeof(cmd_table) / sizeof(cmd_table[0]))

static int cmd_help(char *args) {
 8049a00:	55                   	push   %ebp
 8049a01:	57                   	push   %edi
 8049a02:	56                   	push   %esi
 8049a03:	53                   	push   %ebx
	/* extract the first argument */
	char *arg = strtok(NULL, " ");
	int i;

	if(arg == NULL) {
 8049a04:	31 db                	xor    %ebx,%ebx
 8049a06:	be 00 f2 05 08       	mov    $0x805f200,%esi

};

#define NR_CMD (sizeof(cmd_table) / sizeof(cmd_table[0]))

static int cmd_help(char *args) {
 8049a0b:	83 ec 14             	sub    $0x14,%esp
	/* extract the first argument */
	char *arg = strtok(NULL, " ");
 8049a0e:	68 a6 f6 05 08       	push   $0x805f6a6
 8049a13:	6a 00                	push   $0x0
 8049a15:	e8 46 f1 ff ff       	call   8048b60 <strtok@plt>
	int i;

	if(arg == NULL) {
 8049a1a:	83 c4 10             	add    $0x10,%esp
 8049a1d:	85 c0                	test   %eax,%eax

#define NR_CMD (sizeof(cmd_table) / sizeof(cmd_table[0]))

static int cmd_help(char *args) {
	/* extract the first argument */
	char *arg = strtok(NULL, " ");
 8049a1f:	89 c5                	mov    %eax,%ebp
	int i;

	if(arg == NULL) {
 8049a21:	74 6d                	je     8049a90 <cmd_help+0x90>
 8049a23:	90                   	nop
 8049a24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			printf("%s - %s\n", cmd_table[i].name, cmd_table[i].description);
		}
	}
	else {
		for(i = 0; i < NR_CMD; i ++) {
			if(strcmp(arg, cmd_table[i].name) == 0) {
 8049a28:	8b 3e                	mov    (%esi),%edi
 8049a2a:	83 ec 08             	sub    $0x8,%esp
 8049a2d:	57                   	push   %edi
 8049a2e:	55                   	push   %ebp
 8049a2f:	e8 0c ef ff ff       	call   8048940 <strcmp@plt>
 8049a34:	83 c4 10             	add    $0x10,%esp
 8049a37:	85 c0                	test   %eax,%eax
 8049a39:	74 2d                	je     8049a68 <cmd_help+0x68>
		for(i = 0; i < NR_CMD; i ++) {
			printf("%s - %s\n", cmd_table[i].name, cmd_table[i].description);
		}
	}
	else {
		for(i = 0; i < NR_CMD; i ++) {
 8049a3b:	83 c3 01             	add    $0x1,%ebx
 8049a3e:	83 c6 0c             	add    $0xc,%esi
 8049a41:	83 fb 0a             	cmp    $0xa,%ebx
 8049a44:	75 e2                	jne    8049a28 <cmd_help+0x28>
			if(strcmp(arg, cmd_table[i].name) == 0) {
				printf("%s - %s\n", cmd_table[i].name, cmd_table[i].description);
				return 0;
			}
		}
		printf("Unknown command '%s'\n", arg);
 8049a46:	83 ec 08             	sub    $0x8,%esp
 8049a49:	55                   	push   %ebp
 8049a4a:	68 fb f0 05 08       	push   $0x805f0fb
 8049a4f:	e8 fc ee ff ff       	call   8048950 <printf@plt>
 8049a54:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
}
 8049a57:	31 c0                	xor    %eax,%eax
 8049a59:	83 c4 0c             	add    $0xc,%esp
 8049a5c:	5b                   	pop    %ebx
 8049a5d:	5e                   	pop    %esi
 8049a5e:	5f                   	pop    %edi
 8049a5f:	5d                   	pop    %ebp
 8049a60:	c3                   	ret    
 8049a61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}
	}
	else {
		for(i = 0; i < NR_CMD; i ++) {
			if(strcmp(arg, cmd_table[i].name) == 0) {
				printf("%s - %s\n", cmd_table[i].name, cmd_table[i].description);
 8049a68:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
 8049a6b:	83 ec 04             	sub    $0x4,%esp
 8049a6e:	ff 34 85 04 f2 05 08 	pushl  0x805f204(,%eax,4)
 8049a75:	57                   	push   %edi
 8049a76:	68 f2 f0 05 08       	push   $0x805f0f2
 8049a7b:	e8 d0 ee ff ff       	call   8048950 <printf@plt>
				return 0;
 8049a80:	83 c4 10             	add    $0x10,%esp
			}
		}
		printf("Unknown command '%s'\n", arg);
	}
	return 0;
}
 8049a83:	31 c0                	xor    %eax,%eax
 8049a85:	83 c4 0c             	add    $0xc,%esp
 8049a88:	5b                   	pop    %ebx
 8049a89:	5e                   	pop    %esi
 8049a8a:	5f                   	pop    %edi
 8049a8b:	5d                   	pop    %ebp
 8049a8c:	c3                   	ret    
 8049a8d:	8d 76 00             	lea    0x0(%esi),%esi
 8049a90:	bb 04 f2 05 08       	mov    $0x805f204,%ebx
 8049a95:	8d 76 00             	lea    0x0(%esi),%esi
	int i;

	if(arg == NULL) {
		/* no argument given */
		for(i = 0; i < NR_CMD; i ++) {
			printf("%s - %s\n", cmd_table[i].name, cmd_table[i].description);
 8049a98:	83 ec 04             	sub    $0x4,%esp
 8049a9b:	ff 33                	pushl  (%ebx)
 8049a9d:	ff 73 fc             	pushl  -0x4(%ebx)
 8049aa0:	68 f2 f0 05 08       	push   $0x805f0f2
 8049aa5:	83 c3 0c             	add    $0xc,%ebx
 8049aa8:	e8 a3 ee ff ff       	call   8048950 <printf@plt>
	char *arg = strtok(NULL, " ");
	int i;

	if(arg == NULL) {
		/* no argument given */
		for(i = 0; i < NR_CMD; i ++) {
 8049aad:	83 c4 10             	add    $0x10,%esp
 8049ab0:	81 fb 7c f2 05 08    	cmp    $0x805f27c,%ebx
 8049ab6:	75 e0                	jne    8049a98 <cmd_help+0x98>
			}
		}
		printf("Unknown command '%s'\n", arg);
	}
	return 0;
}
 8049ab8:	83 c4 0c             	add    $0xc,%esp
 8049abb:	31 c0                	xor    %eax,%eax
 8049abd:	5b                   	pop    %ebx
 8049abe:	5e                   	pop    %esi
 8049abf:	5f                   	pop    %edi
 8049ac0:	5d                   	pop    %ebp
 8049ac1:	c3                   	ret    
 8049ac2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049ac9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049ad0 <cmd_info>:
	if(args == NULL)cpu_exec(1);
	else cpu_exec(atoi(args));
	return 0;
}

static int cmd_info(char *args) {
 8049ad0:	53                   	push   %ebx
 8049ad1:	83 ec 08             	sub    $0x8,%esp
 8049ad4:	8b 44 24 10          	mov    0x10(%esp),%eax
	int i;
	if(args == NULL) {
 8049ad8:	85 c0                	test   %eax,%eax
 8049ada:	0f 84 e8 00 00 00    	je     8049bc8 <cmd_info+0xf8>
		printf("no input!");
		return 0;
	}
	if(args[0] == 'r') {
 8049ae0:	0f b6 00             	movzbl (%eax),%eax
 8049ae3:	3c 72                	cmp    $0x72,%al
 8049ae5:	74 19                	je     8049b00 <cmd_info+0x30>
		printf("OF = %d\n", cpu.OF);
		printf("CF = %d\n", cpu.CF);
		printf("SF = %d\n", cpu.SF);
		printf("ZF = %d\n", cpu.ZF);
	}
	else if(args[0] == 'w') {
 8049ae7:	3c 77                	cmp    $0x77,%al
 8049ae9:	0f 84 c9 00 00 00    	je     8049bb8 <cmd_info+0xe8>
		print_wp_info();
	}
	return 0;
}
 8049aef:	83 c4 08             	add    $0x8,%esp
 8049af2:	31 c0                	xor    %eax,%eax
 8049af4:	5b                   	pop    %ebx
 8049af5:	c3                   	ret    
 8049af6:	8d 76 00             	lea    0x0(%esi),%esi
 8049af9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 8049b00:	31 db                	xor    %ebx,%ebx
		printf("no input!");
		return 0;
	}
	if(args[0] == 'r') {
		for(i = R_EAX; i <= R_EDI; i ++) {
			printf("%s = 0x%08x\n", regsl[i], reg_l(i));
 8049b02:	83 ec 04             	sub    $0x4,%esp
 8049b05:	ff 34 9d c0 ae 8f 14 	pushl  0x148faec0(,%ebx,4)
 8049b0c:	ff 34 9d c0 5b 07 08 	pushl  0x8075bc0(,%ebx,4)
 8049b13:	68 1b f1 05 08       	push   $0x805f11b
	if(args == NULL) {
		printf("no input!");
		return 0;
	}
	if(args[0] == 'r') {
		for(i = R_EAX; i <= R_EDI; i ++) {
 8049b18:	83 c3 01             	add    $0x1,%ebx
			printf("%s = 0x%08x\n", regsl[i], reg_l(i));
 8049b1b:	e8 30 ee ff ff       	call   8048950 <printf@plt>
	if(args == NULL) {
		printf("no input!");
		return 0;
	}
	if(args[0] == 'r') {
		for(i = R_EAX; i <= R_EDI; i ++) {
 8049b20:	83 c4 10             	add    $0x10,%esp
 8049b23:	83 fb 08             	cmp    $0x8,%ebx
 8049b26:	75 da                	jne    8049b02 <cmd_info+0x32>
			printf("%s = 0x%04x\n", regsw[i], reg_w(i));
		}
		for(i = R_AL; i <= R_BH; i ++) {
			printf("%s = 0x%02x\n", regsb[i], reg_b(i));
		}*/
		printf("PF = %d\n", cpu.PF);
 8049b28:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 8049b2f:	83 ec 08             	sub    $0x8,%esp
 8049b32:	c0 e8 02             	shr    $0x2,%al
 8049b35:	83 e0 01             	and    $0x1,%eax
 8049b38:	50                   	push   %eax
 8049b39:	68 28 f1 05 08       	push   $0x805f128
 8049b3e:	e8 0d ee ff ff       	call   8048950 <printf@plt>
		printf("OF = %d\n", cpu.OF);
 8049b43:	58                   	pop    %eax
 8049b44:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
 8049b4b:	5a                   	pop    %edx
 8049b4c:	c0 e8 03             	shr    $0x3,%al
 8049b4f:	83 e0 01             	and    $0x1,%eax
 8049b52:	50                   	push   %eax
 8049b53:	68 31 f1 05 08       	push   $0x805f131
 8049b58:	e8 f3 ed ff ff       	call   8048950 <printf@plt>
		printf("CF = %d\n", cpu.CF);
 8049b5d:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 8049b64:	59                   	pop    %ecx
 8049b65:	5b                   	pop    %ebx
 8049b66:	83 e0 01             	and    $0x1,%eax
 8049b69:	50                   	push   %eax
 8049b6a:	68 3a f1 05 08       	push   $0x805f13a
 8049b6f:	e8 dc ed ff ff       	call   8048950 <printf@plt>
		printf("SF = %d\n", cpu.SF);
 8049b74:	58                   	pop    %eax
 8049b75:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 8049b7c:	5a                   	pop    %edx
 8049b7d:	c0 e8 07             	shr    $0x7,%al
 8049b80:	0f b6 c0             	movzbl %al,%eax
 8049b83:	50                   	push   %eax
 8049b84:	68 43 f1 05 08       	push   $0x805f143
 8049b89:	e8 c2 ed ff ff       	call   8048950 <printf@plt>
		printf("ZF = %d\n", cpu.ZF);
 8049b8e:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 8049b95:	59                   	pop    %ecx
 8049b96:	5b                   	pop    %ebx
 8049b97:	c0 e8 06             	shr    $0x6,%al
 8049b9a:	83 e0 01             	and    $0x1,%eax
 8049b9d:	50                   	push   %eax
 8049b9e:	68 4c f1 05 08       	push   $0x805f14c
 8049ba3:	e8 a8 ed ff ff       	call   8048950 <printf@plt>
 8049ba8:	83 c4 10             	add    $0x10,%esp
	}
	else if(args[0] == 'w') {
		print_wp_info();
	}
	return 0;
}
 8049bab:	31 c0                	xor    %eax,%eax
 8049bad:	83 c4 08             	add    $0x8,%esp
 8049bb0:	5b                   	pop    %ebx
 8049bb1:	c3                   	ret    
 8049bb2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		printf("CF = %d\n", cpu.CF);
		printf("SF = %d\n", cpu.SF);
		printf("ZF = %d\n", cpu.ZF);
	}
	else if(args[0] == 'w') {
		print_wp_info();
 8049bb8:	e8 93 02 00 00       	call   8049e50 <print_wp_info>
	}
	return 0;
}
 8049bbd:	83 c4 08             	add    $0x8,%esp
 8049bc0:	31 c0                	xor    %eax,%eax
 8049bc2:	5b                   	pop    %ebx
 8049bc3:	c3                   	ret    
 8049bc4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

static int cmd_info(char *args) {
	int i;
	if(args == NULL) {
		printf("no input!");
 8049bc8:	83 ec 0c             	sub    $0xc,%esp
 8049bcb:	68 11 f1 05 08       	push   $0x805f111
 8049bd0:	e8 7b ed ff ff       	call   8048950 <printf@plt>
		return 0;
 8049bd5:	83 c4 10             	add    $0x10,%esp
 8049bd8:	e9 12 ff ff ff       	jmp    8049aef <cmd_info+0x1f>
 8049bdd:	8d 76 00             	lea    0x0(%esi),%esi

08049be0 <rl_gets>:
void get_func_name(char *, swaddr_t, int *);

void cpu_exec(uint32_t);

/* We use the ``readline'' library to provide more flexibility to read from stdin. */
char* rl_gets() {
 8049be0:	83 ec 0c             	sub    $0xc,%esp
	static char *line_read = NULL;

	if (line_read) {
 8049be3:	a1 3c 5c 07 08       	mov    0x8075c3c,%eax
 8049be8:	85 c0                	test   %eax,%eax
 8049bea:	74 16                	je     8049c02 <rl_gets+0x22>
		free(line_read);
 8049bec:	83 ec 0c             	sub    $0xc,%esp
 8049bef:	50                   	push   %eax
 8049bf0:	e8 8b ed ff ff       	call   8048980 <free@plt>
		line_read = NULL;
 8049bf5:	c7 05 3c 5c 07 08 00 	movl   $0x0,0x8075c3c
 8049bfc:	00 00 00 
 8049bff:	83 c4 10             	add    $0x10,%esp
	}

	line_read = readline("(nemu) ");
 8049c02:	83 ec 0c             	sub    $0xc,%esp
 8049c05:	68 55 f1 05 08       	push   $0x805f155
 8049c0a:	e8 f1 ed ff ff       	call   8048a00 <readline@plt>

	if (line_read && *line_read) {
 8049c0f:	83 c4 10             	add    $0x10,%esp
 8049c12:	85 c0                	test   %eax,%eax
	if (line_read) {
		free(line_read);
		line_read = NULL;
	}

	line_read = readline("(nemu) ");
 8049c14:	a3 3c 5c 07 08       	mov    %eax,0x8075c3c

	if (line_read && *line_read) {
 8049c19:	74 16                	je     8049c31 <rl_gets+0x51>
 8049c1b:	80 38 00             	cmpb   $0x0,(%eax)
 8049c1e:	74 11                	je     8049c31 <rl_gets+0x51>
		add_history(line_read);
 8049c20:	83 ec 0c             	sub    $0xc,%esp
 8049c23:	50                   	push   %eax
 8049c24:	e8 67 ed ff ff       	call   8048990 <add_history@plt>
 8049c29:	a1 3c 5c 07 08       	mov    0x8075c3c,%eax
 8049c2e:	83 c4 10             	add    $0x10,%esp
	}

	return line_read;
}
 8049c31:	83 c4 0c             	add    $0xc,%esp
 8049c34:	c3                   	ret    
 8049c35:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049c39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049c40 <ui_mainloop>:
		printf("Unknown command '%s'\n", arg);
	}
	return 0;
}

void ui_mainloop() {
 8049c40:	55                   	push   %ebp
 8049c41:	57                   	push   %edi
 8049c42:	56                   	push   %esi
 8049c43:	53                   	push   %ebx
 8049c44:	83 ec 0c             	sub    $0xc,%esp
 8049c47:	89 f6                	mov    %esi,%esi
 8049c49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	while(1) {
		char *str = rl_gets();
 8049c50:	e8 8b ff ff ff       	call   8049be0 <rl_gets>
		char *str_end = str + strlen(str);
 8049c55:	83 ec 0c             	sub    $0xc,%esp
	return 0;
}

void ui_mainloop() {
	while(1) {
		char *str = rl_gets();
 8049c58:	89 c3                	mov    %eax,%ebx
		char *str_end = str + strlen(str);
 8049c5a:	50                   	push   %eax
 8049c5b:	e8 40 ee ff ff       	call   8048aa0 <strlen@plt>
 8049c60:	5a                   	pop    %edx
 8049c61:	59                   	pop    %ecx

		/* extract the first token as the command */
		char *cmd = strtok(str, " ");
 8049c62:	68 a6 f6 05 08       	push   $0x805f6a6
 8049c67:	53                   	push   %ebx
}

void ui_mainloop() {
	while(1) {
		char *str = rl_gets();
		char *str_end = str + strlen(str);
 8049c68:	89 c6                	mov    %eax,%esi

		/* extract the first token as the command */
		char *cmd = strtok(str, " ");
 8049c6a:	e8 f1 ee ff ff       	call   8048b60 <strtok@plt>
		if(cmd == NULL) { continue; }
 8049c6f:	83 c4 10             	add    $0x10,%esp
 8049c72:	85 c0                	test   %eax,%eax
	while(1) {
		char *str = rl_gets();
		char *str_end = str + strlen(str);

		/* extract the first token as the command */
		char *cmd = strtok(str, " ");
 8049c74:	89 c7                	mov    %eax,%edi
		if(cmd == NULL) { continue; }
 8049c76:	74 d8                	je     8049c50 <ui_mainloop+0x10>

		/* treat the remaining string as the arguments,
		 * which may need further parsing
		 */
		char *args = cmd + strlen(cmd) + 1;
 8049c78:	83 ec 0c             	sub    $0xc,%esp
}

void ui_mainloop() {
	while(1) {
		char *str = rl_gets();
		char *str_end = str + strlen(str);
 8049c7b:	01 f3                	add    %esi,%ebx
 8049c7d:	be 00 f2 05 08       	mov    $0x805f200,%esi
		if(cmd == NULL) { continue; }

		/* treat the remaining string as the arguments,
		 * which may need further parsing
		 */
		char *args = cmd + strlen(cmd) + 1;
 8049c82:	50                   	push   %eax
 8049c83:	e8 18 ee ff ff       	call   8048aa0 <strlen@plt>
 8049c88:	8d 6c 07 01          	lea    0x1(%edi,%eax,1),%ebp
 8049c8c:	83 c4 10             	add    $0x10,%esp
		if(args >= str_end) {
			args = NULL;
 8049c8f:	39 dd                	cmp    %ebx,%ebp
 8049c91:	19 c0                	sbb    %eax,%eax
 8049c93:	31 db                	xor    %ebx,%ebx
 8049c95:	21 c5                	and    %eax,%ebp
 8049c97:	89 f6                	mov    %esi,%esi
 8049c99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		sdl_clear_event_queue();
#endif

		int i;
		for(i = 0; i < NR_CMD; i ++) {
			if(strcmp(cmd, cmd_table[i].name) == 0) {
 8049ca0:	83 ec 08             	sub    $0x8,%esp
 8049ca3:	ff 36                	pushl  (%esi)
 8049ca5:	57                   	push   %edi
 8049ca6:	e8 95 ec ff ff       	call   8048940 <strcmp@plt>
 8049cab:	83 c4 10             	add    $0x10,%esp
 8049cae:	85 c0                	test   %eax,%eax
 8049cb0:	74 1e                	je     8049cd0 <ui_mainloop+0x90>
		extern void sdl_clear_event_queue(void);
		sdl_clear_event_queue();
#endif

		int i;
		for(i = 0; i < NR_CMD; i ++) {
 8049cb2:	83 c3 01             	add    $0x1,%ebx
 8049cb5:	83 c6 0c             	add    $0xc,%esi
 8049cb8:	83 fb 0a             	cmp    $0xa,%ebx
 8049cbb:	75 e3                	jne    8049ca0 <ui_mainloop+0x60>
				if(cmd_table[i].handler(args) < 0) { return; }
				break;
			}
		}

		if(i == NR_CMD) { printf("Unknown command '%s'\n", cmd); }
 8049cbd:	83 ec 08             	sub    $0x8,%esp
 8049cc0:	57                   	push   %edi
 8049cc1:	68 fb f0 05 08       	push   $0x805f0fb
 8049cc6:	e8 85 ec ff ff       	call   8048950 <printf@plt>
 8049ccb:	83 c4 10             	add    $0x10,%esp
 8049cce:	eb 80                	jmp    8049c50 <ui_mainloop+0x10>
#endif

		int i;
		for(i = 0; i < NR_CMD; i ++) {
			if(strcmp(cmd, cmd_table[i].name) == 0) {
				if(cmd_table[i].handler(args) < 0) { return; }
 8049cd0:	83 ec 0c             	sub    $0xc,%esp
 8049cd3:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
 8049cd6:	55                   	push   %ebp
 8049cd7:	ff 14 85 08 f2 05 08 	call   *0x805f208(,%eax,4)
 8049cde:	83 c4 10             	add    $0x10,%esp
 8049ce1:	85 c0                	test   %eax,%eax
 8049ce3:	0f 89 67 ff ff ff    	jns    8049c50 <ui_mainloop+0x10>
			}
		}

		if(i == NR_CMD) { printf("Unknown command '%s'\n", cmd); }
	}
}
 8049ce9:	83 c4 0c             	add    $0xc,%esp
 8049cec:	5b                   	pop    %ebx
 8049ced:	5e                   	pop    %esi
 8049cee:	5f                   	pop    %edi
 8049cef:	5d                   	pop    %ebp
 8049cf0:	c3                   	ret    
 8049cf1:	66 90                	xchg   %ax,%ax
 8049cf3:	66 90                	xchg   %ax,%ax
 8049cf5:	66 90                	xchg   %ax,%ax
 8049cf7:	66 90                	xchg   %ax,%ax
 8049cf9:	66 90                	xchg   %ax,%ax
 8049cfb:	66 90                	xchg   %ax,%ax
 8049cfd:	66 90                	xchg   %ax,%ax
 8049cff:	90                   	nop

08049d00 <init_wp_list>:

static WP wp_list[NR_WP];
static WP *head, *free_;
static int wp_num = 0;

void init_wp_list() {
 8049d00:	b8 8c 5d 07 08       	mov    $0x8075d8c,%eax
	int i;
	for(i = 0; i < NR_WP; i ++) {
 8049d05:	31 d2                	xor    %edx,%edx
 8049d07:	89 f6                	mov    %esi,%esi
 8049d09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		wp_list[i].NO = i;
 8049d10:	89 90 f4 fe ff ff    	mov    %edx,-0x10c(%eax)
		wp_list[i].next = &wp_list[i + 1];
 8049d16:	83 c2 01             	add    $0x1,%edx
 8049d19:	89 80 f8 fe ff ff    	mov    %eax,-0x108(%eax)
 8049d1f:	05 0c 01 00 00       	add    $0x10c,%eax
static WP *head, *free_;
static int wp_num = 0;

void init_wp_list() {
	int i;
	for(i = 0; i < NR_WP; i ++) {
 8049d24:	83 fa 20             	cmp    $0x20,%edx
 8049d27:	75 e7                	jne    8049d10 <init_wp_list+0x10>
		wp_list[i].NO = i;
		wp_list[i].next = &wp_list[i + 1];
	}
	wp_list[NR_WP - 1].next = NULL;
 8049d29:	c7 05 f8 7c 07 08 00 	movl   $0x0,0x8077cf8
 8049d30:	00 00 00 

	head = NULL;
 8049d33:	c7 05 48 5c 07 08 00 	movl   $0x0,0x8075c48
 8049d3a:	00 00 00 
	free_ = wp_list;
 8049d3d:	c7 05 44 5c 07 08 80 	movl   $0x8075c80,0x8075c44
 8049d44:	5c 07 08 
 8049d47:	c3                   	ret    
 8049d48:	90                   	nop
 8049d49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08049d50 <new_wp>:
}

WP* new_wp() {
	WP *now = free_;
 8049d50:	a1 44 5c 07 08       	mov    0x8075c44,%eax
	
	if(free_ == NULL) {
 8049d55:	85 c0                	test   %eax,%eax
 8049d57:	74 18                	je     8049d71 <new_wp+0x21>
		printf("no more points!\n");
		assert(0);	
	}	

	free_ = (*free_).next;
 8049d59:	8b 50 04             	mov    0x4(%eax),%edx
 8049d5c:	89 15 44 5c 07 08    	mov    %edx,0x8075c44
	(*now).next = head;
 8049d62:	8b 15 48 5c 07 08    	mov    0x8075c48,%edx
	head = now;
 8049d68:	a3 48 5c 07 08       	mov    %eax,0x8075c48
		printf("no more points!\n");
		assert(0);	
	}	

	free_ = (*free_).next;
	(*now).next = head;
 8049d6d:	89 50 04             	mov    %edx,0x4(%eax)
	head = now;

	return now;
}
 8049d70:	c3                   	ret    

	head = NULL;
	free_ = wp_list;
}

WP* new_wp() {
 8049d71:	83 ec 18             	sub    $0x18,%esp
	WP *now = free_;
	
	if(free_ == NULL) {
		printf("no more points!\n");
 8049d74:	68 78 f2 05 08       	push   $0x805f278
 8049d79:	e8 e2 ec ff ff       	call   8048a60 <puts@plt>
		assert(0);	
 8049d7e:	68 14 f3 05 08       	push   $0x805f314
 8049d83:	6a 1b                	push   $0x1b
 8049d85:	68 e8 f2 05 08       	push   $0x805f2e8
 8049d8a:	68 20 ef 05 08       	push   $0x805ef20
 8049d8f:	e8 1c ee ff ff       	call   8048bb0 <__assert_fail@plt>
 8049d94:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8049d9a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08049da0 <free_wp>:
	head = now;

	return now;
}

void free_wp(WP *wp) {
 8049da0:	83 ec 0c             	sub    $0xc,%esp
 8049da3:	8b 4c 24 10          	mov    0x10(%esp),%ecx
	if(wp == NULL) {
 8049da7:	85 c9                	test   %ecx,%ecx
 8049da9:	74 77                	je     8049e22 <free_wp+0x82>
		printf("free a null ponit!\n");
		assert(0);
	}

	WP *now = head;
 8049dab:	8b 15 48 5c 07 08    	mov    0x8075c48,%edx

	if(wp == head) {
 8049db1:	39 d1                	cmp    %edx,%ecx
 8049db3:	75 11                	jne    8049dc6 <free_wp+0x26>
 8049db5:	eb 51                	jmp    8049e08 <free_wp+0x68>
 8049db7:	89 f6                	mov    %esi,%esi
 8049db9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		free_ = wp;
		return;
	}

	while((*now).next != NULL) {
		if((*now).next == wp) {
 8049dc0:	39 c1                	cmp    %eax,%ecx
 8049dc2:	74 2c                	je     8049df0 <free_wp+0x50>
 8049dc4:	89 c2                	mov    %eax,%edx
		(*wp).next = free_;
		free_ = wp;
		return;
	}

	while((*now).next != NULL) {
 8049dc6:	8b 42 04             	mov    0x4(%edx),%eax
 8049dc9:	85 c0                	test   %eax,%eax
 8049dcb:	75 f3                	jne    8049dc0 <free_wp+0x20>
		}
		now = (*now).next;
	}

	if((*now).next == NULL) {
		printf("no this point\n");
 8049dcd:	83 ec 0c             	sub    $0xc,%esp
 8049dd0:	68 9b f2 05 08       	push   $0x805f29b
 8049dd5:	e8 86 ec ff ff       	call   8048a60 <puts@plt>
		assert(0);
 8049dda:	68 0c f3 05 08       	push   $0x805f30c
 8049ddf:	6a 40                	push   $0x40
 8049de1:	68 e8 f2 05 08       	push   $0x805f2e8
 8049de6:	68 20 ef 05 08       	push   $0x805ef20
 8049deb:	e8 c0 ed ff ff       	call   8048bb0 <__assert_fail@plt>
		return;
	}

	while((*now).next != NULL) {
		if((*now).next == wp) {
			(*now).next = (*wp).next;
 8049df0:	8b 41 04             	mov    0x4(%ecx),%eax
 8049df3:	89 42 04             	mov    %eax,0x4(%edx)
			(*wp).next = free_;
 8049df6:	a1 44 5c 07 08       	mov    0x8075c44,%eax
			free_ = wp;
 8049dfb:	89 0d 44 5c 07 08    	mov    %ecx,0x8075c44
	}

	while((*now).next != NULL) {
		if((*now).next == wp) {
			(*now).next = (*wp).next;
			(*wp).next = free_;
 8049e01:	89 41 04             	mov    %eax,0x4(%ecx)

	if((*now).next == NULL) {
		printf("no this point\n");
		assert(0);
	}
}
 8049e04:	83 c4 0c             	add    $0xc,%esp
 8049e07:	c3                   	ret    
	}

	WP *now = head;

	if(wp == head) {
		head = (*head).next;
 8049e08:	8b 41 04             	mov    0x4(%ecx),%eax
 8049e0b:	a3 48 5c 07 08       	mov    %eax,0x8075c48
		(*wp).next = free_;
 8049e10:	a1 44 5c 07 08       	mov    0x8075c44,%eax
		free_ = wp;
 8049e15:	89 0d 44 5c 07 08    	mov    %ecx,0x8075c44

	WP *now = head;

	if(wp == head) {
		head = (*head).next;
		(*wp).next = free_;
 8049e1b:	89 41 04             	mov    %eax,0x4(%ecx)

	if((*now).next == NULL) {
		printf("no this point\n");
		assert(0);
	}
}
 8049e1e:	83 c4 0c             	add    $0xc,%esp
 8049e21:	c3                   	ret    
	return now;
}

void free_wp(WP *wp) {
	if(wp == NULL) {
		printf("free a null ponit!\n");
 8049e22:	83 ec 0c             	sub    $0xc,%esp
 8049e25:	68 88 f2 05 08       	push   $0x805f288
 8049e2a:	e8 31 ec ff ff       	call   8048a60 <puts@plt>
		assert(0);
 8049e2f:	68 0c f3 05 08       	push   $0x805f30c
 8049e34:	6a 28                	push   $0x28
 8049e36:	68 e8 f2 05 08       	push   $0x805f2e8
 8049e3b:	68 20 ef 05 08       	push   $0x805ef20
 8049e40:	e8 6b ed ff ff       	call   8048bb0 <__assert_fail@plt>
 8049e45:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049e49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049e50 <print_wp_info>:
		printf("no this point\n");
		assert(0);
	}
}

void print_wp_info() {
 8049e50:	53                   	push   %ebx
 8049e51:	83 ec 14             	sub    $0x14,%esp
	WP* now = head;
 8049e54:	8b 1d 48 5c 07 08    	mov    0x8075c48,%ebx
	printf("Num\tValue\tExpr\n");
 8049e5a:	68 a9 f2 05 08       	push   $0x805f2a9
 8049e5f:	e8 fc eb ff ff       	call   8048a60 <puts@plt>
	while(now != NULL) {
 8049e64:	83 c4 10             	add    $0x10,%esp
 8049e67:	85 db                	test   %ebx,%ebx
 8049e69:	74 22                	je     8049e8d <print_wp_info+0x3d>
 8049e6b:	90                   	nop
 8049e6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		printf("%d\t%d\t%s\n", (*now).NO, (*now).v, (*now).expr);
 8049e70:	8d 43 0c             	lea    0xc(%ebx),%eax
 8049e73:	50                   	push   %eax
 8049e74:	ff 73 08             	pushl  0x8(%ebx)
 8049e77:	ff 33                	pushl  (%ebx)
 8049e79:	68 b8 f2 05 08       	push   $0x805f2b8
 8049e7e:	e8 cd ea ff ff       	call   8048950 <printf@plt>
		now = (*now).next;
 8049e83:	8b 5b 04             	mov    0x4(%ebx),%ebx
}

void print_wp_info() {
	WP* now = head;
	printf("Num\tValue\tExpr\n");
	while(now != NULL) {
 8049e86:	83 c4 10             	add    $0x10,%esp
 8049e89:	85 db                	test   %ebx,%ebx
 8049e8b:	75 e3                	jne    8049e70 <print_wp_info+0x20>
		printf("%d\t%d\t%s\n", (*now).NO, (*now).v, (*now).expr);
		now = (*now).next;
	}
}
 8049e8d:	83 c4 08             	add    $0x8,%esp
 8049e90:	5b                   	pop    %ebx
 8049e91:	c3                   	ret    
 8049e92:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049e99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049ea0 <add_wp>:

void add_wp(char *args) {
 8049ea0:	56                   	push   %esi
 8049ea1:	53                   	push   %ebx
 8049ea2:	83 ec 14             	sub    $0x14,%esp
	bool flag = true;
 8049ea5:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
	WP *now = new_wp();
 8049eaa:	e8 a1 fe ff ff       	call   8049d50 <new_wp>
 8049eaf:	89 c3                	mov    %eax,%ebx
	(*now).NO = wp_num ++;
 8049eb1:	a1 40 5c 07 08       	mov    0x8075c40,%eax
	strcpy((*now).expr, args);
 8049eb6:	83 ec 08             	sub    $0x8,%esp
 8049eb9:	8d 73 0c             	lea    0xc(%ebx),%esi
}

void add_wp(char *args) {
	bool flag = true;
	WP *now = new_wp();
	(*now).NO = wp_num ++;
 8049ebc:	89 03                	mov    %eax,(%ebx)
 8049ebe:	8d 50 01             	lea    0x1(%eax),%edx
	strcpy((*now).expr, args);
 8049ec1:	ff 74 24 28          	pushl  0x28(%esp)
 8049ec5:	56                   	push   %esi
}

void add_wp(char *args) {
	bool flag = true;
	WP *now = new_wp();
	(*now).NO = wp_num ++;
 8049ec6:	89 15 40 5c 07 08    	mov    %edx,0x8075c40
	strcpy((*now).expr, args);
 8049ecc:	e8 6f eb ff ff       	call   8048a40 <strcpy@plt>
	(*now).v = expr((*now).expr, &flag);
 8049ed1:	58                   	pop    %eax
 8049ed2:	5a                   	pop    %edx
 8049ed3:	8d 44 24 17          	lea    0x17(%esp),%eax
 8049ed7:	50                   	push   %eax
 8049ed8:	56                   	push   %esi
 8049ed9:	e8 02 0c 00 00       	call   804aae0 <expr>
 8049ede:	89 43 08             	mov    %eax,0x8(%ebx)
}
 8049ee1:	83 c4 24             	add    $0x24,%esp
 8049ee4:	5b                   	pop    %ebx
 8049ee5:	5e                   	pop    %esi
 8049ee6:	c3                   	ret    
 8049ee7:	89 f6                	mov    %esi,%esi
 8049ee9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049ef0 <delete_wp>:

void delete_wp(int no) {
	WP *now = head;
 8049ef0:	a1 48 5c 07 08       	mov    0x8075c48,%eax
	(*now).NO = wp_num ++;
	strcpy((*now).expr, args);
	(*now).v = expr((*now).expr, &flag);
}

void delete_wp(int no) {
 8049ef5:	8b 54 24 04          	mov    0x4(%esp),%edx
	WP *now = head;
	while(now != NULL) {
 8049ef9:	85 c0                	test   %eax,%eax
 8049efb:	75 0a                	jne    8049f07 <delete_wp+0x17>
 8049efd:	eb 19                	jmp    8049f18 <delete_wp+0x28>
 8049eff:	90                   	nop
		if((*now).NO == no) {
			free_wp(now);
			return;
		}
		now = (*now).next;
 8049f00:	8b 40 04             	mov    0x4(%eax),%eax
	(*now).v = expr((*now).expr, &flag);
}

void delete_wp(int no) {
	WP *now = head;
	while(now != NULL) {
 8049f03:	85 c0                	test   %eax,%eax
 8049f05:	74 11                	je     8049f18 <delete_wp+0x28>
		if((*now).NO == no) {
 8049f07:	39 10                	cmp    %edx,(%eax)
 8049f09:	75 f5                	jne    8049f00 <delete_wp+0x10>
			free_wp(now);
 8049f0b:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049f0f:	e9 8c fe ff ff       	jmp    8049da0 <free_wp>
 8049f14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			return;
		}
		now = (*now).next;
	}
	printf("no this number's point\n");
 8049f18:	c7 44 24 04 c2 f2 05 	movl   $0x805f2c2,0x4(%esp)
 8049f1f:	08 
 8049f20:	e9 3b eb ff ff       	jmp    8048a60 <puts@plt>
 8049f25:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049f29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049f30 <check_wp>:
}

void check_wp(bool *fl) {
 8049f30:	57                   	push   %edi
 8049f31:	56                   	push   %esi
 8049f32:	53                   	push   %ebx
 8049f33:	83 ec 10             	sub    $0x10,%esp
	WP *now = head;
 8049f36:	8b 1d 48 5c 07 08    	mov    0x8075c48,%ebx
 8049f3c:	8d 7c 24 0f          	lea    0xf(%esp),%edi
	while(now != NULL) {
 8049f40:	85 db                	test   %ebx,%ebx
 8049f42:	75 13                	jne    8049f57 <check_wp+0x27>
 8049f44:	eb 46                	jmp    8049f8c <check_wp+0x5c>
 8049f46:	8d 76 00             	lea    0x0(%esi),%esi
 8049f49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			*fl = false;
			(*now).v = t;
			printf("%d: %s = %d\n", (*now).NO, (*now).expr, t);
			break;
		}
		now = (*now).next;
 8049f50:	8b 5b 04             	mov    0x4(%ebx),%ebx
	printf("no this number's point\n");
}

void check_wp(bool *fl) {
	WP *now = head;
	while(now != NULL) {
 8049f53:	85 db                	test   %ebx,%ebx
 8049f55:	74 35                	je     8049f8c <check_wp+0x5c>
		bool flag =true;
		uint32_t t = expr((*now).expr, &flag);
 8049f57:	8d 73 0c             	lea    0xc(%ebx),%esi
}

void check_wp(bool *fl) {
	WP *now = head;
	while(now != NULL) {
		bool flag =true;
 8049f5a:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
		uint32_t t = expr((*now).expr, &flag);
 8049f5f:	83 ec 08             	sub    $0x8,%esp
 8049f62:	57                   	push   %edi
 8049f63:	56                   	push   %esi
 8049f64:	e8 77 0b 00 00       	call   804aae0 <expr>
		if(t != (*now).v) {
 8049f69:	83 c4 10             	add    $0x10,%esp
 8049f6c:	39 43 08             	cmp    %eax,0x8(%ebx)
 8049f6f:	74 df                	je     8049f50 <check_wp+0x20>
			*fl = false;
 8049f71:	8b 54 24 20          	mov    0x20(%esp),%edx
 8049f75:	c6 02 00             	movb   $0x0,(%edx)
			(*now).v = t;
 8049f78:	89 43 08             	mov    %eax,0x8(%ebx)
			printf("%d: %s = %d\n", (*now).NO, (*now).expr, t);
 8049f7b:	50                   	push   %eax
 8049f7c:	56                   	push   %esi
 8049f7d:	ff 33                	pushl  (%ebx)
 8049f7f:	68 d9 f2 05 08       	push   $0x805f2d9
 8049f84:	e8 c7 e9 ff ff       	call   8048950 <printf@plt>
			break;
 8049f89:	83 c4 10             	add    $0x10,%esp
		}
		now = (*now).next;
	}
}
 8049f8c:	83 c4 10             	add    $0x10,%esp
 8049f8f:	5b                   	pop    %ebx
 8049f90:	5e                   	pop    %esi
 8049f91:	5f                   	pop    %edi
 8049f92:	c3                   	ret    
 8049f93:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8049f99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049fa0 <delete_all_wp>:

void delete_all_wp() {
	while(head != NULL) {
 8049fa0:	a1 48 5c 07 08       	mov    0x8075c48,%eax
 8049fa5:	85 c0                	test   %eax,%eax
 8049fa7:	74 1f                	je     8049fc8 <delete_all_wp+0x28>
		}
		now = (*now).next;
	}
}

void delete_all_wp() {
 8049fa9:	83 ec 0c             	sub    $0xc,%esp
 8049fac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	while(head != NULL) {
		free_wp(head);
 8049fb0:	83 ec 0c             	sub    $0xc,%esp
 8049fb3:	50                   	push   %eax
 8049fb4:	e8 e7 fd ff ff       	call   8049da0 <free_wp>
		now = (*now).next;
	}
}

void delete_all_wp() {
	while(head != NULL) {
 8049fb9:	a1 48 5c 07 08       	mov    0x8075c48,%eax
 8049fbe:	83 c4 10             	add    $0x10,%esp
 8049fc1:	85 c0                	test   %eax,%eax
 8049fc3:	75 eb                	jne    8049fb0 <delete_all_wp+0x10>
		free_wp(head);
	}
}
 8049fc5:	83 c4 0c             	add    $0xc,%esp
 8049fc8:	f3 c3                	repz ret 
 8049fca:	66 90                	xchg   %ax,%ax
 8049fcc:	66 90                	xchg   %ax,%ax
 8049fce:	66 90                	xchg   %ax,%ax

08049fd0 <init_regex>:
static regex_t re[NR_REGEX];

/* Rules are used for many times.
 * Therefore we compile them only once before any usage.
 */
void init_regex() {
 8049fd0:	57                   	push   %edi
 8049fd1:	56                   	push   %esi
 8049fd2:	be 00 7e 07 08       	mov    $0x8077e00,%esi
 8049fd7:	53                   	push   %ebx
 8049fd8:	31 db                	xor    %ebx,%ebx
 8049fda:	83 c4 80             	add    $0xffffff80,%esp
 8049fdd:	eb 10                	jmp    8049fef <init_regex+0x1f>
 8049fdf:	90                   	nop
	int i;
	char error_msg[128];
	int ret;

	for(i = 0; i < NR_REGEX; i ++) {
 8049fe0:	83 c3 01             	add    $0x1,%ebx
 8049fe3:	83 c6 20             	add    $0x20,%esi
 8049fe6:	83 fb 1c             	cmp    $0x1c,%ebx
 8049fe9:	0f 84 91 00 00 00    	je     804a080 <init_regex+0xb0>
		ret = regcomp(&re[i], rules[i].regex, REG_EXTENDED);
 8049fef:	8b 3c dd c0 f5 05 08 	mov    0x805f5c0(,%ebx,8),%edi
 8049ff6:	83 ec 04             	sub    $0x4,%esp
 8049ff9:	6a 01                	push   $0x1
 8049ffb:	57                   	push   %edi
 8049ffc:	56                   	push   %esi
 8049ffd:	e8 7e eb ff ff       	call   8048b80 <regcomp@plt>
		if(ret != 0) {
 804a002:	83 c4 10             	add    $0x10,%esp
 804a005:	85 c0                	test   %eax,%eax
 804a007:	74 d7                	je     8049fe0 <init_regex+0x10>
			regerror(ret, &re[i], error_msg, 128);
 804a009:	68 80 00 00 00       	push   $0x80
 804a00e:	8d 5c 24 04          	lea    0x4(%esp),%ebx
 804a012:	53                   	push   %ebx
 804a013:	56                   	push   %esi
 804a014:	50                   	push   %eax
 804a015:	e8 06 eb ff ff       	call   8048b20 <regerror@plt>
			Assert(ret == 0, "regex compilation failed: %s\n%s", error_msg, rules[i].regex);
 804a01a:	58                   	pop    %eax
 804a01b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804a021:	e8 3a e9 ff ff       	call   8048960 <fflush@plt>
 804a026:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804a02c:	6a 07                	push   $0x7
 804a02e:	6a 01                	push   $0x1
 804a030:	68 92 ed 05 08       	push   $0x805ed92
 804a035:	e8 d6 e9 ff ff       	call   8048a10 <fwrite@plt>
 804a03a:	83 c4 20             	add    $0x20,%esp
 804a03d:	57                   	push   %edi
 804a03e:	53                   	push   %ebx
 804a03f:	68 4c f4 05 08       	push   $0x805f44c
 804a044:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804a04a:	e8 71 ea ff ff       	call   8048ac0 <fprintf@plt>
 804a04f:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804a055:	6a 05                	push   $0x5
 804a057:	6a 01                	push   $0x1
 804a059:	68 b1 ed 05 08       	push   $0x805edb1
 804a05e:	e8 ad e9 ff ff       	call   8048a10 <fwrite@plt>
 804a063:	83 c4 20             	add    $0x20,%esp
 804a066:	68 ad f5 05 08       	push   $0x805f5ad
 804a06b:	6a 4a                	push   $0x4a
 804a06d:	68 4a f3 05 08       	push   $0x805f34a
 804a072:	68 68 f3 05 08       	push   $0x805f368
 804a077:	e8 34 eb ff ff       	call   8048bb0 <__assert_fail@plt>
 804a07c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
	}
}
 804a080:	83 ec 80             	sub    $0xffffff80,%esp
 804a083:	5b                   	pop    %ebx
 804a084:	5e                   	pop    %esi
 804a085:	5f                   	pop    %edi
 804a086:	c3                   	ret    
 804a087:	89 f6                	mov    %esi,%esi
 804a089:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804a090 <not_a_num>:
} Token;

Token tokens[32];
int nr_token;

bool not_a_num(uint32_t p) {
 804a090:	8b 44 24 04          	mov    0x4(%esp),%eax
		if(tokens[p].type != NUM && tokens[p].type != ONUM && tokens[p].type != HNUM && tokens[p].type != '$' && tokens[p].type != VAR) {
 804a094:	8d 04 c0             	lea    (%eax,%eax,8),%eax
 804a097:	8b 14 85 c0 83 0c 08 	mov    0x80c83c0(,%eax,4),%edx
 804a09e:	81 fa 0d 01 00 00    	cmp    $0x10d,%edx
 804a0a4:	0f 95 c1             	setne  %cl
 804a0a7:	83 fa 24             	cmp    $0x24,%edx
 804a0aa:	0f 95 c0             	setne  %al
 804a0ad:	81 ea 02 01 00 00    	sub    $0x102,%edx
 804a0b3:	21 c8                	and    %ecx,%eax
 804a0b5:	83 fa 02             	cmp    $0x2,%edx
 804a0b8:	0f 97 c2             	seta   %dl
 804a0bb:	21 d0                	and    %edx,%eax
			return true;
		}
		else return false;
}
 804a0bd:	c3                   	ret    
 804a0be:	66 90                	xchg   %ax,%ax

0804a0c0 <check_parentheses>:
	}

	return true; 
}

bool check_parentheses(uint32_t p, uint32_t q, bool *success) {
 804a0c0:	56                   	push   %esi
 804a0c1:	53                   	push   %ebx
 804a0c2:	83 ec 04             	sub    $0x4,%esp
 804a0c5:	8b 54 24 10          	mov    0x10(%esp),%edx
 804a0c9:	8b 4c 24 14          	mov    0x14(%esp),%ecx
	int i = 0, j = 0;
	bool flag = true;
	if(p >= q) {
 804a0cd:	39 ca                	cmp    %ecx,%edx
 804a0cf:	0f 83 aa 00 00 00    	jae    804a17f <check_parentheses+0xbf>
		printf("there are something goes wrong\n");
		assert(0);
	}
	if(tokens[p].type != '(' || tokens[q].type != ')')return false;
 804a0d5:	8d 1c d2             	lea    (%edx,%edx,8),%ebx
 804a0d8:	31 c0                	xor    %eax,%eax
 804a0da:	83 3c 9d c0 83 0c 08 	cmpl   $0x28,0x80c83c0(,%ebx,4)
 804a0e1:	28 
 804a0e2:	74 0c                	je     804a0f0 <check_parentheses+0x30>
		printf("brackets not match!\n");
		*success = false;
		return true;
	}
	return flag;
}
 804a0e4:	83 c4 04             	add    $0x4,%esp
 804a0e7:	5b                   	pop    %ebx
 804a0e8:	5e                   	pop    %esi
 804a0e9:	c3                   	ret    
 804a0ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	bool flag = true;
	if(p >= q) {
		printf("there are something goes wrong\n");
		assert(0);
	}
	if(tokens[p].type != '(' || tokens[q].type != ')')return false;
 804a0f0:	8d 1c c9             	lea    (%ecx,%ecx,8),%ebx
 804a0f3:	c1 e3 02             	shl    $0x2,%ebx
 804a0f6:	83 bb c0 83 0c 08 29 	cmpl   $0x29,0x80c83c0(%ebx)
 804a0fd:	75 e5                	jne    804a0e4 <check_parentheses+0x24>
	for(i = p + 1; i < q; i++) {
 804a0ff:	83 c2 01             	add    $0x1,%edx
 804a102:	39 d1                	cmp    %edx,%ecx
 804a104:	76 6f                	jbe    804a175 <check_parentheses+0xb5>
 804a106:	8d 04 d2             	lea    (%edx,%edx,8),%eax
 804a109:	81 c3 c0 83 0c 08    	add    $0x80c83c0,%ebx
 804a10f:	31 f6                	xor    %esi,%esi
 804a111:	8d 14 85 c0 83 0c 08 	lea    0x80c83c0(,%eax,4),%edx
 804a118:	b8 01 00 00 00       	mov    $0x1,%eax
 804a11d:	eb 0d                	jmp    804a12c <check_parentheses+0x6c>
 804a11f:	90                   	nop
		if(tokens[i].type == '(') {
			j++;
		}
		else if(tokens[i].type == ')') {
 804a120:	83 f9 29             	cmp    $0x29,%ecx
 804a123:	74 3b                	je     804a160 <check_parentheses+0xa0>
 804a125:	83 c2 24             	add    $0x24,%edx
	if(p >= q) {
		printf("there are something goes wrong\n");
		assert(0);
	}
	if(tokens[p].type != '(' || tokens[q].type != ')')return false;
	for(i = p + 1; i < q; i++) {
 804a128:	39 da                	cmp    %ebx,%edx
 804a12a:	74 11                	je     804a13d <check_parentheses+0x7d>
		if(tokens[i].type == '(') {
 804a12c:	8b 0a                	mov    (%edx),%ecx
 804a12e:	83 f9 28             	cmp    $0x28,%ecx
 804a131:	75 ed                	jne    804a120 <check_parentheses+0x60>
 804a133:	83 c2 24             	add    $0x24,%edx
			j++;
 804a136:	83 c6 01             	add    $0x1,%esi
	if(p >= q) {
		printf("there are something goes wrong\n");
		assert(0);
	}
	if(tokens[p].type != '(' || tokens[q].type != ')')return false;
	for(i = p + 1; i < q; i++) {
 804a139:	39 da                	cmp    %ebx,%edx
 804a13b:	75 ef                	jne    804a12c <check_parentheses+0x6c>
			j--;
			if(j < 0) flag = false;
			if(j < -1) *success = false;
		}
	}
	if(j != 0) {
 804a13d:	85 f6                	test   %esi,%esi
 804a13f:	74 a3                	je     804a0e4 <check_parentheses+0x24>
		printf("brackets not match!\n");
 804a141:	83 ec 0c             	sub    $0xc,%esp
 804a144:	68 71 f3 05 08       	push   $0x805f371
 804a149:	e8 12 e9 ff ff       	call   8048a60 <puts@plt>
		*success = false;
 804a14e:	8b 44 24 28          	mov    0x28(%esp),%eax
		return true;
 804a152:	83 c4 10             	add    $0x10,%esp
			if(j < -1) *success = false;
		}
	}
	if(j != 0) {
		printf("brackets not match!\n");
		*success = false;
 804a155:	c6 00 00             	movb   $0x0,(%eax)
		return true;
 804a158:	b8 01 00 00 00       	mov    $0x1,%eax
 804a15d:	eb 85                	jmp    804a0e4 <check_parentheses+0x24>
 804a15f:	90                   	nop
		if(tokens[i].type == '(') {
			j++;
		}
		else if(tokens[i].type == ')') {
			j--;
			if(j < 0) flag = false;
 804a160:	83 ee 01             	sub    $0x1,%esi
 804a163:	79 c0                	jns    804a125 <check_parentheses+0x65>
			if(j < -1) *success = false;
 804a165:	83 fe ff             	cmp    $0xffffffff,%esi
 804a168:	74 3b                	je     804a1a5 <check_parentheses+0xe5>
 804a16a:	8b 44 24 18          	mov    0x18(%esp),%eax
 804a16e:	c6 00 00             	movb   $0x0,(%eax)
		if(tokens[i].type == '(') {
			j++;
		}
		else if(tokens[i].type == ')') {
			j--;
			if(j < 0) flag = false;
 804a171:	31 c0                	xor    %eax,%eax
 804a173:	eb b0                	jmp    804a125 <check_parentheses+0x65>
	return true; 
}

bool check_parentheses(uint32_t p, uint32_t q, bool *success) {
	int i = 0, j = 0;
	bool flag = true;
 804a175:	b8 01 00 00 00       	mov    $0x1,%eax
	if(j != 0) {
		printf("brackets not match!\n");
		*success = false;
		return true;
	}
	return flag;
 804a17a:	e9 65 ff ff ff       	jmp    804a0e4 <check_parentheses+0x24>

bool check_parentheses(uint32_t p, uint32_t q, bool *success) {
	int i = 0, j = 0;
	bool flag = true;
	if(p >= q) {
		printf("there are something goes wrong\n");
 804a17f:	83 ec 0c             	sub    $0xc,%esp
 804a182:	68 6c f4 05 08       	push   $0x805f46c
 804a187:	e8 d4 e8 ff ff       	call   8048a60 <puts@plt>
		assert(0);
 804a18c:	68 9b f5 05 08       	push   $0x805f59b
 804a191:	68 90 00 00 00       	push   $0x90
 804a196:	68 4a f3 05 08       	push   $0x805f34a
 804a19b:	68 20 ef 05 08       	push   $0x805ef20
 804a1a0:	e8 0b ea ff ff       	call   8048bb0 <__assert_fail@plt>
		if(tokens[i].type == '(') {
			j++;
		}
		else if(tokens[i].type == ')') {
			j--;
			if(j < 0) flag = false;
 804a1a5:	31 c0                	xor    %eax,%eax
 804a1a7:	e9 79 ff ff ff       	jmp    804a125 <check_parentheses+0x65>
 804a1ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a1b0 <relax>:
		return true;
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
 804a1b0:	53                   	push   %ebx
 804a1b1:	8b 44 24 14          	mov    0x14(%esp),%eax
 804a1b5:	8b 54 24 0c          	mov    0xc(%esp),%edx
	if(v >= *pr) {
 804a1b9:	39 10                	cmp    %edx,(%eax)
 804a1bb:	77 0c                	ja     804a1c9 <relax+0x19>
		*la = i;
 804a1bd:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 804a1c1:	8b 5c 24 08          	mov    0x8(%esp),%ebx
 804a1c5:	89 19                	mov    %ebx,(%ecx)
		*pr = v;
 804a1c7:	89 10                	mov    %edx,(%eax)
	}
	return 0;
}
 804a1c9:	31 c0                	xor    %eax,%eax
 804a1cb:	5b                   	pop    %ebx
 804a1cc:	c3                   	ret    
 804a1cd:	8d 76 00             	lea    0x0(%esi),%esi

0804a1d0 <relax1>:

uint32_t relax1(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
 804a1d0:	53                   	push   %ebx
 804a1d1:	8b 44 24 14          	mov    0x14(%esp),%eax
 804a1d5:	8b 54 24 0c          	mov    0xc(%esp),%edx
	if(v > *pr) {
 804a1d9:	39 10                	cmp    %edx,(%eax)
 804a1db:	73 0c                	jae    804a1e9 <relax1+0x19>
		*la = i;
 804a1dd:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 804a1e1:	8b 5c 24 08          	mov    0x8(%esp),%ebx
 804a1e5:	89 19                	mov    %ebx,(%ecx)
		*pr = v;
 804a1e7:	89 10                	mov    %edx,(%eax)
	}
	return 0;
}
 804a1e9:	31 c0                	xor    %eax,%eax
 804a1eb:	5b                   	pop    %ebx
 804a1ec:	c3                   	ret    
 804a1ed:	8d 76 00             	lea    0x0(%esi),%esi

0804a1f0 <find_the_last_operator>:

uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
 804a1f0:	55                   	push   %ebp
 804a1f1:	57                   	push   %edi
 804a1f2:	56                   	push   %esi
 804a1f3:	53                   	push   %ebx
 804a1f4:	83 ec 08             	sub    $0x8,%esp
 804a1f7:	8b 74 24 20          	mov    0x20(%esp),%esi
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a1fb:	39 74 24 1c          	cmp    %esi,0x1c(%esp)
 804a1ff:	0f 87 6e 03 00 00    	ja     804a573 <find_the_last_operator+0x383>
 804a205:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804a209:	31 ff                	xor    %edi,%edi
 804a20b:	31 ed                	xor    %ebp,%ebp
 804a20d:	31 c9                	xor    %ecx,%ecx
 804a20f:	8d 04 c0             	lea    (%eax,%eax,8),%eax
 804a212:	8d 14 85 9c 83 0c 08 	lea    0x80c839c(,%eax,4),%edx
 804a219:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804a21d:	8d 76 00             	lea    0x0(%esi),%esi
		if(tokens[i].type == '(') j++;
 804a220:	8b 5a 24             	mov    0x24(%edx),%ebx
 804a223:	83 fb 28             	cmp    $0x28,%ebx
 804a226:	74 68                	je     804a290 <find_the_last_operator+0xa0>
		else if(tokens[i].type == ')') j--;
 804a228:	83 fb 29             	cmp    $0x29,%ebx
 804a22b:	74 73                	je     804a2a0 <find_the_last_operator+0xb0>
		else if(j == 0) {
 804a22d:	85 c9                	test   %ecx,%ecx
 804a22f:	75 47                	jne    804a278 <find_the_last_operator+0x88>
			switch(tokens[i].type) {
 804a231:	83 fb 7c             	cmp    $0x7c,%ebx
 804a234:	0f 84 16 03 00 00    	je     804a550 <find_the_last_operator+0x360>
 804a23a:	7f 7c                	jg     804a2b8 <find_the_last_operator+0xc8>
 804a23c:	83 fb 2d             	cmp    $0x2d,%ebx
 804a23f:	0f 84 bb 02 00 00    	je     804a500 <find_the_last_operator+0x310>
 804a245:	0f 8f 2d 01 00 00    	jg     804a378 <find_the_last_operator+0x188>
 804a24b:	83 fb 26             	cmp    $0x26,%ebx
 804a24e:	0f 84 84 02 00 00    	je     804a4d8 <find_the_last_operator+0x2e8>
 804a254:	0f 8e de 01 00 00    	jle    804a438 <find_the_last_operator+0x248>
 804a25a:	83 fb 2a             	cmp    $0x2a,%ebx
 804a25d:	0f 84 5d 01 00 00    	je     804a3c0 <find_the_last_operator+0x1d0>
 804a263:	83 fb 2b             	cmp    $0x2b,%ebx
 804a266:	75 10                	jne    804a278 <find_the_last_operator+0x88>
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a268:	83 ff 04             	cmp    $0x4,%edi
 804a26b:	77 0b                	ja     804a278 <find_the_last_operator+0x88>
 804a26d:	89 c5                	mov    %eax,%ebp
		*la = i;
		*pr = v;
 804a26f:	bf 04 00 00 00       	mov    $0x4,%edi
 804a274:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a278:	83 c0 01             	add    $0x1,%eax
 804a27b:	83 c2 24             	add    $0x24,%edx
 804a27e:	39 c6                	cmp    %eax,%esi
 804a280:	73 9e                	jae    804a220 <find_the_last_operator+0x30>
					break;
			}
		}
	}
	return *la;
}
 804a282:	83 c4 08             	add    $0x8,%esp
 804a285:	89 e8                	mov    %ebp,%eax
 804a287:	5b                   	pop    %ebx
 804a288:	5e                   	pop    %esi
 804a289:	5f                   	pop    %edi
 804a28a:	5d                   	pop    %ebp
 804a28b:	c3                   	ret    
 804a28c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a290:	83 c0 01             	add    $0x1,%eax
		if(tokens[i].type == '(') j++;
 804a293:	83 c1 01             	add    $0x1,%ecx
 804a296:	83 c2 24             	add    $0x24,%edx
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a299:	39 c6                	cmp    %eax,%esi
 804a29b:	73 83                	jae    804a220 <find_the_last_operator+0x30>
 804a29d:	eb e3                	jmp    804a282 <find_the_last_operator+0x92>
 804a29f:	90                   	nop
 804a2a0:	83 c0 01             	add    $0x1,%eax
		if(tokens[i].type == '(') j++;
		else if(tokens[i].type == ')') j--;
 804a2a3:	83 e9 01             	sub    $0x1,%ecx
 804a2a6:	83 c2 24             	add    $0x24,%edx
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a2a9:	39 c6                	cmp    %eax,%esi
 804a2ab:	0f 83 6f ff ff ff    	jae    804a220 <find_the_last_operator+0x30>
 804a2b1:	eb cf                	jmp    804a282 <find_the_last_operator+0x92>
 804a2b3:	90                   	nop
 804a2b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if(tokens[i].type == '(') j++;
		else if(tokens[i].type == ')') j--;
		else if(j == 0) {
			switch(tokens[i].type) {
 804a2b8:	81 fb 07 01 00 00    	cmp    $0x107,%ebx
 804a2be:	74 20                	je     804a2e0 <find_the_last_operator+0xf0>
 804a2c0:	7f 66                	jg     804a328 <find_the_last_operator+0x138>
 804a2c2:	81 fb 01 01 00 00    	cmp    $0x101,%ebx
 804a2c8:	74 36                	je     804a300 <find_the_last_operator+0x110>
 804a2ca:	0f 8e a8 01 00 00    	jle    804a478 <find_the_last_operator+0x288>
 804a2d0:	81 fb 05 01 00 00    	cmp    $0x105,%ebx
 804a2d6:	74 28                	je     804a300 <find_the_last_operator+0x110>
 804a2d8:	81 fb 06 01 00 00    	cmp    $0x106,%ebx
 804a2de:	75 98                	jne    804a278 <find_the_last_operator+0x88>
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a2e0:	83 ff 06             	cmp    $0x6,%edi
 804a2e3:	77 93                	ja     804a278 <find_the_last_operator+0x88>
 804a2e5:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a2e7:	83 c0 01             	add    $0x1,%eax
 804a2ea:	83 c2 24             	add    $0x24,%edx
 804a2ed:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a2ef:	bf 06 00 00 00       	mov    $0x6,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a2f4:	0f 83 26 ff ff ff    	jae    804a220 <find_the_last_operator+0x30>
 804a2fa:	eb 86                	jmp    804a282 <find_the_last_operator+0x92>
 804a2fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a300:	83 ff 07             	cmp    $0x7,%edi
 804a303:	0f 87 6f ff ff ff    	ja     804a278 <find_the_last_operator+0x88>
 804a309:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a30b:	83 c0 01             	add    $0x1,%eax
 804a30e:	83 c2 24             	add    $0x24,%edx
 804a311:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a313:	bf 07 00 00 00       	mov    $0x7,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a318:	0f 83 02 ff ff ff    	jae    804a220 <find_the_last_operator+0x30>
 804a31e:	e9 5f ff ff ff       	jmp    804a282 <find_the_last_operator+0x92>
 804a323:	90                   	nop
 804a324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if(tokens[i].type == '(') j++;
		else if(tokens[i].type == ')') j--;
		else if(j == 0) {
			switch(tokens[i].type) {
 804a328:	81 fb 09 01 00 00    	cmp    $0x109,%ebx
 804a32e:	0f 84 7c 01 00 00    	je     804a4b0 <find_the_last_operator+0x2c0>
 804a334:	0f 8c 4e 01 00 00    	jl     804a488 <find_the_last_operator+0x298>
 804a33a:	81 fb 0b 01 00 00    	cmp    $0x10b,%ebx
 804a340:	74 0c                	je     804a34e <find_the_last_operator+0x15e>
 804a342:	81 fb 0c 01 00 00    	cmp    $0x10c,%ebx
 804a348:	0f 85 2a ff ff ff    	jne    804a278 <find_the_last_operator+0x88>
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a34e:	83 ff 05             	cmp    $0x5,%edi
 804a351:	0f 87 21 ff ff ff    	ja     804a278 <find_the_last_operator+0x88>
 804a357:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a359:	83 c0 01             	add    $0x1,%eax
 804a35c:	83 c2 24             	add    $0x24,%edx
 804a35f:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a361:	bf 05 00 00 00       	mov    $0x5,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a366:	0f 83 b4 fe ff ff    	jae    804a220 <find_the_last_operator+0x30>
 804a36c:	e9 11 ff ff ff       	jmp    804a282 <find_the_last_operator+0x92>
 804a371:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if(tokens[i].type == '(') j++;
		else if(tokens[i].type == ')') j--;
		else if(j == 0) {
			switch(tokens[i].type) {
 804a378:	83 fb 3c             	cmp    $0x3c,%ebx
 804a37b:	0f 84 5f ff ff ff    	je     804a2e0 <find_the_last_operator+0xf0>
 804a381:	0f 8e c1 00 00 00    	jle    804a448 <find_the_last_operator+0x258>
 804a387:	83 fb 3e             	cmp    $0x3e,%ebx
 804a38a:	0f 84 50 ff ff ff    	je     804a2e0 <find_the_last_operator+0xf0>
 804a390:	83 fb 5e             	cmp    $0x5e,%ebx
 804a393:	0f 85 df fe ff ff    	jne    804a278 <find_the_last_operator+0x88>
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a399:	83 ff 09             	cmp    $0x9,%edi
 804a39c:	0f 87 d6 fe ff ff    	ja     804a278 <find_the_last_operator+0x88>
 804a3a2:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a3a4:	83 c0 01             	add    $0x1,%eax
 804a3a7:	83 c2 24             	add    $0x24,%edx
 804a3aa:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a3ac:	bf 09 00 00 00       	mov    $0x9,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a3b1:	0f 83 69 fe ff ff    	jae    804a220 <find_the_last_operator+0x30>
 804a3b7:	e9 c6 fe ff ff       	jmp    804a282 <find_the_last_operator+0x92>
 804a3bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					break;
				case '/':
					relax(i, 3, la, pr);
					break;
				case '*':
					if(i != p && (!not_a_num(i-1) || tokens[i-1].type == ')')) relax(i, 4, la, pr);
 804a3c0:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
 804a3c4:	74 4b                	je     804a411 <find_the_last_operator+0x221>

Token tokens[32];
int nr_token;

bool not_a_num(uint32_t p) {
		if(tokens[p].type != NUM && tokens[p].type != ONUM && tokens[p].type != HNUM && tokens[p].type != '$' && tokens[p].type != VAR) {
 804a3c6:	8b 1a                	mov    (%edx),%ebx
					break;
				case '/':
					relax(i, 3, la, pr);
					break;
				case '*':
					if(i != p && (!not_a_num(i-1) || tokens[i-1].type == ')')) relax(i, 4, la, pr);
 804a3c8:	83 fb 29             	cmp    $0x29,%ebx
 804a3cb:	89 1c 24             	mov    %ebx,(%esp)
 804a3ce:	0f 94 44 24 06       	sete   0x6(%esp)

Token tokens[32];
int nr_token;

bool not_a_num(uint32_t p) {
		if(tokens[p].type != NUM && tokens[p].type != ONUM && tokens[p].type != HNUM && tokens[p].type != '$' && tokens[p].type != VAR) {
 804a3d3:	81 fb 0d 01 00 00    	cmp    $0x10d,%ebx
 804a3d9:	0f 95 44 24 07       	setne  0x7(%esp)
 804a3de:	83 3c 24 24          	cmpl   $0x24,(%esp)
 804a3e2:	0f b6 5c 24 07       	movzbl 0x7(%esp),%ebx
 804a3e7:	0f 95 44 24 07       	setne  0x7(%esp)
 804a3ec:	22 5c 24 07          	and    0x7(%esp),%bl
 804a3f0:	88 5c 24 07          	mov    %bl,0x7(%esp)
 804a3f4:	8b 1c 24             	mov    (%esp),%ebx
 804a3f7:	81 eb 02 01 00 00    	sub    $0x102,%ebx
 804a3fd:	83 fb 02             	cmp    $0x2,%ebx
 804a400:	0f 97 c3             	seta   %bl
 804a403:	22 5c 24 07          	and    0x7(%esp),%bl
					break;
				case '/':
					relax(i, 3, la, pr);
					break;
				case '*':
					if(i != p && (!not_a_num(i-1) || tokens[i-1].type == ')')) relax(i, 4, la, pr);
 804a407:	38 5c 24 06          	cmp    %bl,0x6(%esp)
 804a40b:	0f 83 57 fe ff ff    	jae    804a268 <find_the_last_operator+0x78>
	}
	return 0;
}

uint32_t relax1(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v > *pr) {
 804a411:	83 ff 01             	cmp    $0x1,%edi
 804a414:	0f 87 5e fe ff ff    	ja     804a278 <find_the_last_operator+0x88>
 804a41a:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a41c:	83 c0 01             	add    $0x1,%eax
 804a41f:	83 c2 24             	add    $0x24,%edx
 804a422:	39 c6                	cmp    %eax,%esi
}

uint32_t relax1(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v > *pr) {
		*la = i;
		*pr = v;
 804a424:	bf 02 00 00 00       	mov    $0x2,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a429:	0f 83 f1 fd ff ff    	jae    804a220 <find_the_last_operator+0x30>
 804a42f:	e9 4e fe ff ff       	jmp    804a282 <find_the_last_operator+0x92>
 804a434:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if(tokens[i].type == '(') j++;
		else if(tokens[i].type == ')') j--;
		else if(j == 0) {
			switch(tokens[i].type) {
 804a438:	83 fb 21             	cmp    $0x21,%ebx
 804a43b:	74 d4                	je     804a411 <find_the_last_operator+0x221>
 804a43d:	e9 36 fe ff ff       	jmp    804a278 <find_the_last_operator+0x88>
 804a442:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804a448:	83 fb 2f             	cmp    $0x2f,%ebx
 804a44b:	0f 85 27 fe ff ff    	jne    804a278 <find_the_last_operator+0x88>
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a451:	83 ff 03             	cmp    $0x3,%edi
 804a454:	0f 87 1e fe ff ff    	ja     804a278 <find_the_last_operator+0x88>
 804a45a:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a45c:	83 c0 01             	add    $0x1,%eax
 804a45f:	83 c2 24             	add    $0x24,%edx
 804a462:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a464:	bf 03 00 00 00       	mov    $0x3,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a469:	0f 83 b1 fd ff ff    	jae    804a220 <find_the_last_operator+0x30>
 804a46f:	e9 0e fe ff ff       	jmp    804a282 <find_the_last_operator+0x92>
 804a474:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if(tokens[i].type == '(') j++;
		else if(tokens[i].type == ')') j--;
		else if(j == 0) {
			switch(tokens[i].type) {
 804a478:	83 fb 7e             	cmp    $0x7e,%ebx
 804a47b:	74 94                	je     804a411 <find_the_last_operator+0x221>
 804a47d:	e9 f6 fd ff ff       	jmp    804a278 <find_the_last_operator+0x88>
 804a482:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a488:	83 ff 0b             	cmp    $0xb,%edi
 804a48b:	0f 87 e7 fd ff ff    	ja     804a278 <find_the_last_operator+0x88>
 804a491:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a493:	83 c0 01             	add    $0x1,%eax
 804a496:	83 c2 24             	add    $0x24,%edx
 804a499:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a49b:	bf 0b 00 00 00       	mov    $0xb,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a4a0:	0f 83 7a fd ff ff    	jae    804a220 <find_the_last_operator+0x30>
 804a4a6:	e9 d7 fd ff ff       	jmp    804a282 <find_the_last_operator+0x92>
 804a4ab:	90                   	nop
 804a4ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a4b0:	83 ff 0c             	cmp    $0xc,%edi
 804a4b3:	0f 87 bf fd ff ff    	ja     804a278 <find_the_last_operator+0x88>
 804a4b9:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a4bb:	83 c0 01             	add    $0x1,%eax
 804a4be:	83 c2 24             	add    $0x24,%edx
 804a4c1:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a4c3:	bf 0c 00 00 00       	mov    $0xc,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a4c8:	0f 83 52 fd ff ff    	jae    804a220 <find_the_last_operator+0x30>
 804a4ce:	e9 af fd ff ff       	jmp    804a282 <find_the_last_operator+0x92>
 804a4d3:	90                   	nop
 804a4d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a4d8:	83 ff 08             	cmp    $0x8,%edi
 804a4db:	0f 87 97 fd ff ff    	ja     804a278 <find_the_last_operator+0x88>
 804a4e1:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a4e3:	83 c0 01             	add    $0x1,%eax
 804a4e6:	83 c2 24             	add    $0x24,%edx
 804a4e9:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a4eb:	bf 08 00 00 00       	mov    $0x8,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a4f0:	0f 83 2a fd ff ff    	jae    804a220 <find_the_last_operator+0x30>
 804a4f6:	e9 87 fd ff ff       	jmp    804a282 <find_the_last_operator+0x92>
 804a4fb:	90                   	nop
 804a4fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					break;
				case '+':
					relax(i, 4, la, pr);
					break;
				case '-':
					if(i != p && (!not_a_num(i-1) || tokens[i-1].type == ')')) relax(i, 4, la, pr);
 804a500:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
 804a504:	0f 84 07 ff ff ff    	je     804a411 <find_the_last_operator+0x221>

Token tokens[32];
int nr_token;

bool not_a_num(uint32_t p) {
		if(tokens[p].type != NUM && tokens[p].type != ONUM && tokens[p].type != HNUM && tokens[p].type != '$' && tokens[p].type != VAR) {
 804a50a:	81 3a 0d 01 00 00    	cmpl   $0x10d,(%edx)
 804a510:	0f 95 04 24          	setne  (%esp)
 804a514:	83 3a 24             	cmpl   $0x24,(%edx)
 804a517:	0f 95 c3             	setne  %bl
 804a51a:	22 1c 24             	and    (%esp),%bl
 804a51d:	88 1c 24             	mov    %bl,(%esp)
 804a520:	8b 1a                	mov    (%edx),%ebx
 804a522:	81 eb 02 01 00 00    	sub    $0x102,%ebx
 804a528:	83 fb 02             	cmp    $0x2,%ebx
 804a52b:	0f 97 c3             	seta   %bl
 804a52e:	22 1c 24             	and    (%esp),%bl
					break;
				case '+':
					relax(i, 4, la, pr);
					break;
				case '-':
					if(i != p && (!not_a_num(i-1) || tokens[i-1].type == ')')) relax(i, 4, la, pr);
 804a531:	83 3a 29             	cmpl   $0x29,(%edx)
 804a534:	0f 94 04 24          	sete   (%esp)
 804a538:	3a 1c 24             	cmp    (%esp),%bl
 804a53b:	0f 87 d0 fe ff ff    	ja     804a411 <find_the_last_operator+0x221>
 804a541:	e9 22 fd ff ff       	jmp    804a268 <find_the_last_operator+0x78>
 804a546:	8d 76 00             	lea    0x0(%esi),%esi
 804a549:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a550:	83 ff 0a             	cmp    $0xa,%edi
 804a553:	0f 87 1f fd ff ff    	ja     804a278 <find_the_last_operator+0x88>
 804a559:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a55b:	83 c0 01             	add    $0x1,%eax
 804a55e:	83 c2 24             	add    $0x24,%edx
 804a561:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a563:	bf 0a 00 00 00       	mov    $0xa,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a568:	0f 83 b2 fc ff ff    	jae    804a220 <find_the_last_operator+0x30>
 804a56e:	e9 0f fd ff ff       	jmp    804a282 <find_the_last_operator+0x92>
	return 0;
}

uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
 804a573:	31 ed                	xor    %ebp,%ebp
 804a575:	e9 08 fd ff ff       	jmp    804a282 <find_the_last_operator+0x92>
 804a57a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804a580 <eval>:
		}
	}
	return *la;
}

uint32_t eval(uint32_t p, uint32_t q, bool *success) {
 804a580:	55                   	push   %ebp
 804a581:	57                   	push   %edi
 804a582:	56                   	push   %esi
 804a583:	53                   	push   %ebx
 804a584:	83 ec 1c             	sub    $0x1c,%esp
 804a587:	8b 5c 24 30          	mov    0x30(%esp),%ebx
 804a58b:	8b 74 24 34          	mov    0x34(%esp),%esi
 804a58f:	8b 7c 24 38          	mov    0x38(%esp),%edi
	int i;
	uint32_t op, val1, val2, ret;
	if(p > q) {
 804a593:	39 f3                	cmp    %esi,%ebx
 804a595:	77 34                	ja     804a5cb <eval+0x4b>
 804a597:	89 f6                	mov    %esi,%esi
 804a599:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		/* Bad expression */
		printf("p is less then q\n");
		*success = false;
		return 0;
	}
	else if(p == q) { 
 804a5a0:	0f 84 12 01 00 00    	je     804a6b8 <eval+0x138>
					   printf("dont have this number!\n");
					   *success = false;
					   return 0;
		}
	}
	else if(check_parentheses(p, q, success) == true) {
 804a5a6:	83 ec 04             	sub    $0x4,%esp
 804a5a9:	57                   	push   %edi
 804a5aa:	56                   	push   %esi
 804a5ab:	53                   	push   %ebx
 804a5ac:	e8 0f fb ff ff       	call   804a0c0 <check_parentheses>
 804a5b1:	83 c4 10             	add    $0x10,%esp
 804a5b4:	3c 01                	cmp    $0x1,%al
 804a5b6:	75 38                	jne    804a5f0 <eval+0x70>
		if(!(*success)) {
 804a5b8:	80 3f 00             	cmpb   $0x0,(%edi)
 804a5bb:	0f 84 e7 00 00 00    	je     804a6a8 <eval+0x128>
			return 0;
		}
		return eval(p + 1, q - 1, success); 
 804a5c1:	83 ee 01             	sub    $0x1,%esi
 804a5c4:	83 c3 01             	add    $0x1,%ebx
}

uint32_t eval(uint32_t p, uint32_t q, bool *success) {
	int i;
	uint32_t op, val1, val2, ret;
	if(p > q) {
 804a5c7:	39 de                	cmp    %ebx,%esi
 804a5c9:	73 d5                	jae    804a5a0 <eval+0x20>
		/* Bad expression */
		printf("p is less then q\n");
 804a5cb:	83 ec 0c             	sub    $0xc,%esp
		*success = false;
		return 0;
 804a5ce:	31 db                	xor    %ebx,%ebx
uint32_t eval(uint32_t p, uint32_t q, bool *success) {
	int i;
	uint32_t op, val1, val2, ret;
	if(p > q) {
		/* Bad expression */
		printf("p is less then q\n");
 804a5d0:	68 85 f3 05 08       	push   $0x805f385
 804a5d5:	e8 86 e4 ff ff       	call   8048a60 <puts@plt>
		*success = false;
 804a5da:	c6 07 00             	movb   $0x0,(%edi)
		return 0;
 804a5dd:	83 c4 10             	add    $0x10,%esp
						*success = false;
						return 0;
			}
		}
	}
}
 804a5e0:	83 c4 1c             	add    $0x1c,%esp
 804a5e3:	89 d8                	mov    %ebx,%eax
 804a5e5:	5b                   	pop    %ebx
 804a5e6:	5e                   	pop    %esi
 804a5e7:	5f                   	pop    %edi
 804a5e8:	5d                   	pop    %ebp
 804a5e9:	c3                   	ret    
 804a5ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			return 0;
		}
		return eval(p + 1, q - 1, success); 
	}
	else {
		op = find_the_last_operator(p, q);
 804a5f0:	83 ec 08             	sub    $0x8,%esp
 804a5f3:	56                   	push   %esi
 804a5f4:	53                   	push   %ebx
 804a5f5:	e8 f6 fb ff ff       	call   804a1f0 <find_the_last_operator>
 804a5fa:	83 c4 10             	add    $0x10,%esp
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
 804a5fd:	39 d8                	cmp    %ebx,%eax
			return 0;
		}
		return eval(p + 1, q - 1, success); 
	}
	else {
		op = find_the_last_operator(p, q);
 804a5ff:	89 c5                	mov    %eax,%ebp
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
 804a601:	74 42                	je     804a645 <eval+0xc5>
 804a603:	8d 48 ff             	lea    -0x1(%eax),%ecx

Token tokens[32];
int nr_token;

bool not_a_num(uint32_t p) {
		if(tokens[p].type != NUM && tokens[p].type != ONUM && tokens[p].type != HNUM && tokens[p].type != '$' && tokens[p].type != VAR) {
 804a606:	8d 04 c9             	lea    (%ecx,%ecx,8),%eax
 804a609:	8b 14 85 c0 83 0c 08 	mov    0x80c83c0(,%eax,4),%edx
		}
		return eval(p + 1, q - 1, success); 
	}
	else {
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
 804a610:	83 fa 29             	cmp    $0x29,%edx
 804a613:	0f 94 44 24 08       	sete   0x8(%esp)

Token tokens[32];
int nr_token;

bool not_a_num(uint32_t p) {
		if(tokens[p].type != NUM && tokens[p].type != ONUM && tokens[p].type != HNUM && tokens[p].type != '$' && tokens[p].type != VAR) {
 804a618:	81 fa 0d 01 00 00    	cmp    $0x10d,%edx
 804a61e:	0f 95 44 24 0f       	setne  0xf(%esp)
 804a623:	83 fa 24             	cmp    $0x24,%edx
 804a626:	0f 95 c0             	setne  %al
 804a629:	22 44 24 0f          	and    0xf(%esp),%al
 804a62d:	81 ea 02 01 00 00    	sub    $0x102,%edx
 804a633:	83 fa 02             	cmp    $0x2,%edx
 804a636:	0f 97 c2             	seta   %dl
 804a639:	21 d0                	and    %edx,%eax
		}
		return eval(p + 1, q - 1, success); 
	}
	else {
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
 804a63b:	38 44 24 08          	cmp    %al,0x8(%esp)
 804a63f:	0f 83 e6 00 00 00    	jae    804a72b <eval+0x1ab>
						*success = false;
						return 0;
			}
		}
		else {
			val2 = eval(op + 1, q, success);
 804a645:	8d 45 01             	lea    0x1(%ebp),%eax
 804a648:	83 ec 04             	sub    $0x4,%esp
 804a64b:	57                   	push   %edi
 804a64c:	56                   	push   %esi
 804a64d:	50                   	push   %eax
 804a64e:	e8 2d ff ff ff       	call   804a580 <eval>
			if(!(*success)) return 0;
 804a653:	83 c4 10             	add    $0x10,%esp
 804a656:	80 3f 00             	cmpb   $0x0,(%edi)
 804a659:	74 4d                	je     804a6a8 <eval+0x128>
			switch(tokens[op].type) {
 804a65b:	8d 54 ed 00          	lea    0x0(%ebp,%ebp,8),%edx
 804a65f:	8b 14 95 c0 83 0c 08 	mov    0x80c83c0(,%edx,4),%edx
 804a666:	83 fa 2a             	cmp    $0x2a,%edx
 804a669:	0f 84 f2 02 00 00    	je     804a961 <eval+0x3e1>
 804a66f:	0f 8e 03 02 00 00    	jle    804a878 <eval+0x2f8>
				case '-': return -val2;
 804a675:	89 c3                	mov    %eax,%ebx
 804a677:	f7 db                	neg    %ebx
			}
		}
		else {
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a679:	83 fa 2d             	cmp    $0x2d,%edx
 804a67c:	0f 84 5e ff ff ff    	je     804a5e0 <eval+0x60>
				case '-': return -val2;
				case '*': return hwaddr_read(val2, 4);
				case '!': return !val2;
				case '~': return ~val2;
 804a682:	f7 d0                	not    %eax
			}
		}
		else {
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a684:	83 fa 7e             	cmp    $0x7e,%edx
				case '-': return -val2;
				case '*': return hwaddr_read(val2, 4);
				case '!': return !val2;
				case '~': return ~val2;
 804a687:	89 c3                	mov    %eax,%ebx
			}
		}
		else {
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a689:	0f 84 51 ff ff ff    	je     804a5e0 <eval+0x60>
				case '-': return -val2;
				case '*': return hwaddr_read(val2, 4);
				case '!': return !val2;
				case '~': return ~val2;
				default:
						printf("the operator deosn't implemented.\n");
 804a68f:	83 ec 0c             	sub    $0xc,%esp
 804a692:	68 8c f4 05 08       	push   $0x805f48c
 804a697:	e8 c4 e3 ff ff       	call   8048a60 <puts@plt>
						*success = false;
 804a69c:	c6 07 00             	movb   $0x0,(%edi)
						return 0;
 804a69f:	83 c4 10             	add    $0x10,%esp
 804a6a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			}
		}
	}
}
 804a6a8:	83 c4 1c             	add    $0x1c,%esp
				case '!': return !val2;
				case '~': return ~val2;
				default:
						printf("the operator deosn't implemented.\n");
						*success = false;
						return 0;
 804a6ab:	31 db                	xor    %ebx,%ebx
			}
		}
	}
}
 804a6ad:	89 d8                	mov    %ebx,%eax
 804a6af:	5b                   	pop    %ebx
 804a6b0:	5e                   	pop    %esi
 804a6b1:	5f                   	pop    %edi
 804a6b2:	5d                   	pop    %ebp
 804a6b3:	c3                   	ret    
 804a6b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

Token tokens[32];
int nr_token;

bool not_a_num(uint32_t p) {
		if(tokens[p].type != NUM && tokens[p].type != ONUM && tokens[p].type != HNUM && tokens[p].type != '$' && tokens[p].type != VAR) {
 804a6b8:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
 804a6bb:	8b 04 85 c0 83 0c 08 	mov    0x80c83c0(,%eax,4),%eax
 804a6c2:	3d 0d 01 00 00       	cmp    $0x10d,%eax
 804a6c7:	0f 95 c1             	setne  %cl
 804a6ca:	83 f8 24             	cmp    $0x24,%eax
 804a6cd:	0f 95 c2             	setne  %dl
 804a6d0:	84 d1                	test   %dl,%cl
 804a6d2:	74 25                	je     804a6f9 <eval+0x179>
 804a6d4:	8d 90 fe fe ff ff    	lea    -0x102(%eax),%edx
 804a6da:	83 fa 02             	cmp    $0x2,%edx
 804a6dd:	76 1a                	jbe    804a6f9 <eval+0x179>
		*success = false;
		return 0;
	}
	else if(p == q) { 
		if(not_a_num(p)){
			printf("not a number!\n");
 804a6df:	83 ec 0c             	sub    $0xc,%esp
			*success = false;
			return 0;
 804a6e2:	31 db                	xor    %ebx,%ebx
		*success = false;
		return 0;
	}
	else if(p == q) { 
		if(not_a_num(p)){
			printf("not a number!\n");
 804a6e4:	68 da f3 05 08       	push   $0x805f3da
 804a6e9:	e8 72 e3 ff ff       	call   8048a60 <puts@plt>
			*success = false;
 804a6ee:	c6 07 00             	movb   $0x0,(%edi)
			return 0;
 804a6f1:	83 c4 10             	add    $0x10,%esp
 804a6f4:	e9 e7 fe ff ff       	jmp    804a5e0 <eval+0x60>
		}
		switch(tokens[p].type) {
 804a6f9:	3d 03 01 00 00       	cmp    $0x103,%eax
 804a6fe:	0f 84 0a 01 00 00    	je     804a80e <eval+0x28e>
 804a704:	0f 8f b6 00 00 00    	jg     804a7c0 <eval+0x240>
 804a70a:	83 f8 24             	cmp    $0x24,%eax
 804a70d:	0f 84 94 01 00 00    	je     804a8a7 <eval+0x327>
 804a713:	3d 02 01 00 00       	cmp    $0x102,%eax
 804a718:	0f 85 6f 01 00 00    	jne    804a88d <eval+0x30d>
			case NUM: return strtol(tokens[p].str, NULL, 10); 
 804a71e:	c7 44 24 38 0a 00 00 	movl   $0xa,0x38(%esp)
 804a725:	00 
 804a726:	e9 eb 00 00 00       	jmp    804a816 <eval+0x296>
		return eval(p + 1, q - 1, success); 
	}
	else {
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
 804a72b:	83 ec 04             	sub    $0x4,%esp
 804a72e:	57                   	push   %edi
 804a72f:	51                   	push   %ecx
 804a730:	53                   	push   %ebx
 804a731:	e8 4a fe ff ff       	call   804a580 <eval>
 804a736:	89 44 24 18          	mov    %eax,0x18(%esp)
			val2 = eval(op + 1, q, success);
 804a73a:	8d 45 01             	lea    0x1(%ebp),%eax
 804a73d:	83 c4 0c             	add    $0xc,%esp
 804a740:	57                   	push   %edi
 804a741:	56                   	push   %esi
 804a742:	50                   	push   %eax
 804a743:	e8 38 fe ff ff       	call   804a580 <eval>
			if(!(*success)) return 0;
 804a748:	83 c4 10             	add    $0x10,%esp
 804a74b:	80 3f 00             	cmpb   $0x0,(%edi)
	}
	else {
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
 804a74e:	89 c1                	mov    %eax,%ecx
			if(!(*success)) return 0;
 804a750:	0f 84 52 ff ff ff    	je     804a6a8 <eval+0x128>
			switch(tokens[op].type) {
 804a756:	8d 44 ed 00          	lea    0x0(%ebp,%ebp,8),%eax
 804a75a:	8b 54 24 08          	mov    0x8(%esp),%edx
 804a75e:	8b 04 85 c0 83 0c 08 	mov    0x80c83c0(,%eax,4),%eax
 804a765:	83 f8 5e             	cmp    $0x5e,%eax
 804a768:	0f 84 30 03 00 00    	je     804aa9e <eval+0x51e>
 804a76e:	0f 8e c4 00 00 00    	jle    804a838 <eval+0x2b8>
 804a774:	3d 07 01 00 00       	cmp    $0x107,%eax
 804a779:	0f 84 28 03 00 00    	je     804aaa7 <eval+0x527>
 804a77f:	0f 8f f4 01 00 00    	jg     804a979 <eval+0x3f9>
 804a785:	3d 01 01 00 00       	cmp    $0x101,%eax
 804a78a:	0f 84 38 03 00 00    	je     804aac8 <eval+0x548>
 804a790:	0f 8e 1d 03 00 00    	jle    804aab3 <eval+0x533>
 804a796:	3d 05 01 00 00       	cmp    $0x105,%eax
 804a79b:	0f 84 e5 02 00 00    	je     804aa86 <eval+0x506>
				case RS: return val1 >> val2;
				case '%': return val1 % val2;
				case '<': return val1 < val2;
				case '>': return val1 > val2;
				case NOT_LE: return val1 >= val2;
				case NOT_LA: return val1 <= val2;
 804a7a1:	31 db                	xor    %ebx,%ebx
 804a7a3:	39 ca                	cmp    %ecx,%edx
 804a7a5:	0f 96 c3             	setbe  %bl
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a7a8:	3d 06 01 00 00       	cmp    $0x106,%eax
 804a7ad:	0f 84 2d fe ff ff    	je     804a5e0 <eval+0x60>
 804a7b3:	e9 d7 fe ff ff       	jmp    804a68f <eval+0x10f>
 804a7b8:	90                   	nop
 804a7b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if(not_a_num(p)){
			printf("not a number!\n");
			*success = false;
			return 0;
		}
		switch(tokens[p].type) {
 804a7c0:	3d 04 01 00 00       	cmp    $0x104,%eax
 804a7c5:	0f 84 89 01 00 00    	je     804a954 <eval+0x3d4>
 804a7cb:	3d 0d 01 00 00       	cmp    $0x10d,%eax
 804a7d0:	0f 85 b7 00 00 00    	jne    804a88d <eval+0x30d>
						  if(strcmp("eip", tokens[p].str+1) == 0) return cpu.eip;
						  printf("register name wrong.\n");
						  *success = false;
						  return 0;
			case VAR:
						  ret = read_sym(tokens[p].str);
 804a7d6:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
 804a7d9:	83 ec 0c             	sub    $0xc,%esp
 804a7dc:	8d 04 85 c4 83 0c 08 	lea    0x80c83c4(,%eax,4),%eax
 804a7e3:	50                   	push   %eax
 804a7e4:	e8 e7 ed ff ff       	call   80495d0 <read_sym>
						  if(ret) return ret;
 804a7e9:	83 c4 10             	add    $0x10,%esp
 804a7ec:	85 c0                	test   %eax,%eax
 804a7ee:	89 c3                	mov    %eax,%ebx
 804a7f0:	0f 85 ea fd ff ff    	jne    804a5e0 <eval+0x60>
						  printf("dont have this variable\n");
 804a7f6:	83 ec 0c             	sub    $0xc,%esp
 804a7f9:	68 ab f3 05 08       	push   $0x805f3ab
 804a7fe:	e8 5d e2 ff ff       	call   8048a60 <puts@plt>
						  *success = false;
 804a803:	c6 07 00             	movb   $0x0,(%edi)
						  return 0;
 804a806:	83 c4 10             	add    $0x10,%esp
 804a809:	e9 d2 fd ff ff       	jmp    804a5e0 <eval+0x60>
			return 0;
		}
		switch(tokens[p].type) {
			case NUM: return strtol(tokens[p].str, NULL, 10); 
			case ONUM: return strtol(tokens[p].str, NULL, 8); 
			case HNUM: return strtol(tokens[p].str, NULL, 16); 
 804a80e:	c7 44 24 38 10 00 00 	movl   $0x10,0x38(%esp)
 804a815:	00 
			*success = false;
			return 0;
		}
		switch(tokens[p].type) {
			case NUM: return strtol(tokens[p].str, NULL, 10); 
			case ONUM: return strtol(tokens[p].str, NULL, 8); 
 804a816:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
 804a819:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
 804a820:	00 
 804a821:	8d 04 85 c4 83 0c 08 	lea    0x80c83c4(,%eax,4),%eax
 804a828:	89 44 24 30          	mov    %eax,0x30(%esp)
						*success = false;
						return 0;
			}
		}
	}
}
 804a82c:	83 c4 1c             	add    $0x1c,%esp
 804a82f:	5b                   	pop    %ebx
 804a830:	5e                   	pop    %esi
 804a831:	5f                   	pop    %edi
 804a832:	5d                   	pop    %ebp
			*success = false;
			return 0;
		}
		switch(tokens[p].type) {
			case NUM: return strtol(tokens[p].str, NULL, 10); 
			case ONUM: return strtol(tokens[p].str, NULL, 8); 
 804a833:	e9 68 e3 ff ff       	jmp    8048ba0 <strtol@plt>
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a838:	83 f8 2b             	cmp    $0x2b,%eax
 804a83b:	0f 84 3d 02 00 00    	je     804aa7e <eval+0x4fe>
 804a841:	0f 8e 66 01 00 00    	jle    804a9ad <eval+0x42d>
 804a847:	83 f8 2f             	cmp    $0x2f,%eax
 804a84a:	0f 84 f8 01 00 00    	je     804aa48 <eval+0x4c8>
 804a850:	0f 8e da 01 00 00    	jle    804aa30 <eval+0x4b0>
 804a856:	83 f8 3c             	cmp    $0x3c,%eax
 804a859:	0f 84 33 02 00 00    	je     804aa92 <eval+0x512>
				case '^': return val1 ^ val2;
				case LS: return val1 << val2;
				case RS: return val1 >> val2;
				case '%': return val1 % val2;
				case '<': return val1 < val2;
				case '>': return val1 > val2;
 804a85f:	31 db                	xor    %ebx,%ebx
 804a861:	39 ca                	cmp    %ecx,%edx
 804a863:	0f 97 c3             	seta   %bl
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a866:	83 f8 3e             	cmp    $0x3e,%eax
 804a869:	0f 84 71 fd ff ff    	je     804a5e0 <eval+0x60>
 804a86f:	e9 1b fe ff ff       	jmp    804a68f <eval+0x10f>
 804a874:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
				case '-': return -val2;
				case '*': return hwaddr_read(val2, 4);
				case '!': return !val2;
 804a878:	31 db                	xor    %ebx,%ebx
 804a87a:	85 c0                	test   %eax,%eax
 804a87c:	0f 94 c3             	sete   %bl
			}
		}
		else {
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a87f:	83 fa 21             	cmp    $0x21,%edx
 804a882:	0f 84 58 fd ff ff    	je     804a5e0 <eval+0x60>
 804a888:	e9 02 fe ff ff       	jmp    804a68f <eval+0x10f>
						  if(ret) return ret;
						  printf("dont have this variable\n");
						  *success = false;
						  return 0;
			default:
					   printf("dont have this number!\n");
 804a88d:	83 ec 0c             	sub    $0xc,%esp
					   *success = false;
					   return 0;
 804a890:	31 db                	xor    %ebx,%ebx
						  if(ret) return ret;
						  printf("dont have this variable\n");
						  *success = false;
						  return 0;
			default:
					   printf("dont have this number!\n");
 804a892:	68 c3 f3 05 08       	push   $0x805f3c3
 804a897:	e8 c4 e1 ff ff       	call   8048a60 <puts@plt>
					   *success = false;
 804a89c:	c6 07 00             	movb   $0x0,(%edi)
					   return 0;
 804a89f:	83 c4 10             	add    $0x10,%esp
 804a8a2:	e9 39 fd ff ff       	jmp    804a5e0 <eval+0x60>
 804a8a7:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
		if(not_a_num(p)){
			printf("not a number!\n");
			*success = false;
			return 0;
		}
		switch(tokens[p].type) {
 804a8aa:	31 db                	xor    %ebx,%ebx
 804a8ac:	8d 2c 85 c1 83 0c 08 	lea    0x80c83c1(,%eax,4),%ebp
 804a8b3:	8d 75 04             	lea    0x4(%ebp),%esi
 804a8b6:	8d 76 00             	lea    0x0(%esi),%esi
 804a8b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			case NUM: return strtol(tokens[p].str, NULL, 10); 
			case ONUM: return strtol(tokens[p].str, NULL, 8); 
			case HNUM: return strtol(tokens[p].str, NULL, 16); 
			case '$':
						  for(i = R_EAX; i <= R_EDI; i ++) {
							  if(strcmp(regsl[i], tokens[p].str+1) == 0) {
 804a8c0:	83 ec 08             	sub    $0x8,%esp
 804a8c3:	56                   	push   %esi
 804a8c4:	ff 34 9d c0 5b 07 08 	pushl  0x8075bc0(,%ebx,4)
 804a8cb:	e8 70 e0 ff ff       	call   8048940 <strcmp@plt>
 804a8d0:	83 c4 10             	add    $0x10,%esp
 804a8d3:	85 c0                	test   %eax,%eax
 804a8d5:	0f 84 fe 00 00 00    	je     804a9d9 <eval+0x459>
		switch(tokens[p].type) {
			case NUM: return strtol(tokens[p].str, NULL, 10); 
			case ONUM: return strtol(tokens[p].str, NULL, 8); 
			case HNUM: return strtol(tokens[p].str, NULL, 16); 
			case '$':
						  for(i = R_EAX; i <= R_EDI; i ++) {
 804a8db:	83 c3 01             	add    $0x1,%ebx
 804a8de:	83 fb 08             	cmp    $0x8,%ebx
 804a8e1:	75 dd                	jne    804a8c0 <eval+0x340>
 804a8e3:	30 db                	xor    %bl,%bl
 804a8e5:	8d 76 00             	lea    0x0(%esi),%esi
							  if(strcmp(regsl[i], tokens[p].str+1) == 0) {
								  return reg_l(i);
							  }
						  }
						  for(i = R_AX; i <= R_DI; i ++) {
							  if(strcmp(regsw[i], tokens[p].str+1) == 0) {
 804a8e8:	83 ec 08             	sub    $0x8,%esp
 804a8eb:	56                   	push   %esi
 804a8ec:	ff 34 9d a0 5b 07 08 	pushl  0x8075ba0(,%ebx,4)
 804a8f3:	e8 48 e0 ff ff       	call   8048940 <strcmp@plt>
 804a8f8:	83 c4 10             	add    $0x10,%esp
 804a8fb:	85 c0                	test   %eax,%eax
 804a8fd:	0f 84 e2 00 00 00    	je     804a9e5 <eval+0x465>
						  for(i = R_EAX; i <= R_EDI; i ++) {
							  if(strcmp(regsl[i], tokens[p].str+1) == 0) {
								  return reg_l(i);
							  }
						  }
						  for(i = R_AX; i <= R_DI; i ++) {
 804a903:	83 c3 01             	add    $0x1,%ebx
 804a906:	83 fb 08             	cmp    $0x8,%ebx
 804a909:	75 dd                	jne    804a8e8 <eval+0x368>
 804a90b:	30 db                	xor    %bl,%bl
							  if(strcmp(regsw[i], tokens[p].str+1) == 0) {
								  return reg_w(i);
							  }
						  }
						  for(i = R_AL; i <= R_BH; i ++) {
							  if(strcmp(regsb[i], tokens[p].str+1) == 0) {
 804a90d:	83 ec 08             	sub    $0x8,%esp
 804a910:	56                   	push   %esi
 804a911:	ff 34 9d 80 5b 07 08 	pushl  0x8075b80(,%ebx,4)
 804a918:	e8 23 e0 ff ff       	call   8048940 <strcmp@plt>
 804a91d:	83 c4 10             	add    $0x10,%esp
 804a920:	85 c0                	test   %eax,%eax
 804a922:	0f 84 f3 00 00 00    	je     804aa1b <eval+0x49b>
						  for(i = R_AX; i <= R_DI; i ++) {
							  if(strcmp(regsw[i], tokens[p].str+1) == 0) {
								  return reg_w(i);
							  }
						  }
						  for(i = R_AL; i <= R_BH; i ++) {
 804a928:	83 c3 01             	add    $0x1,%ebx
 804a92b:	83 fb 08             	cmp    $0x8,%ebx
 804a92e:	75 dd                	jne    804a90d <eval+0x38d>
							  if(strcmp(regsb[i], tokens[p].str+1) == 0) {
								  return reg_b(i);
							  }
						  }
						  if(strcmp("eip", tokens[p].str+1) == 0) return cpu.eip;
 804a930:	80 7d 04 65          	cmpb   $0x65,0x4(%ebp)
 804a934:	0f 84 b8 00 00 00    	je     804a9f2 <eval+0x472>
						  printf("register name wrong.\n");
 804a93a:	83 ec 0c             	sub    $0xc,%esp
						  *success = false;
						  return 0;
 804a93d:	31 db                	xor    %ebx,%ebx
							  if(strcmp(regsb[i], tokens[p].str+1) == 0) {
								  return reg_b(i);
							  }
						  }
						  if(strcmp("eip", tokens[p].str+1) == 0) return cpu.eip;
						  printf("register name wrong.\n");
 804a93f:	68 96 f3 05 08       	push   $0x805f396
 804a944:	e8 17 e1 ff ff       	call   8048a60 <puts@plt>
						  *success = false;
 804a949:	c6 07 00             	movb   $0x0,(%edi)
						  return 0;
 804a94c:	83 c4 10             	add    $0x10,%esp
 804a94f:	e9 8c fc ff ff       	jmp    804a5e0 <eval+0x60>
			*success = false;
			return 0;
		}
		switch(tokens[p].type) {
			case NUM: return strtol(tokens[p].str, NULL, 10); 
			case ONUM: return strtol(tokens[p].str, NULL, 8); 
 804a954:	c7 44 24 38 08 00 00 	movl   $0x8,0x38(%esp)
 804a95b:	00 
 804a95c:	e9 b5 fe ff ff       	jmp    804a816 <eval+0x296>
		else {
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
				case '-': return -val2;
				case '*': return hwaddr_read(val2, 4);
 804a961:	c7 44 24 34 04 00 00 	movl   $0x4,0x34(%esp)
 804a968:	00 
 804a969:	89 44 24 30          	mov    %eax,0x30(%esp)
						*success = false;
						return 0;
			}
		}
	}
}
 804a96d:	83 c4 1c             	add    $0x1c,%esp
 804a970:	5b                   	pop    %ebx
 804a971:	5e                   	pop    %esi
 804a972:	5f                   	pop    %edi
 804a973:	5d                   	pop    %ebp
		else {
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
				case '-': return -val2;
				case '*': return hwaddr_read(val2, 4);
 804a974:	e9 67 05 00 00       	jmp    804aee0 <hwaddr_read>
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a979:	3d 09 01 00 00       	cmp    $0x109,%eax
 804a97e:	0f 84 e4 00 00 00    	je     804aa68 <eval+0x4e8>
 804a984:	0f 8c cb 00 00 00    	jl     804aa55 <eval+0x4d5>
				case '&': return val1 & val2;
				case '|': return val1 | val2;
				case AND: return val1 && val2;
				case OR: return val1 || val2;
				case '^': return val1 ^ val2;
				case LS: return val1 << val2;
 804a98a:	89 d3                	mov    %edx,%ebx
 804a98c:	d3 e3                	shl    %cl,%ebx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a98e:	3d 0b 01 00 00       	cmp    $0x10b,%eax
 804a993:	0f 84 47 fc ff ff    	je     804a5e0 <eval+0x60>
				case '|': return val1 | val2;
				case AND: return val1 && val2;
				case OR: return val1 || val2;
				case '^': return val1 ^ val2;
				case LS: return val1 << val2;
				case RS: return val1 >> val2;
 804a999:	d3 ea                	shr    %cl,%edx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a99b:	3d 0c 01 00 00       	cmp    $0x10c,%eax
				case '|': return val1 | val2;
				case AND: return val1 && val2;
				case OR: return val1 || val2;
				case '^': return val1 ^ val2;
				case LS: return val1 << val2;
				case RS: return val1 >> val2;
 804a9a0:	89 d3                	mov    %edx,%ebx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a9a2:	0f 84 38 fc ff ff    	je     804a5e0 <eval+0x60>
 804a9a8:	e9 e2 fc ff ff       	jmp    804a68f <eval+0x10f>
				case '+': return val1 + val2;
				case '-': return val1 - val2;
				case '*': return val1 * val2;
				case '/': return val1 / val2;
				case '&': return val1 & val2;
 804a9ad:	89 cb                	mov    %ecx,%ebx
 804a9af:	21 d3                	and    %edx,%ebx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a9b1:	83 f8 26             	cmp    $0x26,%eax
 804a9b4:	0f 84 26 fc ff ff    	je     804a5e0 <eval+0x60>
 804a9ba:	83 f8 2a             	cmp    $0x2a,%eax
 804a9bd:	0f 84 b1 00 00 00    	je     804aa74 <eval+0x4f4>
 804a9c3:	83 f8 25             	cmp    $0x25,%eax
 804a9c6:	0f 85 c3 fc ff ff    	jne    804a68f <eval+0x10f>
				case AND: return val1 && val2;
				case OR: return val1 || val2;
				case '^': return val1 ^ val2;
				case LS: return val1 << val2;
				case RS: return val1 >> val2;
				case '%': return val1 % val2;
 804a9cc:	89 d0                	mov    %edx,%eax
 804a9ce:	31 d2                	xor    %edx,%edx
 804a9d0:	f7 f1                	div    %ecx
 804a9d2:	89 d3                	mov    %edx,%ebx
 804a9d4:	e9 07 fc ff ff       	jmp    804a5e0 <eval+0x60>
			case ONUM: return strtol(tokens[p].str, NULL, 8); 
			case HNUM: return strtol(tokens[p].str, NULL, 16); 
			case '$':
						  for(i = R_EAX; i <= R_EDI; i ++) {
							  if(strcmp(regsl[i], tokens[p].str+1) == 0) {
								  return reg_l(i);
 804a9d9:	8b 1c 9d c0 ae 8f 14 	mov    0x148faec0(,%ebx,4),%ebx
 804a9e0:	e9 fb fb ff ff       	jmp    804a5e0 <eval+0x60>
							  }
						  }
						  for(i = R_AX; i <= R_DI; i ++) {
							  if(strcmp(regsw[i], tokens[p].str+1) == 0) {
								  return reg_w(i);
 804a9e5:	0f b7 1c 9d c0 ae 8f 	movzwl 0x148faec0(,%ebx,4),%ebx
 804a9ec:	14 
 804a9ed:	e9 ee fb ff ff       	jmp    804a5e0 <eval+0x60>
						  for(i = R_AL; i <= R_BH; i ++) {
							  if(strcmp(regsb[i], tokens[p].str+1) == 0) {
								  return reg_b(i);
							  }
						  }
						  if(strcmp("eip", tokens[p].str+1) == 0) return cpu.eip;
 804a9f2:	80 7e 01 69          	cmpb   $0x69,0x1(%esi)
 804a9f6:	0f 85 3e ff ff ff    	jne    804a93a <eval+0x3ba>
 804a9fc:	80 7e 02 70          	cmpb   $0x70,0x2(%esi)
 804aa00:	0f 85 34 ff ff ff    	jne    804a93a <eval+0x3ba>
 804aa06:	80 7e 03 00          	cmpb   $0x0,0x3(%esi)
 804aa0a:	0f 85 2a ff ff ff    	jne    804a93a <eval+0x3ba>
 804aa10:	8b 1d e0 ae 8f 14    	mov    0x148faee0,%ebx
 804aa16:	e9 c5 fb ff ff       	jmp    804a5e0 <eval+0x60>
								  return reg_w(i);
							  }
						  }
						  for(i = R_AL; i <= R_BH; i ++) {
							  if(strcmp(regsb[i], tokens[p].str+1) == 0) {
								  return reg_b(i);
 804aa1b:	89 d8                	mov    %ebx,%eax
 804aa1d:	c1 fb 02             	sar    $0x2,%ebx
 804aa20:	83 e0 03             	and    $0x3,%eax
 804aa23:	0f b6 9c 83 c0 ae 8f 	movzbl 0x148faec0(%ebx,%eax,4),%ebx
 804aa2a:	14 
 804aa2b:	e9 b0 fb ff ff       	jmp    804a5e0 <eval+0x60>
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
				case '+': return val1 + val2;
				case '-': return val1 - val2;
 804aa30:	29 ca                	sub    %ecx,%edx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804aa32:	83 f8 2d             	cmp    $0x2d,%eax
				case '+': return val1 + val2;
				case '-': return val1 - val2;
 804aa35:	89 d3                	mov    %edx,%ebx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804aa37:	0f 84 a3 fb ff ff    	je     804a5e0 <eval+0x60>
 804aa3d:	e9 4d fc ff ff       	jmp    804a68f <eval+0x10f>
 804aa42:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				case '+': return val1 + val2;
				case '-': return val1 - val2;
				case '*': return val1 * val2;
				case '/': return val1 / val2;
 804aa48:	89 d0                	mov    %edx,%eax
 804aa4a:	31 d2                	xor    %edx,%edx
 804aa4c:	f7 f1                	div    %ecx
 804aa4e:	89 c3                	mov    %eax,%ebx
 804aa50:	e9 8b fb ff ff       	jmp    804a5e0 <eval+0x60>
				case '&': return val1 & val2;
				case '|': return val1 | val2;
				case AND: return val1 && val2;
 804aa55:	85 c9                	test   %ecx,%ecx
 804aa57:	0f 95 c0             	setne  %al
 804aa5a:	31 db                	xor    %ebx,%ebx
 804aa5c:	85 d2                	test   %edx,%edx
 804aa5e:	0f 95 c3             	setne  %bl
 804aa61:	21 c3                	and    %eax,%ebx
 804aa63:	e9 78 fb ff ff       	jmp    804a5e0 <eval+0x60>
				case OR: return val1 || val2;
 804aa68:	31 db                	xor    %ebx,%ebx
 804aa6a:	09 d1                	or     %edx,%ecx
 804aa6c:	0f 95 c3             	setne  %bl
 804aa6f:	e9 6c fb ff ff       	jmp    804a5e0 <eval+0x60>
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
				case '+': return val1 + val2;
				case '-': return val1 - val2;
				case '*': return val1 * val2;
 804aa74:	0f af ca             	imul   %edx,%ecx
 804aa77:	89 cb                	mov    %ecx,%ebx
 804aa79:	e9 62 fb ff ff       	jmp    804a5e0 <eval+0x60>
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
				case '+': return val1 + val2;
 804aa7e:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
 804aa81:	e9 5a fb ff ff       	jmp    804a5e0 <eval+0x60>
				case '%': return val1 % val2;
				case '<': return val1 < val2;
				case '>': return val1 > val2;
				case NOT_LE: return val1 >= val2;
				case NOT_LA: return val1 <= val2;
				case NOT_EQ: return val1 != val2;
 804aa86:	31 db                	xor    %ebx,%ebx
 804aa88:	39 ca                	cmp    %ecx,%edx
 804aa8a:	0f 95 c3             	setne  %bl
 804aa8d:	e9 4e fb ff ff       	jmp    804a5e0 <eval+0x60>
				case OR: return val1 || val2;
				case '^': return val1 ^ val2;
				case LS: return val1 << val2;
				case RS: return val1 >> val2;
				case '%': return val1 % val2;
				case '<': return val1 < val2;
 804aa92:	31 db                	xor    %ebx,%ebx
 804aa94:	39 ca                	cmp    %ecx,%edx
 804aa96:	0f 92 c3             	setb   %bl
 804aa99:	e9 42 fb ff ff       	jmp    804a5e0 <eval+0x60>
				case '/': return val1 / val2;
				case '&': return val1 & val2;
				case '|': return val1 | val2;
				case AND: return val1 && val2;
				case OR: return val1 || val2;
				case '^': return val1 ^ val2;
 804aa9e:	31 d1                	xor    %edx,%ecx
 804aaa0:	89 cb                	mov    %ecx,%ebx
 804aaa2:	e9 39 fb ff ff       	jmp    804a5e0 <eval+0x60>
				case LS: return val1 << val2;
				case RS: return val1 >> val2;
				case '%': return val1 % val2;
				case '<': return val1 < val2;
				case '>': return val1 > val2;
				case NOT_LE: return val1 >= val2;
 804aaa7:	31 db                	xor    %ebx,%ebx
 804aaa9:	39 ca                	cmp    %ecx,%edx
 804aaab:	0f 93 c3             	setae  %bl
 804aaae:	e9 2d fb ff ff       	jmp    804a5e0 <eval+0x60>
				case '+': return val1 + val2;
				case '-': return val1 - val2;
				case '*': return val1 * val2;
				case '/': return val1 / val2;
				case '&': return val1 & val2;
				case '|': return val1 | val2;
 804aab3:	09 d1                	or     %edx,%ecx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804aab5:	83 f8 7c             	cmp    $0x7c,%eax
				case '+': return val1 + val2;
				case '-': return val1 - val2;
				case '*': return val1 * val2;
				case '/': return val1 / val2;
				case '&': return val1 & val2;
				case '|': return val1 | val2;
 804aab8:	89 cb                	mov    %ecx,%ebx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804aaba:	0f 84 20 fb ff ff    	je     804a5e0 <eval+0x60>
 804aac0:	e9 ca fb ff ff       	jmp    804a68f <eval+0x10f>
 804aac5:	8d 76 00             	lea    0x0(%esi),%esi
				case '<': return val1 < val2;
				case '>': return val1 > val2;
				case NOT_LE: return val1 >= val2;
				case NOT_LA: return val1 <= val2;
				case NOT_EQ: return val1 != val2;
				case EQ: return val1 == val2;
 804aac8:	31 db                	xor    %ebx,%ebx
 804aaca:	39 ca                	cmp    %ecx,%edx
 804aacc:	0f 94 c3             	sete   %bl
 804aacf:	e9 0c fb ff ff       	jmp    804a5e0 <eval+0x60>
 804aad4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804aada:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804aae0 <expr>:
			}
		}
	}
}

uint32_t expr(char *e, bool *success) {
 804aae0:	55                   	push   %ebp
 804aae1:	57                   	push   %edi
 804aae2:	56                   	push   %esi
 804aae3:	53                   	push   %ebx
 804aae4:	83 ec 2c             	sub    $0x2c,%esp
static bool make_token(char *e) {
	int position = 0;
	int i;
	regmatch_t pmatch;
	
	nr_token = 0;
 804aae7:	c7 05 80 83 0c 08 00 	movl   $0x0,0x80c8380
 804aaee:	00 00 00 
 804aaf1:	8d 74 24 18          	lea    0x18(%esp),%esi
		}
		else return false;
}

static bool make_token(char *e) {
	int position = 0;
 804aaf5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804aafc:	00 
	int i;
	regmatch_t pmatch;
	
	nr_token = 0;

	while(e[position] != '\0') {
 804aafd:	8b 5c 24 08          	mov    0x8(%esp),%ebx
 804ab01:	03 5c 24 40          	add    0x40(%esp),%ebx
 804ab05:	80 3b 00             	cmpb   $0x0,(%ebx)
 804ab08:	0f 84 58 01 00 00    	je     804ac66 <expr+0x186>
 804ab0e:	bf 00 7e 07 08       	mov    $0x8077e00,%edi
 804ab13:	31 ed                	xor    %ebp,%ebp
 804ab15:	8d 76 00             	lea    0x0(%esi),%esi
		/* Try all rules one by one. */
		for(i = 0; i < NR_REGEX; i ++) {
			if(regexec(&re[i], e + position, 1, &pmatch, 0) == 0 && pmatch.rm_so == 0) {
 804ab18:	83 ec 0c             	sub    $0xc,%esp
 804ab1b:	6a 00                	push   $0x0
 804ab1d:	56                   	push   %esi
 804ab1e:	6a 01                	push   $0x1
 804ab20:	53                   	push   %ebx
 804ab21:	57                   	push   %edi
 804ab22:	e8 19 e0 ff ff       	call   8048b40 <regexec@plt>
 804ab27:	83 c4 20             	add    $0x20,%esp
 804ab2a:	85 c0                	test   %eax,%eax
 804ab2c:	75 08                	jne    804ab36 <expr+0x56>
 804ab2e:	8b 44 24 18          	mov    0x18(%esp),%eax
 804ab32:	85 c0                	test   %eax,%eax
 804ab34:	74 42                	je     804ab78 <expr+0x98>
	
	nr_token = 0;

	while(e[position] != '\0') {
		/* Try all rules one by one. */
		for(i = 0; i < NR_REGEX; i ++) {
 804ab36:	83 c5 01             	add    $0x1,%ebp
 804ab39:	83 c7 20             	add    $0x20,%edi
 804ab3c:	83 fd 1c             	cmp    $0x1c,%ebp
 804ab3f:	75 d7                	jne    804ab18 <expr+0x38>
				break;
			}
		}

		if(i == NR_REGEX) {
			printf("no match at position %d\n%s\n%*.s^\n", position, e, position, "");
 804ab41:	83 ec 0c             	sub    $0xc,%esp
 804ab44:	68 10 f1 05 08       	push   $0x805f110
 804ab49:	8b 44 24 18          	mov    0x18(%esp),%eax
 804ab4d:	50                   	push   %eax
 804ab4e:	ff 74 24 54          	pushl  0x54(%esp)
 804ab52:	50                   	push   %eax
 804ab53:	68 44 f5 05 08       	push   $0x805f544
 804ab58:	e8 f3 dd ff ff       	call   8048950 <printf@plt>
	}
}

uint32_t expr(char *e, bool *success) {
	if(!make_token(e)) {
		*success = false;
 804ab5d:	8b 44 24 64          	mov    0x64(%esp),%eax
		return 0;
 804ab61:	83 c4 20             	add    $0x20,%esp
	}
}

uint32_t expr(char *e, bool *success) {
	if(!make_token(e)) {
		*success = false;
 804ab64:	c6 00 00             	movb   $0x0,(%eax)
		return 0;
	}

	/* TODO: Insert codes to evaluate the expression. */
	return eval(0, nr_token-1, success);
}
 804ab67:	83 c4 2c             	add    $0x2c,%esp
}

uint32_t expr(char *e, bool *success) {
	if(!make_token(e)) {
		*success = false;
		return 0;
 804ab6a:	31 c0                	xor    %eax,%eax
	}

	/* TODO: Insert codes to evaluate the expression. */
	return eval(0, nr_token-1, success);
}
 804ab6c:	5b                   	pop    %ebx
 804ab6d:	5e                   	pop    %esi
 804ab6e:	5f                   	pop    %edi
 804ab6f:	5d                   	pop    %ebp
 804ab70:	c3                   	ret    
 804ab71:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	while(e[position] != '\0') {
		/* Try all rules one by one. */
		for(i = 0; i < NR_REGEX; i ++) {
			if(regexec(&re[i], e + position, 1, &pmatch, 0) == 0 && pmatch.rm_so == 0) {
				char *substr_start = e + position;
				int substr_len = pmatch.rm_eo;
 804ab78:	8b 7c 24 1c          	mov    0x1c(%esp),%edi

				Log("match rules[%d] = \"%s\" at position %d with len %d: %.*s", i, rules[i].regex, position, substr_len, substr_len, substr_start);
 804ab7c:	8b 14 ed c0 f5 05 08 	mov    0x805f5c0(,%ebp,8),%edx
 804ab83:	83 ec 04             	sub    $0x4,%esp
 804ab86:	53                   	push   %ebx
 804ab87:	57                   	push   %edi
 804ab88:	57                   	push   %edi
 804ab89:	ff 74 24 18          	pushl  0x18(%esp)
 804ab8d:	52                   	push   %edx
 804ab8e:	89 54 24 24          	mov    %edx,0x24(%esp)
 804ab92:	55                   	push   %ebp
 804ab93:	68 80 f5 05 08       	push   $0x805f580
 804ab98:	6a 6c                	push   $0x6c
 804ab9a:	68 4a f3 05 08       	push   $0x805f34a
 804ab9f:	68 b0 f4 05 08       	push   $0x805f4b0
 804aba4:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804abaa:	e8 11 df ff ff       	call   8048ac0 <fprintf@plt>
 804abaf:	83 c4 24             	add    $0x24,%esp
 804abb2:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804abb8:	e8 a3 dd ff ff       	call   8048960 <fflush@plt>
 804abbd:	83 c4 0c             	add    $0xc,%esp
 804abc0:	53                   	push   %ebx
 804abc1:	57                   	push   %edi
 804abc2:	57                   	push   %edi
 804abc3:	ff 74 24 18          	pushl  0x18(%esp)
 804abc7:	8b 54 24 20          	mov    0x20(%esp),%edx
 804abcb:	52                   	push   %edx
 804abcc:	55                   	push   %ebp
 804abcd:	68 80 f5 05 08       	push   $0x805f580
 804abd2:	6a 6c                	push   $0x6c
 804abd4:	68 4a f3 05 08       	push   $0x805f34a
 804abd9:	68 00 f5 05 08       	push   $0x805f500
 804abde:	ff 35 28 5c 07 08    	pushl  0x8075c28
 804abe4:	e8 d7 de ff ff       	call   8048ac0 <fprintf@plt>
 804abe9:	83 c4 24             	add    $0x24,%esp
 804abec:	ff 35 28 5c 07 08    	pushl  0x8075c28
 804abf2:	e8 69 dd ff ff       	call   8048960 <fflush@plt>
				/* TODO: Now a new token is recognized with rules[i]. Add codes
				 * to record the token in the array ``tokens''. For certain 
				 * types of tokens, some extra actions should be performed.
				 */

				switch(rules[i].token_type) {
 804abf7:	8b 04 ed c4 f5 05 08 	mov    0x805f5c4(,%ebp,8),%eax
			if(regexec(&re[i], e + position, 1, &pmatch, 0) == 0 && pmatch.rm_so == 0) {
				char *substr_start = e + position;
				int substr_len = pmatch.rm_eo;

				Log("match rules[%d] = \"%s\" at position %d with len %d: %.*s", i, rules[i].regex, position, substr_len, substr_len, substr_start);
				position += substr_len;
 804abfe:	01 7c 24 18          	add    %edi,0x18(%esp)
				/* TODO: Now a new token is recognized with rules[i]. Add codes
				 * to record the token in the array ``tokens''. For certain 
				 * types of tokens, some extra actions should be performed.
				 */

				switch(rules[i].token_type) {
 804ac02:	83 c4 10             	add    $0x10,%esp
 804ac05:	3d 00 01 00 00       	cmp    $0x100,%eax
 804ac0a:	0f 84 ed fe ff ff    	je     804aafd <expr+0x1d>
					case NOTYPE: break;
					default: 
						tokens[nr_token].type = rules[i].token_type;
 804ac10:	8b 2d 80 83 0c 08    	mov    0x80c8380,%ebp
						strncpy(tokens[nr_token].str, substr_start, substr_len);
 804ac16:	83 ec 04             	sub    $0x4,%esp
 804ac19:	57                   	push   %edi
 804ac1a:	53                   	push   %ebx
				 */

				switch(rules[i].token_type) {
					case NOTYPE: break;
					default: 
						tokens[nr_token].type = rules[i].token_type;
 804ac1b:	8d 4c ed 00          	lea    0x0(%ebp,%ebp,8),%ecx
						strncpy(tokens[nr_token].str, substr_start, substr_len);
						tokens[nr_token].str[substr_len] = '\0';
						nr_token++;
 804ac1f:	83 c5 01             	add    $0x1,%ebp
				 */

				switch(rules[i].token_type) {
					case NOTYPE: break;
					default: 
						tokens[nr_token].type = rules[i].token_type;
 804ac22:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
 804ac29:	89 04 8d c0 83 0c 08 	mov    %eax,0x80c83c0(,%ecx,4)
						strncpy(tokens[nr_token].str, substr_start, substr_len);
 804ac30:	8d 82 c4 83 0c 08    	lea    0x80c83c4(%edx),%eax
 804ac36:	89 54 24 18          	mov    %edx,0x18(%esp)
 804ac3a:	50                   	push   %eax
 804ac3b:	e8 f0 de ff ff       	call   8048b30 <strncpy@plt>
						tokens[nr_token].str[substr_len] = '\0';
 804ac40:	8b 54 24 1c          	mov    0x1c(%esp),%edx
						nr_token++;
 804ac44:	83 c4 10             	add    $0x10,%esp
	int i;
	regmatch_t pmatch;
	
	nr_token = 0;

	while(e[position] != '\0') {
 804ac47:	8b 5c 24 08          	mov    0x8(%esp),%ebx
 804ac4b:	03 5c 24 40          	add    0x40(%esp),%ebx
					case NOTYPE: break;
					default: 
						tokens[nr_token].type = rules[i].token_type;
						strncpy(tokens[nr_token].str, substr_start, substr_len);
						tokens[nr_token].str[substr_len] = '\0';
						nr_token++;
 804ac4f:	89 2d 80 83 0c 08    	mov    %ebp,0x80c8380
				switch(rules[i].token_type) {
					case NOTYPE: break;
					default: 
						tokens[nr_token].type = rules[i].token_type;
						strncpy(tokens[nr_token].str, substr_start, substr_len);
						tokens[nr_token].str[substr_len] = '\0';
 804ac55:	c6 84 17 c4 83 0c 08 	movb   $0x0,0x80c83c4(%edi,%edx,1)
 804ac5c:	00 
	int i;
	regmatch_t pmatch;
	
	nr_token = 0;

	while(e[position] != '\0') {
 804ac5d:	80 3b 00             	cmpb   $0x0,(%ebx)
 804ac60:	0f 85 a8 fe ff ff    	jne    804ab0e <expr+0x2e>
		*success = false;
		return 0;
	}

	/* TODO: Insert codes to evaluate the expression. */
	return eval(0, nr_token-1, success);
 804ac66:	a1 80 83 0c 08       	mov    0x80c8380,%eax
 804ac6b:	83 ec 04             	sub    $0x4,%esp
 804ac6e:	ff 74 24 48          	pushl  0x48(%esp)
 804ac72:	83 e8 01             	sub    $0x1,%eax
 804ac75:	50                   	push   %eax
 804ac76:	6a 00                	push   $0x0
 804ac78:	e8 03 f9 ff ff       	call   804a580 <eval>
 804ac7d:	83 c4 10             	add    $0x10,%esp
}
 804ac80:	83 c4 2c             	add    $0x2c,%esp
 804ac83:	5b                   	pop    %ebx
 804ac84:	5e                   	pop    %esi
 804ac85:	5f                   	pop    %edi
 804ac86:	5d                   	pop    %ebp
 804ac87:	c3                   	ret    
 804ac88:	66 90                	xchg   %ax,%ax
 804ac8a:	66 90                	xchg   %ax,%ax
 804ac8c:	66 90                	xchg   %ax,%ax
 804ac8e:	66 90                	xchg   %ax,%ax

0804ac90 <print_bin_instr>:
char asm_buf[128];

/* Used with exception handling. */
jmp_buf jbuf;

void print_bin_instr(swaddr_t eip, int len) {
 804ac90:	55                   	push   %ebp
 804ac91:	57                   	push   %edi
 804ac92:	56                   	push   %esi
 804ac93:	53                   	push   %ebx
 804ac94:	83 ec 10             	sub    $0x10,%esp
 804ac97:	8b 5c 24 24          	mov    0x24(%esp),%ebx
 804ac9b:	8b 6c 24 28          	mov    0x28(%esp),%ebp
	int i;
	int l = sprintf(asm_buf, "%8x:   ", eip);
 804ac9f:	53                   	push   %ebx
 804aca0:	68 a0 f6 05 08       	push   $0x805f6a0
 804aca5:	68 80 89 0c 08       	push   $0x80c8980
 804acaa:	e8 e1 de ff ff       	call   8048b90 <sprintf@plt>
	for(i = 0; i < len; i ++) {
 804acaf:	83 c4 10             	add    $0x10,%esp
 804acb2:	85 ed                	test   %ebp,%ebp
/* Used with exception handling. */
jmp_buf jbuf;

void print_bin_instr(swaddr_t eip, int len) {
	int i;
	int l = sprintf(asm_buf, "%8x:   ", eip);
 804acb4:	89 c6                	mov    %eax,%esi
	for(i = 0; i < len; i ++) {
 804acb6:	7e 34                	jle    804acec <print_bin_instr+0x5c>
 804acb8:	8d 3c 2b             	lea    (%ebx,%ebp,1),%edi
 804acbb:	90                   	nop
 804acbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 804acc0:	83 ec 08             	sub    $0x8,%esp
 804acc3:	6a 01                	push   $0x1
 804acc5:	53                   	push   %ebx
 804acc6:	83 c3 01             	add    $0x1,%ebx
 804acc9:	e8 92 02 00 00       	call   804af60 <swaddr_read>
		l += sprintf(asm_buf + l, "%02x ", instr_fetch(eip + i, 1));
 804acce:	83 c4 0c             	add    $0xc,%esp
 804acd1:	50                   	push   %eax
 804acd2:	8d 86 80 89 0c 08    	lea    0x80c8980(%esi),%eax
 804acd8:	68 a8 f6 05 08       	push   $0x805f6a8
 804acdd:	50                   	push   %eax
 804acde:	e8 ad de ff ff       	call   8048b90 <sprintf@plt>
jmp_buf jbuf;

void print_bin_instr(swaddr_t eip, int len) {
	int i;
	int l = sprintf(asm_buf, "%8x:   ", eip);
	for(i = 0; i < len; i ++) {
 804ace3:	83 c4 10             	add    $0x10,%esp
		l += sprintf(asm_buf + l, "%02x ", instr_fetch(eip + i, 1));
 804ace6:	01 c6                	add    %eax,%esi
jmp_buf jbuf;

void print_bin_instr(swaddr_t eip, int len) {
	int i;
	int l = sprintf(asm_buf, "%8x:   ", eip);
	for(i = 0; i < len; i ++) {
 804ace8:	39 fb                	cmp    %edi,%ebx
 804acea:	75 d4                	jne    804acc0 <print_bin_instr+0x30>
		l += sprintf(asm_buf + l, "%02x ", instr_fetch(eip + i, 1));
	}
	sprintf(asm_buf + l, "%*.s", 50 - (12 + 3 * len), "");
 804acec:	8d 44 6d 00          	lea    0x0(%ebp,%ebp,2),%eax
 804acf0:	81 c6 80 89 0c 08    	add    $0x80c8980,%esi
 804acf6:	68 10 f1 05 08       	push   $0x805f110
 804acfb:	f7 d8                	neg    %eax
 804acfd:	83 c0 26             	add    $0x26,%eax
 804ad00:	50                   	push   %eax
 804ad01:	68 ae f6 05 08       	push   $0x805f6ae
 804ad06:	56                   	push   %esi
 804ad07:	e8 84 de ff ff       	call   8048b90 <sprintf@plt>
}
 804ad0c:	83 c4 1c             	add    $0x1c,%esp
 804ad0f:	5b                   	pop    %ebx
 804ad10:	5e                   	pop    %esi
 804ad11:	5f                   	pop    %edi
 804ad12:	5d                   	pop    %ebp
 804ad13:	c3                   	ret    
 804ad14:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804ad1a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804ad20 <do_int3>:

/* This function will be called when an `int3' instruction is being executed. */
void do_int3() {
 804ad20:	83 ec 14             	sub    $0x14,%esp
	printf("\nHit breakpoint at eip = 0x%08x\n", cpu.eip);
 804ad23:	ff 35 e0 ae 8f 14    	pushl  0x148faee0
 804ad29:	68 b4 f6 05 08       	push   $0x805f6b4
 804ad2e:	e8 1d dc ff ff       	call   8048950 <printf@plt>
	nemu_state = STOP;
 804ad33:	c7 05 80 81 07 08 00 	movl   $0x0,0x8078180
 804ad3a:	00 00 00 
}
 804ad3d:	83 c4 1c             	add    $0x1c,%esp
 804ad40:	c3                   	ret    
 804ad41:	eb 0d                	jmp    804ad50 <cpu_exec>
 804ad43:	90                   	nop
 804ad44:	90                   	nop
 804ad45:	90                   	nop
 804ad46:	90                   	nop
 804ad47:	90                   	nop
 804ad48:	90                   	nop
 804ad49:	90                   	nop
 804ad4a:	90                   	nop
 804ad4b:	90                   	nop
 804ad4c:	90                   	nop
 804ad4d:	90                   	nop
 804ad4e:	90                   	nop
 804ad4f:	90                   	nop

0804ad50 <cpu_exec>:

/* Simulate how the CPU works. */
void cpu_exec(volatile uint32_t n) {
 804ad50:	56                   	push   %esi
 804ad51:	53                   	push   %ebx
 804ad52:	83 ec 14             	sub    $0x14,%esp
	if(nemu_state == END) {
 804ad55:	83 3d 80 81 07 08 02 	cmpl   $0x2,0x8078180
 804ad5c:	0f 84 5e 01 00 00    	je     804aec0 <cpu_exec+0x170>
		return;
	}
	nemu_state = RUNNING;

#ifdef DEBUG
	volatile uint32_t n_temp = n;
 804ad62:	8b 44 24 20          	mov    0x20(%esp),%eax
#endif

	setjmp(jbuf);
 804ad66:	83 ec 0c             	sub    $0xc,%esp
void cpu_exec(volatile uint32_t n) {
	if(nemu_state == END) {
		printf("Program execution has ended. To restart the program, exit NEMU and run again.\n");
		return;
	}
	nemu_state = RUNNING;
 804ad69:	c7 05 80 81 07 08 01 	movl   $0x1,0x8078180
 804ad70:	00 00 00 

#ifdef DEBUG
	volatile uint32_t n_temp = n;
 804ad73:	89 44 24 18          	mov    %eax,0x18(%esp)
#endif

	setjmp(jbuf);
 804ad77:	68 40 88 0c 08       	push   $0x80c8840
 804ad7c:	e8 ef db ff ff       	call   8048970 <_setjmp@plt>

	for(; n > 0; n --) {
 804ad81:	8b 44 24 30          	mov    0x30(%esp),%eax
 804ad85:	83 c4 10             	add    $0x10,%esp
 804ad88:	85 c0                	test   %eax,%eax
 804ad8a:	0f 84 15 01 00 00    	je     804aea5 <cpu_exec+0x155>
		}
#endif

		/* TODO: check watchpoints here. */
		bool flag = true;
		check_wp(&flag);
 804ad90:	8d 74 24 0b          	lea    0xb(%esp),%esi
 804ad94:	eb 2e                	jmp    804adc4 <cpu_exec+0x74>
 804ad96:	8d 76 00             	lea    0x0(%esi),%esi
 804ad99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		if(!flag) {
			nemu_state = STOP;
			printf("\nHit breakpoint at eip = 0x%08x\n", cpu.eip);
		}

		if(nemu_state != RUNNING) { return; }
 804ada0:	83 3d 80 81 07 08 01 	cmpl   $0x1,0x8078180
 804ada7:	0f 85 f2 00 00 00    	jne    804ae9f <cpu_exec+0x14f>
	volatile uint32_t n_temp = n;
#endif

	setjmp(jbuf);

	for(; n > 0; n --) {
 804adad:	8b 44 24 20          	mov    0x20(%esp),%eax
 804adb1:	83 e8 01             	sub    $0x1,%eax
 804adb4:	89 44 24 20          	mov    %eax,0x20(%esp)
 804adb8:	8b 44 24 20          	mov    0x20(%esp),%eax
 804adbc:	85 c0                	test   %eax,%eax
 804adbe:	0f 84 ec 00 00 00    	je     804aeb0 <cpu_exec+0x160>
#ifdef DEBUG
		swaddr_t eip_temp = cpu.eip;
		if((n & 0xffff) == 0) {
 804adc4:	8b 54 24 20          	mov    0x20(%esp),%edx

	setjmp(jbuf);

	for(; n > 0; n --) {
#ifdef DEBUG
		swaddr_t eip_temp = cpu.eip;
 804adc8:	8b 1d e0 ae 8f 14    	mov    0x148faee0,%ebx
		if((n & 0xffff) == 0) {
 804adce:	66 85 d2             	test   %dx,%dx
 804add1:	89 d8                	mov    %ebx,%eax
 804add3:	75 18                	jne    804aded <cpu_exec+0x9d>
			/* Output some dots while executing the program. */
			fputc('.', stderr);
 804add5:	83 ec 08             	sub    $0x8,%esp
 804add8:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804adde:	6a 2e                	push   $0x2e
 804ade0:	e8 8b dd ff ff       	call   8048b70 <fputc@plt>
 804ade5:	a1 e0 ae 8f 14       	mov    0x148faee0,%eax
 804adea:	83 c4 10             	add    $0x10,%esp
		}
#endif

		/* Execute one instruction, including instruction fetch,
		 * instruction decode, and the actual execution. */
		int instr_len = exec(cpu.eip);
 804aded:	83 ec 0c             	sub    $0xc,%esp
 804adf0:	50                   	push   %eax
 804adf1:	e8 5a 22 00 00       	call   804d050 <exec>
 804adf6:	5a                   	pop    %edx
 804adf7:	59                   	pop    %ecx

		cpu.eip += instr_len;

#ifdef DEBUG
		print_bin_instr(eip_temp, instr_len);
 804adf8:	50                   	push   %eax
 804adf9:	53                   	push   %ebx

		/* Execute one instruction, including instruction fetch,
		 * instruction decode, and the actual execution. */
		int instr_len = exec(cpu.eip);

		cpu.eip += instr_len;
 804adfa:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0

#ifdef DEBUG
		print_bin_instr(eip_temp, instr_len);
 804ae00:	e8 8b fe ff ff       	call   804ac90 <print_bin_instr>
 804ae05:	5b                   	pop    %ebx
 804ae06:	58                   	pop    %eax
		strcat(asm_buf, assembly);
 804ae07:	68 00 89 0c 08       	push   $0x80c8900
 804ae0c:	68 80 89 0c 08       	push   $0x80c8980
 804ae11:	e8 0a dc ff ff       	call   8048a20 <strcat@plt>
		Log_write("%s\n", asm_buf);
 804ae16:	83 c4 0c             	add    $0xc,%esp
 804ae19:	68 80 89 0c 08       	push   $0x80c8980
 804ae1e:	68 be f2 05 08       	push   $0x805f2be
 804ae23:	ff 35 28 5c 07 08    	pushl  0x8075c28
 804ae29:	e8 92 dc ff ff       	call   8048ac0 <fprintf@plt>
 804ae2e:	58                   	pop    %eax
 804ae2f:	ff 35 28 5c 07 08    	pushl  0x8075c28
 804ae35:	e8 26 db ff ff       	call   8048960 <fflush@plt>
 804ae3a:	83 c4 10             	add    $0x10,%esp
		if(n_temp < MAX_INSTR_TO_PRINT) {
 804ae3d:	8b 44 24 0c          	mov    0xc(%esp),%eax
 804ae41:	83 f8 09             	cmp    $0x9,%eax
 804ae44:	77 10                	ja     804ae56 <cpu_exec+0x106>
			printf("%s\n", asm_buf);
 804ae46:	83 ec 0c             	sub    $0xc,%esp
 804ae49:	68 80 89 0c 08       	push   $0x80c8980
 804ae4e:	e8 0d dc ff ff       	call   8048a60 <puts@plt>
 804ae53:	83 c4 10             	add    $0x10,%esp
		}
#endif

		/* TODO: check watchpoints here. */
		bool flag = true;
 804ae56:	c6 44 24 0b 01       	movb   $0x1,0xb(%esp)
		check_wp(&flag);
 804ae5b:	83 ec 0c             	sub    $0xc,%esp
 804ae5e:	56                   	push   %esi
 804ae5f:	e8 cc f0 ff ff       	call   8049f30 <check_wp>
 804ae64:	83 c4 10             	add    $0x10,%esp
		if(!flag) {
 804ae67:	80 7c 24 0b 00       	cmpb   $0x0,0xb(%esp)
 804ae6c:	0f 85 2e ff ff ff    	jne    804ada0 <cpu_exec+0x50>
			nemu_state = STOP;
			printf("\nHit breakpoint at eip = 0x%08x\n", cpu.eip);
 804ae72:	83 ec 08             	sub    $0x8,%esp
 804ae75:	ff 35 e0 ae 8f 14    	pushl  0x148faee0

		/* TODO: check watchpoints here. */
		bool flag = true;
		check_wp(&flag);
		if(!flag) {
			nemu_state = STOP;
 804ae7b:	c7 05 80 81 07 08 00 	movl   $0x0,0x8078180
 804ae82:	00 00 00 
			printf("\nHit breakpoint at eip = 0x%08x\n", cpu.eip);
 804ae85:	68 b4 f6 05 08       	push   $0x805f6b4
 804ae8a:	e8 c1 da ff ff       	call   8048950 <printf@plt>
 804ae8f:	83 c4 10             	add    $0x10,%esp
		}

		if(nemu_state != RUNNING) { return; }
 804ae92:	83 3d 80 81 07 08 01 	cmpl   $0x1,0x8078180
 804ae99:	0f 84 0e ff ff ff    	je     804adad <cpu_exec+0x5d>
	}

	if(nemu_state == RUNNING) { 
		nemu_state = STOP; 
	}
}
 804ae9f:	83 c4 14             	add    $0x14,%esp
 804aea2:	5b                   	pop    %ebx
 804aea3:	5e                   	pop    %esi
 804aea4:	c3                   	ret    
		}

		if(nemu_state != RUNNING) { return; }
	}

	if(nemu_state == RUNNING) { 
 804aea5:	83 3d 80 81 07 08 01 	cmpl   $0x1,0x8078180
 804aeac:	75 f1                	jne    804ae9f <cpu_exec+0x14f>
 804aeae:	66 90                	xchg   %ax,%ax
		nemu_state = STOP; 
 804aeb0:	c7 05 80 81 07 08 00 	movl   $0x0,0x8078180
 804aeb7:	00 00 00 
	}
}
 804aeba:	83 c4 14             	add    $0x14,%esp
 804aebd:	5b                   	pop    %ebx
 804aebe:	5e                   	pop    %esi
 804aebf:	c3                   	ret    
}

/* Simulate how the CPU works. */
void cpu_exec(volatile uint32_t n) {
	if(nemu_state == END) {
		printf("Program execution has ended. To restart the program, exit NEMU and run again.\n");
 804aec0:	83 ec 0c             	sub    $0xc,%esp
 804aec3:	68 d8 f6 05 08       	push   $0x805f6d8
 804aec8:	e8 93 db ff ff       	call   8048a60 <puts@plt>
 804aecd:	83 c4 10             	add    $0x10,%esp
	}

	if(nemu_state == RUNNING) { 
		nemu_state = STOP; 
	}
}
 804aed0:	83 c4 14             	add    $0x14,%esp
 804aed3:	5b                   	pop    %ebx
 804aed4:	5e                   	pop    %esi
 804aed5:	c3                   	ret    
 804aed6:	66 90                	xchg   %ax,%ax
 804aed8:	66 90                	xchg   %ax,%ax
 804aeda:	66 90                	xchg   %ax,%ax
 804aedc:	66 90                	xchg   %ax,%ax
 804aede:	66 90                	xchg   %ax,%ax

0804aee0 <hwaddr_read>:
uint32_t l1cache_read(hwaddr_t, size_t);
void l1cache_write(hwaddr_t, size_t, uint32_t);

/* Memory accessing interfaces */

uint32_t hwaddr_read(hwaddr_t addr, size_t len) {
 804aee0:	53                   	push   %ebx
 804aee1:	83 ec 10             	sub    $0x10,%esp
 804aee4:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
 804aee8:	53                   	push   %ebx
 804aee9:	ff 74 24 1c          	pushl  0x1c(%esp)
 804aeed:	e8 1e 0c 00 00       	call   804bb10 <l1cache_read>
 804aef2:	b9 04 00 00 00       	mov    $0x4,%ecx
 804aef7:	ba ff ff ff ff       	mov    $0xffffffff,%edx
	//return dram_read(addr, len) & (~0u >> ((4 - len) << 3));
}
 804aefc:	83 c4 18             	add    $0x18,%esp
void l1cache_write(hwaddr_t, size_t, uint32_t);

/* Memory accessing interfaces */

uint32_t hwaddr_read(hwaddr_t addr, size_t len) {
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
 804aeff:	29 d9                	sub    %ebx,%ecx
 804af01:	c1 e1 03             	shl    $0x3,%ecx
 804af04:	d3 ea                	shr    %cl,%edx
 804af06:	21 d0                	and    %edx,%eax
	//return dram_read(addr, len) & (~0u >> ((4 - len) << 3));
}
 804af08:	5b                   	pop    %ebx
 804af09:	c3                   	ret    
 804af0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804af10 <hwaddr_write>:

void hwaddr_write(hwaddr_t addr, size_t len, uint32_t data) {
	l1cache_write(addr, len, data);
 804af10:	e9 9b 0d 00 00       	jmp    804bcb0 <l1cache_write>
 804af15:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804af19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804af20 <lnaddr_read>:
	//dram_write(addr, len, data);
}

uint32_t lnaddr_read(lnaddr_t addr, size_t len) {
 804af20:	53                   	push   %ebx
 804af21:	83 ec 10             	sub    $0x10,%esp
 804af24:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
void l1cache_write(hwaddr_t, size_t, uint32_t);

/* Memory accessing interfaces */

uint32_t hwaddr_read(hwaddr_t addr, size_t len) {
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
 804af28:	53                   	push   %ebx
 804af29:	ff 74 24 1c          	pushl  0x1c(%esp)
 804af2d:	e8 de 0b 00 00       	call   804bb10 <l1cache_read>
 804af32:	b9 04 00 00 00       	mov    $0x4,%ecx
 804af37:	ba ff ff ff ff       	mov    $0xffffffff,%edx
	//dram_write(addr, len, data);
}

uint32_t lnaddr_read(lnaddr_t addr, size_t len) {
	return hwaddr_read(addr, len);
}
 804af3c:	83 c4 18             	add    $0x18,%esp
void l1cache_write(hwaddr_t, size_t, uint32_t);

/* Memory accessing interfaces */

uint32_t hwaddr_read(hwaddr_t addr, size_t len) {
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
 804af3f:	29 d9                	sub    %ebx,%ecx
 804af41:	c1 e1 03             	shl    $0x3,%ecx
 804af44:	d3 ea                	shr    %cl,%edx
 804af46:	21 d0                	and    %edx,%eax
	//dram_write(addr, len, data);
}

uint32_t lnaddr_read(lnaddr_t addr, size_t len) {
	return hwaddr_read(addr, len);
}
 804af48:	5b                   	pop    %ebx
 804af49:	c3                   	ret    
 804af4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804af50 <lnaddr_write>:
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
	//return dram_read(addr, len) & (~0u >> ((4 - len) << 3));
}

void hwaddr_write(hwaddr_t addr, size_t len, uint32_t data) {
	l1cache_write(addr, len, data);
 804af50:	e9 5b 0d 00 00       	jmp    804bcb0 <l1cache_write>
 804af55:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804af59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804af60 <swaddr_read>:

void lnaddr_write(lnaddr_t addr, size_t len, uint32_t data) {
	hwaddr_write(addr, len, data);
}

uint32_t swaddr_read(swaddr_t addr, size_t len) {
 804af60:	53                   	push   %ebx
 804af61:	83 ec 08             	sub    $0x8,%esp
 804af64:	8b 5c 24 14          	mov    0x14(%esp),%ebx
#ifdef DEBUG
	assert(len == 1 || len == 2 || len == 4);
 804af68:	8d 43 ff             	lea    -0x1(%ebx),%eax
 804af6b:	83 f8 01             	cmp    $0x1,%eax
 804af6e:	76 05                	jbe    804af75 <swaddr_read+0x15>
 804af70:	83 fb 04             	cmp    $0x4,%ebx
 804af73:	75 25                	jne    804af9a <swaddr_read+0x3a>
void l1cache_write(hwaddr_t, size_t, uint32_t);

/* Memory accessing interfaces */

uint32_t hwaddr_read(hwaddr_t addr, size_t len) {
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
 804af75:	83 ec 08             	sub    $0x8,%esp
 804af78:	53                   	push   %ebx
 804af79:	ff 74 24 1c          	pushl  0x1c(%esp)
 804af7d:	e8 8e 0b 00 00       	call   804bb10 <l1cache_read>
 804af82:	b9 04 00 00 00       	mov    $0x4,%ecx
 804af87:	ba ff ff ff ff       	mov    $0xffffffff,%edx
uint32_t swaddr_read(swaddr_t addr, size_t len) {
#ifdef DEBUG
	assert(len == 1 || len == 2 || len == 4);
#endif
	return lnaddr_read(addr, len);
}
 804af8c:	83 c4 18             	add    $0x18,%esp
void l1cache_write(hwaddr_t, size_t, uint32_t);

/* Memory accessing interfaces */

uint32_t hwaddr_read(hwaddr_t addr, size_t len) {
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
 804af8f:	29 d9                	sub    %ebx,%ecx
 804af91:	c1 e1 03             	shl    $0x3,%ecx
 804af94:	d3 ea                	shr    %cl,%edx
 804af96:	21 d0                	and    %edx,%eax
uint32_t swaddr_read(swaddr_t addr, size_t len) {
#ifdef DEBUG
	assert(len == 1 || len == 2 || len == 4);
#endif
	return lnaddr_read(addr, len);
}
 804af98:	5b                   	pop    %ebx
 804af99:	c3                   	ret    
	hwaddr_write(addr, len, data);
}

uint32_t swaddr_read(swaddr_t addr, size_t len) {
#ifdef DEBUG
	assert(len == 1 || len == 2 || len == 4);
 804af9a:	68 6e f7 05 08       	push   $0x805f76e
 804af9f:	6a 1e                	push   $0x1e
 804afa1:	68 26 f7 05 08       	push   $0x805f726
 804afa6:	68 40 f7 05 08       	push   $0x805f740
 804afab:	e8 00 dc ff ff       	call   8048bb0 <__assert_fail@plt>

0804afb0 <swaddr_write>:
#endif
	return lnaddr_read(addr, len);
}

void swaddr_write(swaddr_t addr, size_t len, uint32_t data) {
 804afb0:	53                   	push   %ebx
 804afb1:	83 ec 08             	sub    $0x8,%esp
 804afb4:	8b 44 24 14          	mov    0x14(%esp),%eax
 804afb8:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 804afbc:	8b 5c 24 18          	mov    0x18(%esp),%ebx
#ifdef DEBUG
	assert(len == 1 || len == 2 || len == 4);
 804afc0:	8d 50 ff             	lea    -0x1(%eax),%edx
 804afc3:	83 fa 01             	cmp    $0x1,%edx
 804afc6:	76 05                	jbe    804afcd <swaddr_write+0x1d>
 804afc8:	83 f8 04             	cmp    $0x4,%eax
 804afcb:	75 15                	jne    804afe2 <swaddr_write+0x32>
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
	//return dram_read(addr, len) & (~0u >> ((4 - len) << 3));
}

void hwaddr_write(hwaddr_t addr, size_t len, uint32_t data) {
	l1cache_write(addr, len, data);
 804afcd:	89 5c 24 18          	mov    %ebx,0x18(%esp)
 804afd1:	89 44 24 14          	mov    %eax,0x14(%esp)
 804afd5:	89 4c 24 10          	mov    %ecx,0x10(%esp)
void swaddr_write(swaddr_t addr, size_t len, uint32_t data) {
#ifdef DEBUG
	assert(len == 1 || len == 2 || len == 4);
#endif
	lnaddr_write(addr, len, data);
}
 804afd9:	83 c4 08             	add    $0x8,%esp
 804afdc:	5b                   	pop    %ebx
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
	//return dram_read(addr, len) & (~0u >> ((4 - len) << 3));
}

void hwaddr_write(hwaddr_t addr, size_t len, uint32_t data) {
	l1cache_write(addr, len, data);
 804afdd:	e9 ce 0c 00 00       	jmp    804bcb0 <l1cache_write>
	return lnaddr_read(addr, len);
}

void swaddr_write(swaddr_t addr, size_t len, uint32_t data) {
#ifdef DEBUG
	assert(len == 1 || len == 2 || len == 4);
 804afe2:	68 61 f7 05 08       	push   $0x805f761
 804afe7:	6a 25                	push   $0x25
 804afe9:	68 26 f7 05 08       	push   $0x805f726
 804afee:	68 40 f7 05 08       	push   $0x805f740
 804aff3:	e8 b8 db ff ff       	call   8048bb0 <__assert_fail@plt>
 804aff8:	66 90                	xchg   %ax,%ax
 804affa:	66 90                	xchg   %ax,%ax
 804affc:	66 90                	xchg   %ax,%ax
 804affe:	66 90                	xchg   %ax,%ax

0804b000 <check_cache>:

static uint8_t check_cache(hwaddr_t addr) {
	l2cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
 804b000:	89 c2                	mov    %eax,%edx
			l2cache[i][j].dirty = false;
		}
	}
}

static uint8_t check_cache(hwaddr_t addr) {
 804b002:	55                   	push   %ebp
 804b003:	57                   	push   %edi
	l2cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
 804b004:	c1 ea 06             	shr    $0x6,%edx
			l2cache[i][j].dirty = false;
		}
	}
}

static uint8_t check_cache(hwaddr_t addr) {
 804b007:	56                   	push   %esi
	l2cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b008:	89 c5                	mov    %eax,%ebp
	uint32_t set = temp.set;
 804b00a:	0f b7 ca             	movzwl %dx,%ecx
			l2cache[i][j].dirty = false;
		}
	}
}

static uint8_t check_cache(hwaddr_t addr) {
 804b00d:	53                   	push   %ebx
	l2cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b00e:	c1 ed 16             	shr    $0x16,%ebp
 804b011:	8d 34 c9             	lea    (%ecx,%ecx,8),%esi
 804b014:	83 e5 1f             	and    $0x1f,%ebp
			l2cache[i][j].dirty = false;
		}
	}
}

static uint8_t check_cache(hwaddr_t addr) {
 804b017:	83 ec 5c             	sub    $0x5c,%esp
	l2cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b01a:	89 eb                	mov    %ebp,%ebx
 804b01c:	c1 e6 07             	shl    $0x7,%esi
 804b01f:	89 6c 24 04          	mov    %ebp,0x4(%esp)
	uint32_t set = temp.set;
	uint8_t way = 0;
	int i;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
 804b023:	31 ed                	xor    %ebp,%ebp
 804b025:	8d be 00 8a 0c 08    	lea    0x80c8a00(%esi),%edi

static uint8_t check_cache(hwaddr_t addr) {
	l2cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
 804b02b:	89 0c 24             	mov    %ecx,(%esp)
 804b02e:	89 74 24 08          	mov    %esi,0x8(%esp)
	uint8_t way = 0;
	int i;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
 804b032:	89 e9                	mov    %ebp,%ecx

static uint8_t check_cache(hwaddr_t addr) {
	l2cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
 804b034:	89 fa                	mov    %edi,%edx
 804b036:	8d 76 00             	lea    0x0(%esi),%esi
 804b039:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	uint8_t way = 0;
	int i;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
		if(l2cache[set][way].valid && (l2cache[set][way].tag == tag)) {
 804b040:	80 7a 44 00          	cmpb   $0x0,0x44(%edx)
 804b044:	74 09                	je     804b04f <check_cache+0x4f>
 804b046:	39 5a 40             	cmp    %ebx,0x40(%edx)
 804b049:	0f 84 80 01 00 00    	je     804b1cf <check_cache+0x1cf>
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
	uint8_t way = 0;
	int i;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
 804b04f:	83 c1 01             	add    $0x1,%ecx
 804b052:	83 c2 48             	add    $0x48,%edx
 804b055:	80 f9 10             	cmp    $0x10,%cl
 804b058:	75 e6                	jne    804b040 <check_cache+0x40>
			break;
		}

	if(!success) {
		uint8_t temp1[CACHE_BLOCK_SIZE];
		hwaddr_t addr_temp = addr & ~CACHE_BLOCK_MASK;
 804b05a:	83 e0 c0             	and    $0xffffffc0,%eax
 804b05d:	8d 6c 24 10          	lea    0x10(%esp),%ebp
 804b061:	8d 74 24 50          	lea    0x50(%esp),%esi
 804b065:	89 c3                	mov    %eax,%ebx
 804b067:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804b06b:	29 eb                	sub    %ebp,%ebx
 804b06d:	8d 76 00             	lea    0x0(%esi),%esi
 804b070:	8d 04 2b             	lea    (%ebx,%ebp,1),%eax
		for(i = 0; i < CACHE_BLOCK_SIZE; i ++) {
			temp1[i] = (uint8_t)(dram_read(addr_temp + i , 1) & 0xff);
 804b073:	83 ec 08             	sub    $0x8,%esp
 804b076:	83 c5 01             	add    $0x1,%ebp
 804b079:	6a 01                	push   $0x1
 804b07b:	50                   	push   %eax
 804b07c:	e8 2f 08 00 00       	call   804b8b0 <dram_read>
 804b081:	88 45 ff             	mov    %al,-0x1(%ebp)
		}

	if(!success) {
		uint8_t temp1[CACHE_BLOCK_SIZE];
		hwaddr_t addr_temp = addr & ~CACHE_BLOCK_MASK;
		for(i = 0; i < CACHE_BLOCK_SIZE; i ++) {
 804b084:	83 c4 10             	add    $0x10,%esp
 804b087:	39 f5                	cmp    %esi,%ebp
 804b089:	75 e5                	jne    804b070 <check_cache+0x70>
 804b08b:	31 db                	xor    %ebx,%ebx
 804b08d:	8d 76 00             	lea    0x0(%esi),%esi
			temp1[i] = (uint8_t)(dram_read(addr_temp + i , 1) & 0xff);
		}
		for(way = 0; way < CACHE_WAY_SIZE; way ++)
			if(!l2cache[set][way].valid) break;
 804b090:	80 7f 44 00          	cmpb   $0x0,0x44(%edi)
 804b094:	89 dd                	mov    %ebx,%ebp
 804b096:	0f 84 92 00 00 00    	je     804b12e <check_cache+0x12e>
 804b09c:	83 c3 01             	add    $0x1,%ebx
 804b09f:	83 c7 48             	add    $0x48,%edi
		uint8_t temp1[CACHE_BLOCK_SIZE];
		hwaddr_t addr_temp = addr & ~CACHE_BLOCK_MASK;
		for(i = 0; i < CACHE_BLOCK_SIZE; i ++) {
			temp1[i] = (uint8_t)(dram_read(addr_temp + i , 1) & 0xff);
		}
		for(way = 0; way < CACHE_WAY_SIZE; way ++)
 804b0a2:	83 fb 10             	cmp    $0x10,%ebx
 804b0a5:	75 e9                	jne    804b090 <check_cache+0x90>
			if(!l2cache[set][way].valid) break;
		if(way == CACHE_WAY_SIZE) way = rand() & (CACHE_WAY_SIZE - 1);
 804b0a7:	e8 a4 da ff ff       	call   8048b50 <rand@plt>
 804b0ac:	89 c5                	mov    %eax,%ebp
		if(l2cache[set][way].valid && l2cache[set][way].dirty) {
 804b0ae:	8b 0c 24             	mov    (%esp),%ecx
		for(i = 0; i < CACHE_BLOCK_SIZE; i ++) {
			temp1[i] = (uint8_t)(dram_read(addr_temp + i , 1) & 0xff);
		}
		for(way = 0; way < CACHE_WAY_SIZE; way ++)
			if(!l2cache[set][way].valid) break;
		if(way == CACHE_WAY_SIZE) way = rand() & (CACHE_WAY_SIZE - 1);
 804b0b1:	83 e5 0f             	and    $0xf,%ebp
		if(l2cache[set][way].valid && l2cache[set][way].dirty) {
 804b0b4:	89 e8                	mov    %ebp,%eax
 804b0b6:	0f b6 d8             	movzbl %al,%ebx
 804b0b9:	8d 14 c9             	lea    (%ecx,%ecx,8),%edx
 804b0bc:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
 804b0bf:	c1 e2 07             	shl    $0x7,%edx
 804b0c2:	c1 e0 03             	shl    $0x3,%eax
 804b0c5:	8d 94 10 40 8a 0c 08 	lea    0x80c8a40(%eax,%edx,1),%edx
 804b0cc:	80 7a 04 00          	cmpb   $0x0,0x4(%edx)
 804b0d0:	74 5c                	je     804b12e <check_cache+0x12e>
 804b0d2:	80 7a 05 00          	cmpb   $0x0,0x5(%edx)
 804b0d6:	74 56                	je     804b12e <check_cache+0x12e>
 804b0d8:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
 804b0dc:	8b 74 24 08          	mov    0x8(%esp),%esi
 804b0e0:	89 5c 24 08          	mov    %ebx,0x8(%esp)
 804b0e4:	89 cf                	mov    %ecx,%edi
 804b0e6:	29 ce                	sub    %ecx,%esi
 804b0e8:	89 cb                	mov    %ecx,%ebx
 804b0ea:	83 c7 40             	add    $0x40,%edi
 804b0ed:	01 c6                	add    %eax,%esi
 804b0ef:	89 fa                	mov    %edi,%edx
 804b0f1:	89 d7                	mov    %edx,%edi
 804b0f3:	90                   	nop
 804b0f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			for(i = 0; i < CACHE_BLOCK_SIZE; i ++) {
				dram_write(addr_temp + i, 1, l2cache[set][way].buf[i]);
 804b0f8:	0f b6 94 1e 00 8a 0c 	movzbl 0x80c8a00(%esi,%ebx,1),%edx
 804b0ff:	08 
 804b100:	83 ec 04             	sub    $0x4,%esp
 804b103:	52                   	push   %edx
 804b104:	6a 01                	push   $0x1
 804b106:	53                   	push   %ebx
 804b107:	83 c3 01             	add    $0x1,%ebx
 804b10a:	e8 e1 07 00 00       	call   804b8f0 <dram_write>
		}
		for(way = 0; way < CACHE_WAY_SIZE; way ++)
			if(!l2cache[set][way].valid) break;
		if(way == CACHE_WAY_SIZE) way = rand() & (CACHE_WAY_SIZE - 1);
		if(l2cache[set][way].valid && l2cache[set][way].dirty) {
			for(i = 0; i < CACHE_BLOCK_SIZE; i ++) {
 804b10f:	83 c4 10             	add    $0x10,%esp
 804b112:	39 fb                	cmp    %edi,%ebx
 804b114:	75 e2                	jne    804b0f8 <check_cache+0xf8>
				dram_write(addr_temp + i, 1, l2cache[set][way].buf[i]);
			}
			l2cache[set][way].dirty = false;
 804b116:	8b 04 24             	mov    (%esp),%eax
 804b119:	8b 5c 24 08          	mov    0x8(%esp),%ebx
 804b11d:	8d 04 c0             	lea    (%eax,%eax,8),%eax
 804b120:	8d 14 db             	lea    (%ebx,%ebx,8),%edx
 804b123:	c1 e0 07             	shl    $0x7,%eax
 804b126:	c6 84 d0 45 8a 0c 08 	movb   $0x0,0x80c8a45(%eax,%edx,8)
 804b12d:	00 
		}
		memcpy(l2cache[set][way].buf, temp1, CACHE_BLOCK_SIZE);
 804b12e:	8b 04 24             	mov    (%esp),%eax
 804b131:	8d 14 db             	lea    (%ebx,%ebx,8),%edx
 804b134:	8b 5c 24 10          	mov    0x10(%esp),%ebx
 804b138:	8d 04 c0             	lea    (%eax,%eax,8),%eax
 804b13b:	c1 e0 07             	shl    $0x7,%eax
 804b13e:	8d 14 d0             	lea    (%eax,%edx,8),%edx
 804b141:	8d 82 00 8a 0c 08    	lea    0x80c8a00(%edx),%eax
 804b147:	89 9a 00 8a 0c 08    	mov    %ebx,0x80c8a00(%edx)
 804b14d:	8b 54 24 14          	mov    0x14(%esp),%edx
 804b151:	89 50 04             	mov    %edx,0x4(%eax)
 804b154:	8b 54 24 18          	mov    0x18(%esp),%edx
 804b158:	89 50 08             	mov    %edx,0x8(%eax)
 804b15b:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 804b15f:	89 50 0c             	mov    %edx,0xc(%eax)
 804b162:	8b 54 24 20          	mov    0x20(%esp),%edx
 804b166:	89 50 10             	mov    %edx,0x10(%eax)
 804b169:	8b 54 24 24          	mov    0x24(%esp),%edx
 804b16d:	89 50 14             	mov    %edx,0x14(%eax)
 804b170:	8b 54 24 28          	mov    0x28(%esp),%edx
 804b174:	89 50 18             	mov    %edx,0x18(%eax)
 804b177:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 804b17b:	89 50 1c             	mov    %edx,0x1c(%eax)
 804b17e:	8b 54 24 30          	mov    0x30(%esp),%edx
 804b182:	89 50 20             	mov    %edx,0x20(%eax)
 804b185:	8b 54 24 34          	mov    0x34(%esp),%edx
 804b189:	89 50 24             	mov    %edx,0x24(%eax)
 804b18c:	8b 54 24 38          	mov    0x38(%esp),%edx
 804b190:	89 50 28             	mov    %edx,0x28(%eax)
 804b193:	8b 54 24 3c          	mov    0x3c(%esp),%edx
 804b197:	89 50 2c             	mov    %edx,0x2c(%eax)
 804b19a:	8b 54 24 40          	mov    0x40(%esp),%edx
 804b19e:	89 50 30             	mov    %edx,0x30(%eax)
 804b1a1:	8b 54 24 44          	mov    0x44(%esp),%edx
 804b1a5:	89 50 34             	mov    %edx,0x34(%eax)
 804b1a8:	8b 54 24 48          	mov    0x48(%esp),%edx
 804b1ac:	89 50 38             	mov    %edx,0x38(%eax)
 804b1af:	8b 54 24 4c          	mov    0x4c(%esp),%edx
 804b1b3:	89 50 3c             	mov    %edx,0x3c(%eax)
		l2cache[set][way].valid = true;
 804b1b6:	c6 40 44 01          	movb   $0x1,0x44(%eax)
		l2cache[set][way].dirty = false;
		l2cache[set][way].tag = tag;
 804b1ba:	8b 7c 24 04          	mov    0x4(%esp),%edi
			}
			l2cache[set][way].dirty = false;
		}
		memcpy(l2cache[set][way].buf, temp1, CACHE_BLOCK_SIZE);
		l2cache[set][way].valid = true;
		l2cache[set][way].dirty = false;
 804b1be:	c6 40 45 00          	movb   $0x0,0x45(%eax)
		l2cache[set][way].tag = tag;
 804b1c2:	89 78 40             	mov    %edi,0x40(%eax)
	}	
	else {
		//Log("Hit");
	}
	return way;
}
 804b1c5:	83 c4 5c             	add    $0x5c,%esp
 804b1c8:	89 e8                	mov    %ebp,%eax
 804b1ca:	5b                   	pop    %ebx
 804b1cb:	5e                   	pop    %esi
 804b1cc:	5f                   	pop    %edi
 804b1cd:	5d                   	pop    %ebp
 804b1ce:	c3                   	ret    
 804b1cf:	83 c4 5c             	add    $0x5c,%esp
 804b1d2:	89 cd                	mov    %ecx,%ebp
 804b1d4:	5b                   	pop    %ebx
 804b1d5:	89 e8                	mov    %ebp,%eax
 804b1d7:	5e                   	pop    %esi
 804b1d8:	5f                   	pop    %edi
 804b1d9:	5d                   	pop    %ebp
 804b1da:	c3                   	ret    
 804b1db:	90                   	nop
 804b1dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804b1e0 <init_l2cache>:
l2CB l2cache[CACHE_SET_SIZE][CACHE_WAY_SIZE];

uint32_t dram_read(hwaddr_t addr, size_t len);
void dram_write(hwaddr_t addr, size_t len, uint32_t data);

void init_l2cache() {
 804b1e0:	b8 00 8a 0c 08       	mov    $0x80c8a00,%eax
 804b1e5:	b9 00 8a 8c 0c       	mov    $0xc8c8a00,%ecx
 804b1ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804b1f0:	8d 90 80 04 00 00    	lea    0x480(%eax),%edx
 804b1f6:	8d 76 00             	lea    0x0(%esi),%esi
 804b1f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	int i, j;
	for(i = 0; i < CACHE_SET_SIZE; i ++) {
		for(j = 0; j < CACHE_WAY_SIZE; j ++) {
			l2cache[i][j].valid = false;
 804b200:	c6 40 44 00          	movb   $0x0,0x44(%eax)
			l2cache[i][j].dirty = false;
 804b204:	c6 40 45 00          	movb   $0x0,0x45(%eax)
 804b208:	83 c0 48             	add    $0x48,%eax
void dram_write(hwaddr_t addr, size_t len, uint32_t data);

void init_l2cache() {
	int i, j;
	for(i = 0; i < CACHE_SET_SIZE; i ++) {
		for(j = 0; j < CACHE_WAY_SIZE; j ++) {
 804b20b:	39 d0                	cmp    %edx,%eax
 804b20d:	75 f1                	jne    804b200 <init_l2cache+0x20>
uint32_t dram_read(hwaddr_t addr, size_t len);
void dram_write(hwaddr_t addr, size_t len, uint32_t data);

void init_l2cache() {
	int i, j;
	for(i = 0; i < CACHE_SET_SIZE; i ++) {
 804b20f:	39 c1                	cmp    %eax,%ecx
 804b211:	75 dd                	jne    804b1f0 <init_l2cache+0x10>
 804b213:	f3 c3                	repz ret 
 804b215:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804b219:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804b220 <l2cache_read>:
		//Log("Hit");
	}
	return way;
}

uint32_t l2cache_read(hwaddr_t addr, size_t len) {
 804b220:	55                   	push   %ebp
 804b221:	57                   	push   %edi
 804b222:	56                   	push   %esi
 804b223:	53                   	push   %ebx
 804b224:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
 804b22a:	8b b4 24 a4 00 00 00 	mov    0xa4(%esp),%esi
 804b231:	8b bc 24 a0 00 00 00 	mov    0xa0(%esp),%edi
	assert(len == 1 || len == 2 || len == 4);
 804b238:	8d 46 ff             	lea    -0x1(%esi),%eax
 804b23b:	83 f8 01             	cmp    $0x1,%eax
 804b23e:	76 09                	jbe    804b249 <l2cache_read+0x29>
 804b240:	83 fe 04             	cmp    $0x4,%esi
 804b243:	0f 85 5f 01 00 00    	jne    804b3a8 <l2cache_read+0x188>
	l2cache_addr temp;
	temp.addr = addr;

	uint32_t set = temp.set;
 804b249:	89 fd                	mov    %edi,%ebp
	uint8_t way = check_cache(addr);
 804b24b:	89 f8                	mov    %edi,%eax
	uint32_t block = temp.block;
 804b24d:	89 fb                	mov    %edi,%ebx
uint32_t l2cache_read(hwaddr_t addr, size_t len) {
	assert(len == 1 || len == 2 || len == 4);
	l2cache_addr temp;
	temp.addr = addr;

	uint32_t set = temp.set;
 804b24f:	c1 ed 06             	shr    $0x6,%ebp
	uint8_t way = check_cache(addr);
	uint32_t block = temp.block;
 804b252:	83 e3 3f             	and    $0x3f,%ebx
	assert(len == 1 || len == 2 || len == 4);
	l2cache_addr temp;
	temp.addr = addr;

	uint32_t set = temp.set;
	uint8_t way = check_cache(addr);
 804b255:	e8 a6 fd ff ff       	call   804b000 <check_cache>
uint32_t l2cache_read(hwaddr_t addr, size_t len) {
	assert(len == 1 || len == 2 || len == 4);
	l2cache_addr temp;
	temp.addr = addr;

	uint32_t set = temp.set;
 804b25a:	0f b7 ed             	movzwl %bp,%ebp
	uint8_t way = check_cache(addr);
	uint32_t block = temp.block;

	uint8_t buf[CACHE_BLOCK_SIZE << 1];
	memcpy(buf, l2cache[set][way].buf, CACHE_BLOCK_SIZE);
 804b25d:	0f b6 c0             	movzbl %al,%eax
 804b260:	8d 14 c0             	lea    (%eax,%eax,8),%edx
 804b263:	8d 44 ed 00          	lea    0x0(%ebp,%ebp,8),%eax
 804b267:	c1 e0 07             	shl    $0x7,%eax
 804b26a:	8d 04 d0             	lea    (%eax,%edx,8),%eax
 804b26d:	8d 90 00 8a 0c 08    	lea    0x80c8a00(%eax),%edx
 804b273:	8b 80 00 8a 0c 08    	mov    0x80c8a00(%eax),%eax
 804b279:	89 04 24             	mov    %eax,(%esp)
 804b27c:	8b 42 04             	mov    0x4(%edx),%eax
 804b27f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804b283:	8b 42 08             	mov    0x8(%edx),%eax
 804b286:	89 44 24 08          	mov    %eax,0x8(%esp)
 804b28a:	8b 42 0c             	mov    0xc(%edx),%eax
 804b28d:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804b291:	8b 42 10             	mov    0x10(%edx),%eax
 804b294:	89 44 24 10          	mov    %eax,0x10(%esp)
 804b298:	8b 42 14             	mov    0x14(%edx),%eax
 804b29b:	89 44 24 14          	mov    %eax,0x14(%esp)
 804b29f:	8b 42 18             	mov    0x18(%edx),%eax
 804b2a2:	89 44 24 18          	mov    %eax,0x18(%esp)
 804b2a6:	8b 42 1c             	mov    0x1c(%edx),%eax
 804b2a9:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 804b2ad:	8b 42 20             	mov    0x20(%edx),%eax
 804b2b0:	89 44 24 20          	mov    %eax,0x20(%esp)
 804b2b4:	8b 42 24             	mov    0x24(%edx),%eax
 804b2b7:	89 44 24 24          	mov    %eax,0x24(%esp)
 804b2bb:	8b 42 28             	mov    0x28(%edx),%eax
 804b2be:	89 44 24 28          	mov    %eax,0x28(%esp)
 804b2c2:	8b 42 2c             	mov    0x2c(%edx),%eax
 804b2c5:	89 44 24 2c          	mov    %eax,0x2c(%esp)
 804b2c9:	8b 42 30             	mov    0x30(%edx),%eax
 804b2cc:	89 44 24 30          	mov    %eax,0x30(%esp)
 804b2d0:	8b 42 34             	mov    0x34(%edx),%eax
 804b2d3:	89 44 24 34          	mov    %eax,0x34(%esp)
 804b2d7:	8b 42 38             	mov    0x38(%edx),%eax
 804b2da:	89 44 24 38          	mov    %eax,0x38(%esp)
 804b2de:	8b 42 3c             	mov    0x3c(%edx),%eax
 804b2e1:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	if(block + len > CACHE_BLOCK_SIZE) {
 804b2e5:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
 804b2e8:	83 f8 40             	cmp    $0x40,%eax
 804b2eb:	0f 86 98 00 00 00    	jbe    804b389 <l2cache_read+0x169>
		temp.addr += CACHE_BLOCK_SIZE;
 804b2f1:	8d 47 40             	lea    0x40(%edi),%eax
		set = temp.set;
 804b2f4:	89 c7                	mov    %eax,%edi
 804b2f6:	c1 ef 06             	shr    $0x6,%edi
		way = check_cache(temp.addr);
 804b2f9:	e8 02 fd ff ff       	call   804b000 <check_cache>

	uint8_t buf[CACHE_BLOCK_SIZE << 1];
	memcpy(buf, l2cache[set][way].buf, CACHE_BLOCK_SIZE);
	if(block + len > CACHE_BLOCK_SIZE) {
		temp.addr += CACHE_BLOCK_SIZE;
		set = temp.set;
 804b2fe:	0f b7 ff             	movzwl %di,%edi
		way = check_cache(temp.addr);
		memcpy(buf + CACHE_BLOCK_SIZE, l2cache[set][way].buf, CACHE_BLOCK_SIZE);
 804b301:	0f b6 c0             	movzbl %al,%eax
 804b304:	8d 14 c0             	lea    (%eax,%eax,8),%edx
 804b307:	8d 04 ff             	lea    (%edi,%edi,8),%eax
 804b30a:	c1 e0 07             	shl    $0x7,%eax
 804b30d:	8d 14 d0             	lea    (%eax,%edx,8),%edx
 804b310:	8d 82 00 8a 0c 08    	lea    0x80c8a00(%edx),%eax
 804b316:	8b 92 00 8a 0c 08    	mov    0x80c8a00(%edx),%edx
 804b31c:	89 54 24 40          	mov    %edx,0x40(%esp)
 804b320:	8b 50 04             	mov    0x4(%eax),%edx
 804b323:	89 54 24 44          	mov    %edx,0x44(%esp)
 804b327:	8b 50 08             	mov    0x8(%eax),%edx
 804b32a:	89 54 24 48          	mov    %edx,0x48(%esp)
 804b32e:	8b 50 0c             	mov    0xc(%eax),%edx
 804b331:	89 54 24 4c          	mov    %edx,0x4c(%esp)
 804b335:	8b 50 10             	mov    0x10(%eax),%edx
 804b338:	89 54 24 50          	mov    %edx,0x50(%esp)
 804b33c:	8b 50 14             	mov    0x14(%eax),%edx
 804b33f:	89 54 24 54          	mov    %edx,0x54(%esp)
 804b343:	8b 50 18             	mov    0x18(%eax),%edx
 804b346:	89 54 24 58          	mov    %edx,0x58(%esp)
 804b34a:	8b 50 1c             	mov    0x1c(%eax),%edx
 804b34d:	89 54 24 5c          	mov    %edx,0x5c(%esp)
 804b351:	8b 50 20             	mov    0x20(%eax),%edx
 804b354:	89 54 24 60          	mov    %edx,0x60(%esp)
 804b358:	8b 50 24             	mov    0x24(%eax),%edx
 804b35b:	89 54 24 64          	mov    %edx,0x64(%esp)
 804b35f:	8b 50 28             	mov    0x28(%eax),%edx
 804b362:	89 54 24 68          	mov    %edx,0x68(%esp)
 804b366:	8b 50 2c             	mov    0x2c(%eax),%edx
 804b369:	89 54 24 6c          	mov    %edx,0x6c(%esp)
 804b36d:	8b 50 30             	mov    0x30(%eax),%edx
 804b370:	89 54 24 70          	mov    %edx,0x70(%esp)
 804b374:	8b 50 34             	mov    0x34(%eax),%edx
 804b377:	89 54 24 74          	mov    %edx,0x74(%esp)
 804b37b:	8b 50 38             	mov    0x38(%eax),%edx
 804b37e:	8b 40 3c             	mov    0x3c(%eax),%eax
 804b381:	89 54 24 78          	mov    %edx,0x78(%esp)
 804b385:	89 44 24 7c          	mov    %eax,0x7c(%esp)
	}
	return (*(uint32_t *)(buf + block)) & (~0u >> ((4 - len) << 3));
 804b389:	b9 04 00 00 00       	mov    $0x4,%ecx
 804b38e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804b393:	29 f1                	sub    %esi,%ecx
 804b395:	c1 e1 03             	shl    $0x3,%ecx
 804b398:	d3 e8                	shr    %cl,%eax
 804b39a:	23 04 1c             	and    (%esp,%ebx,1),%eax
}
 804b39d:	81 c4 8c 00 00 00    	add    $0x8c,%esp
 804b3a3:	5b                   	pop    %ebx
 804b3a4:	5e                   	pop    %esi
 804b3a5:	5f                   	pop    %edi
 804b3a6:	5d                   	pop    %ebp
 804b3a7:	c3                   	ret    
	}
	return way;
}

uint32_t l2cache_read(hwaddr_t addr, size_t len) {
	assert(len == 1 || len == 2 || len == 4);
 804b3a8:	68 a2 f7 05 08       	push   $0x805f7a2
 804b3ad:	6a 5a                	push   $0x5a
 804b3af:	68 7a f7 05 08       	push   $0x805f77a
 804b3b4:	68 40 f7 05 08       	push   $0x805f740
 804b3b9:	e8 f2 d7 ff ff       	call   8048bb0 <__assert_fail@plt>
 804b3be:	66 90                	xchg   %ax,%ax

0804b3c0 <l2cache_write>:
		memcpy(buf + CACHE_BLOCK_SIZE, l2cache[set][way].buf, CACHE_BLOCK_SIZE);
	}
	return (*(uint32_t *)(buf + block)) & (~0u >> ((4 - len) << 3));
}

void l2cache_write(hwaddr_t addr, size_t len, uint32_t data) {
 804b3c0:	55                   	push   %ebp
 804b3c1:	57                   	push   %edi
 804b3c2:	56                   	push   %esi
 804b3c3:	53                   	push   %ebx
 804b3c4:	83 ec 1c             	sub    $0x1c,%esp
 804b3c7:	8b 44 24 30          	mov    0x30(%esp),%eax
 804b3cb:	8b 7c 24 34          	mov    0x34(%esp),%edi
 804b3cf:	8b 74 24 38          	mov    0x38(%esp),%esi
 804b3d3:	89 44 24 04          	mov    %eax,0x4(%esp)
	assert(len == 1 || len == 2 || len == 4);
 804b3d7:	8d 47 ff             	lea    -0x1(%edi),%eax
 804b3da:	83 f8 01             	cmp    $0x1,%eax
 804b3dd:	76 09                	jbe    804b3e8 <l2cache_write+0x28>
 804b3df:	83 ff 04             	cmp    $0x4,%edi
 804b3e2:	0f 85 56 01 00 00    	jne    804b53e <l2cache_write+0x17e>
	l2cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b3e8:	8b 4c 24 04          	mov    0x4(%esp),%ecx
	uint32_t set = temp.set;
 804b3ec:	89 c8                	mov    %ecx,%eax

void l2cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
	l2cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b3ee:	89 cb                	mov    %ecx,%ebx
	uint32_t set = temp.set;
	uint32_t block = temp.block;
 804b3f0:	89 cd                	mov    %ecx,%ebp
void l2cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
	l2cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
 804b3f2:	c1 e8 06             	shr    $0x6,%eax

void l2cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
	l2cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b3f5:	c1 eb 16             	shr    $0x16,%ebx
	uint32_t set = temp.set;
	uint32_t block = temp.block;
 804b3f8:	83 e5 3f             	and    $0x3f,%ebp
void l2cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
	l2cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
 804b3fb:	0f b7 c0             	movzwl %ax,%eax

void l2cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
	l2cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b3fe:	83 e3 1f             	and    $0x1f,%ebx
 804b401:	8d 0c c0             	lea    (%eax,%eax,8),%ecx
	uint32_t set = temp.set;
 804b404:	89 44 24 08          	mov    %eax,0x8(%esp)
	uint32_t block = temp.block;
 804b408:	31 c0                	xor    %eax,%eax
 804b40a:	c1 e1 07             	shl    $0x7,%ecx
 804b40d:	8d 91 00 8a 0c 08    	lea    0x80c8a00(%ecx),%edx
 804b413:	90                   	nop
 804b414:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	uint8_t way = 0;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
	if(l2cache[set][way].valid && (l2cache[set][way].tag == tag)) {
 804b418:	80 7a 44 00          	cmpb   $0x0,0x44(%edx)
 804b41c:	74 05                	je     804b423 <l2cache_write+0x63>
 804b41e:	39 5a 40             	cmp    %ebx,0x40(%edx)
 804b421:	74 27                	je     804b44a <l2cache_write+0x8a>
 804b423:	83 c0 01             	add    $0x1,%eax
 804b426:	83 c2 48             	add    $0x48,%edx
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
	uint32_t block = temp.block;
	uint8_t way = 0;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
 804b429:	83 f8 10             	cmp    $0x10,%eax
 804b42c:	75 ea                	jne    804b418 <l2cache_write+0x58>
			}
			l2cache[set][way].dirty = true;
		}
	}
	else {
		dram_write(addr, len, data);
 804b42e:	8b 44 24 04          	mov    0x4(%esp),%eax
 804b432:	89 74 24 38          	mov    %esi,0x38(%esp)
 804b436:	89 7c 24 34          	mov    %edi,0x34(%esp)
 804b43a:	89 44 24 30          	mov    %eax,0x30(%esp)
	}
	return;
}
 804b43e:	83 c4 1c             	add    $0x1c,%esp
 804b441:	5b                   	pop    %ebx
 804b442:	5e                   	pop    %esi
 804b443:	5f                   	pop    %edi
 804b444:	5d                   	pop    %ebp
			}
			l2cache[set][way].dirty = true;
		}
	}
	else {
		dram_write(addr, len, data);
 804b445:	e9 a6 04 00 00       	jmp    804b8f0 <dram_write>
		success = true;
		break;
	}
	if(success){
		int i;
		for(i = 0; i < len; i ++) {
 804b44a:	85 ff                	test   %edi,%edi
 804b44c:	0f 84 ca 00 00 00    	je     804b51c <l2cache_write+0x15c>
	assert(len == 1 || len == 2 || len == 4);
	l2cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
	uint32_t block = temp.block;
 804b452:	89 eb                	mov    %ebp,%ebx
 804b454:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804b458:	0f b6 d3             	movzbl %bl,%edx
 804b45b:	8d 1c c0             	lea    (%eax,%eax,8),%ebx
 804b45e:	01 d1                	add    %edx,%ecx
 804b460:	8d 2c d9             	lea    (%ecx,%ebx,8),%ebp
 804b463:	31 db                	xor    %ebx,%ebx
 804b465:	8d 76 00             	lea    0x0(%esi),%esi
		break;
	}
	if(success){
		int i;
		for(i = 0; i < len; i ++) {
			if(block + i < CACHE_BLOCK_SIZE)l2cache[set][way].buf[block + i] = (uint8_t)((data >> (i << 3)) & 0xff);
 804b468:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
 804b46f:	89 f0                	mov    %esi,%eax
 804b471:	d3 e8                	shr    %cl,%eax
 804b473:	88 84 1d 00 8a 0c 08 	mov    %al,0x80c8a00(%ebp,%ebx,1)
		success = true;
		break;
	}
	if(success){
		int i;
		for(i = 0; i < len; i ++) {
 804b47a:	83 c3 01             	add    $0x1,%ebx
 804b47d:	39 fb                	cmp    %edi,%ebx
 804b47f:	0f 84 93 00 00 00    	je     804b518 <l2cache_write+0x158>
 804b485:	8d 0c 1a             	lea    (%edx,%ebx,1),%ecx
			if(block + i < CACHE_BLOCK_SIZE)l2cache[set][way].buf[block + i] = (uint8_t)((data >> (i << 3)) & 0xff);
 804b488:	83 f9 3f             	cmp    $0x3f,%ecx
 804b48b:	76 db                	jbe    804b468 <l2cache_write+0xa8>
 804b48d:	8b 44 24 0c          	mov    0xc(%esp),%eax
			else break;
		}
		l2cache[set][way].dirty = true;
		if(i != len) {
			temp.addr += CACHE_BLOCK_SIZE;
 804b491:	8b 6c 24 04          	mov    0x4(%esp),%ebp
		int i;
		for(i = 0; i < len; i ++) {
			if(block + i < CACHE_BLOCK_SIZE)l2cache[set][way].buf[block + i] = (uint8_t)((data >> (i << 3)) & 0xff);
			else break;
		}
		l2cache[set][way].dirty = true;
 804b495:	8d 14 c0             	lea    (%eax,%eax,8),%edx
 804b498:	8b 44 24 08          	mov    0x8(%esp),%eax
		if(i != len) {
			temp.addr += CACHE_BLOCK_SIZE;
 804b49c:	83 c5 40             	add    $0x40,%ebp
		int i;
		for(i = 0; i < len; i ++) {
			if(block + i < CACHE_BLOCK_SIZE)l2cache[set][way].buf[block + i] = (uint8_t)((data >> (i << 3)) & 0xff);
			else break;
		}
		l2cache[set][way].dirty = true;
 804b49f:	8d 04 c0             	lea    (%eax,%eax,8),%eax
 804b4a2:	c1 e0 07             	shl    $0x7,%eax
 804b4a5:	c6 84 d0 45 8a 0c 08 	movb   $0x1,0x80c8a45(%eax,%edx,8)
 804b4ac:	01 
		if(i != len) {
			temp.addr += CACHE_BLOCK_SIZE;
			way = check_cache(temp.addr);
 804b4ad:	89 e8                	mov    %ebp,%eax
			set = temp.set;
 804b4af:	c1 ed 06             	shr    $0x6,%ebp
			else break;
		}
		l2cache[set][way].dirty = true;
		if(i != len) {
			temp.addr += CACHE_BLOCK_SIZE;
			way = check_cache(temp.addr);
 804b4b2:	e8 49 fb ff ff       	call   804b000 <check_cache>
			set = temp.set;
			tag = temp.tag;
			int j;
			for(j = 0; j < len - i; j ++) {
 804b4b7:	29 df                	sub    %ebx,%edi
		}
		l2cache[set][way].dirty = true;
		if(i != len) {
			temp.addr += CACHE_BLOCK_SIZE;
			way = check_cache(temp.addr);
			set = temp.set;
 804b4b9:	0f b7 ed             	movzwl %bp,%ebp
			tag = temp.tag;
			int j;
			for(j = 0; j < len - i; j ++) {
 804b4bc:	74 7b                	je     804b539 <l2cache_write+0x179>
 804b4be:	8d 0c dd 00 00 00 00 	lea    0x0(,%ebx,8),%ecx
 804b4c5:	0f b6 c0             	movzbl %al,%eax
 804b4c8:	d3 ee                	shr    %cl,%esi
 804b4ca:	8d 4c ed 00          	lea    0x0(%ebp,%ebp,8),%ecx
 804b4ce:	89 f3                	mov    %esi,%ebx
 804b4d0:	8d 34 c0             	lea    (%eax,%eax,8),%esi
 804b4d3:	c1 e1 07             	shl    $0x7,%ecx
 804b4d6:	c1 e6 03             	shl    $0x3,%esi
 804b4d9:	01 cf                	add    %ecx,%edi
 804b4db:	8d 94 0e 00 8a 0c 08 	lea    0x80c8a00(%esi,%ecx,1),%edx
 804b4e2:	8d 8c 3e 00 8a 0c 08 	lea    0x80c8a00(%esi,%edi,1),%ecx
 804b4e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
				l2cache[set][way].buf[j] = (uint8_t)((data >> (i << 3)) & 0xff);
 804b4f0:	88 1a                	mov    %bl,(%edx)
 804b4f2:	83 c2 01             	add    $0x1,%edx
			temp.addr += CACHE_BLOCK_SIZE;
			way = check_cache(temp.addr);
			set = temp.set;
			tag = temp.tag;
			int j;
			for(j = 0; j < len - i; j ++) {
 804b4f5:	39 ca                	cmp    %ecx,%edx
 804b4f7:	75 f7                	jne    804b4f0 <l2cache_write+0x130>
				l2cache[set][way].buf[j] = (uint8_t)((data >> (i << 3)) & 0xff);
			}
			l2cache[set][way].dirty = true;
 804b4f9:	8d 14 c0             	lea    (%eax,%eax,8),%edx
 804b4fc:	8d 44 ed 00          	lea    0x0(%ebp,%ebp,8),%eax
 804b500:	c1 e0 07             	shl    $0x7,%eax
 804b503:	c6 84 d0 45 8a 0c 08 	movb   $0x1,0x80c8a45(%eax,%edx,8)
 804b50a:	01 
	}
	else {
		dram_write(addr, len, data);
	}
	return;
}
 804b50b:	83 c4 1c             	add    $0x1c,%esp
 804b50e:	5b                   	pop    %ebx
 804b50f:	5e                   	pop    %esi
 804b510:	5f                   	pop    %edi
 804b511:	5d                   	pop    %ebp
 804b512:	c3                   	ret    
 804b513:	90                   	nop
 804b514:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804b518:	8b 44 24 0c          	mov    0xc(%esp),%eax
		int i;
		for(i = 0; i < len; i ++) {
			if(block + i < CACHE_BLOCK_SIZE)l2cache[set][way].buf[block + i] = (uint8_t)((data >> (i << 3)) & 0xff);
			else break;
		}
		l2cache[set][way].dirty = true;
 804b51c:	8d 14 c0             	lea    (%eax,%eax,8),%edx
 804b51f:	8b 44 24 08          	mov    0x8(%esp),%eax
 804b523:	8d 04 c0             	lea    (%eax,%eax,8),%eax
 804b526:	c1 e0 07             	shl    $0x7,%eax
 804b529:	c6 84 d0 45 8a 0c 08 	movb   $0x1,0x80c8a45(%eax,%edx,8)
 804b530:	01 
	}
	else {
		dram_write(addr, len, data);
	}
	return;
}
 804b531:	83 c4 1c             	add    $0x1c,%esp
 804b534:	5b                   	pop    %ebx
 804b535:	5e                   	pop    %esi
 804b536:	5f                   	pop    %edi
 804b537:	5d                   	pop    %ebp
 804b538:	c3                   	ret    
 804b539:	0f b6 c0             	movzbl %al,%eax
 804b53c:	eb bb                	jmp    804b4f9 <l2cache_write+0x139>
	}
	return (*(uint32_t *)(buf + block)) & (~0u >> ((4 - len) << 3));
}

void l2cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
 804b53e:	68 94 f7 05 08       	push   $0x805f794
 804b543:	6a 6e                	push   $0x6e
 804b545:	68 7a f7 05 08       	push   $0x805f77a
 804b54a:	68 40 f7 05 08       	push   $0x805f740
 804b54f:	e8 5c d6 ff ff       	call   8048bb0 <__assert_fail@plt>
 804b554:	66 90                	xchg   %ax,%ax
 804b556:	66 90                	xchg   %ax,%ax
 804b558:	66 90                	xchg   %ax,%ax
 804b55a:	66 90                	xchg   %ax,%ax
 804b55c:	66 90                	xchg   %ax,%ax
 804b55e:	66 90                	xchg   %ax,%ax

0804b560 <ddr3_write>:

	/* burst read */
	memcpy(data, rowbufs[rank][bank].buf + col, BURST_LEN);
}

static void ddr3_write(hwaddr_t addr, void *data, uint8_t *mask) {
 804b560:	55                   	push   %ebp
 804b561:	57                   	push   %edi
 804b562:	56                   	push   %esi
 804b563:	53                   	push   %ebx
 804b564:	83 ec 1c             	sub    $0x1c,%esp
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);
 804b567:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
 804b56c:	0f 87 3e 01 00 00    	ja     804b6b0 <ddr3_write+0x150>

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
 804b572:	83 e0 f8             	and    $0xfffffff8,%eax
 804b575:	89 cb                	mov    %ecx,%ebx
	uint32_t rank = temp.rank;
 804b577:	89 c1                	mov    %eax,%ecx
	uint32_t bank = temp.bank;
 804b579:	89 c5                	mov    %eax,%ebp
static void ddr3_write(hwaddr_t addr, void *data, uint8_t *mask) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
 804b57b:	c1 e9 17             	shr    $0x17,%ecx
	uint32_t bank = temp.bank;
 804b57e:	c1 ed 14             	shr    $0x14,%ebp
static void ddr3_write(hwaddr_t addr, void *data, uint8_t *mask) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
 804b581:	83 e1 0f             	and    $0xf,%ecx
	uint32_t bank = temp.bank;
 804b584:	83 e5 07             	and    $0x7,%ebp
static void ddr3_write(hwaddr_t addr, void *data, uint8_t *mask) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
 804b587:	89 cf                	mov    %ecx,%edi
 804b589:	89 4c 24 08          	mov    %ecx,0x8(%esp)
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
 804b58d:	89 c1                	mov    %eax,%ecx
	uint32_t col = temp.col;
 804b58f:	25 f8 03 00 00       	and    $0x3f8,%eax

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
 804b594:	c1 e9 0a             	shr    $0xa,%ecx
	uint32_t col = temp.col;
 804b597:	89 44 24 0c          	mov    %eax,0xc(%esp)

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
 804b59b:	89 e8                	mov    %ebp,%eax

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
 804b59d:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
	uint32_t col = temp.col;

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
 804b5a3:	c1 e0 0a             	shl    $0xa,%eax

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
 804b5a6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
	uint32_t col = temp.col;

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
 804b5aa:	8d 0c e8             	lea    (%eax,%ebp,8),%ecx
 804b5ad:	69 c7 40 20 00 00    	imul   $0x2040,%edi,%eax
 804b5b3:	8d 84 01 00 8a 8c 14 	lea    0x148c8a00(%ecx,%eax,1),%eax
 804b5ba:	80 b8 04 04 00 00 00 	cmpb   $0x0,0x404(%eax)
 804b5c1:	74 0c                	je     804b5cf <ddr3_write+0x6f>
 804b5c3:	8b 7c 24 04          	mov    0x4(%esp),%edi
 804b5c7:	39 b8 00 04 00 00    	cmp    %edi,0x400(%eax)
 804b5cd:	74 47                	je     804b616 <ddr3_write+0xb6>
		/* read a row into row buffer */
		memcpy(rowbufs[rank][bank].buf, dram[rank][bank][row], NR_COL);
 804b5cf:	8b 7c 24 08          	mov    0x8(%esp),%edi
 804b5d3:	89 e8                	mov    %ebp,%eax
 804b5d5:	c1 e0 0a             	shl    $0xa,%eax
 804b5d8:	8d 0c e8             	lea    (%eax,%ebp,8),%ecx
 804b5db:	8d 74 fd 00          	lea    0x0(%ebp,%edi,8),%esi
 804b5df:	69 c7 40 20 00 00    	imul   $0x2040,%edi,%eax
 804b5e5:	c1 e6 0a             	shl    $0xa,%esi
 804b5e8:	03 74 24 04          	add    0x4(%esp),%esi
 804b5ec:	8d 84 01 00 8a 8c 14 	lea    0x148c8a00(%ecx,%eax,1),%eax
 804b5f3:	b9 00 01 00 00       	mov    $0x100,%ecx
 804b5f8:	c1 e6 0a             	shl    $0xa,%esi
 804b5fb:	89 c7                	mov    %eax,%edi
		rowbufs[rank][bank].row_idx = row;
		rowbufs[rank][bank].valid = true;
 804b5fd:	c6 80 04 04 00 00 01 	movb   $0x1,0x404(%eax)
	uint32_t row = temp.row;
	uint32_t col = temp.col;

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
		/* read a row into row buffer */
		memcpy(rowbufs[rank][bank].buf, dram[rank][bank][row], NR_COL);
 804b604:	81 c6 00 8a 8c 0c    	add    $0xc8c8a00,%esi
 804b60a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		rowbufs[rank][bank].row_idx = row;
 804b60c:	8b 7c 24 04          	mov    0x4(%esp),%edi
 804b610:	89 b8 00 04 00 00    	mov    %edi,0x400(%eax)
		rowbufs[rank][bank].valid = true;
	}

	/* burst write */
	memcpy_with_mask(rowbufs[rank][bank].buf + col, data, BURST_LEN, mask);
 804b616:	89 e8                	mov    %ebp,%eax
 804b618:	31 f6                	xor    %esi,%esi
 804b61a:	c1 e0 0a             	shl    $0xa,%eax
 804b61d:	8d 0c e8             	lea    (%eax,%ebp,8),%ecx
 804b620:	69 44 24 08 40 20 00 	imul   $0x2040,0x8(%esp),%eax
 804b627:	00 
 804b628:	8d 84 01 00 8a 8c 14 	lea    0x148c8a00(%ecx,%eax,1),%eax
 804b62f:	03 44 24 0c          	add    0xc(%esp),%eax
 804b633:	90                   	nop
 804b634:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#include "common.h"

inline static void memcpy_with_mask(void *dest, const void *src, size_t len, uint8_t *mask) {
	int i;
	for(i = 0; i < len; i ++) {
		if(mask[i]) {
 804b638:	80 3c 33 00          	cmpb   $0x0,(%ebx,%esi,1)
 804b63c:	74 07                	je     804b645 <ddr3_write+0xe5>
			((uint8_t *)dest)[i] = ((uint8_t *)src)[i];
 804b63e:	0f b6 0c 32          	movzbl (%edx,%esi,1),%ecx
 804b642:	88 0c 30             	mov    %cl,(%eax,%esi,1)

#include "common.h"

inline static void memcpy_with_mask(void *dest, const void *src, size_t len, uint8_t *mask) {
	int i;
	for(i = 0; i < len; i ++) {
 804b645:	83 c6 01             	add    $0x1,%esi
 804b648:	83 fe 08             	cmp    $0x8,%esi
 804b64b:	75 eb                	jne    804b638 <ddr3_write+0xd8>

	/* write back to dram */
	memcpy(dram[rank][bank][row], rowbufs[rank][bank].buf, NR_COL);
 804b64d:	8b 7c 24 08          	mov    0x8(%esp),%edi
 804b651:	89 ea                	mov    %ebp,%edx
 804b653:	c1 e2 0a             	shl    $0xa,%edx
 804b656:	8d 1c ea             	lea    (%edx,%ebp,8),%ebx
 804b659:	8d 44 fd 00          	lea    0x0(%ebp,%edi,8),%eax
 804b65d:	69 d7 40 20 00 00    	imul   $0x2040,%edi,%edx
 804b663:	c1 e0 0a             	shl    $0xa,%eax
 804b666:	03 44 24 04          	add    0x4(%esp),%eax
 804b66a:	01 da                	add    %ebx,%edx
 804b66c:	8d b2 00 8a 8c 14    	lea    0x148c8a00(%edx),%esi
 804b672:	8b 92 00 8a 8c 14    	mov    0x148c8a00(%edx),%edx
 804b678:	c1 e0 0a             	shl    $0xa,%eax
 804b67b:	8d 88 00 8a 8c 0c    	lea    0xc8c8a00(%eax),%ecx
 804b681:	89 90 00 8a 8c 0c    	mov    %edx,0xc8c8a00(%eax)
 804b687:	8b 86 fc 03 00 00    	mov    0x3fc(%esi),%eax
 804b68d:	8d 79 04             	lea    0x4(%ecx),%edi
 804b690:	83 e7 fc             	and    $0xfffffffc,%edi
 804b693:	89 81 fc 03 00 00    	mov    %eax,0x3fc(%ecx)
 804b699:	29 f9                	sub    %edi,%ecx
 804b69b:	29 ce                	sub    %ecx,%esi
 804b69d:	81 c1 00 04 00 00    	add    $0x400,%ecx
 804b6a3:	c1 e9 02             	shr    $0x2,%ecx
 804b6a6:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
 804b6a8:	83 c4 1c             	add    $0x1c,%esp
 804b6ab:	5b                   	pop    %ebx
 804b6ac:	5e                   	pop    %esi
 804b6ad:	5f                   	pop    %edi
 804b6ae:	5d                   	pop    %ebp
 804b6af:	c3                   	ret    
	/* burst read */
	memcpy(data, rowbufs[rank][bank].buf + col, BURST_LEN);
}

static void ddr3_write(hwaddr_t addr, void *data, uint8_t *mask) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);
 804b6b0:	83 ec 0c             	sub    $0xc,%esp
 804b6b3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804b6b9:	89 c3                	mov    %eax,%ebx
 804b6bb:	e8 a0 d2 ff ff       	call   8048960 <fflush@plt>
 804b6c0:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804b6c6:	6a 07                	push   $0x7
 804b6c8:	6a 01                	push   $0x1
 804b6ca:	68 92 ed 05 08       	push   $0x805ed92
 804b6cf:	e8 3c d3 ff ff       	call   8048a10 <fwrite@plt>
 804b6d4:	83 c4 1c             	add    $0x1c,%esp
 804b6d7:	53                   	push   %ebx
 804b6d8:	68 c8 f7 05 08       	push   $0x805f7c8
 804b6dd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804b6e3:	e8 d8 d3 ff ff       	call   8048ac0 <fprintf@plt>
 804b6e8:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804b6ee:	6a 05                	push   $0x5
 804b6f0:	6a 01                	push   $0x1
 804b6f2:	68 b1 ed 05 08       	push   $0x805edb1
 804b6f7:	e8 14 d3 ff ff       	call   8048a10 <fwrite@plt>
 804b6fc:	83 c4 20             	add    $0x20,%esp
 804b6ff:	68 31 f8 05 08       	push   $0x805f831
 804b704:	6a 4c                	push   $0x4c
 804b706:	68 af f7 05 08       	push   $0x805f7af
 804b70b:	68 00 f8 05 08       	push   $0x805f800
 804b710:	e8 9b d4 ff ff       	call   8048bb0 <__assert_fail@plt>
 804b715:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804b719:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804b720 <ddr3_read>:
			rowbufs[i][j].valid = false;
		}
	}
}

static void ddr3_read(hwaddr_t addr, void *data) {
 804b720:	55                   	push   %ebp
 804b721:	57                   	push   %edi
 804b722:	56                   	push   %esi
 804b723:	53                   	push   %ebx
 804b724:	83 ec 1c             	sub    $0x1c,%esp
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);
 804b727:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
 804b72c:	0f 87 ce 00 00 00    	ja     804b800 <ddr3_read+0xe0>

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
 804b732:	83 e0 f8             	and    $0xfffffff8,%eax
 804b735:	89 d5                	mov    %edx,%ebp
	uint32_t rank = temp.rank;
	uint32_t bank = temp.bank;
 804b737:	89 c2                	mov    %eax,%edx
static void ddr3_read(hwaddr_t addr, void *data) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
 804b739:	89 c3                	mov    %eax,%ebx
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
 804b73b:	89 c1                	mov    %eax,%ecx
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
	uint32_t bank = temp.bank;
 804b73d:	c1 ea 14             	shr    $0x14,%edx
	uint32_t row = temp.row;
	uint32_t col = temp.col;
 804b740:	25 f8 03 00 00       	and    $0x3f8,%eax
static void ddr3_read(hwaddr_t addr, void *data) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
 804b745:	c1 eb 17             	shr    $0x17,%ebx
	uint32_t bank = temp.bank;
 804b748:	83 e2 07             	and    $0x7,%edx
	uint32_t row = temp.row;
 804b74b:	c1 e9 0a             	shr    $0xa,%ecx
	uint32_t col = temp.col;
 804b74e:	89 44 24 0c          	mov    %eax,0xc(%esp)

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
 804b752:	89 d0                	mov    %edx,%eax

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
 804b754:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
static void ddr3_read(hwaddr_t addr, void *data) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
 804b75a:	83 e3 0f             	and    $0xf,%ebx
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
	uint32_t col = temp.col;

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
 804b75d:	c1 e0 0a             	shl    $0xa,%eax

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
 804b760:	89 4c 24 08          	mov    %ecx,0x8(%esp)
	uint32_t col = temp.col;

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
 804b764:	8d 0c d0             	lea    (%eax,%edx,8),%ecx
 804b767:	69 c3 40 20 00 00    	imul   $0x2040,%ebx,%eax
 804b76d:	8d 84 01 00 8a 8c 14 	lea    0x148c8a00(%ecx,%eax,1),%eax
 804b774:	80 b8 04 04 00 00 00 	cmpb   $0x0,0x404(%eax)
 804b77b:	74 0c                	je     804b789 <ddr3_read+0x69>
 804b77d:	8b 7c 24 08          	mov    0x8(%esp),%edi
 804b781:	39 b8 00 04 00 00    	cmp    %edi,0x400(%eax)
 804b787:	74 42                	je     804b7cb <ddr3_read+0xab>
		/* read a row into row buffer */
		memcpy(rowbufs[rank][bank].buf, dram[rank][bank][row], NR_COL);
 804b789:	89 d0                	mov    %edx,%eax
 804b78b:	8d 34 da             	lea    (%edx,%ebx,8),%esi
 804b78e:	c1 e0 0a             	shl    $0xa,%eax
 804b791:	8d 0c d0             	lea    (%eax,%edx,8),%ecx
 804b794:	c1 e6 0a             	shl    $0xa,%esi
 804b797:	03 74 24 08          	add    0x8(%esp),%esi
 804b79b:	69 c3 40 20 00 00    	imul   $0x2040,%ebx,%eax
 804b7a1:	8d 84 01 00 8a 8c 14 	lea    0x148c8a00(%ecx,%eax,1),%eax
 804b7a8:	c1 e6 0a             	shl    $0xa,%esi
 804b7ab:	b9 00 01 00 00       	mov    $0x100,%ecx
 804b7b0:	81 c6 00 8a 8c 0c    	add    $0xc8c8a00,%esi
 804b7b6:	89 c7                	mov    %eax,%edi
		rowbufs[rank][bank].row_idx = row;
		rowbufs[rank][bank].valid = true;
 804b7b8:	c6 80 04 04 00 00 01 	movb   $0x1,0x404(%eax)
	uint32_t row = temp.row;
	uint32_t col = temp.col;

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
		/* read a row into row buffer */
		memcpy(rowbufs[rank][bank].buf, dram[rank][bank][row], NR_COL);
 804b7bf:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		rowbufs[rank][bank].row_idx = row;
 804b7c1:	8b 7c 24 08          	mov    0x8(%esp),%edi
 804b7c5:	89 b8 00 04 00 00    	mov    %edi,0x400(%eax)
		rowbufs[rank][bank].valid = true;
	}

	/* burst read */
	memcpy(data, rowbufs[rank][bank].buf + col, BURST_LEN);
 804b7cb:	89 d0                	mov    %edx,%eax
 804b7cd:	c1 e0 0a             	shl    $0xa,%eax
 804b7d0:	8d 04 d0             	lea    (%eax,%edx,8),%eax
 804b7d3:	69 db 40 20 00 00    	imul   $0x2040,%ebx,%ebx
 804b7d9:	8d 84 18 00 8a 8c 14 	lea    0x148c8a00(%eax,%ebx,1),%eax
 804b7e0:	03 44 24 0c          	add    0xc(%esp),%eax
 804b7e4:	8b 10                	mov    (%eax),%edx
 804b7e6:	89 55 00             	mov    %edx,0x0(%ebp)
 804b7e9:	8b 40 04             	mov    0x4(%eax),%eax
 804b7ec:	89 45 04             	mov    %eax,0x4(%ebp)
}
 804b7ef:	83 c4 1c             	add    $0x1c,%esp
 804b7f2:	5b                   	pop    %ebx
 804b7f3:	5e                   	pop    %esi
 804b7f4:	5f                   	pop    %edi
 804b7f5:	5d                   	pop    %ebp
 804b7f6:	c3                   	ret    
 804b7f7:	89 f6                	mov    %esi,%esi
 804b7f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		}
	}
}

static void ddr3_read(hwaddr_t addr, void *data) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);
 804b800:	83 ec 0c             	sub    $0xc,%esp
 804b803:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804b809:	89 c3                	mov    %eax,%ebx
 804b80b:	e8 50 d1 ff ff       	call   8048960 <fflush@plt>
 804b810:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804b816:	6a 07                	push   $0x7
 804b818:	6a 01                	push   $0x1
 804b81a:	68 92 ed 05 08       	push   $0x805ed92
 804b81f:	e8 ec d1 ff ff       	call   8048a10 <fwrite@plt>
 804b824:	83 c4 1c             	add    $0x1c,%esp
 804b827:	53                   	push   %ebx
 804b828:	68 c8 f7 05 08       	push   $0x805f7c8
 804b82d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804b833:	e8 88 d2 ff ff       	call   8048ac0 <fprintf@plt>
 804b838:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804b83e:	6a 05                	push   $0x5
 804b840:	6a 01                	push   $0x1
 804b842:	68 b1 ed 05 08       	push   $0x805edb1
 804b847:	e8 c4 d1 ff ff       	call   8048a10 <fwrite@plt>
 804b84c:	83 c4 20             	add    $0x20,%esp
 804b84f:	68 3c f8 05 08       	push   $0x805f83c
 804b854:	6a 37                	push   $0x37
 804b856:	68 af f7 05 08       	push   $0x805f7af
 804b85b:	68 00 f8 05 08       	push   $0x805f800
 804b860:	e8 4b d3 ff ff       	call   8048bb0 <__assert_fail@plt>
 804b865:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804b869:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804b870 <init_ddr3>:
	bool valid;
} RB;

RB rowbufs[NR_RANK][NR_BANK];

void init_ddr3() {
 804b870:	31 d2                	xor    %edx,%edx
 804b872:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804b878:	31 c0                	xor    %eax,%eax
 804b87a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	int i, j;
	for(i = 0; i < NR_RANK; i ++) {
		for(j = 0; j < NR_BANK; j ++) {
			rowbufs[i][j].valid = false;
 804b880:	c6 84 02 04 8e 8c 14 	movb   $0x0,0x148c8e04(%edx,%eax,1)
 804b887:	00 
 804b888:	05 08 04 00 00       	add    $0x408,%eax
RB rowbufs[NR_RANK][NR_BANK];

void init_ddr3() {
	int i, j;
	for(i = 0; i < NR_RANK; i ++) {
		for(j = 0; j < NR_BANK; j ++) {
 804b88d:	3d 40 20 00 00       	cmp    $0x2040,%eax
 804b892:	75 ec                	jne    804b880 <init_ddr3+0x10>
 804b894:	81 c2 40 20 00 00    	add    $0x2040,%edx

RB rowbufs[NR_RANK][NR_BANK];

void init_ddr3() {
	int i, j;
	for(i = 0; i < NR_RANK; i ++) {
 804b89a:	81 fa 00 04 02 00    	cmp    $0x20400,%edx
 804b8a0:	75 d6                	jne    804b878 <init_ddr3+0x8>
 804b8a2:	f3 c3                	repz ret 
 804b8a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804b8aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804b8b0 <dram_read>:

	/* write back to dram */
	memcpy(dram[rank][bank][row], rowbufs[rank][bank].buf, NR_COL);
}

uint32_t dram_read(hwaddr_t addr, size_t len) {
 804b8b0:	56                   	push   %esi
 804b8b1:	53                   	push   %ebx
 804b8b2:	83 ec 14             	sub    $0x14,%esp
 804b8b5:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	uint32_t offset = addr & BURST_MASK;
	uint8_t temp[2 * BURST_LEN];
	
	ddr3_read(addr, temp);
 804b8b9:	89 e2                	mov    %esp,%edx
 804b8bb:	89 d8                	mov    %ebx,%eax
	/* write back to dram */
	memcpy(dram[rank][bank][row], rowbufs[rank][bank].buf, NR_COL);
}

uint32_t dram_read(hwaddr_t addr, size_t len) {
	uint32_t offset = addr & BURST_MASK;
 804b8bd:	89 de                	mov    %ebx,%esi
	uint8_t temp[2 * BURST_LEN];
	
	ddr3_read(addr, temp);
 804b8bf:	e8 5c fe ff ff       	call   804b720 <ddr3_read>

	if(offset + len > BURST_LEN) {
 804b8c4:	8b 44 24 24          	mov    0x24(%esp),%eax
	/* write back to dram */
	memcpy(dram[rank][bank][row], rowbufs[rank][bank].buf, NR_COL);
}

uint32_t dram_read(hwaddr_t addr, size_t len) {
	uint32_t offset = addr & BURST_MASK;
 804b8c8:	83 e6 07             	and    $0x7,%esi
	uint8_t temp[2 * BURST_LEN];
	
	ddr3_read(addr, temp);

	if(offset + len > BURST_LEN) {
 804b8cb:	01 f0                	add    %esi,%eax
 804b8cd:	83 f8 08             	cmp    $0x8,%eax
 804b8d0:	76 0c                	jbe    804b8de <dram_read+0x2e>
		/* data cross the burst boundary */
		ddr3_read(addr + BURST_LEN, temp + BURST_LEN);
 804b8d2:	8d 43 08             	lea    0x8(%ebx),%eax
 804b8d5:	8d 54 24 08          	lea    0x8(%esp),%edx
 804b8d9:	e8 42 fe ff ff       	call   804b720 <ddr3_read>
	}

	return unalign_rw(temp + offset, 4);
 804b8de:	8b 04 34             	mov    (%esp,%esi,1),%eax
}
 804b8e1:	83 c4 14             	add    $0x14,%esp
 804b8e4:	5b                   	pop    %ebx
 804b8e5:	5e                   	pop    %esi
 804b8e6:	c3                   	ret    
 804b8e7:	89 f6                	mov    %esi,%esi
 804b8e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804b8f0 <dram_write>:

void dram_write(hwaddr_t addr, size_t len, uint32_t data) {
 804b8f0:	57                   	push   %edi
 804b8f1:	56                   	push   %esi
 804b8f2:	53                   	push   %ebx
 804b8f3:	83 ec 20             	sub    $0x20,%esp
 804b8f6:	8b 74 24 30          	mov    0x30(%esp),%esi
	uint32_t offset = addr & BURST_MASK;
	uint8_t temp[2 * BURST_LEN];
	uint8_t mask[2 * BURST_LEN];
	memset(mask, 0, 2 * BURST_LEN);

	*(uint32_t *)(temp + offset) = data;
 804b8fa:	8b 44 24 38          	mov    0x38(%esp),%eax
	memset(mask + offset, 1, len);
 804b8fe:	83 ec 04             	sub    $0x4,%esp
	}

	return unalign_rw(temp + offset, 4);
}

void dram_write(hwaddr_t addr, size_t len, uint32_t data) {
 804b901:	8b 5c 24 38          	mov    0x38(%esp),%ebx
	uint32_t offset = addr & BURST_MASK;
	uint8_t temp[2 * BURST_LEN];
	uint8_t mask[2 * BURST_LEN];
	memset(mask, 0, 2 * BURST_LEN);
 804b905:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b90c:	00 
 804b90d:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
 804b914:	00 
 804b915:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 804b91c:	00 

	return unalign_rw(temp + offset, 4);
}

void dram_write(hwaddr_t addr, size_t len, uint32_t data) {
	uint32_t offset = addr & BURST_MASK;
 804b91d:	89 f7                	mov    %esi,%edi
	uint8_t temp[2 * BURST_LEN];
	uint8_t mask[2 * BURST_LEN];
	memset(mask, 0, 2 * BURST_LEN);
 804b91f:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
 804b926:	00 

	return unalign_rw(temp + offset, 4);
}

void dram_write(hwaddr_t addr, size_t len, uint32_t data) {
	uint32_t offset = addr & BURST_MASK;
 804b927:	83 e7 07             	and    $0x7,%edi
	uint8_t temp[2 * BURST_LEN];
	uint8_t mask[2 * BURST_LEN];
	memset(mask, 0, 2 * BURST_LEN);

	*(uint32_t *)(temp + offset) = data;
 804b92a:	89 44 3c 04          	mov    %eax,0x4(%esp,%edi,1)
	memset(mask + offset, 1, len);
 804b92e:	53                   	push   %ebx

	ddr3_write(addr, temp, mask);

	if(offset + len > BURST_LEN) {
 804b92f:	01 fb                	add    %edi,%ebx
	uint8_t temp[2 * BURST_LEN];
	uint8_t mask[2 * BURST_LEN];
	memset(mask, 0, 2 * BURST_LEN);

	*(uint32_t *)(temp + offset) = data;
	memset(mask + offset, 1, len);
 804b931:	6a 01                	push   $0x1
 804b933:	8d 44 24 1c          	lea    0x1c(%esp),%eax
 804b937:	01 f8                	add    %edi,%eax
 804b939:	50                   	push   %eax
 804b93a:	e8 b1 d1 ff ff       	call   8048af0 <memset@plt>

	ddr3_write(addr, temp, mask);
 804b93f:	8d 4c 24 20          	lea    0x20(%esp),%ecx
 804b943:	8d 54 24 10          	lea    0x10(%esp),%edx
 804b947:	89 f0                	mov    %esi,%eax
 804b949:	e8 12 fc ff ff       	call   804b560 <ddr3_write>

	if(offset + len > BURST_LEN) {
 804b94e:	83 c4 10             	add    $0x10,%esp
 804b951:	83 fb 08             	cmp    $0x8,%ebx
 804b954:	76 10                	jbe    804b966 <dram_write+0x76>
		/* data cross the burst boundary */
		ddr3_write(addr + BURST_LEN, temp + BURST_LEN, mask + BURST_LEN);
 804b956:	8d 46 08             	lea    0x8(%esi),%eax
 804b959:	8d 4c 24 18          	lea    0x18(%esp),%ecx
 804b95d:	8d 54 24 08          	lea    0x8(%esp),%edx
 804b961:	e8 fa fb ff ff       	call   804b560 <ddr3_write>
	}
}
 804b966:	83 c4 20             	add    $0x20,%esp
 804b969:	5b                   	pop    %ebx
 804b96a:	5e                   	pop    %esi
 804b96b:	5f                   	pop    %edi
 804b96c:	c3                   	ret    
 804b96d:	66 90                	xchg   %ax,%ax
 804b96f:	90                   	nop

0804b970 <check_cache>:

static uint8_t check_cache(hwaddr_t addr) {
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
 804b970:	89 c2                	mov    %eax,%edx
			l1cache[i][j].valid = false;
		}
	}
}

static uint8_t check_cache(hwaddr_t addr) {
 804b972:	55                   	push   %ebp
 804b973:	57                   	push   %edi
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
 804b974:	c1 ea 06             	shr    $0x6,%edx
			l1cache[i][j].valid = false;
		}
	}
}

static uint8_t check_cache(hwaddr_t addr) {
 804b977:	56                   	push   %esi
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b978:	89 c5                	mov    %eax,%ebp
	uint32_t set = temp.set;
 804b97a:	83 e2 7f             	and    $0x7f,%edx
			l1cache[i][j].valid = false;
		}
	}
}

static uint8_t check_cache(hwaddr_t addr) {
 804b97d:	53                   	push   %ebx
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b97e:	c1 ed 0d             	shr    $0xd,%ebp
 804b981:	8d 3c d2             	lea    (%edx,%edx,8),%edi
 804b984:	81 e5 ff 3f 00 00    	and    $0x3fff,%ebp
			l1cache[i][j].valid = false;
		}
	}
}

static uint8_t check_cache(hwaddr_t addr) {
 804b98a:	83 ec 5c             	sub    $0x5c,%esp
 804b98d:	c1 e7 06             	shl    $0x6,%edi
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
 804b990:	89 54 24 0c          	mov    %edx,0xc(%esp)
}

static uint8_t check_cache(hwaddr_t addr) {
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b994:	89 6c 24 08          	mov    %ebp,0x8(%esp)
 804b998:	81 c7 00 8e 8e 14    	add    $0x148e8e00,%edi
	uint32_t set = temp.set;
	uint8_t way = 0;
	int i;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
 804b99e:	31 d2                	xor    %edx,%edx

static uint8_t check_cache(hwaddr_t addr) {
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
 804b9a0:	89 f9                	mov    %edi,%ecx
 804b9a2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	uint8_t way = 0;
	int i;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
		if(l1cache[set][way].valid && (l1cache[set][way].tag == tag)) {
 804b9a8:	80 79 44 00          	cmpb   $0x0,0x44(%ecx)
 804b9ac:	74 0d                	je     804b9bb <check_cache+0x4b>
 804b9ae:	8b 74 24 08          	mov    0x8(%esp),%esi
 804b9b2:	39 71 40             	cmp    %esi,0x40(%ecx)
 804b9b5:	0f 84 f1 00 00 00    	je     804baac <check_cache+0x13c>
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
	uint8_t way = 0;
	int i;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
 804b9bb:	83 c2 01             	add    $0x1,%edx
 804b9be:	83 c1 48             	add    $0x48,%ecx
 804b9c1:	80 fa 08             	cmp    $0x8,%dl
 804b9c4:	75 e2                	jne    804b9a8 <check_cache+0x38>
 804b9c6:	89 c3                	mov    %eax,%ebx
			break;
		}

	if(!success) {
		uint8_t temp1[CACHE_BLOCK_SIZE];
		hwaddr_t addr_temp = addr & ~CACHE_BLOCK_MASK;
 804b9c8:	8d 6c 24 10          	lea    0x10(%esp),%ebp
 804b9cc:	8d 74 24 50          	lea    0x50(%esp),%esi
 804b9d0:	83 e3 c0             	and    $0xffffffc0,%ebx
 804b9d3:	29 eb                	sub    %ebp,%ebx
 804b9d5:	8d 76 00             	lea    0x0(%esi),%esi
 804b9d8:	8d 04 2b             	lea    (%ebx,%ebp,1),%eax
		for(i = 0;i < CACHE_BLOCK_SIZE;i++) {
			temp1[i] = (uint8_t)(l2cache_read(addr_temp + i , 1) & 0xff);
 804b9db:	83 ec 08             	sub    $0x8,%esp
 804b9de:	83 c5 01             	add    $0x1,%ebp
 804b9e1:	6a 01                	push   $0x1
 804b9e3:	50                   	push   %eax
 804b9e4:	e8 37 f8 ff ff       	call   804b220 <l2cache_read>
 804b9e9:	88 45 ff             	mov    %al,-0x1(%ebp)
		}

	if(!success) {
		uint8_t temp1[CACHE_BLOCK_SIZE];
		hwaddr_t addr_temp = addr & ~CACHE_BLOCK_MASK;
		for(i = 0;i < CACHE_BLOCK_SIZE;i++) {
 804b9ec:	83 c4 10             	add    $0x10,%esp
 804b9ef:	39 f5                	cmp    %esi,%ebp
 804b9f1:	75 e5                	jne    804b9d8 <check_cache+0x68>
 804b9f3:	31 c0                	xor    %eax,%eax
 804b9f5:	8d 76 00             	lea    0x0(%esi),%esi
			temp1[i] = (uint8_t)(l2cache_read(addr_temp + i , 1) & 0xff);
		}
		for(way = 0; way < CACHE_WAY_SIZE; way ++)
			if(!l1cache[set][way].valid) break;
 804b9f8:	80 7f 44 00          	cmpb   $0x0,0x44(%edi)
 804b9fc:	89 c2                	mov    %eax,%edx
 804b9fe:	74 18                	je     804ba18 <check_cache+0xa8>
 804ba00:	83 c0 01             	add    $0x1,%eax
 804ba03:	83 c7 48             	add    $0x48,%edi
		uint8_t temp1[CACHE_BLOCK_SIZE];
		hwaddr_t addr_temp = addr & ~CACHE_BLOCK_MASK;
		for(i = 0;i < CACHE_BLOCK_SIZE;i++) {
			temp1[i] = (uint8_t)(l2cache_read(addr_temp + i , 1) & 0xff);
		}
		for(way = 0; way < CACHE_WAY_SIZE; way ++)
 804ba06:	83 f8 08             	cmp    $0x8,%eax
 804ba09:	75 ed                	jne    804b9f8 <check_cache+0x88>
			if(!l1cache[set][way].valid) break;
		if(way == CACHE_WAY_SIZE) way = rand() & (CACHE_WAY_SIZE - 1);
 804ba0b:	e8 40 d1 ff ff       	call   8048b50 <rand@plt>
 804ba10:	89 c2                	mov    %eax,%edx
 804ba12:	83 e2 07             	and    $0x7,%edx
 804ba15:	0f b6 c2             	movzbl %dl,%eax
		memcpy(l1cache[set][way].buf, temp1, CACHE_BLOCK_SIZE);
 804ba18:	8d 0c c0             	lea    (%eax,%eax,8),%ecx
 804ba1b:	8b 44 24 0c          	mov    0xc(%esp),%eax
 804ba1f:	8b 5c 24 10          	mov    0x10(%esp),%ebx
 804ba23:	8d 04 c0             	lea    (%eax,%eax,8),%eax
 804ba26:	c1 e0 06             	shl    $0x6,%eax
 804ba29:	8d 0c c8             	lea    (%eax,%ecx,8),%ecx
 804ba2c:	8d 81 00 8e 8e 14    	lea    0x148e8e00(%ecx),%eax
 804ba32:	89 99 00 8e 8e 14    	mov    %ebx,0x148e8e00(%ecx)
 804ba38:	8b 4c 24 14          	mov    0x14(%esp),%ecx
 804ba3c:	89 48 04             	mov    %ecx,0x4(%eax)
 804ba3f:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 804ba43:	89 48 08             	mov    %ecx,0x8(%eax)
 804ba46:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
 804ba4a:	89 48 0c             	mov    %ecx,0xc(%eax)
 804ba4d:	8b 4c 24 20          	mov    0x20(%esp),%ecx
 804ba51:	89 48 10             	mov    %ecx,0x10(%eax)
 804ba54:	8b 4c 24 24          	mov    0x24(%esp),%ecx
 804ba58:	89 48 14             	mov    %ecx,0x14(%eax)
 804ba5b:	8b 4c 24 28          	mov    0x28(%esp),%ecx
 804ba5f:	89 48 18             	mov    %ecx,0x18(%eax)
 804ba62:	8b 4c 24 2c          	mov    0x2c(%esp),%ecx
 804ba66:	89 48 1c             	mov    %ecx,0x1c(%eax)
 804ba69:	8b 4c 24 30          	mov    0x30(%esp),%ecx
 804ba6d:	89 48 20             	mov    %ecx,0x20(%eax)
 804ba70:	8b 4c 24 34          	mov    0x34(%esp),%ecx
 804ba74:	89 48 24             	mov    %ecx,0x24(%eax)
 804ba77:	8b 4c 24 38          	mov    0x38(%esp),%ecx
 804ba7b:	89 48 28             	mov    %ecx,0x28(%eax)
 804ba7e:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
 804ba82:	89 48 2c             	mov    %ecx,0x2c(%eax)
 804ba85:	8b 4c 24 40          	mov    0x40(%esp),%ecx
 804ba89:	89 48 30             	mov    %ecx,0x30(%eax)
 804ba8c:	8b 4c 24 44          	mov    0x44(%esp),%ecx
 804ba90:	89 48 34             	mov    %ecx,0x34(%eax)
 804ba93:	8b 4c 24 48          	mov    0x48(%esp),%ecx
 804ba97:	89 48 38             	mov    %ecx,0x38(%eax)
 804ba9a:	8b 4c 24 4c          	mov    0x4c(%esp),%ecx
 804ba9e:	89 48 3c             	mov    %ecx,0x3c(%eax)
		l1cache[set][way].valid = true;
 804baa1:	c6 40 44 01          	movb   $0x1,0x44(%eax)
		l1cache[set][way].tag = tag;
 804baa5:	8b 7c 24 08          	mov    0x8(%esp),%edi
 804baa9:	89 78 40             	mov    %edi,0x40(%eax)
	}	
	else {
		//Log("Hit");
	}
	return way;
}
 804baac:	83 c4 5c             	add    $0x5c,%esp
 804baaf:	89 d0                	mov    %edx,%eax
 804bab1:	5b                   	pop    %ebx
 804bab2:	5e                   	pop    %esi
 804bab3:	5f                   	pop    %edi
 804bab4:	5d                   	pop    %ebp
 804bab5:	c3                   	ret    
 804bab6:	8d 76 00             	lea    0x0(%esi),%esi
 804bab9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804bac0 <init_l1cache>:
l1CB l1cache[CACHE_SET_SIZE][CACHE_WAY_SIZE];

uint32_t l2cache_read(hwaddr_t addr, size_t len);
void l2cache_write(hwaddr_t addr, size_t len, uint32_t data);

void init_l1cache() {
 804bac0:	83 ec 18             	sub    $0x18,%esp
	int i, j;
	srand((unsigned)(time(0)));
 804bac3:	6a 00                	push   $0x0
 804bac5:	e8 f6 ce ff ff       	call   80489c0 <time@plt>
 804baca:	89 04 24             	mov    %eax,(%esp)
 804bacd:	e8 be cf ff ff       	call   8048a90 <srand@plt>
 804bad2:	83 c4 10             	add    $0x10,%esp
 804bad5:	31 d2                	xor    %edx,%edx
 804bad7:	89 f6                	mov    %esi,%esi
 804bad9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
l1CB l1cache[CACHE_SET_SIZE][CACHE_WAY_SIZE];

uint32_t l2cache_read(hwaddr_t addr, size_t len);
void l2cache_write(hwaddr_t addr, size_t len, uint32_t data);

void init_l1cache() {
 804bae0:	31 c0                	xor    %eax,%eax
 804bae2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	int i, j;
	srand((unsigned)(time(0)));
	for(i = 0; i < CACHE_SET_SIZE; i ++) {
		for(j = 0; j < CACHE_WAY_SIZE; j ++) {
			l1cache[i][j].valid = false;
 804bae8:	c6 84 02 44 8e 8e 14 	movb   $0x0,0x148e8e44(%edx,%eax,1)
 804baef:	00 
 804baf0:	83 c0 48             	add    $0x48,%eax

void init_l1cache() {
	int i, j;
	srand((unsigned)(time(0)));
	for(i = 0; i < CACHE_SET_SIZE; i ++) {
		for(j = 0; j < CACHE_WAY_SIZE; j ++) {
 804baf3:	3d 40 02 00 00       	cmp    $0x240,%eax
 804baf8:	75 ee                	jne    804bae8 <init_l1cache+0x28>
 804bafa:	81 c2 40 02 00 00    	add    $0x240,%edx
void l2cache_write(hwaddr_t addr, size_t len, uint32_t data);

void init_l1cache() {
	int i, j;
	srand((unsigned)(time(0)));
	for(i = 0; i < CACHE_SET_SIZE; i ++) {
 804bb00:	81 fa 00 20 01 00    	cmp    $0x12000,%edx
 804bb06:	75 d8                	jne    804bae0 <init_l1cache+0x20>
		for(j = 0; j < CACHE_WAY_SIZE; j ++) {
			l1cache[i][j].valid = false;
		}
	}
}
 804bb08:	83 c4 0c             	add    $0xc,%esp
 804bb0b:	c3                   	ret    
 804bb0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804bb10 <l1cache_read>:
		//Log("Hit");
	}
	return way;
}

uint32_t l1cache_read(hwaddr_t addr, size_t len) {
 804bb10:	55                   	push   %ebp
 804bb11:	57                   	push   %edi
 804bb12:	56                   	push   %esi
 804bb13:	53                   	push   %ebx
 804bb14:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
 804bb1a:	8b b4 24 a4 00 00 00 	mov    0xa4(%esp),%esi
 804bb21:	8b bc 24 a0 00 00 00 	mov    0xa0(%esp),%edi
	assert(len == 1 || len == 2 || len == 4);
 804bb28:	8d 46 ff             	lea    -0x1(%esi),%eax
 804bb2b:	83 f8 01             	cmp    $0x1,%eax
 804bb2e:	76 09                	jbe    804bb39 <l1cache_read+0x29>
 804bb30:	83 fe 04             	cmp    $0x4,%esi
 804bb33:	0f 85 5f 01 00 00    	jne    804bc98 <l1cache_read+0x188>
	l1cache_addr temp;
	temp.addr = addr;

	uint32_t set = temp.set;
 804bb39:	89 fd                	mov    %edi,%ebp
	uint8_t way = check_cache(addr);
 804bb3b:	89 f8                	mov    %edi,%eax
	uint32_t block = temp.block;
 804bb3d:	89 fb                	mov    %edi,%ebx
uint32_t l1cache_read(hwaddr_t addr, size_t len) {
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;

	uint32_t set = temp.set;
 804bb3f:	c1 ed 06             	shr    $0x6,%ebp
	uint8_t way = check_cache(addr);
	uint32_t block = temp.block;
 804bb42:	83 e3 3f             	and    $0x3f,%ebx
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;

	uint32_t set = temp.set;
	uint8_t way = check_cache(addr);
 804bb45:	e8 26 fe ff ff       	call   804b970 <check_cache>
uint32_t l1cache_read(hwaddr_t addr, size_t len) {
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;

	uint32_t set = temp.set;
 804bb4a:	83 e5 7f             	and    $0x7f,%ebp
	uint8_t way = check_cache(addr);
	uint32_t block = temp.block;

	uint8_t buf[CACHE_BLOCK_SIZE << 1];
	memcpy(buf, l1cache[set][way].buf, CACHE_BLOCK_SIZE);
 804bb4d:	0f b6 c0             	movzbl %al,%eax
 804bb50:	8d 14 c0             	lea    (%eax,%eax,8),%edx
 804bb53:	8d 44 ed 00          	lea    0x0(%ebp,%ebp,8),%eax
 804bb57:	c1 e0 06             	shl    $0x6,%eax
 804bb5a:	8d 04 d0             	lea    (%eax,%edx,8),%eax
 804bb5d:	8d 90 00 8e 8e 14    	lea    0x148e8e00(%eax),%edx
 804bb63:	8b 80 00 8e 8e 14    	mov    0x148e8e00(%eax),%eax
 804bb69:	89 04 24             	mov    %eax,(%esp)
 804bb6c:	8b 42 04             	mov    0x4(%edx),%eax
 804bb6f:	89 44 24 04          	mov    %eax,0x4(%esp)
 804bb73:	8b 42 08             	mov    0x8(%edx),%eax
 804bb76:	89 44 24 08          	mov    %eax,0x8(%esp)
 804bb7a:	8b 42 0c             	mov    0xc(%edx),%eax
 804bb7d:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804bb81:	8b 42 10             	mov    0x10(%edx),%eax
 804bb84:	89 44 24 10          	mov    %eax,0x10(%esp)
 804bb88:	8b 42 14             	mov    0x14(%edx),%eax
 804bb8b:	89 44 24 14          	mov    %eax,0x14(%esp)
 804bb8f:	8b 42 18             	mov    0x18(%edx),%eax
 804bb92:	89 44 24 18          	mov    %eax,0x18(%esp)
 804bb96:	8b 42 1c             	mov    0x1c(%edx),%eax
 804bb99:	89 44 24 1c          	mov    %eax,0x1c(%esp)
 804bb9d:	8b 42 20             	mov    0x20(%edx),%eax
 804bba0:	89 44 24 20          	mov    %eax,0x20(%esp)
 804bba4:	8b 42 24             	mov    0x24(%edx),%eax
 804bba7:	89 44 24 24          	mov    %eax,0x24(%esp)
 804bbab:	8b 42 28             	mov    0x28(%edx),%eax
 804bbae:	89 44 24 28          	mov    %eax,0x28(%esp)
 804bbb2:	8b 42 2c             	mov    0x2c(%edx),%eax
 804bbb5:	89 44 24 2c          	mov    %eax,0x2c(%esp)
 804bbb9:	8b 42 30             	mov    0x30(%edx),%eax
 804bbbc:	89 44 24 30          	mov    %eax,0x30(%esp)
 804bbc0:	8b 42 34             	mov    0x34(%edx),%eax
 804bbc3:	89 44 24 34          	mov    %eax,0x34(%esp)
 804bbc7:	8b 42 38             	mov    0x38(%edx),%eax
 804bbca:	89 44 24 38          	mov    %eax,0x38(%esp)
 804bbce:	8b 42 3c             	mov    0x3c(%edx),%eax
 804bbd1:	89 44 24 3c          	mov    %eax,0x3c(%esp)
	if(block + len > CACHE_BLOCK_SIZE) {
 804bbd5:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
 804bbd8:	83 f8 40             	cmp    $0x40,%eax
 804bbdb:	0f 86 98 00 00 00    	jbe    804bc79 <l1cache_read+0x169>
		temp.addr += CACHE_BLOCK_SIZE;
 804bbe1:	8d 47 40             	lea    0x40(%edi),%eax
		set = temp.set;
 804bbe4:	89 c7                	mov    %eax,%edi
 804bbe6:	c1 ef 06             	shr    $0x6,%edi
		way = check_cache(temp.addr);
 804bbe9:	e8 82 fd ff ff       	call   804b970 <check_cache>

	uint8_t buf[CACHE_BLOCK_SIZE << 1];
	memcpy(buf, l1cache[set][way].buf, CACHE_BLOCK_SIZE);
	if(block + len > CACHE_BLOCK_SIZE) {
		temp.addr += CACHE_BLOCK_SIZE;
		set = temp.set;
 804bbee:	83 e7 7f             	and    $0x7f,%edi
		way = check_cache(temp.addr);
		memcpy(buf + CACHE_BLOCK_SIZE, l1cache[set][way].buf, CACHE_BLOCK_SIZE);
 804bbf1:	0f b6 c0             	movzbl %al,%eax
 804bbf4:	8d 14 c0             	lea    (%eax,%eax,8),%edx
 804bbf7:	8d 04 ff             	lea    (%edi,%edi,8),%eax
 804bbfa:	c1 e0 06             	shl    $0x6,%eax
 804bbfd:	8d 14 d0             	lea    (%eax,%edx,8),%edx
 804bc00:	8d 82 00 8e 8e 14    	lea    0x148e8e00(%edx),%eax
 804bc06:	8b 92 00 8e 8e 14    	mov    0x148e8e00(%edx),%edx
 804bc0c:	89 54 24 40          	mov    %edx,0x40(%esp)
 804bc10:	8b 50 04             	mov    0x4(%eax),%edx
 804bc13:	89 54 24 44          	mov    %edx,0x44(%esp)
 804bc17:	8b 50 08             	mov    0x8(%eax),%edx
 804bc1a:	89 54 24 48          	mov    %edx,0x48(%esp)
 804bc1e:	8b 50 0c             	mov    0xc(%eax),%edx
 804bc21:	89 54 24 4c          	mov    %edx,0x4c(%esp)
 804bc25:	8b 50 10             	mov    0x10(%eax),%edx
 804bc28:	89 54 24 50          	mov    %edx,0x50(%esp)
 804bc2c:	8b 50 14             	mov    0x14(%eax),%edx
 804bc2f:	89 54 24 54          	mov    %edx,0x54(%esp)
 804bc33:	8b 50 18             	mov    0x18(%eax),%edx
 804bc36:	89 54 24 58          	mov    %edx,0x58(%esp)
 804bc3a:	8b 50 1c             	mov    0x1c(%eax),%edx
 804bc3d:	89 54 24 5c          	mov    %edx,0x5c(%esp)
 804bc41:	8b 50 20             	mov    0x20(%eax),%edx
 804bc44:	89 54 24 60          	mov    %edx,0x60(%esp)
 804bc48:	8b 50 24             	mov    0x24(%eax),%edx
 804bc4b:	89 54 24 64          	mov    %edx,0x64(%esp)
 804bc4f:	8b 50 28             	mov    0x28(%eax),%edx
 804bc52:	89 54 24 68          	mov    %edx,0x68(%esp)
 804bc56:	8b 50 2c             	mov    0x2c(%eax),%edx
 804bc59:	89 54 24 6c          	mov    %edx,0x6c(%esp)
 804bc5d:	8b 50 30             	mov    0x30(%eax),%edx
 804bc60:	89 54 24 70          	mov    %edx,0x70(%esp)
 804bc64:	8b 50 34             	mov    0x34(%eax),%edx
 804bc67:	89 54 24 74          	mov    %edx,0x74(%esp)
 804bc6b:	8b 50 38             	mov    0x38(%eax),%edx
 804bc6e:	8b 40 3c             	mov    0x3c(%eax),%eax
 804bc71:	89 54 24 78          	mov    %edx,0x78(%esp)
 804bc75:	89 44 24 7c          	mov    %eax,0x7c(%esp)
	}
	return (*(uint32_t *)(buf + block)) & (~0u >> ((4 - len) << 3));
 804bc79:	b9 04 00 00 00       	mov    $0x4,%ecx
 804bc7e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804bc83:	29 f1                	sub    %esi,%ecx
 804bc85:	c1 e1 03             	shl    $0x3,%ecx
 804bc88:	d3 e8                	shr    %cl,%eax
 804bc8a:	23 04 1c             	and    (%esp,%ebx,1),%eax
}
 804bc8d:	81 c4 8c 00 00 00    	add    $0x8c,%esp
 804bc93:	5b                   	pop    %ebx
 804bc94:	5e                   	pop    %esi
 804bc95:	5f                   	pop    %edi
 804bc96:	5d                   	pop    %ebp
 804bc97:	c3                   	ret    
	}
	return way;
}

uint32_t l1cache_read(hwaddr_t addr, size_t len) {
	assert(len == 1 || len == 2 || len == 4);
 804bc98:	68 6e f8 05 08       	push   $0x805f86e
 804bc9d:	6a 53                	push   $0x53
 804bc9f:	68 46 f8 05 08       	push   $0x805f846
 804bca4:	68 40 f7 05 08       	push   $0x805f740
 804bca9:	e8 02 cf ff ff       	call   8048bb0 <__assert_fail@plt>
 804bcae:	66 90                	xchg   %ax,%ax

0804bcb0 <l1cache_write>:
		memcpy(buf + CACHE_BLOCK_SIZE, l1cache[set][way].buf, CACHE_BLOCK_SIZE);
	}
	return (*(uint32_t *)(buf + block)) & (~0u >> ((4 - len) << 3));
}

void l1cache_write(hwaddr_t addr, size_t len, uint32_t data) {
 804bcb0:	55                   	push   %ebp
 804bcb1:	57                   	push   %edi
 804bcb2:	56                   	push   %esi
 804bcb3:	53                   	push   %ebx
 804bcb4:	83 ec 1c             	sub    $0x1c,%esp
 804bcb7:	8b 7c 24 34          	mov    0x34(%esp),%edi
 804bcbb:	8b 6c 24 30          	mov    0x30(%esp),%ebp
 804bcbf:	8b 5c 24 38          	mov    0x38(%esp),%ebx
	assert(len == 1 || len == 2 || len == 4);
 804bcc3:	8d 47 ff             	lea    -0x1(%edi),%eax
 804bcc6:	83 f8 01             	cmp    $0x1,%eax
 804bcc9:	76 09                	jbe    804bcd4 <l1cache_write+0x24>
 804bccb:	83 ff 04             	cmp    $0x4,%edi
 804bcce:	0f 85 05 01 00 00    	jne    804bdd9 <l1cache_write+0x129>
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
	uint32_t block = temp.block;
 804bcd4:	89 e8                	mov    %ebp,%eax

void l1cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804bcd6:	89 ea                	mov    %ebp,%edx
	uint32_t set = temp.set;
	uint32_t block = temp.block;
 804bcd8:	31 f6                	xor    %esi,%esi
 804bcda:	83 e0 3f             	and    $0x3f,%eax

void l1cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804bcdd:	c1 ea 0d             	shr    $0xd,%edx
	uint32_t set = temp.set;
	uint32_t block = temp.block;
 804bce0:	88 44 24 08          	mov    %al,0x8(%esp)
void l1cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
 804bce4:	89 e8                	mov    %ebp,%eax

void l1cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804bce6:	81 e2 ff 3f 00 00    	and    $0x3fff,%edx
	uint32_t set = temp.set;
 804bcec:	c1 e8 06             	shr    $0x6,%eax
 804bcef:	83 e0 7f             	and    $0x7f,%eax
 804bcf2:	8d 0c c0             	lea    (%eax,%eax,8),%ecx
 804bcf5:	c1 e1 06             	shl    $0x6,%ecx
 804bcf8:	8d 81 00 8e 8e 14    	lea    0x148e8e00(%ecx),%eax
 804bcfe:	66 90                	xchg   %ax,%ax
	uint32_t block = temp.block;
	uint8_t way = 0;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
	if(l1cache[set][way].valid && (l1cache[set][way].tag == tag)) {
 804bd00:	80 78 44 00          	cmpb   $0x0,0x44(%eax)
 804bd04:	74 05                	je     804bd0b <l1cache_write+0x5b>
 804bd06:	39 50 40             	cmp    %edx,0x40(%eax)
 804bd09:	74 23                	je     804bd2e <l1cache_write+0x7e>
 804bd0b:	83 c6 01             	add    $0x1,%esi
 804bd0e:	83 c0 48             	add    $0x48,%eax
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
	uint32_t block = temp.block;
	uint8_t way = 0;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
 804bd11:	83 fe 08             	cmp    $0x8,%esi
 804bd14:	75 ea                	jne    804bd00 <l1cache_write+0x50>
	if(l1cache[set][way].valid && (l1cache[set][way].tag == tag)) {
		success = true;
		break;
	}
	l2cache_write(addr, len, data);
 804bd16:	89 5c 24 38          	mov    %ebx,0x38(%esp)
 804bd1a:	89 7c 24 34          	mov    %edi,0x34(%esp)
 804bd1e:	89 6c 24 30          	mov    %ebp,0x30(%esp)
				l1cache[set][way].buf[j] = (uint8_t)((data >> (i << 3)) & 0xff);
			}
		}
	}
	return;
}
 804bd22:	83 c4 1c             	add    $0x1c,%esp
 804bd25:	5b                   	pop    %ebx
 804bd26:	5e                   	pop    %esi
 804bd27:	5f                   	pop    %edi
 804bd28:	5d                   	pop    %ebp
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
	if(l1cache[set][way].valid && (l1cache[set][way].tag == tag)) {
		success = true;
		break;
	}
	l2cache_write(addr, len, data);
 804bd29:	e9 92 f6 ff ff       	jmp    804b3c0 <l2cache_write>
 804bd2e:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
 804bd32:	83 ec 04             	sub    $0x4,%esp
 804bd35:	53                   	push   %ebx
 804bd36:	57                   	push   %edi
 804bd37:	55                   	push   %ebp
 804bd38:	e8 83 f6 ff ff       	call   804b3c0 <l2cache_write>
	if(success){
		int i;
		for(i = 0; i < len; i ++) {
 804bd3d:	83 c4 10             	add    $0x10,%esp
 804bd40:	85 ff                	test   %edi,%edi
 804bd42:	0f 84 89 00 00 00    	je     804bdd1 <l1cache_write+0x121>
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
	uint32_t block = temp.block;
 804bd48:	0f b6 44 24 08       	movzbl 0x8(%esp),%eax
 804bd4d:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
 804bd51:	8d 14 f6             	lea    (%esi,%esi,8),%edx
 804bd54:	89 6c 24 08          	mov    %ebp,0x8(%esp)
 804bd58:	31 f6                	xor    %esi,%esi
 804bd5a:	01 c1                	add    %eax,%ecx
 804bd5c:	8d 14 d1             	lea    (%ecx,%edx,8),%edx
 804bd5f:	90                   	nop
	}
	l2cache_write(addr, len, data);
	if(success){
		int i;
		for(i = 0; i < len; i ++) {
			if(block + i < CACHE_BLOCK_SIZE)l1cache[set][way].buf[block + i] = (uint8_t)((data >> (i << 3)) & 0xff);
 804bd60:	8d 0c f5 00 00 00 00 	lea    0x0(,%esi,8),%ecx
 804bd67:	89 dd                	mov    %ebx,%ebp
 804bd69:	d3 ed                	shr    %cl,%ebp
 804bd6b:	89 e9                	mov    %ebp,%ecx
 804bd6d:	88 8c 32 00 8e 8e 14 	mov    %cl,0x148e8e00(%edx,%esi,1)
		break;
	}
	l2cache_write(addr, len, data);
	if(success){
		int i;
		for(i = 0; i < len; i ++) {
 804bd74:	83 c6 01             	add    $0x1,%esi
 804bd77:	39 fe                	cmp    %edi,%esi
 804bd79:	74 56                	je     804bdd1 <l1cache_write+0x121>
 804bd7b:	8d 0c 30             	lea    (%eax,%esi,1),%ecx
			if(block + i < CACHE_BLOCK_SIZE)l1cache[set][way].buf[block + i] = (uint8_t)((data >> (i << 3)) & 0xff);
 804bd7e:	83 f9 3f             	cmp    $0x3f,%ecx
 804bd81:	76 dd                	jbe    804bd60 <l1cache_write+0xb0>
 804bd83:	8b 6c 24 08          	mov    0x8(%esp),%ebp
			else break;
		}
		if(i != len) {
			temp.addr += CACHE_BLOCK_SIZE;
 804bd87:	83 c5 40             	add    $0x40,%ebp
			way = check_cache(temp.addr);
 804bd8a:	89 e8                	mov    %ebp,%eax
			set = temp.set;
 804bd8c:	c1 ed 06             	shr    $0x6,%ebp
			if(block + i < CACHE_BLOCK_SIZE)l1cache[set][way].buf[block + i] = (uint8_t)((data >> (i << 3)) & 0xff);
			else break;
		}
		if(i != len) {
			temp.addr += CACHE_BLOCK_SIZE;
			way = check_cache(temp.addr);
 804bd8f:	e8 dc fb ff ff       	call   804b970 <check_cache>
			set = temp.set;
 804bd94:	83 e5 7f             	and    $0x7f,%ebp
			tag = temp.tag;
			int j;
			for(j = 0; j < len - i; j ++) {
 804bd97:	29 f7                	sub    %esi,%edi
 804bd99:	74 36                	je     804bdd1 <l1cache_write+0x121>
 804bd9b:	8d 0c f5 00 00 00 00 	lea    0x0(,%esi,8),%ecx
 804bda2:	0f b6 c0             	movzbl %al,%eax
 804bda5:	8d 14 c0             	lea    (%eax,%eax,8),%edx
 804bda8:	d3 eb                	shr    %cl,%ebx
 804bdaa:	8d 4c ed 00          	lea    0x0(%ebp,%ebp,8),%ecx
 804bdae:	c1 e2 03             	shl    $0x3,%edx
 804bdb1:	c1 e1 06             	shl    $0x6,%ecx
 804bdb4:	01 cf                	add    %ecx,%edi
 804bdb6:	8d 84 0a 00 8e 8e 14 	lea    0x148e8e00(%edx,%ecx,1),%eax
 804bdbd:	8d 94 3a 00 8e 8e 14 	lea    0x148e8e00(%edx,%edi,1),%edx
 804bdc4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				l1cache[set][way].buf[j] = (uint8_t)((data >> (i << 3)) & 0xff);
 804bdc8:	88 18                	mov    %bl,(%eax)
 804bdca:	83 c0 01             	add    $0x1,%eax
			temp.addr += CACHE_BLOCK_SIZE;
			way = check_cache(temp.addr);
			set = temp.set;
			tag = temp.tag;
			int j;
			for(j = 0; j < len - i; j ++) {
 804bdcd:	39 d0                	cmp    %edx,%eax
 804bdcf:	75 f7                	jne    804bdc8 <l1cache_write+0x118>
				l1cache[set][way].buf[j] = (uint8_t)((data >> (i << 3)) & 0xff);
			}
		}
	}
	return;
}
 804bdd1:	83 c4 1c             	add    $0x1c,%esp
 804bdd4:	5b                   	pop    %ebx
 804bdd5:	5e                   	pop    %esi
 804bdd6:	5f                   	pop    %edi
 804bdd7:	5d                   	pop    %ebp
 804bdd8:	c3                   	ret    
	}
	return (*(uint32_t *)(buf + block)) & (~0u >> ((4 - len) << 3));
}

void l1cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
 804bdd9:	68 60 f8 05 08       	push   $0x805f860
 804bdde:	6a 67                	push   $0x67
 804bde0:	68 46 f8 05 08       	push   $0x805f846
 804bde5:	68 40 f7 05 08       	push   $0x805f740
 804bdea:	e8 c1 cd ff ff       	call   8048bb0 <__assert_fail@plt>
 804bdef:	90                   	nop

0804bdf0 <movs_w>:
#include "cpu/exec/template-start.h"

#define instr movs

make_helper(concat(movs_, SUFFIX)) {
 804bdf0:	83 ec 14             	sub    $0x14,%esp
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
 804bdf3:	6a 02                	push   $0x2
 804bdf5:	ff 35 d8 ae 8f 14    	pushl  0x148faed8
 804bdfb:	e8 60 f1 ff ff       	call   804af60 <swaddr_read>
 804be00:	83 c4 0c             	add    $0xc,%esp
 804be03:	0f b7 c0             	movzwl %ax,%eax
 804be06:	50                   	push   %eax
 804be07:	6a 02                	push   $0x2
 804be09:	ff 35 dc ae 8f 14    	pushl  0x148faedc
 804be0f:	e8 9c f1 ff ff       	call   804afb0 <swaddr_write>
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804be14:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
 804be1b:	ba 01 00 00 00       	mov    $0x1,%edx
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804be20:	68 18 ae 8f 14       	push   $0x148fae18
 804be25:	68 7b f8 05 08       	push   $0x805f87b
 804be2a:	6a 50                	push   $0x50
 804be2c:	68 00 89 0c 08       	push   $0x80c8900

#define instr movs

make_helper(concat(movs_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804be31:	c0 e8 02             	shr    $0x2,%al
 804be34:	83 e0 01             	and    $0x1,%eax
 804be37:	01 c0                	add    %eax,%eax
 804be39:	29 c2                	sub    %eax,%edx
 804be3b:	89 d0                	mov    %edx,%eax
 804be3d:	01 c0                	add    %eax,%eax
 804be3f:	01 05 dc ae 8f 14    	add    %eax,0x148faedc
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804be45:	01 05 d8 ae 8f 14    	add    %eax,0x148faed8
	print_asm_template1();
 804be4b:	e8 b0 cc ff ff       	call   8048b00 <snprintf@plt>
 804be50:	83 c4 20             	add    $0x20,%esp
 804be53:	83 f8 4f             	cmp    $0x4f,%eax
 804be56:	7f 10                	jg     804be68 <movs_w+0x78>
	return 1;
}
 804be58:	b8 01 00 00 00       	mov    $0x1,%eax
 804be5d:	83 c4 0c             	add    $0xc,%esp
 804be60:	c3                   	ret    
 804be61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

make_helper(concat(movs_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804be68:	83 ec 0c             	sub    $0xc,%esp
 804be6b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804be71:	e8 ea ca ff ff       	call   8048960 <fflush@plt>
 804be76:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804be7c:	6a 07                	push   $0x7
 804be7e:	6a 01                	push   $0x1
 804be80:	68 92 ed 05 08       	push   $0x805ed92
 804be85:	e8 86 cb ff ff       	call   8048a10 <fwrite@plt>
 804be8a:	83 c4 20             	add    $0x20,%esp
 804be8d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804be93:	6a 10                	push   $0x10
 804be95:	6a 01                	push   $0x1
 804be97:	68 84 f8 05 08       	push   $0x805f884
 804be9c:	e8 6f cb ff ff       	call   8048a10 <fwrite@plt>
 804bea1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804bea7:	6a 05                	push   $0x5
 804bea9:	6a 01                	push   $0x1
 804beab:	68 b1 ed 05 08       	push   $0x805edb1
 804beb0:	e8 5b cb ff ff       	call   8048a10 <fwrite@plt>
 804beb5:	83 c4 20             	add    $0x20,%esp
 804beb8:	68 18 ae 8f 14       	push   $0x148fae18
 804bebd:	68 7b f8 05 08       	push   $0x805f87b
 804bec2:	6a 50                	push   $0x50
 804bec4:	68 00 89 0c 08       	push   $0x80c8900
 804bec9:	e8 32 cc ff ff       	call   8048b00 <snprintf@plt>
 804bece:	83 c4 10             	add    $0x10,%esp
 804bed1:	83 f8 4f             	cmp    $0x4f,%eax
 804bed4:	7e 82                	jle    804be58 <movs_w+0x68>
 804bed6:	68 ae f9 05 08       	push   $0x805f9ae
 804bedb:	6a 09                	push   $0x9
 804bedd:	68 a8 f8 05 08       	push   $0x805f8a8
 804bee2:	68 d0 f8 05 08       	push   $0x805f8d0
 804bee7:	e8 c4 cc ff ff       	call   8048bb0 <__assert_fail@plt>
 804beec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804bef0 <movs_l>:
#include "cpu/exec/template-start.h"

#define instr movs

make_helper(concat(movs_, SUFFIX)) {
 804bef0:	83 ec 14             	sub    $0x14,%esp
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
 804bef3:	6a 04                	push   $0x4
 804bef5:	ff 35 d8 ae 8f 14    	pushl  0x148faed8
 804befb:	e8 60 f0 ff ff       	call   804af60 <swaddr_read>
 804bf00:	83 c4 0c             	add    $0xc,%esp
 804bf03:	50                   	push   %eax
 804bf04:	6a 04                	push   $0x4
 804bf06:	ff 35 dc ae 8f 14    	pushl  0x148faedc
 804bf0c:	e8 9f f0 ff ff       	call   804afb0 <swaddr_write>
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804bf11:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
 804bf18:	8b 0d dc ae 8f 14    	mov    0x148faedc,%ecx
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804bf1e:	68 18 ae 8f 14       	push   $0x148fae18
 804bf23:	68 95 f8 05 08       	push   $0x805f895
 804bf28:	6a 50                	push   $0x50
 804bf2a:	68 00 89 0c 08       	push   $0x80c8900
 804bf2f:	8d 51 04             	lea    0x4(%ecx),%edx
 804bf32:	8b 0d d8 ae 8f 14    	mov    0x148faed8,%ecx

#define instr movs

make_helper(concat(movs_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804bf38:	c0 e8 02             	shr    $0x2,%al
 804bf3b:	83 e0 01             	and    $0x1,%eax
 804bf3e:	c1 e0 03             	shl    $0x3,%eax
 804bf41:	29 c2                	sub    %eax,%edx
 804bf43:	89 15 dc ae 8f 14    	mov    %edx,0x148faedc
 804bf49:	8d 51 04             	lea    0x4(%ecx),%edx
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804bf4c:	29 c2                	sub    %eax,%edx
 804bf4e:	89 15 d8 ae 8f 14    	mov    %edx,0x148faed8
	print_asm_template1();
 804bf54:	e8 a7 cb ff ff       	call   8048b00 <snprintf@plt>
 804bf59:	83 c4 20             	add    $0x20,%esp
 804bf5c:	83 f8 4f             	cmp    $0x4f,%eax
 804bf5f:	7f 0f                	jg     804bf70 <movs_l+0x80>
	return 1;
}
 804bf61:	b8 01 00 00 00       	mov    $0x1,%eax
 804bf66:	83 c4 0c             	add    $0xc,%esp
 804bf69:	c3                   	ret    
 804bf6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

make_helper(concat(movs_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804bf70:	83 ec 0c             	sub    $0xc,%esp
 804bf73:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804bf79:	e8 e2 c9 ff ff       	call   8048960 <fflush@plt>
 804bf7e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804bf84:	6a 07                	push   $0x7
 804bf86:	6a 01                	push   $0x1
 804bf88:	68 92 ed 05 08       	push   $0x805ed92
 804bf8d:	e8 7e ca ff ff       	call   8048a10 <fwrite@plt>
 804bf92:	83 c4 20             	add    $0x20,%esp
 804bf95:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804bf9b:	6a 10                	push   $0x10
 804bf9d:	6a 01                	push   $0x1
 804bf9f:	68 84 f8 05 08       	push   $0x805f884
 804bfa4:	e8 67 ca ff ff       	call   8048a10 <fwrite@plt>
 804bfa9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804bfaf:	6a 05                	push   $0x5
 804bfb1:	6a 01                	push   $0x1
 804bfb3:	68 b1 ed 05 08       	push   $0x805edb1
 804bfb8:	e8 53 ca ff ff       	call   8048a10 <fwrite@plt>
 804bfbd:	83 c4 20             	add    $0x20,%esp
 804bfc0:	68 18 ae 8f 14       	push   $0x148fae18
 804bfc5:	68 95 f8 05 08       	push   $0x805f895
 804bfca:	6a 50                	push   $0x50
 804bfcc:	68 00 89 0c 08       	push   $0x80c8900
 804bfd1:	e8 2a cb ff ff       	call   8048b00 <snprintf@plt>
 804bfd6:	83 c4 10             	add    $0x10,%esp
 804bfd9:	83 f8 4f             	cmp    $0x4f,%eax
 804bfdc:	7e 83                	jle    804bf61 <movs_l+0x71>
 804bfde:	68 a7 f9 05 08       	push   $0x805f9a7
 804bfe3:	6a 09                	push   $0x9
 804bfe5:	68 a8 f8 05 08       	push   $0x805f8a8
 804bfea:	68 18 f9 05 08       	push   $0x805f918
 804bfef:	e8 bc cb ff ff       	call   8048bb0 <__assert_fail@plt>
 804bff4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804bffa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804c000 <movs_b>:
#include "cpu/exec/template-start.h"

#define instr movs

make_helper(concat(movs_, SUFFIX)) {
 804c000:	83 ec 14             	sub    $0x14,%esp
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
 804c003:	6a 01                	push   $0x1
 804c005:	ff 35 d8 ae 8f 14    	pushl  0x148faed8
 804c00b:	e8 50 ef ff ff       	call   804af60 <swaddr_read>
 804c010:	83 c4 0c             	add    $0xc,%esp
 804c013:	0f b6 c0             	movzbl %al,%eax
 804c016:	50                   	push   %eax
 804c017:	6a 01                	push   $0x1
 804c019:	ff 35 dc ae 8f 14    	pushl  0x148faedc
 804c01f:	e8 8c ef ff ff       	call   804afb0 <swaddr_write>
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c024:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
 804c02b:	8b 0d dc ae 8f 14    	mov    0x148faedc,%ecx
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804c031:	68 18 ae 8f 14       	push   $0x148fae18
 804c036:	68 9e f8 05 08       	push   $0x805f89e
 804c03b:	6a 50                	push   $0x50
 804c03d:	68 00 89 0c 08       	push   $0x80c8900
 804c042:	8d 51 01             	lea    0x1(%ecx),%edx
 804c045:	8b 0d d8 ae 8f 14    	mov    0x148faed8,%ecx

#define instr movs

make_helper(concat(movs_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c04b:	c0 e8 02             	shr    $0x2,%al
 804c04e:	83 e0 01             	and    $0x1,%eax
 804c051:	01 c0                	add    %eax,%eax
 804c053:	29 c2                	sub    %eax,%edx
 804c055:	89 15 dc ae 8f 14    	mov    %edx,0x148faedc
 804c05b:	8d 51 01             	lea    0x1(%ecx),%edx
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c05e:	29 c2                	sub    %eax,%edx
 804c060:	89 15 d8 ae 8f 14    	mov    %edx,0x148faed8
	print_asm_template1();
 804c066:	e8 95 ca ff ff       	call   8048b00 <snprintf@plt>
 804c06b:	83 c4 20             	add    $0x20,%esp
 804c06e:	83 f8 4f             	cmp    $0x4f,%eax
 804c071:	7f 0d                	jg     804c080 <movs_b+0x80>
	return 1;
}
 804c073:	b8 01 00 00 00       	mov    $0x1,%eax
 804c078:	83 c4 0c             	add    $0xc,%esp
 804c07b:	c3                   	ret    
 804c07c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

make_helper(concat(movs_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804c080:	83 ec 0c             	sub    $0xc,%esp
 804c083:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804c089:	e8 d2 c8 ff ff       	call   8048960 <fflush@plt>
 804c08e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c094:	6a 07                	push   $0x7
 804c096:	6a 01                	push   $0x1
 804c098:	68 92 ed 05 08       	push   $0x805ed92
 804c09d:	e8 6e c9 ff ff       	call   8048a10 <fwrite@plt>
 804c0a2:	83 c4 20             	add    $0x20,%esp
 804c0a5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c0ab:	6a 10                	push   $0x10
 804c0ad:	6a 01                	push   $0x1
 804c0af:	68 84 f8 05 08       	push   $0x805f884
 804c0b4:	e8 57 c9 ff ff       	call   8048a10 <fwrite@plt>
 804c0b9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c0bf:	6a 05                	push   $0x5
 804c0c1:	6a 01                	push   $0x1
 804c0c3:	68 b1 ed 05 08       	push   $0x805edb1
 804c0c8:	e8 43 c9 ff ff       	call   8048a10 <fwrite@plt>
 804c0cd:	83 c4 20             	add    $0x20,%esp
 804c0d0:	68 18 ae 8f 14       	push   $0x148fae18
 804c0d5:	68 9e f8 05 08       	push   $0x805f89e
 804c0da:	6a 50                	push   $0x50
 804c0dc:	68 00 89 0c 08       	push   $0x80c8900
 804c0e1:	e8 1a ca ff ff       	call   8048b00 <snprintf@plt>
 804c0e6:	83 c4 10             	add    $0x10,%esp
 804c0e9:	83 f8 4f             	cmp    $0x4f,%eax
 804c0ec:	7e 85                	jle    804c073 <movs_b+0x73>
 804c0ee:	68 b5 f9 05 08       	push   $0x805f9b5
 804c0f3:	6a 09                	push   $0x9
 804c0f5:	68 a8 f8 05 08       	push   $0x805f8a8
 804c0fa:	68 60 f9 05 08       	push   $0x805f960
 804c0ff:	e8 ac ca ff ff       	call   8048bb0 <__assert_fail@plt>
 804c104:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804c10a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804c110 <movs_v>:

#define DATA_BYTE 4
#include "movs-template.h"
#undef DATA_BYTE

make_helper_v(movs)
 804c110:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804c117:	8b 54 24 04          	mov    0x4(%esp),%edx
 804c11b:	b8 f0 bd 04 08       	mov    $0x804bdf0,%eax
 804c120:	75 05                	jne    804c127 <movs_v+0x17>
 804c122:	b8 f0 be 04 08       	mov    $0x804bef0,%eax
 804c127:	89 54 24 04          	mov    %edx,0x4(%esp)
 804c12b:	ff e0                	jmp    *%eax
 804c12d:	66 90                	xchg   %ax,%ax
 804c12f:	90                   	nop

0804c130 <do_call_w>:
#include "cpu/exec/template-start.h"

#define instr call

static void do_execute() {
 804c130:	83 ec 10             	sub    $0x10,%esp
	if(instr_fetch(cpu.eip, 1) == 0xff)
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
#elif DATA_BYTE == 2
	reg_w(R_SP)= reg_w(R_SP)- DATA_BYTE;
 804c133:	0f b7 05 d0 ae 8f 14 	movzwl 0x148faed0,%eax
	swaddr_write(reg_w(R_SP), DATA_BYTE, cpu.ip + 3);
 804c13a:	0f b7 15 e0 ae 8f 14 	movzwl 0x148faee0,%edx
	if(instr_fetch(cpu.eip, 1) == 0xff)
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
#elif DATA_BYTE == 2
	reg_w(R_SP)= reg_w(R_SP)- DATA_BYTE;
 804c141:	83 e8 02             	sub    $0x2,%eax
	swaddr_write(reg_w(R_SP), DATA_BYTE, cpu.ip + 3);
 804c144:	83 c2 03             	add    $0x3,%edx
	if(instr_fetch(cpu.eip, 1) == 0xff)
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
#elif DATA_BYTE == 2
	reg_w(R_SP)= reg_w(R_SP)- DATA_BYTE;
 804c147:	66 a3 d0 ae 8f 14    	mov    %ax,0x148faed0
	swaddr_write(reg_w(R_SP), DATA_BYTE, cpu.ip + 3);
 804c14d:	0f b7 c0             	movzwl %ax,%eax
 804c150:	52                   	push   %edx
 804c151:	6a 02                	push   $0x2
 804c153:	50                   	push   %eax
 804c154:	e8 57 ee ff ff       	call   804afb0 <swaddr_write>
 804c159:	58                   	pop    %eax
 804c15a:	5a                   	pop    %edx
 804c15b:	6a 01                	push   $0x1
 804c15d:	ff 35 e0 ae 8f 14    	pushl  0x148faee0
 804c163:	e8 f8 ed ff ff       	call   804af60 <swaddr_read>
	if(instr_fetch(cpu.eip, 1) == 0xff)
 804c168:	83 c4 10             	add    $0x10,%esp
 804c16b:	3d ff 00 00 00       	cmp    $0xff,%eax
 804c170:	0f 84 c2 00 00 00    	je     804c238 <do_call_w+0x108>
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
 804c176:	a1 e0 ae 8f 14       	mov    0x148faee0,%eax
 804c17b:	03 05 14 ae 8f 14    	add    0x148fae14,%eax
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804c181:	68 18 ae 8f 14       	push   $0x148fae18
 804c186:	68 bc f9 05 08       	push   $0x805f9bc
	swaddr_write(reg_w(R_SP), DATA_BYTE, cpu.ip + 3);
	if(instr_fetch(cpu.eip, 1) == 0xff)
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
	cpu.eip = cpu.eip & 0xffff;
 804c18b:	25 ff ff 00 00       	and    $0xffff,%eax
#endif
	print_asm_template1();
 804c190:	6a 50                	push   $0x50
 804c192:	68 00 89 0c 08       	push   $0x80c8900
	swaddr_write(reg_w(R_SP), DATA_BYTE, cpu.ip + 3);
	if(instr_fetch(cpu.eip, 1) == 0xff)
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
	cpu.eip = cpu.eip & 0xffff;
 804c197:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
#endif
	print_asm_template1();
 804c19c:	e8 5f c9 ff ff       	call   8048b00 <snprintf@plt>
 804c1a1:	83 c4 10             	add    $0x10,%esp
 804c1a4:	83 f8 4f             	cmp    $0x4f,%eax
 804c1a7:	7f 07                	jg     804c1b0 <do_call_w+0x80>
}
 804c1a9:	83 c4 0c             	add    $0xc,%esp
 804c1ac:	c3                   	ret    
 804c1ad:	8d 76 00             	lea    0x0(%esi),%esi
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804c1b0:	83 ec 0c             	sub    $0xc,%esp
 804c1b3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804c1b9:	e8 a2 c7 ff ff       	call   8048960 <fflush@plt>
 804c1be:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c1c4:	6a 07                	push   $0x7
 804c1c6:	6a 01                	push   $0x1
 804c1c8:	68 92 ed 05 08       	push   $0x805ed92
 804c1cd:	e8 3e c8 ff ff       	call   8048a10 <fwrite@plt>
 804c1d2:	83 c4 20             	add    $0x20,%esp
 804c1d5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c1db:	6a 10                	push   $0x10
 804c1dd:	6a 01                	push   $0x1
 804c1df:	68 84 f8 05 08       	push   $0x805f884
 804c1e4:	e8 27 c8 ff ff       	call   8048a10 <fwrite@plt>
 804c1e9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c1ef:	6a 05                	push   $0x5
 804c1f1:	6a 01                	push   $0x1
 804c1f3:	68 b1 ed 05 08       	push   $0x805edb1
 804c1f8:	e8 13 c8 ff ff       	call   8048a10 <fwrite@plt>
 804c1fd:	83 c4 20             	add    $0x20,%esp
 804c200:	68 18 ae 8f 14       	push   $0x148fae18
 804c205:	68 bc f9 05 08       	push   $0x805f9bc
 804c20a:	6a 50                	push   $0x50
 804c20c:	68 00 89 0c 08       	push   $0x80c8900
 804c211:	e8 ea c8 ff ff       	call   8048b00 <snprintf@plt>
 804c216:	83 c4 10             	add    $0x10,%esp
 804c219:	83 f8 4f             	cmp    $0x4f,%eax
 804c21c:	7e 8b                	jle    804c1a9 <do_call_w+0x79>
 804c21e:	68 91 fa 05 08       	push   $0x805fa91
 804c223:	6a 16                	push   $0x16
 804c225:	68 d0 f9 05 08       	push   $0x805f9d0
 804c22a:	68 f8 f9 05 08       	push   $0x805f9f8
 804c22f:	e8 7c c9 ff ff       	call   8048bb0 <__assert_fail@plt>
 804c234:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + op_src->val;
#elif DATA_BYTE == 2
	reg_w(R_SP)= reg_w(R_SP)- DATA_BYTE;
	swaddr_write(reg_w(R_SP), DATA_BYTE, cpu.ip + 3);
	if(instr_fetch(cpu.eip, 1) == 0xff)
		cpu.eip = op_src->val - 2;
 804c238:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
 804c23d:	83 e8 02             	sub    $0x2,%eax
 804c240:	e9 3c ff ff ff       	jmp    804c181 <do_call_w+0x51>
 804c245:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804c249:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804c250 <call_i_w>:
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
}

make_instr_helper(i)
 804c250:	53                   	push   %ebx
 804c251:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804c254:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804c258:	83 c0 01             	add    $0x1,%eax
 804c25b:	50                   	push   %eax
 804c25c:	e8 4f 0a 01 00       	call   805ccb0 <decode_i_w>
 804c261:	89 c3                	mov    %eax,%ebx
	execute();
 804c263:	e8 c8 fe ff ff       	call   804c130 <do_call_w>
 804c268:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804c26b:	8d 43 01             	lea    0x1(%ebx),%eax
 804c26e:	5b                   	pop    %ebx
 804c26f:	c3                   	ret    

0804c270 <call_rm_w>:
make_instr_helper(rm)
 804c270:	53                   	push   %ebx
 804c271:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804c274:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804c278:	83 c0 01             	add    $0x1,%eax
 804c27b:	50                   	push   %eax
 804c27c:	e8 df 0b 01 00       	call   805ce60 <decode_rm_w>
 804c281:	89 c3                	mov    %eax,%ebx
	execute();
 804c283:	e8 a8 fe ff ff       	call   804c130 <do_call_w>
 804c288:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804c28b:	8d 43 01             	lea    0x1(%ebx),%eax
 804c28e:	5b                   	pop    %ebx
 804c28f:	c3                   	ret    

0804c290 <do_call_l>:
#include "cpu/exec/template-start.h"

#define instr call

static void do_execute() {
 804c290:	83 ec 10             	sub    $0x10,%esp
#if DATA_BYTE == 4
	reg_l(R_ESP) = reg_l(R_ESP) - DATA_BYTE;
	swaddr_write(reg_l(R_ESP), DATA_BYTE, cpu.eip + 5);
 804c293:	8b 0d e0 ae 8f 14    	mov    0x148faee0,%ecx

#define instr call

static void do_execute() {
#if DATA_BYTE == 4
	reg_l(R_ESP) = reg_l(R_ESP) - DATA_BYTE;
 804c299:	a1 d0 ae 8f 14       	mov    0x148faed0,%eax
	swaddr_write(reg_l(R_ESP), DATA_BYTE, cpu.eip + 5);
 804c29e:	8d 51 05             	lea    0x5(%ecx),%edx

#define instr call

static void do_execute() {
#if DATA_BYTE == 4
	reg_l(R_ESP) = reg_l(R_ESP) - DATA_BYTE;
 804c2a1:	83 e8 04             	sub    $0x4,%eax
 804c2a4:	a3 d0 ae 8f 14       	mov    %eax,0x148faed0
	swaddr_write(reg_l(R_ESP), DATA_BYTE, cpu.eip + 5);
 804c2a9:	52                   	push   %edx
 804c2aa:	6a 04                	push   $0x4
 804c2ac:	50                   	push   %eax
 804c2ad:	e8 fe ec ff ff       	call   804afb0 <swaddr_write>

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 804c2b2:	58                   	pop    %eax
 804c2b3:	5a                   	pop    %edx
 804c2b4:	6a 01                	push   $0x1
 804c2b6:	ff 35 e0 ae 8f 14    	pushl  0x148faee0
 804c2bc:	e8 9f ec ff ff       	call   804af60 <swaddr_read>
	if(instr_fetch(cpu.eip, 1) == 0xff)
 804c2c1:	83 c4 10             	add    $0x10,%esp
 804c2c4:	3d ff 00 00 00       	cmp    $0xff,%eax
		cpu.eip = op_src->val - 2;
 804c2c9:	a1 14 ae 8f 14       	mov    0x148fae14,%eax

static void do_execute() {
#if DATA_BYTE == 4
	reg_l(R_ESP) = reg_l(R_ESP) - DATA_BYTE;
	swaddr_write(reg_l(R_ESP), DATA_BYTE, cpu.eip + 5);
	if(instr_fetch(cpu.eip, 1) == 0xff)
 804c2ce:	0f 84 b4 00 00 00    	je     804c388 <do_call_l+0xf8>
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
 804c2d4:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804c2da:	68 18 ae 8f 14       	push   $0x148fae18
 804c2df:	68 c5 f9 05 08       	push   $0x805f9c5
 804c2e4:	6a 50                	push   $0x50
 804c2e6:	68 00 89 0c 08       	push   $0x80c8900
 804c2eb:	e8 10 c8 ff ff       	call   8048b00 <snprintf@plt>
 804c2f0:	83 c4 10             	add    $0x10,%esp
 804c2f3:	83 f8 4f             	cmp    $0x4f,%eax
 804c2f6:	7f 08                	jg     804c300 <do_call_l+0x70>
}
 804c2f8:	83 c4 0c             	add    $0xc,%esp
 804c2fb:	c3                   	ret    
 804c2fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804c300:	83 ec 0c             	sub    $0xc,%esp
 804c303:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804c309:	e8 52 c6 ff ff       	call   8048960 <fflush@plt>
 804c30e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c314:	6a 07                	push   $0x7
 804c316:	6a 01                	push   $0x1
 804c318:	68 92 ed 05 08       	push   $0x805ed92
 804c31d:	e8 ee c6 ff ff       	call   8048a10 <fwrite@plt>
 804c322:	83 c4 20             	add    $0x20,%esp
 804c325:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c32b:	6a 10                	push   $0x10
 804c32d:	6a 01                	push   $0x1
 804c32f:	68 84 f8 05 08       	push   $0x805f884
 804c334:	e8 d7 c6 ff ff       	call   8048a10 <fwrite@plt>
 804c339:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c33f:	6a 05                	push   $0x5
 804c341:	6a 01                	push   $0x1
 804c343:	68 b1 ed 05 08       	push   $0x805edb1
 804c348:	e8 c3 c6 ff ff       	call   8048a10 <fwrite@plt>
 804c34d:	83 c4 20             	add    $0x20,%esp
 804c350:	68 18 ae 8f 14       	push   $0x148fae18
 804c355:	68 c5 f9 05 08       	push   $0x805f9c5
 804c35a:	6a 50                	push   $0x50
 804c35c:	68 00 89 0c 08       	push   $0x80c8900
 804c361:	e8 9a c7 ff ff       	call   8048b00 <snprintf@plt>
 804c366:	83 c4 10             	add    $0x10,%esp
 804c369:	83 f8 4f             	cmp    $0x4f,%eax
 804c36c:	7e 8a                	jle    804c2f8 <do_call_l+0x68>
 804c36e:	68 87 fa 05 08       	push   $0x805fa87
 804c373:	6a 16                	push   $0x16
 804c375:	68 d0 f9 05 08       	push   $0x805f9d0
 804c37a:	68 40 fa 05 08       	push   $0x805fa40
 804c37f:	e8 2c c8 ff ff       	call   8048bb0 <__assert_fail@plt>
 804c384:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static void do_execute() {
#if DATA_BYTE == 4
	reg_l(R_ESP) = reg_l(R_ESP) - DATA_BYTE;
	swaddr_write(reg_l(R_ESP), DATA_BYTE, cpu.eip + 5);
	if(instr_fetch(cpu.eip, 1) == 0xff)
		cpu.eip = op_src->val - 2;
 804c388:	83 e8 02             	sub    $0x2,%eax
 804c38b:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
 804c390:	e9 45 ff ff ff       	jmp    804c2da <do_call_l+0x4a>
 804c395:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804c399:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804c3a0 <call_i_l>:
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
}

make_instr_helper(i)
 804c3a0:	53                   	push   %ebx
 804c3a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804c3a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804c3a8:	83 c0 01             	add    $0x1,%eax
 804c3ab:	50                   	push   %eax
 804c3ac:	e8 8f 0c 01 00       	call   805d040 <decode_i_l>
 804c3b1:	89 c3                	mov    %eax,%ebx
	execute();
 804c3b3:	e8 d8 fe ff ff       	call   804c290 <do_call_l>
 804c3b8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804c3bb:	8d 43 01             	lea    0x1(%ebx),%eax
 804c3be:	5b                   	pop    %ebx
 804c3bf:	c3                   	ret    

0804c3c0 <call_rm_l>:
make_instr_helper(rm)
 804c3c0:	53                   	push   %ebx
 804c3c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804c3c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804c3c8:	83 c0 01             	add    $0x1,%eax
 804c3cb:	50                   	push   %eax
 804c3cc:	e8 5f 0e 01 00       	call   805d230 <decode_rm_l>
 804c3d1:	89 c3                	mov    %eax,%ebx
	execute();
 804c3d3:	e8 b8 fe ff ff       	call   804c290 <do_call_l>
 804c3d8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804c3db:	8d 43 01             	lea    0x1(%ebx),%eax
 804c3de:	5b                   	pop    %ebx
 804c3df:	c3                   	ret    

0804c3e0 <call_i_v>:
#include "call-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(call_i)
 804c3e0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804c3e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804c3eb:	b8 50 c2 04 08       	mov    $0x804c250,%eax
 804c3f0:	75 05                	jne    804c3f7 <call_i_v+0x17>
 804c3f2:	b8 a0 c3 04 08       	mov    $0x804c3a0,%eax
 804c3f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804c3fb:	ff e0                	jmp    *%eax
 804c3fd:	8d 76 00             	lea    0x0(%esi),%esi

0804c400 <call_rm_v>:
make_helper_v(call_rm)
 804c400:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804c407:	8b 54 24 04          	mov    0x4(%esp),%edx
 804c40b:	b8 70 c2 04 08       	mov    $0x804c270,%eax
 804c410:	75 05                	jne    804c417 <call_rm_v+0x17>
 804c412:	b8 c0 c3 04 08       	mov    $0x804c3c0,%eax
 804c417:	89 54 24 04          	mov    %edx,0x4(%esp)
 804c41b:	ff e0                	jmp    *%eax
 804c41d:	66 90                	xchg   %ax,%ax
 804c41f:	90                   	nop

0804c420 <cld>:
#include "cpu/exec/helper.h"

int cld(uint32_t eip) {
	cpu.DF = 0;
 804c420:	80 25 e5 ae 8f 14 fb 	andb   $0xfb,0x148faee5
	return 1;
}
 804c427:	b8 01 00 00 00       	mov    $0x1,%eax
 804c42c:	c3                   	ret    
 804c42d:	66 90                	xchg   %ax,%ax
 804c42f:	90                   	nop

0804c430 <ret_i_w>:
#include "cpu/exec/template-start.h"

#define instr ret

make_helper(ret_i_w) {
 804c430:	53                   	push   %ebx
	decode_i_w(eip + 1);
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
 804c431:	bb 04 00 00 00       	mov    $0x4,%ebx
#include "cpu/exec/template-start.h"

#define instr ret

make_helper(ret_i_w) {
 804c436:	83 ec 14             	sub    $0x14,%esp
	decode_i_w(eip + 1);
 804c439:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804c43d:	83 c0 01             	add    $0x1,%eax
 804c440:	50                   	push   %eax
 804c441:	e8 6a 08 01 00       	call   805ccb0 <decode_i_w>
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
 804c446:	0f b6 0d 04 ae 8f 14 	movzbl 0x148fae04,%ecx
 804c44d:	58                   	pop    %eax
 804c44e:	89 d8                	mov    %ebx,%eax
 804c450:	5a                   	pop    %edx
 804c451:	d3 f8                	sar    %cl,%eax
 804c453:	50                   	push   %eax
 804c454:	ff 35 d0 ae 8f 14    	pushl  0x148faed0
 804c45a:	e8 01 eb ff ff       	call   804af60 <swaddr_read>
	reg_l(R_ESP) = reg_l(R_ESP) + (4 >> ops_decoded.is_data_size_16);
 804c45f:	0f b6 0d 04 ae 8f 14 	movzbl 0x148fae04,%ecx

#define instr ret

make_helper(ret_i_w) {
	decode_i_w(eip + 1);
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
 804c466:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
 804c46b:	a1 d0 ae 8f 14       	mov    0x148faed0,%eax
 804c470:	03 05 14 ae 8f 14    	add    0x148fae14,%eax
	reg_l(R_ESP) = reg_l(R_ESP) + (4 >> ops_decoded.is_data_size_16);
	reg_l(R_ESP) += op_src->val;
	print_asm_template1();
 804c476:	68 18 ae 8f 14       	push   $0x148fae18
 804c47b:	68 9b fa 05 08       	push   $0x805fa9b
 804c480:	6a 50                	push   $0x50
 804c482:	68 00 89 0c 08       	push   $0x80c8900
#define instr ret

make_helper(ret_i_w) {
	decode_i_w(eip + 1);
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
	reg_l(R_ESP) = reg_l(R_ESP) + (4 >> ops_decoded.is_data_size_16);
 804c487:	d3 fb                	sar    %cl,%ebx
	reg_l(R_ESP) += op_src->val;
 804c489:	01 c3                	add    %eax,%ebx
 804c48b:	89 1d d0 ae 8f 14    	mov    %ebx,0x148faed0
	print_asm_template1();
 804c491:	e8 6a c6 ff ff       	call   8048b00 <snprintf@plt>
 804c496:	83 c4 20             	add    $0x20,%esp
 804c499:	83 f8 4f             	cmp    $0x4f,%eax
 804c49c:	7f 0a                	jg     804c4a8 <ret_i_w+0x78>
	return 0;
}
 804c49e:	83 c4 08             	add    $0x8,%esp
 804c4a1:	31 c0                	xor    %eax,%eax
 804c4a3:	5b                   	pop    %ebx
 804c4a4:	c3                   	ret    
 804c4a5:	8d 76 00             	lea    0x0(%esi),%esi
make_helper(ret_i_w) {
	decode_i_w(eip + 1);
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
	reg_l(R_ESP) = reg_l(R_ESP) + (4 >> ops_decoded.is_data_size_16);
	reg_l(R_ESP) += op_src->val;
	print_asm_template1();
 804c4a8:	83 ec 0c             	sub    $0xc,%esp
 804c4ab:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804c4b1:	e8 aa c4 ff ff       	call   8048960 <fflush@plt>
 804c4b6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c4bc:	6a 07                	push   $0x7
 804c4be:	6a 01                	push   $0x1
 804c4c0:	68 92 ed 05 08       	push   $0x805ed92
 804c4c5:	e8 46 c5 ff ff       	call   8048a10 <fwrite@plt>
 804c4ca:	83 c4 20             	add    $0x20,%esp
 804c4cd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c4d3:	6a 10                	push   $0x10
 804c4d5:	6a 01                	push   $0x1
 804c4d7:	68 84 f8 05 08       	push   $0x805f884
 804c4dc:	e8 2f c5 ff ff       	call   8048a10 <fwrite@plt>
 804c4e1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c4e7:	6a 05                	push   $0x5
 804c4e9:	6a 01                	push   $0x1
 804c4eb:	68 b1 ed 05 08       	push   $0x805edb1
 804c4f0:	e8 1b c5 ff ff       	call   8048a10 <fwrite@plt>
 804c4f5:	83 c4 20             	add    $0x20,%esp
 804c4f8:	68 18 ae 8f 14       	push   $0x148fae18
 804c4fd:	68 9b fa 05 08       	push   $0x805fa9b
 804c502:	6a 50                	push   $0x50
 804c504:	68 00 89 0c 08       	push   $0x80c8900
 804c509:	e8 f2 c5 ff ff       	call   8048b00 <snprintf@plt>
 804c50e:	83 c4 10             	add    $0x10,%esp
 804c511:	83 f8 4f             	cmp    $0x4f,%eax
 804c514:	7e 88                	jle    804c49e <ret_i_w+0x6e>
 804c516:	68 8b fb 05 08       	push   $0x805fb8b
 804c51b:	6a 0a                	push   $0xa
 804c51d:	68 cc fa 05 08       	push   $0x805facc
 804c522:	68 f4 fa 05 08       	push   $0x805faf4
 804c527:	e8 84 c6 ff ff       	call   8048bb0 <__assert_fail@plt>
 804c52c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804c530 <ret>:
#include "ret-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper(ret) {
 804c530:	53                   	push   %ebx
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
 804c531:	bb 04 00 00 00       	mov    $0x4,%ebx
 804c536:	89 d8                	mov    %ebx,%eax
#include "ret-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper(ret) {
 804c538:	83 ec 10             	sub    $0x10,%esp
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
 804c53b:	0f b6 0d 04 ae 8f 14 	movzbl 0x148fae04,%ecx
 804c542:	d3 f8                	sar    %cl,%eax
 804c544:	50                   	push   %eax
 804c545:	ff 35 d0 ae 8f 14    	pushl  0x148faed0
 804c54b:	e8 10 ea ff ff       	call   804af60 <swaddr_read>
	reg_l(R_ESP) = reg_l(R_ESP) + (4 >> ops_decoded.is_data_size_16);
 804c550:	0f b6 0d 04 ae 8f 14 	movzbl 0x148fae04,%ecx
	print_asm_template1();
 804c557:	68 18 ae 8f 14       	push   $0x148fae18
 804c55c:	68 a3 fa 05 08       	push   $0x805faa3
 804c561:	6a 50                	push   $0x50
 804c563:	68 00 89 0c 08       	push   $0x80c8900
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper(ret) {
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
 804c568:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
	reg_l(R_ESP) = reg_l(R_ESP) + (4 >> ops_decoded.is_data_size_16);
 804c56d:	d3 fb                	sar    %cl,%ebx
 804c56f:	01 1d d0 ae 8f 14    	add    %ebx,0x148faed0
	print_asm_template1();
 804c575:	e8 86 c5 ff ff       	call   8048b00 <snprintf@plt>
 804c57a:	83 c4 20             	add    $0x20,%esp
 804c57d:	83 f8 4f             	cmp    $0x4f,%eax
 804c580:	7f 0e                	jg     804c590 <ret+0x60>
	return 0;
}
 804c582:	83 c4 08             	add    $0x8,%esp
 804c585:	31 c0                	xor    %eax,%eax
 804c587:	5b                   	pop    %ebx
 804c588:	c3                   	ret    
 804c589:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
/* for instruction encoding overloading */

make_helper(ret) {
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
	reg_l(R_ESP) = reg_l(R_ESP) + (4 >> ops_decoded.is_data_size_16);
	print_asm_template1();
 804c590:	83 ec 0c             	sub    $0xc,%esp
 804c593:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804c599:	e8 c2 c3 ff ff       	call   8048960 <fflush@plt>
 804c59e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c5a4:	6a 07                	push   $0x7
 804c5a6:	6a 01                	push   $0x1
 804c5a8:	68 92 ed 05 08       	push   $0x805ed92
 804c5ad:	e8 5e c4 ff ff       	call   8048a10 <fwrite@plt>
 804c5b2:	83 c4 20             	add    $0x20,%esp
 804c5b5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c5bb:	6a 10                	push   $0x10
 804c5bd:	6a 01                	push   $0x1
 804c5bf:	68 84 f8 05 08       	push   $0x805f884
 804c5c4:	e8 47 c4 ff ff       	call   8048a10 <fwrite@plt>
 804c5c9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c5cf:	6a 05                	push   $0x5
 804c5d1:	6a 01                	push   $0x1
 804c5d3:	68 b1 ed 05 08       	push   $0x805edb1
 804c5d8:	e8 33 c4 ff ff       	call   8048a10 <fwrite@plt>
 804c5dd:	83 c4 20             	add    $0x20,%esp
 804c5e0:	68 18 ae 8f 14       	push   $0x148fae18
 804c5e5:	68 a3 fa 05 08       	push   $0x805faa3
 804c5ea:	6a 50                	push   $0x50
 804c5ec:	68 00 89 0c 08       	push   $0x80c8900
 804c5f1:	e8 0a c5 ff ff       	call   8048b00 <snprintf@plt>
 804c5f6:	83 c4 10             	add    $0x10,%esp
 804c5f9:	83 f8 4f             	cmp    $0x4f,%eax
 804c5fc:	7e 84                	jle    804c582 <ret+0x52>
 804c5fe:	68 87 fb 05 08       	push   $0x805fb87
 804c603:	6a 0c                	push   $0xc
 804c605:	68 b0 fa 05 08       	push   $0x805fab0
 804c60a:	68 3c fb 05 08       	push   $0x805fb3c
 804c60f:	e8 9c c5 ff ff       	call   8048bb0 <__assert_fail@plt>
 804c614:	66 90                	xchg   %ax,%ax
 804c616:	66 90                	xchg   %ax,%ax
 804c618:	66 90                	xchg   %ax,%ax
 804c61a:	66 90                	xchg   %ax,%ax
 804c61c:	66 90                	xchg   %ax,%ax
 804c61e:	66 90                	xchg   %ax,%ax

0804c620 <leave_r_l>:
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
}

make_instr_helper(r)
 804c620:	53                   	push   %ebx
 804c621:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804c624:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804c628:	83 c0 01             	add    $0x1,%eax
 804c62b:	50                   	push   %eax
 804c62c:	e8 1f 0c 01 00       	call   805d250 <decode_r_l>
 804c631:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
 804c633:	a1 d4 ae 8f 14       	mov    0x148faed4,%eax
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c638:	5a                   	pop    %edx
 804c639:	59                   	pop    %ecx
 804c63a:	6a 04                	push   $0x4
 804c63c:	50                   	push   %eax
#include "cpu/exec/template-start.h"

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
 804c63d:	a3 d0 ae 8f 14       	mov    %eax,0x148faed0
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c642:	e8 19 e9 ff ff       	call   804af60 <swaddr_read>
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c647:	68 18 ae 8f 14       	push   $0x148fae18
 804c64c:	68 93 fb 05 08       	push   $0x805fb93
 804c651:	6a 50                	push   $0x50
 804c653:	68 00 89 0c 08       	push   $0x80c8900
#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
	reg_l(R_ESP) += DATA_BYTE;
 804c658:	83 05 d0 ae 8f 14 04 	addl   $0x4,0x148faed0

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c65f:	a3 d4 ae 8f 14       	mov    %eax,0x148faed4
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c664:	e8 97 c4 ff ff       	call   8048b00 <snprintf@plt>
 804c669:	83 c4 20             	add    $0x20,%esp
 804c66c:	83 f8 4f             	cmp    $0x4f,%eax
 804c66f:	7f 0f                	jg     804c680 <leave_r_l+0x60>
}

make_instr_helper(r)
 804c671:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804c674:	8d 43 01             	lea    0x1(%ebx),%eax
 804c677:	5b                   	pop    %ebx
 804c678:	c3                   	ret    
 804c679:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c680:	83 ec 0c             	sub    $0xc,%esp
 804c683:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804c689:	e8 d2 c2 ff ff       	call   8048960 <fflush@plt>
 804c68e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c694:	6a 07                	push   $0x7
 804c696:	6a 01                	push   $0x1
 804c698:	68 92 ed 05 08       	push   $0x805ed92
 804c69d:	e8 6e c3 ff ff       	call   8048a10 <fwrite@plt>
 804c6a2:	83 c4 20             	add    $0x20,%esp
 804c6a5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c6ab:	6a 10                	push   $0x10
 804c6ad:	6a 01                	push   $0x1
 804c6af:	68 84 f8 05 08       	push   $0x805f884
 804c6b4:	e8 57 c3 ff ff       	call   8048a10 <fwrite@plt>
 804c6b9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c6bf:	6a 05                	push   $0x5
 804c6c1:	6a 01                	push   $0x1
 804c6c3:	68 b1 ed 05 08       	push   $0x805edb1
 804c6c8:	e8 43 c3 ff ff       	call   8048a10 <fwrite@plt>
 804c6cd:	83 c4 20             	add    $0x20,%esp
 804c6d0:	68 18 ae 8f 14       	push   $0x148fae18
 804c6d5:	68 93 fb 05 08       	push   $0x805fb93
 804c6da:	6a 50                	push   $0x50
 804c6dc:	68 00 89 0c 08       	push   $0x80c8900
 804c6e1:	e8 1a c4 ff ff       	call   8048b00 <snprintf@plt>
 804c6e6:	83 c4 10             	add    $0x10,%esp
 804c6e9:	83 f8 4f             	cmp    $0x4f,%eax
 804c6ec:	7e 83                	jle    804c671 <leave_r_l+0x51>
 804c6ee:	68 b8 fc 05 08       	push   $0x805fcb8
 804c6f3:	6a 09                	push   $0x9
 804c6f5:	68 b4 fb 05 08       	push   $0x805fbb4
 804c6fa:	68 e0 fb 05 08       	push   $0x805fbe0
 804c6ff:	e8 ac c4 ff ff       	call   8048bb0 <__assert_fail@plt>
 804c704:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804c70a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804c710 <leave_r_w>:
}

make_instr_helper(r)
 804c710:	53                   	push   %ebx
 804c711:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804c714:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804c718:	83 c0 01             	add    $0x1,%eax
 804c71b:	50                   	push   %eax
 804c71c:	e8 5f 07 01 00       	call   805ce80 <decode_r_w>
 804c721:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
 804c723:	a1 d4 ae 8f 14       	mov    0x148faed4,%eax
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c728:	5a                   	pop    %edx
 804c729:	59                   	pop    %ecx
 804c72a:	6a 02                	push   $0x2
 804c72c:	50                   	push   %eax
#include "cpu/exec/template-start.h"

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
 804c72d:	a3 d0 ae 8f 14       	mov    %eax,0x148faed0
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c732:	e8 29 e8 ff ff       	call   804af60 <swaddr_read>
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c737:	68 18 ae 8f 14       	push   $0x148fae18
 804c73c:	68 9d fb 05 08       	push   $0x805fb9d
 804c741:	6a 50                	push   $0x50
 804c743:	68 00 89 0c 08       	push   $0x80c8900
#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
	reg_l(R_ESP) += DATA_BYTE;
 804c748:	83 05 d0 ae 8f 14 02 	addl   $0x2,0x148faed0

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c74f:	66 a3 d4 ae 8f 14    	mov    %ax,0x148faed4
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c755:	e8 a6 c3 ff ff       	call   8048b00 <snprintf@plt>
 804c75a:	83 c4 20             	add    $0x20,%esp
 804c75d:	83 f8 4f             	cmp    $0x4f,%eax
 804c760:	7f 0e                	jg     804c770 <leave_r_w+0x60>
}

make_instr_helper(r)
 804c762:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804c765:	8d 43 01             	lea    0x1(%ebx),%eax
 804c768:	5b                   	pop    %ebx
 804c769:	c3                   	ret    
 804c76a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c770:	83 ec 0c             	sub    $0xc,%esp
 804c773:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804c779:	e8 e2 c1 ff ff       	call   8048960 <fflush@plt>
 804c77e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c784:	6a 07                	push   $0x7
 804c786:	6a 01                	push   $0x1
 804c788:	68 92 ed 05 08       	push   $0x805ed92
 804c78d:	e8 7e c2 ff ff       	call   8048a10 <fwrite@plt>
 804c792:	83 c4 20             	add    $0x20,%esp
 804c795:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c79b:	6a 10                	push   $0x10
 804c79d:	6a 01                	push   $0x1
 804c79f:	68 84 f8 05 08       	push   $0x805f884
 804c7a4:	e8 67 c2 ff ff       	call   8048a10 <fwrite@plt>
 804c7a9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c7af:	6a 05                	push   $0x5
 804c7b1:	6a 01                	push   $0x1
 804c7b3:	68 b1 ed 05 08       	push   $0x805edb1
 804c7b8:	e8 53 c2 ff ff       	call   8048a10 <fwrite@plt>
 804c7bd:	83 c4 20             	add    $0x20,%esp
 804c7c0:	68 18 ae 8f 14       	push   $0x148fae18
 804c7c5:	68 9d fb 05 08       	push   $0x805fb9d
 804c7ca:	6a 50                	push   $0x50
 804c7cc:	68 00 89 0c 08       	push   $0x80c8900
 804c7d1:	e8 2a c3 ff ff       	call   8048b00 <snprintf@plt>
 804c7d6:	83 c4 10             	add    $0x10,%esp
 804c7d9:	83 f8 4f             	cmp    $0x4f,%eax
 804c7dc:	7e 84                	jle    804c762 <leave_r_w+0x52>
 804c7de:	68 c3 fc 05 08       	push   $0x805fcc3
 804c7e3:	6a 09                	push   $0x9
 804c7e5:	68 b4 fb 05 08       	push   $0x805fbb4
 804c7ea:	68 28 fc 05 08       	push   $0x805fc28
 804c7ef:	e8 bc c3 ff ff       	call   8048bb0 <__assert_fail@plt>
 804c7f4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804c7fa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804c800 <leave_r_b>:
}

make_instr_helper(r)
 804c800:	53                   	push   %ebx
 804c801:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804c804:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804c808:	83 c0 01             	add    $0x1,%eax
 804c80b:	50                   	push   %eax
 804c80c:	e8 3f 03 01 00       	call   805cb50 <decode_r_b>
 804c811:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
 804c813:	a1 d4 ae 8f 14       	mov    0x148faed4,%eax
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c818:	5a                   	pop    %edx
 804c819:	59                   	pop    %ecx
 804c81a:	6a 01                	push   $0x1
 804c81c:	50                   	push   %eax
#include "cpu/exec/template-start.h"

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
 804c81d:	a3 d0 ae 8f 14       	mov    %eax,0x148faed0
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c822:	e8 39 e7 ff ff       	call   804af60 <swaddr_read>
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c827:	68 18 ae 8f 14       	push   $0x148fae18
 804c82c:	68 a7 fb 05 08       	push   $0x805fba7
 804c831:	6a 50                	push   $0x50
 804c833:	68 00 89 0c 08       	push   $0x80c8900
#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
	reg_l(R_ESP) += DATA_BYTE;
 804c838:	83 05 d0 ae 8f 14 01 	addl   $0x1,0x148faed0

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c83f:	a2 c5 ae 8f 14       	mov    %al,0x148faec5
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c844:	e8 b7 c2 ff ff       	call   8048b00 <snprintf@plt>
 804c849:	83 c4 20             	add    $0x20,%esp
 804c84c:	83 f8 4f             	cmp    $0x4f,%eax
 804c84f:	7f 0f                	jg     804c860 <leave_r_b+0x60>
}

make_instr_helper(r)
 804c851:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804c854:	8d 43 01             	lea    0x1(%ebx),%eax
 804c857:	5b                   	pop    %ebx
 804c858:	c3                   	ret    
 804c859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c860:	83 ec 0c             	sub    $0xc,%esp
 804c863:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804c869:	e8 f2 c0 ff ff       	call   8048960 <fflush@plt>
 804c86e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c874:	6a 07                	push   $0x7
 804c876:	6a 01                	push   $0x1
 804c878:	68 92 ed 05 08       	push   $0x805ed92
 804c87d:	e8 8e c1 ff ff       	call   8048a10 <fwrite@plt>
 804c882:	83 c4 20             	add    $0x20,%esp
 804c885:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c88b:	6a 10                	push   $0x10
 804c88d:	6a 01                	push   $0x1
 804c88f:	68 84 f8 05 08       	push   $0x805f884
 804c894:	e8 77 c1 ff ff       	call   8048a10 <fwrite@plt>
 804c899:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c89f:	6a 05                	push   $0x5
 804c8a1:	6a 01                	push   $0x1
 804c8a3:	68 b1 ed 05 08       	push   $0x805edb1
 804c8a8:	e8 63 c1 ff ff       	call   8048a10 <fwrite@plt>
 804c8ad:	83 c4 20             	add    $0x20,%esp
 804c8b0:	68 18 ae 8f 14       	push   $0x148fae18
 804c8b5:	68 a7 fb 05 08       	push   $0x805fba7
 804c8ba:	6a 50                	push   $0x50
 804c8bc:	68 00 89 0c 08       	push   $0x80c8900
 804c8c1:	e8 3a c2 ff ff       	call   8048b00 <snprintf@plt>
 804c8c6:	83 c4 10             	add    $0x10,%esp
 804c8c9:	83 f8 4f             	cmp    $0x4f,%eax
 804c8cc:	7e 83                	jle    804c851 <leave_r_b+0x51>
 804c8ce:	68 ce fc 05 08       	push   $0x805fcce
 804c8d3:	6a 09                	push   $0x9
 804c8d5:	68 b4 fb 05 08       	push   $0x805fbb4
 804c8da:	68 70 fc 05 08       	push   $0x805fc70
 804c8df:	e8 cc c2 ff ff       	call   8048bb0 <__assert_fail@plt>
 804c8e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804c8ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804c8f0 <leave_r_v>:
#include "leave-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(leave_r)
 804c8f0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804c8f7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804c8fb:	b8 10 c7 04 08       	mov    $0x804c710,%eax
 804c900:	75 05                	jne    804c907 <leave_r_v+0x17>
 804c902:	b8 20 c6 04 08       	mov    $0x804c620,%eax
 804c907:	89 54 24 04          	mov    %edx,0x4(%esp)
 804c90b:	ff e0                	jmp    *%eax
 804c90d:	66 90                	xchg   %ax,%ax
 804c90f:	90                   	nop

0804c910 <cmps_w>:
#include "cpu/exec/template-start.h"

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
 804c910:	0f b7 15 dc ae 8f 14 	movzwl 0x148faedc,%edx
 804c917:	0f b7 0d d8 ae 8f 14 	movzwl 0x148faed8,%ecx
#include "cpu/exec/template-start.h"

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
 804c91e:	57                   	push   %edi
 804c91f:	56                   	push   %esi
 804c920:	53                   	push   %ebx
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804c921:	68 18 ae 8f 14       	push   $0x148fae18
 804c926:	68 d9 fc 05 08       	push   $0x805fcd9
 804c92b:	6a 50                	push   $0x50
#include "cpu/exec/template-start.h"

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
 804c92d:	89 cb                	mov    %ecx,%ebx
 804c92f:	29 d1                	sub    %edx,%ecx
 804c931:	89 d6                	mov    %edx,%esi
	uint32_t pf = (res & 255);
 804c933:	0f b6 d1             	movzbl %cl,%edx
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804c936:	68 00 89 0c 08       	push   $0x80c8900
#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 804c93b:	89 d0                	mov    %edx,%eax
 804c93d:	c1 e8 04             	shr    $0x4,%eax
 804c940:	31 c2                	xor    %eax,%edx
	pf = (pf >> 2) ^ pf;
 804c942:	89 d0                	mov    %edx,%eax
 804c944:	c1 e8 02             	shr    $0x2,%eax
 804c947:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 804c949:	89 c2                	mov    %eax,%edx
 804c94b:	d1 ea                	shr    %edx
 804c94d:	89 d7                	mov    %edx,%edi
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c94f:	89 f2                	mov    %esi,%edx
 804c951:	0f b6 35 e4 ae 8f 14 	movzbl 0x148faee4,%esi
make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 804c958:	31 c7                	xor    %eax,%edi
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c95a:	29 d3                	sub    %edx,%ebx
make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 804c95c:	89 fa                	mov    %edi,%edx
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c95e:	83 e3 01             	and    $0x1,%ebx
	cpu.PF = (pf & 1);
 804c961:	83 e2 01             	and    $0x1,%edx
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c964:	83 e6 fa             	and    $0xfffffffa,%esi
	cpu.PF = (pf & 1);
 804c967:	c1 e2 02             	shl    $0x2,%edx
 804c96a:	89 f0                	mov    %esi,%eax
 804c96c:	09 d8                	or     %ebx,%eax
 804c96e:	09 d0                	or     %edx,%eax
	cpu.ZF = (res == 0);
 804c970:	85 c9                	test   %ecx,%ecx
 804c972:	0f 94 c2             	sete   %dl
 804c975:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = (res >> 31) & 1;
 804c978:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 804c97b:	c1 e2 06             	shl    $0x6,%edx
	cpu.SF = (res >> 31) & 1;
 804c97e:	c1 e1 07             	shl    $0x7,%ecx
 804c981:	09 d0                	or     %edx,%eax
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c983:	ba 01 00 00 00       	mov    $0x1,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 804c988:	09 c8                	or     %ecx,%eax
 804c98a:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
 804c98f:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
 804c996:	83 e0 f7             	and    $0xfffffff7,%eax
 804c999:	a2 e5 ae 8f 14       	mov    %al,0x148faee5
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c99e:	c0 e8 02             	shr    $0x2,%al
 804c9a1:	83 e0 01             	and    $0x1,%eax
 804c9a4:	01 c0                	add    %eax,%eax
 804c9a6:	29 c2                	sub    %eax,%edx
 804c9a8:	89 d0                	mov    %edx,%eax
 804c9aa:	01 c0                	add    %eax,%eax
 804c9ac:	01 05 d8 ae 8f 14    	add    %eax,0x148faed8
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c9b2:	01 05 dc ae 8f 14    	add    %eax,0x148faedc
	print_asm_template1();
 804c9b8:	e8 43 c1 ff ff       	call   8048b00 <snprintf@plt>
 804c9bd:	83 c4 10             	add    $0x10,%esp
 804c9c0:	83 f8 4f             	cmp    $0x4f,%eax
 804c9c3:	7f 0b                	jg     804c9d0 <cmps_w+0xc0>
	return 1;
}
 804c9c5:	b8 01 00 00 00       	mov    $0x1,%eax
 804c9ca:	5b                   	pop    %ebx
 804c9cb:	5e                   	pop    %esi
 804c9cc:	5f                   	pop    %edi
 804c9cd:	c3                   	ret    
 804c9ce:	66 90                	xchg   %ax,%ax
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804c9d0:	83 ec 0c             	sub    $0xc,%esp
 804c9d3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804c9d9:	e8 82 bf ff ff       	call   8048960 <fflush@plt>
 804c9de:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c9e4:	6a 07                	push   $0x7
 804c9e6:	6a 01                	push   $0x1
 804c9e8:	68 92 ed 05 08       	push   $0x805ed92
 804c9ed:	e8 1e c0 ff ff       	call   8048a10 <fwrite@plt>
 804c9f2:	83 c4 20             	add    $0x20,%esp
 804c9f5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804c9fb:	6a 10                	push   $0x10
 804c9fd:	6a 01                	push   $0x1
 804c9ff:	68 84 f8 05 08       	push   $0x805f884
 804ca04:	e8 07 c0 ff ff       	call   8048a10 <fwrite@plt>
 804ca09:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804ca0f:	6a 05                	push   $0x5
 804ca11:	6a 01                	push   $0x1
 804ca13:	68 b1 ed 05 08       	push   $0x805edb1
 804ca18:	e8 f3 bf ff ff       	call   8048a10 <fwrite@plt>
 804ca1d:	83 c4 20             	add    $0x20,%esp
 804ca20:	68 18 ae 8f 14       	push   $0x148fae18
 804ca25:	68 d9 fc 05 08       	push   $0x805fcd9
 804ca2a:	6a 50                	push   $0x50
 804ca2c:	68 00 89 0c 08       	push   $0x80c8900
 804ca31:	e8 ca c0 ff ff       	call   8048b00 <snprintf@plt>
 804ca36:	83 c4 10             	add    $0x10,%esp
 804ca39:	83 f8 4f             	cmp    $0x4f,%eax
 804ca3c:	7e 87                	jle    804c9c5 <cmps_w+0xb5>
 804ca3e:	68 fa fd 05 08       	push   $0x805fdfa
 804ca43:	6a 12                	push   $0x12
 804ca45:	68 f4 fc 05 08       	push   $0x805fcf4
 804ca4a:	68 1c fd 05 08       	push   $0x805fd1c
 804ca4f:	e8 5c c1 ff ff       	call   8048bb0 <__assert_fail@plt>
 804ca54:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804ca5a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804ca60 <cmps_l>:
#include "cpu/exec/template-start.h"

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
 804ca60:	55                   	push   %ebp
 804ca61:	57                   	push   %edi
 804ca62:	56                   	push   %esi
 804ca63:	53                   	push   %ebx
 804ca64:	83 ec 0c             	sub    $0xc,%esp
	uint32_t res = REG(R_ESI) - REG(R_EDI);
 804ca67:	8b 0d d8 ae 8f 14    	mov    0x148faed8,%ecx
 804ca6d:	8b 15 dc ae 8f 14    	mov    0x148faedc,%edx
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804ca73:	68 18 ae 8f 14       	push   $0x148fae18
 804ca78:	68 e2 fc 05 08       	push   $0x805fce2
 804ca7d:	6a 50                	push   $0x50
 804ca7f:	68 00 89 0c 08       	push   $0x80c8900
#include "cpu/exec/template-start.h"

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
 804ca84:	89 cf                	mov    %ecx,%edi
 804ca86:	29 d7                	sub    %edx,%edi
	uint32_t pf = (res & 255);
 804ca88:	89 f8                	mov    %edi,%eax
 804ca8a:	0f b6 c0             	movzbl %al,%eax
	pf = (pf >> 4) ^ pf;
 804ca8d:	89 c3                	mov    %eax,%ebx
 804ca8f:	c1 eb 04             	shr    $0x4,%ebx
 804ca92:	31 d8                	xor    %ebx,%eax
	pf = (pf >> 2) ^ pf;
 804ca94:	89 c3                	mov    %eax,%ebx
 804ca96:	c1 eb 02             	shr    $0x2,%ebx
 804ca99:	31 d8                	xor    %ebx,%eax
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804ca9b:	89 cb                	mov    %ecx,%ebx
 804ca9d:	29 d3                	sub    %edx,%ebx
make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 804ca9f:	89 c6                	mov    %eax,%esi
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804caa1:	83 e3 01             	and    $0x1,%ebx
make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 804caa4:	d1 ee                	shr    %esi
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804caa6:	89 dd                	mov    %ebx,%ebp
 804caa8:	0f b6 1d e4 ae 8f 14 	movzbl 0x148faee4,%ebx
make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 804caaf:	31 f0                	xor    %esi,%eax
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
 804cab1:	83 e0 01             	and    $0x1,%eax
 804cab4:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804cabb:	83 e3 fa             	and    $0xfffffffa,%ebx
	cpu.PF = (pf & 1);
 804cabe:	09 eb                	or     %ebp,%ebx
 804cac0:	09 f3                	or     %esi,%ebx
	cpu.ZF = (res == 0);
 804cac2:	85 ff                	test   %edi,%edi
 804cac4:	0f 94 c0             	sete   %al
	cpu.SF = (res >> 31) & 1;
 804cac7:	c1 ef 1f             	shr    $0x1f,%edi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 804caca:	83 e3 3f             	and    $0x3f,%ebx
 804cacd:	c1 e0 06             	shl    $0x6,%eax
	cpu.SF = (res >> 31) & 1;
 804cad0:	89 fd                	mov    %edi,%ebp
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 804cad2:	89 c6                	mov    %eax,%esi
	cpu.SF = (res >> 31) & 1;
 804cad4:	c1 e5 07             	shl    $0x7,%ebp
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
 804cad7:	89 c8                	mov    %ecx,%eax
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 804cad9:	09 f3                	or     %esi,%ebx
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
 804cadb:	c1 e8 1f             	shr    $0x1f,%eax
 804cade:	83 c1 04             	add    $0x4,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 804cae1:	09 eb                	or     %ebp,%ebx
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
 804cae3:	31 c7                	xor    %eax,%edi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 804cae5:	88 1d e4 ae 8f 14    	mov    %bl,0x148faee4
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
 804caeb:	89 d3                	mov    %edx,%ebx
 804caed:	83 c2 04             	add    $0x4,%edx
 804caf0:	c1 eb 1f             	shr    $0x1f,%ebx
 804caf3:	31 d8                	xor    %ebx,%eax
 804caf5:	0f b6 1d e5 ae 8f 14 	movzbl 0x148faee5,%ebx
 804cafc:	21 f8                	and    %edi,%eax
 804cafe:	c1 e0 03             	shl    $0x3,%eax
 804cb01:	83 e3 f7             	and    $0xfffffff7,%ebx
 804cb04:	09 d8                	or     %ebx,%eax
 804cb06:	a2 e5 ae 8f 14       	mov    %al,0x148faee5
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804cb0b:	c0 e8 02             	shr    $0x2,%al
 804cb0e:	83 e0 01             	and    $0x1,%eax
 804cb11:	c1 e0 03             	shl    $0x3,%eax
 804cb14:	29 c1                	sub    %eax,%ecx
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804cb16:	29 c2                	sub    %eax,%edx
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804cb18:	89 0d d8 ae 8f 14    	mov    %ecx,0x148faed8
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804cb1e:	89 15 dc ae 8f 14    	mov    %edx,0x148faedc
	print_asm_template1();
 804cb24:	e8 d7 bf ff ff       	call   8048b00 <snprintf@plt>
 804cb29:	83 c4 10             	add    $0x10,%esp
 804cb2c:	83 f8 4f             	cmp    $0x4f,%eax
 804cb2f:	7f 0f                	jg     804cb40 <cmps_l+0xe0>
	return 1;
}
 804cb31:	83 c4 0c             	add    $0xc,%esp
 804cb34:	b8 01 00 00 00       	mov    $0x1,%eax
 804cb39:	5b                   	pop    %ebx
 804cb3a:	5e                   	pop    %esi
 804cb3b:	5f                   	pop    %edi
 804cb3c:	5d                   	pop    %ebp
 804cb3d:	c3                   	ret    
 804cb3e:	66 90                	xchg   %ax,%ax
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804cb40:	83 ec 0c             	sub    $0xc,%esp
 804cb43:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804cb49:	e8 12 be ff ff       	call   8048960 <fflush@plt>
 804cb4e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804cb54:	6a 07                	push   $0x7
 804cb56:	6a 01                	push   $0x1
 804cb58:	68 92 ed 05 08       	push   $0x805ed92
 804cb5d:	e8 ae be ff ff       	call   8048a10 <fwrite@plt>
 804cb62:	83 c4 20             	add    $0x20,%esp
 804cb65:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804cb6b:	6a 10                	push   $0x10
 804cb6d:	6a 01                	push   $0x1
 804cb6f:	68 84 f8 05 08       	push   $0x805f884
 804cb74:	e8 97 be ff ff       	call   8048a10 <fwrite@plt>
 804cb79:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804cb7f:	6a 05                	push   $0x5
 804cb81:	6a 01                	push   $0x1
 804cb83:	68 b1 ed 05 08       	push   $0x805edb1
 804cb88:	e8 83 be ff ff       	call   8048a10 <fwrite@plt>
 804cb8d:	83 c4 20             	add    $0x20,%esp
 804cb90:	68 18 ae 8f 14       	push   $0x148fae18
 804cb95:	68 e2 fc 05 08       	push   $0x805fce2
 804cb9a:	6a 50                	push   $0x50
 804cb9c:	68 00 89 0c 08       	push   $0x80c8900
 804cba1:	e8 5a bf ff ff       	call   8048b00 <snprintf@plt>
 804cba6:	83 c4 10             	add    $0x10,%esp
 804cba9:	83 f8 4f             	cmp    $0x4f,%eax
 804cbac:	7e 83                	jle    804cb31 <cmps_l+0xd1>
 804cbae:	68 f3 fd 05 08       	push   $0x805fdf3
 804cbb3:	6a 12                	push   $0x12
 804cbb5:	68 f4 fc 05 08       	push   $0x805fcf4
 804cbba:	68 64 fd 05 08       	push   $0x805fd64
 804cbbf:	e8 ec bf ff ff       	call   8048bb0 <__assert_fail@plt>
 804cbc4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804cbca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804cbd0 <cmps_b>:
#include "cpu/exec/template-start.h"

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
 804cbd0:	56                   	push   %esi
 804cbd1:	53                   	push   %ebx
 804cbd2:	83 ec 04             	sub    $0x4,%esp
	uint32_t res = REG(R_ESI) - REG(R_EDI);
 804cbd5:	0f b6 0d c9 ae 8f 14 	movzbl 0x148faec9,%ecx
 804cbdc:	0f b6 15 cd ae 8f 14 	movzbl 0x148faecd,%edx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804cbe3:	0f b6 35 e4 ae 8f 14 	movzbl 0x148faee4,%esi
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804cbea:	68 18 ae 8f 14       	push   $0x148fae18
 804cbef:	68 eb fc 05 08       	push   $0x805fceb
 804cbf4:	6a 50                	push   $0x50
 804cbf6:	68 00 89 0c 08       	push   $0x80c8900
#include "cpu/exec/template-start.h"

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
 804cbfb:	89 cb                	mov    %ecx,%ebx
 804cbfd:	29 d1                	sub    %edx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804cbff:	2a 1d cd ae 8f 14    	sub    0x148faecd,%bl

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
 804cc05:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804cc08:	83 e6 fa             	and    $0xfffffffa,%esi
#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 804cc0b:	89 c2                	mov    %eax,%edx
 804cc0d:	c1 ea 04             	shr    $0x4,%edx
 804cc10:	31 d0                	xor    %edx,%eax
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804cc12:	83 e3 01             	and    $0x1,%ebx

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804cc15:	89 c2                	mov    %eax,%edx
 804cc17:	c1 ea 02             	shr    $0x2,%edx
 804cc1a:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 804cc1c:	89 c2                	mov    %eax,%edx
 804cc1e:	d1 ea                	shr    %edx
 804cc20:	31 c2                	xor    %eax,%edx
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
 804cc22:	89 f0                	mov    %esi,%eax
 804cc24:	8b 35 d8 ae 8f 14    	mov    0x148faed8,%esi
 804cc2a:	83 e2 01             	and    $0x1,%edx
 804cc2d:	09 d8                	or     %ebx,%eax
 804cc2f:	8b 1d dc ae 8f 14    	mov    0x148faedc,%ebx
 804cc35:	c1 e2 02             	shl    $0x2,%edx
 804cc38:	09 d0                	or     %edx,%eax
	cpu.ZF = (res == 0);
 804cc3a:	85 c9                	test   %ecx,%ecx
 804cc3c:	0f 94 c2             	sete   %dl
 804cc3f:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = (res >> 31) & 1;
 804cc42:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 804cc45:	c1 e2 06             	shl    $0x6,%edx
	cpu.SF = (res >> 31) & 1;
 804cc48:	c1 e1 07             	shl    $0x7,%ecx
 804cc4b:	09 d0                	or     %edx,%eax
 804cc4d:	8d 56 01             	lea    0x1(%esi),%edx
 804cc50:	09 c8                	or     %ecx,%eax
 804cc52:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
 804cc57:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
 804cc5e:	83 e0 f7             	and    $0xfffffff7,%eax
 804cc61:	a2 e5 ae 8f 14       	mov    %al,0x148faee5
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804cc66:	c0 e8 02             	shr    $0x2,%al
 804cc69:	83 e0 01             	and    $0x1,%eax
 804cc6c:	01 c0                	add    %eax,%eax
 804cc6e:	29 c2                	sub    %eax,%edx
 804cc70:	89 15 d8 ae 8f 14    	mov    %edx,0x148faed8
 804cc76:	8d 53 01             	lea    0x1(%ebx),%edx
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804cc79:	29 c2                	sub    %eax,%edx
 804cc7b:	89 15 dc ae 8f 14    	mov    %edx,0x148faedc
	print_asm_template1();
 804cc81:	e8 7a be ff ff       	call   8048b00 <snprintf@plt>
 804cc86:	83 c4 10             	add    $0x10,%esp
 804cc89:	83 f8 4f             	cmp    $0x4f,%eax
 804cc8c:	7f 12                	jg     804cca0 <cmps_b+0xd0>
	return 1;
}
 804cc8e:	83 c4 04             	add    $0x4,%esp
 804cc91:	b8 01 00 00 00       	mov    $0x1,%eax
 804cc96:	5b                   	pop    %ebx
 804cc97:	5e                   	pop    %esi
 804cc98:	c3                   	ret    
 804cc99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804cca0:	83 ec 0c             	sub    $0xc,%esp
 804cca3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804cca9:	e8 b2 bc ff ff       	call   8048960 <fflush@plt>
 804ccae:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804ccb4:	6a 07                	push   $0x7
 804ccb6:	6a 01                	push   $0x1
 804ccb8:	68 92 ed 05 08       	push   $0x805ed92
 804ccbd:	e8 4e bd ff ff       	call   8048a10 <fwrite@plt>
 804ccc2:	83 c4 20             	add    $0x20,%esp
 804ccc5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804cccb:	6a 10                	push   $0x10
 804cccd:	6a 01                	push   $0x1
 804cccf:	68 84 f8 05 08       	push   $0x805f884
 804ccd4:	e8 37 bd ff ff       	call   8048a10 <fwrite@plt>
 804ccd9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804ccdf:	6a 05                	push   $0x5
 804cce1:	6a 01                	push   $0x1
 804cce3:	68 b1 ed 05 08       	push   $0x805edb1
 804cce8:	e8 23 bd ff ff       	call   8048a10 <fwrite@plt>
 804cced:	83 c4 20             	add    $0x20,%esp
 804ccf0:	68 18 ae 8f 14       	push   $0x148fae18
 804ccf5:	68 eb fc 05 08       	push   $0x805fceb
 804ccfa:	6a 50                	push   $0x50
 804ccfc:	68 00 89 0c 08       	push   $0x80c8900
 804cd01:	e8 fa bd ff ff       	call   8048b00 <snprintf@plt>
 804cd06:	83 c4 10             	add    $0x10,%esp
 804cd09:	83 f8 4f             	cmp    $0x4f,%eax
 804cd0c:	7e 80                	jle    804cc8e <cmps_b+0xbe>
 804cd0e:	68 01 fe 05 08       	push   $0x805fe01
 804cd13:	6a 12                	push   $0x12
 804cd15:	68 f4 fc 05 08       	push   $0x805fcf4
 804cd1a:	68 ac fd 05 08       	push   $0x805fdac
 804cd1f:	e8 8c be ff ff       	call   8048bb0 <__assert_fail@plt>
 804cd24:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804cd2a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804cd30 <cmps_v>:

#define DATA_BYTE 4
#include "cmps-template.h"
#undef DATA_BYTE

make_helper_v(cmps)
 804cd30:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804cd37:	8b 54 24 04          	mov    0x4(%esp),%edx
 804cd3b:	b8 10 c9 04 08       	mov    $0x804c910,%eax
 804cd40:	75 05                	jne    804cd47 <cmps_v+0x17>
 804cd42:	b8 60 ca 04 08       	mov    $0x804ca60,%eax
 804cd47:	89 54 24 04          	mov    %edx,0x4(%esp)
 804cd4b:	ff e0                	jmp    *%eax
 804cd4d:	66 90                	xchg   %ax,%ax
 804cd4f:	90                   	nop

0804cd50 <group5>:
make_group(group4,
	inc_rm_b, dec_rm_b, inv, inv, 
	inv, inv, inv, inv)

/* 0xff */
make_group(group5,
 804cd50:	53                   	push   %ebx
 804cd51:	83 ec 10             	sub    $0x10,%esp
 804cd54:	8b 5c 24 18          	mov    0x18(%esp),%ebx

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 804cd58:	6a 01                	push   $0x1
 804cd5a:	8d 43 01             	lea    0x1(%ebx),%eax
 804cd5d:	50                   	push   %eax
 804cd5e:	e8 fd e1 ff ff       	call   804af60 <swaddr_read>
 804cd63:	c0 e8 03             	shr    $0x3,%al
 804cd66:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804cd6a:	83 e0 07             	and    $0x7,%eax
 804cd6d:	8b 04 85 60 fe 05 08 	mov    0x805fe60(,%eax,4),%eax
 804cd74:	83 c4 18             	add    $0x18,%esp
 804cd77:	5b                   	pop    %ebx
 804cd78:	ff e0                	jmp    *%eax
 804cd7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804cd80 <group4>:
make_group(group3_v,
	test_i2rm_v, inv, not_rm_v, neg_rm_v, 
	mul_rm_v, imul_rm2a_v, div_rm_v, idiv_rm_v)

/* 0xfe */
make_group(group4,
 804cd80:	53                   	push   %ebx
 804cd81:	83 ec 10             	sub    $0x10,%esp
 804cd84:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804cd88:	6a 01                	push   $0x1
 804cd8a:	8d 43 01             	lea    0x1(%ebx),%eax
 804cd8d:	50                   	push   %eax
 804cd8e:	e8 cd e1 ff ff       	call   804af60 <swaddr_read>
 804cd93:	c0 e8 03             	shr    $0x3,%al
 804cd96:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804cd9a:	83 e0 07             	and    $0x7,%eax
 804cd9d:	8b 04 85 80 fe 05 08 	mov    0x805fe80(,%eax,4),%eax
 804cda4:	83 c4 18             	add    $0x18,%esp
 804cda7:	5b                   	pop    %ebx
 804cda8:	ff e0                	jmp    *%eax
 804cdaa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804cdb0 <group3_v>:
make_group(group3_b,
	test_i2rm_b, inv, not_rm_b, neg_rm_b, 
	mul_rm_b, imul_rm2a_b, div_rm_b, idiv_rm_b)

/* 0xf7 */
make_group(group3_v,
 804cdb0:	53                   	push   %ebx
 804cdb1:	83 ec 10             	sub    $0x10,%esp
 804cdb4:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804cdb8:	6a 01                	push   $0x1
 804cdba:	8d 43 01             	lea    0x1(%ebx),%eax
 804cdbd:	50                   	push   %eax
 804cdbe:	e8 9d e1 ff ff       	call   804af60 <swaddr_read>
 804cdc3:	c0 e8 03             	shr    $0x3,%al
 804cdc6:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804cdca:	83 e0 07             	and    $0x7,%eax
 804cdcd:	8b 04 85 a0 fe 05 08 	mov    0x805fea0(,%eax,4),%eax
 804cdd4:	83 c4 18             	add    $0x18,%esp
 804cdd7:	5b                   	pop    %ebx
 804cdd8:	ff e0                	jmp    *%eax
 804cdda:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804cde0 <group3_b>:
make_group(group2_cl_v,
	inv, inv, inv, inv, 
	shl_rm_cl_v, shr_rm_cl_v, inv, sar_rm_cl_v)

/* 0xf6 */
make_group(group3_b,
 804cde0:	53                   	push   %ebx
 804cde1:	83 ec 10             	sub    $0x10,%esp
 804cde4:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804cde8:	6a 01                	push   $0x1
 804cdea:	8d 43 01             	lea    0x1(%ebx),%eax
 804cded:	50                   	push   %eax
 804cdee:	e8 6d e1 ff ff       	call   804af60 <swaddr_read>
 804cdf3:	c0 e8 03             	shr    $0x3,%al
 804cdf6:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804cdfa:	83 e0 07             	and    $0x7,%eax
 804cdfd:	8b 04 85 c0 fe 05 08 	mov    0x805fec0(,%eax,4),%eax
 804ce04:	83 c4 18             	add    $0x18,%esp
 804ce07:	5b                   	pop    %ebx
 804ce08:	ff e0                	jmp    *%eax
 804ce0a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804ce10 <group2_cl_v>:
make_group(group2_cl_b,
	inv, inv, inv, inv, 
	shl_rm_cl_b, shr_rm_cl_b, inv, sar_rm_cl_b)

/* 0xd3 */
make_group(group2_cl_v,
 804ce10:	53                   	push   %ebx
 804ce11:	83 ec 10             	sub    $0x10,%esp
 804ce14:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804ce18:	6a 01                	push   $0x1
 804ce1a:	8d 43 01             	lea    0x1(%ebx),%eax
 804ce1d:	50                   	push   %eax
 804ce1e:	e8 3d e1 ff ff       	call   804af60 <swaddr_read>
 804ce23:	c0 e8 03             	shr    $0x3,%al
 804ce26:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804ce2a:	83 e0 07             	and    $0x7,%eax
 804ce2d:	8b 04 85 e0 fe 05 08 	mov    0x805fee0(,%eax,4),%eax
 804ce34:	83 c4 18             	add    $0x18,%esp
 804ce37:	5b                   	pop    %ebx
 804ce38:	ff e0                	jmp    *%eax
 804ce3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804ce40 <group2_cl_b>:
make_group(group2_1_v,
	inv, inv, inv, inv, 
	shl_rm_1_v, shr_rm_1_v, inv, sar_rm_1_v)

/* 0xd2 */
make_group(group2_cl_b,
 804ce40:	53                   	push   %ebx
 804ce41:	83 ec 10             	sub    $0x10,%esp
 804ce44:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804ce48:	6a 01                	push   $0x1
 804ce4a:	8d 43 01             	lea    0x1(%ebx),%eax
 804ce4d:	50                   	push   %eax
 804ce4e:	e8 0d e1 ff ff       	call   804af60 <swaddr_read>
 804ce53:	c0 e8 03             	shr    $0x3,%al
 804ce56:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804ce5a:	83 e0 07             	and    $0x7,%eax
 804ce5d:	8b 04 85 00 ff 05 08 	mov    0x805ff00(,%eax,4),%eax
 804ce64:	83 c4 18             	add    $0x18,%esp
 804ce67:	5b                   	pop    %ebx
 804ce68:	ff e0                	jmp    *%eax
 804ce6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804ce70 <group2_1_v>:
make_group(group2_1_b,
	inv, inv, inv, inv, 
	shl_rm_1_b, shr_rm_1_b, inv, sar_rm_1_b)

/* 0xd1 */
make_group(group2_1_v,
 804ce70:	53                   	push   %ebx
 804ce71:	83 ec 10             	sub    $0x10,%esp
 804ce74:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804ce78:	6a 01                	push   $0x1
 804ce7a:	8d 43 01             	lea    0x1(%ebx),%eax
 804ce7d:	50                   	push   %eax
 804ce7e:	e8 dd e0 ff ff       	call   804af60 <swaddr_read>
 804ce83:	c0 e8 03             	shr    $0x3,%al
 804ce86:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804ce8a:	83 e0 07             	and    $0x7,%eax
 804ce8d:	8b 04 85 20 ff 05 08 	mov    0x805ff20(,%eax,4),%eax
 804ce94:	83 c4 18             	add    $0x18,%esp
 804ce97:	5b                   	pop    %ebx
 804ce98:	ff e0                	jmp    *%eax
 804ce9a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804cea0 <group2_1_b>:
make_group(group2_i_v,
	inv, inv, inv, inv, 
	shl_rm_imm_v, shr_rm_imm_v, inv, sar_rm_imm_v)

/* 0xd0 */
make_group(group2_1_b,
 804cea0:	53                   	push   %ebx
 804cea1:	83 ec 10             	sub    $0x10,%esp
 804cea4:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804cea8:	6a 01                	push   $0x1
 804ceaa:	8d 43 01             	lea    0x1(%ebx),%eax
 804cead:	50                   	push   %eax
 804ceae:	e8 ad e0 ff ff       	call   804af60 <swaddr_read>
 804ceb3:	c0 e8 03             	shr    $0x3,%al
 804ceb6:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804ceba:	83 e0 07             	and    $0x7,%eax
 804cebd:	8b 04 85 40 ff 05 08 	mov    0x805ff40(,%eax,4),%eax
 804cec4:	83 c4 18             	add    $0x18,%esp
 804cec7:	5b                   	pop    %ebx
 804cec8:	ff e0                	jmp    *%eax
 804ceca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804ced0 <group2_i_v>:
make_group(group2_i_b,
	inv, inv, inv, inv, 
	shl_rm_imm_b, shr_rm_imm_b, inv, sar_rm_imm_b)

/* 0xc1 */
make_group(group2_i_v,
 804ced0:	53                   	push   %ebx
 804ced1:	83 ec 10             	sub    $0x10,%esp
 804ced4:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804ced8:	6a 01                	push   $0x1
 804ceda:	8d 43 01             	lea    0x1(%ebx),%eax
 804cedd:	50                   	push   %eax
 804cede:	e8 7d e0 ff ff       	call   804af60 <swaddr_read>
 804cee3:	c0 e8 03             	shr    $0x3,%al
 804cee6:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804ceea:	83 e0 07             	and    $0x7,%eax
 804ceed:	8b 04 85 60 ff 05 08 	mov    0x805ff60(,%eax,4),%eax
 804cef4:	83 c4 18             	add    $0x18,%esp
 804cef7:	5b                   	pop    %ebx
 804cef8:	ff e0                	jmp    *%eax
 804cefa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804cf00 <group2_i_b>:
make_group(group1_sx_v,
	add_si2rm_v, or_si2rm_v, adc_si2rm_v, sbb_si2rm_v, 
	and_si2rm_v, sub_si2rm_v, xor_si2rm_v, cmp_si2rm_v)

/* 0xc0 */
make_group(group2_i_b,
 804cf00:	53                   	push   %ebx
 804cf01:	83 ec 10             	sub    $0x10,%esp
 804cf04:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804cf08:	6a 01                	push   $0x1
 804cf0a:	8d 43 01             	lea    0x1(%ebx),%eax
 804cf0d:	50                   	push   %eax
 804cf0e:	e8 4d e0 ff ff       	call   804af60 <swaddr_read>
 804cf13:	c0 e8 03             	shr    $0x3,%al
 804cf16:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804cf1a:	83 e0 07             	and    $0x7,%eax
 804cf1d:	8b 04 85 80 ff 05 08 	mov    0x805ff80(,%eax,4),%eax
 804cf24:	83 c4 18             	add    $0x18,%esp
 804cf27:	5b                   	pop    %ebx
 804cf28:	ff e0                	jmp    *%eax
 804cf2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804cf30 <group1_sx_v>:
make_group(group1_v,
	add_i2rm_v, or_i2rm_v, adc_i2rm_v, sbb_i2rm_v, 
	and_i2rm_v, sub_i2rm_v, xor_i2rm_v, cmp_i2rm_v)

/* 0x83 */
make_group(group1_sx_v,
 804cf30:	53                   	push   %ebx
 804cf31:	83 ec 10             	sub    $0x10,%esp
 804cf34:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804cf38:	6a 01                	push   $0x1
 804cf3a:	8d 43 01             	lea    0x1(%ebx),%eax
 804cf3d:	50                   	push   %eax
 804cf3e:	e8 1d e0 ff ff       	call   804af60 <swaddr_read>
 804cf43:	c0 e8 03             	shr    $0x3,%al
 804cf46:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804cf4a:	83 e0 07             	and    $0x7,%eax
 804cf4d:	8b 04 85 a0 ff 05 08 	mov    0x805ffa0(,%eax,4),%eax
 804cf54:	83 c4 18             	add    $0x18,%esp
 804cf57:	5b                   	pop    %ebx
 804cf58:	ff e0                	jmp    *%eax
 804cf5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804cf60 <group1_v>:
make_group(group1_b,
	add_i2rm_b, or_i2rm_b, adc_i2rm_b, sbb_i2rm_b, 
	and_i2rm_b, sub_i2rm_b, xor_i2rm_b, cmp_i2rm_b)

/* 0x81 */
make_group(group1_v,
 804cf60:	53                   	push   %ebx
 804cf61:	83 ec 10             	sub    $0x10,%esp
 804cf64:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804cf68:	6a 01                	push   $0x1
 804cf6a:	8d 43 01             	lea    0x1(%ebx),%eax
 804cf6d:	50                   	push   %eax
 804cf6e:	e8 ed df ff ff       	call   804af60 <swaddr_read>
 804cf73:	c0 e8 03             	shr    $0x3,%al
 804cf76:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804cf7a:	83 e0 07             	and    $0x7,%eax
 804cf7d:	8b 04 85 c0 ff 05 08 	mov    0x805ffc0(,%eax,4),%eax
 804cf84:	83 c4 18             	add    $0x18,%esp
 804cf87:	5b                   	pop    %ebx
 804cf88:	ff e0                	jmp    *%eax
 804cf8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804cf90 <group1_b>:
		m.val = instr_fetch(eip + 1, 1); \
		return concat(opcode_table_, name) [m.opcode](eip); \
	}
	
/* 0x80 */
make_group(group1_b,
 804cf90:	53                   	push   %ebx
 804cf91:	83 ec 10             	sub    $0x10,%esp
 804cf94:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804cf98:	6a 01                	push   $0x1
 804cf9a:	8d 43 01             	lea    0x1(%ebx),%eax
 804cf9d:	50                   	push   %eax
 804cf9e:	e8 bd df ff ff       	call   804af60 <swaddr_read>
 804cfa3:	c0 e8 03             	shr    $0x3,%al
 804cfa6:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804cfaa:	83 e0 07             	and    $0x7,%eax
 804cfad:	8b 04 85 e0 ff 05 08 	mov    0x805ffe0(,%eax,4),%eax
 804cfb4:	83 c4 18             	add    $0x18,%esp
 804cfb7:	5b                   	pop    %ebx
 804cfb8:	ff e0                	jmp    *%eax
 804cfba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804cfc0 <_2byte_esc>:
make_helper(exec) {
	ops_decoded.opcode = instr_fetch(eip, 1);
	return opcode_table[ ops_decoded.opcode ](eip);
}

static make_helper(_2byte_esc) {
 804cfc0:	53                   	push   %ebx
 804cfc1:	83 ec 10             	sub    $0x10,%esp
	eip ++;
 804cfc4:	8b 44 24 18          	mov    0x18(%esp),%eax
 804cfc8:	6a 01                	push   $0x1
 804cfca:	8d 58 01             	lea    0x1(%eax),%ebx
 804cfcd:	53                   	push   %ebx
 804cfce:	e8 8d df ff ff       	call   804af60 <swaddr_read>
	uint32_t opcode = instr_fetch(eip, 1);
	ops_decoded.opcode = opcode | 0x100;
 804cfd3:	89 c2                	mov    %eax,%edx
	return _2byte_opcode_table[opcode](eip) + 1; 
 804cfd5:	89 1c 24             	mov    %ebx,(%esp)
}

static make_helper(_2byte_esc) {
	eip ++;
	uint32_t opcode = instr_fetch(eip, 1);
	ops_decoded.opcode = opcode | 0x100;
 804cfd8:	80 ce 01             	or     $0x1,%dh
 804cfdb:	89 15 00 ae 8f 14    	mov    %edx,0x148fae00
	return _2byte_opcode_table[opcode](eip) + 1; 
 804cfe1:	ff 14 85 80 53 07 08 	call   *0x8075380(,%eax,4)
}
 804cfe8:	83 c4 18             	add    $0x18,%esp

static make_helper(_2byte_esc) {
	eip ++;
	uint32_t opcode = instr_fetch(eip, 1);
	ops_decoded.opcode = opcode | 0x100;
	return _2byte_opcode_table[opcode](eip) + 1; 
 804cfeb:	83 c0 01             	add    $0x1,%eax
}
 804cfee:	5b                   	pop    %ebx
 804cfef:	c3                   	ret    

0804cff0 <group7>:

make_group(group6,
	inv, inv, inv, inv, 
	inv, inv, inv, inv)

make_group(group7,
 804cff0:	53                   	push   %ebx
 804cff1:	83 ec 10             	sub    $0x10,%esp
 804cff4:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804cff8:	6a 01                	push   $0x1
 804cffa:	8d 43 01             	lea    0x1(%ebx),%eax
 804cffd:	50                   	push   %eax
 804cffe:	e8 5d df ff ff       	call   804af60 <swaddr_read>
 804d003:	c0 e8 03             	shr    $0x3,%al
 804d006:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804d00a:	83 e0 07             	and    $0x7,%eax
 804d00d:	8b 04 85 20 fe 05 08 	mov    0x805fe20(,%eax,4),%eax
 804d014:	83 c4 18             	add    $0x18,%esp
 804d017:	5b                   	pop    %ebx
 804d018:	ff e0                	jmp    *%eax
 804d01a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804d020 <group6>:
/* 0xff */
make_group(group5,
	inc_rm_v, dec_rm_v, call_rm_v, inv, 
	jmp_rm_v, jmp_rm_v, push_rm_v, inv)

make_group(group6,
 804d020:	53                   	push   %ebx
 804d021:	83 ec 10             	sub    $0x10,%esp
 804d024:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804d028:	6a 01                	push   $0x1
 804d02a:	8d 43 01             	lea    0x1(%ebx),%eax
 804d02d:	50                   	push   %eax
 804d02e:	e8 2d df ff ff       	call   804af60 <swaddr_read>
 804d033:	c0 e8 03             	shr    $0x3,%al
 804d036:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804d03a:	83 e0 07             	and    $0x7,%eax
 804d03d:	8b 04 85 40 fe 05 08 	mov    0x805fe40(,%eax,4),%eax
 804d044:	83 c4 18             	add    $0x18,%esp
 804d047:	5b                   	pop    %ebx
 804d048:	ff e0                	jmp    *%eax
 804d04a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804d050 <exec>:
/* 0xf4 */	inv, inv, inv, inv,
/* 0xf8 */	inv, inv, inv, inv,
/* 0xfc */	inv, inv, inv, inv
};

make_helper(exec) {
 804d050:	53                   	push   %ebx
 804d051:	83 ec 10             	sub    $0x10,%esp
 804d054:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804d058:	6a 01                	push   $0x1
 804d05a:	53                   	push   %ebx
 804d05b:	e8 00 df ff ff       	call   804af60 <swaddr_read>
	ops_decoded.opcode = instr_fetch(eip, 1);
	return opcode_table[ ops_decoded.opcode ](eip);
 804d060:	89 5c 24 20          	mov    %ebx,0x20(%esp)
/* 0xf8 */	inv, inv, inv, inv,
/* 0xfc */	inv, inv, inv, inv
};

make_helper(exec) {
	ops_decoded.opcode = instr_fetch(eip, 1);
 804d064:	a3 00 ae 8f 14       	mov    %eax,0x148fae00
	return opcode_table[ ops_decoded.opcode ](eip);
 804d069:	8b 04 85 80 57 07 08 	mov    0x8075780(,%eax,4),%eax
}
 804d070:	83 c4 18             	add    $0x18,%esp
 804d073:	5b                   	pop    %ebx
/* 0xfc */	inv, inv, inv, inv
};

make_helper(exec) {
	ops_decoded.opcode = instr_fetch(eip, 1);
	return opcode_table[ ops_decoded.opcode ](eip);
 804d074:	ff e0                	jmp    *%eax
 804d076:	66 90                	xchg   %ax,%ax
 804d078:	66 90                	xchg   %ax,%ax
 804d07a:	66 90                	xchg   %ax,%ax
 804d07c:	66 90                	xchg   %ax,%ax
 804d07e:	66 90                	xchg   %ax,%ax

0804d080 <sets_rm_b>:
	int8_t res = cpu.SF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d080:	53                   	push   %ebx
 804d081:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d084:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d088:	83 c0 01             	add    $0x1,%eax
 804d08b:	50                   	push   %eax
 804d08c:	e8 9f fa 00 00       	call   805cb30 <decode_rm_b>
 804d091:	89 c3                	mov    %eax,%ebx

#define instr sets

static void do_execute() {
	int8_t res = cpu.SF;
	OPERAND_W(op_src, res);
 804d093:	58                   	pop    %eax
 804d094:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr sets

static void do_execute() {
	int8_t res = cpu.SF;
 804d095:	0f b6 15 e4 ae 8f 14 	movzbl 0x148faee4,%edx
 804d09c:	c0 ea 07             	shr    $0x7,%dl
	OPERAND_W(op_src, res);
 804d09f:	0f b6 d2             	movzbl %dl,%edx
 804d0a2:	52                   	push   %edx
 804d0a3:	68 08 ae 8f 14       	push   $0x148fae08
 804d0a8:	e8 93 fb 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804d0ad:	68 18 ae 8f 14       	push   $0x148fae18
 804d0b2:	68 00 00 06 08       	push   $0x8060000
 804d0b7:	6a 50                	push   $0x50
 804d0b9:	68 00 89 0c 08       	push   $0x80c8900
 804d0be:	e8 3d ba ff ff       	call   8048b00 <snprintf@plt>
 804d0c3:	83 c4 20             	add    $0x20,%esp
 804d0c6:	83 f8 4f             	cmp    $0x4f,%eax
 804d0c9:	7f 0d                	jg     804d0d8 <sets_rm_b+0x58>
}

make_instr_helper(rm)
 804d0cb:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d0ce:	8d 43 01             	lea    0x1(%ebx),%eax
 804d0d1:	5b                   	pop    %ebx
 804d0d2:	c3                   	ret    
 804d0d3:	90                   	nop
 804d0d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr sets

static void do_execute() {
	int8_t res = cpu.SF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d0d8:	83 ec 0c             	sub    $0xc,%esp
 804d0db:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804d0e1:	e8 7a b8 ff ff       	call   8048960 <fflush@plt>
 804d0e6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d0ec:	6a 07                	push   $0x7
 804d0ee:	6a 01                	push   $0x1
 804d0f0:	68 92 ed 05 08       	push   $0x805ed92
 804d0f5:	e8 16 b9 ff ff       	call   8048a10 <fwrite@plt>
 804d0fa:	83 c4 20             	add    $0x20,%esp
 804d0fd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d103:	6a 10                	push   $0x10
 804d105:	6a 01                	push   $0x1
 804d107:	68 84 f8 05 08       	push   $0x805f884
 804d10c:	e8 ff b8 ff ff       	call   8048a10 <fwrite@plt>
 804d111:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d117:	6a 05                	push   $0x5
 804d119:	6a 01                	push   $0x1
 804d11b:	68 b1 ed 05 08       	push   $0x805edb1
 804d120:	e8 eb b8 ff ff       	call   8048a10 <fwrite@plt>
 804d125:	83 c4 20             	add    $0x20,%esp
 804d128:	68 18 ae 8f 14       	push   $0x148fae18
 804d12d:	68 00 00 06 08       	push   $0x8060000
 804d132:	6a 50                	push   $0x50
 804d134:	68 00 89 0c 08       	push   $0x80c8900
 804d139:	e8 c2 b9 ff ff       	call   8048b00 <snprintf@plt>
 804d13e:	83 c4 10             	add    $0x10,%esp
 804d141:	83 f8 4f             	cmp    $0x4f,%eax
 804d144:	7e 85                	jle    804d0cb <sets_rm_b+0x4b>
 804d146:	68 7b 00 06 08       	push   $0x806007b
 804d14b:	6a 08                	push   $0x8
 804d14d:	68 0c 00 06 08       	push   $0x806000c
 804d152:	68 34 00 06 08       	push   $0x8060034
 804d157:	e8 54 ba ff ff       	call   8048bb0 <__assert_fail@plt>
 804d15c:	66 90                	xchg   %ax,%ax
 804d15e:	66 90                	xchg   %ax,%ax

0804d160 <setb_rm_b>:
	int8_t res = cpu.CF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d160:	53                   	push   %ebx
 804d161:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d164:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d168:	83 c0 01             	add    $0x1,%eax
 804d16b:	50                   	push   %eax
 804d16c:	e8 bf f9 00 00       	call   805cb30 <decode_rm_b>
 804d171:	89 c3                	mov    %eax,%ebx

#define instr setb

static void do_execute() {
	int8_t res = cpu.CF;
	OPERAND_W(op_src, res);
 804d173:	58                   	pop    %eax
 804d174:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setb

static void do_execute() {
	int8_t res = cpu.CF;
 804d175:	0f b6 15 e4 ae 8f 14 	movzbl 0x148faee4,%edx
	OPERAND_W(op_src, res);
 804d17c:	83 e2 01             	and    $0x1,%edx
 804d17f:	52                   	push   %edx
 804d180:	68 08 ae 8f 14       	push   $0x148fae08
 804d185:	e8 b6 fa 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804d18a:	68 18 ae 8f 14       	push   $0x148fae18
 804d18f:	68 85 00 06 08       	push   $0x8060085
 804d194:	6a 50                	push   $0x50
 804d196:	68 00 89 0c 08       	push   $0x80c8900
 804d19b:	e8 60 b9 ff ff       	call   8048b00 <snprintf@plt>
 804d1a0:	83 c4 20             	add    $0x20,%esp
 804d1a3:	83 f8 4f             	cmp    $0x4f,%eax
 804d1a6:	7f 08                	jg     804d1b0 <setb_rm_b+0x50>
}

make_instr_helper(rm)
 804d1a8:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d1ab:	8d 43 01             	lea    0x1(%ebx),%eax
 804d1ae:	5b                   	pop    %ebx
 804d1af:	c3                   	ret    
#define instr setb

static void do_execute() {
	int8_t res = cpu.CF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d1b0:	83 ec 0c             	sub    $0xc,%esp
 804d1b3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804d1b9:	e8 a2 b7 ff ff       	call   8048960 <fflush@plt>
 804d1be:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d1c4:	6a 07                	push   $0x7
 804d1c6:	6a 01                	push   $0x1
 804d1c8:	68 92 ed 05 08       	push   $0x805ed92
 804d1cd:	e8 3e b8 ff ff       	call   8048a10 <fwrite@plt>
 804d1d2:	83 c4 20             	add    $0x20,%esp
 804d1d5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d1db:	6a 10                	push   $0x10
 804d1dd:	6a 01                	push   $0x1
 804d1df:	68 84 f8 05 08       	push   $0x805f884
 804d1e4:	e8 27 b8 ff ff       	call   8048a10 <fwrite@plt>
 804d1e9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d1ef:	6a 05                	push   $0x5
 804d1f1:	6a 01                	push   $0x1
 804d1f3:	68 b1 ed 05 08       	push   $0x805edb1
 804d1f8:	e8 13 b8 ff ff       	call   8048a10 <fwrite@plt>
 804d1fd:	83 c4 20             	add    $0x20,%esp
 804d200:	68 18 ae 8f 14       	push   $0x148fae18
 804d205:	68 85 00 06 08       	push   $0x8060085
 804d20a:	6a 50                	push   $0x50
 804d20c:	68 00 89 0c 08       	push   $0x80c8900
 804d211:	e8 ea b8 ff ff       	call   8048b00 <snprintf@plt>
 804d216:	83 c4 10             	add    $0x10,%esp
 804d219:	83 f8 4f             	cmp    $0x4f,%eax
 804d21c:	7e 8a                	jle    804d1a8 <setb_rm_b+0x48>
 804d21e:	68 ff 00 06 08       	push   $0x80600ff
 804d223:	6a 08                	push   $0x8
 804d225:	68 90 00 06 08       	push   $0x8060090
 804d22a:	68 b8 00 06 08       	push   $0x80600b8
 804d22f:	e8 7c b9 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d234:	66 90                	xchg   %ax,%ax
 804d236:	66 90                	xchg   %ax,%ax
 804d238:	66 90                	xchg   %ax,%ax
 804d23a:	66 90                	xchg   %ax,%ax
 804d23c:	66 90                	xchg   %ax,%ax
 804d23e:	66 90                	xchg   %ax,%ax

0804d240 <setne_rm_b>:
	int8_t res = !cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d240:	53                   	push   %ebx
 804d241:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d244:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d248:	83 c0 01             	add    $0x1,%eax
 804d24b:	50                   	push   %eax
 804d24c:	e8 df f8 00 00       	call   805cb30 <decode_rm_b>
 804d251:	89 c3                	mov    %eax,%ebx

#define instr setne

static void do_execute() {
	int8_t res = !cpu.ZF;
	OPERAND_W(op_src, res);
 804d253:	58                   	pop    %eax
 804d254:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setne

static void do_execute() {
	int8_t res = !cpu.ZF;
 804d255:	0f b6 15 e4 ae 8f 14 	movzbl 0x148faee4,%edx
 804d25c:	c0 ea 06             	shr    $0x6,%dl
 804d25f:	83 f2 01             	xor    $0x1,%edx
 804d262:	83 e2 01             	and    $0x1,%edx
	OPERAND_W(op_src, res);
 804d265:	52                   	push   %edx
 804d266:	68 08 ae 8f 14       	push   $0x148fae08
 804d26b:	e8 d0 f9 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804d270:	68 18 ae 8f 14       	push   $0x148fae18
 804d275:	68 09 01 06 08       	push   $0x8060109
 804d27a:	6a 50                	push   $0x50
 804d27c:	68 00 89 0c 08       	push   $0x80c8900
 804d281:	e8 7a b8 ff ff       	call   8048b00 <snprintf@plt>
 804d286:	83 c4 20             	add    $0x20,%esp
 804d289:	83 f8 4f             	cmp    $0x4f,%eax
 804d28c:	7f 12                	jg     804d2a0 <setne_rm_b+0x60>
}

make_instr_helper(rm)
 804d28e:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d291:	8d 43 01             	lea    0x1(%ebx),%eax
 804d294:	5b                   	pop    %ebx
 804d295:	c3                   	ret    
 804d296:	8d 76 00             	lea    0x0(%esi),%esi
 804d299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#define instr setne

static void do_execute() {
	int8_t res = !cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d2a0:	83 ec 0c             	sub    $0xc,%esp
 804d2a3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804d2a9:	e8 b2 b6 ff ff       	call   8048960 <fflush@plt>
 804d2ae:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d2b4:	6a 07                	push   $0x7
 804d2b6:	6a 01                	push   $0x1
 804d2b8:	68 92 ed 05 08       	push   $0x805ed92
 804d2bd:	e8 4e b7 ff ff       	call   8048a10 <fwrite@plt>
 804d2c2:	83 c4 20             	add    $0x20,%esp
 804d2c5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d2cb:	6a 10                	push   $0x10
 804d2cd:	6a 01                	push   $0x1
 804d2cf:	68 84 f8 05 08       	push   $0x805f884
 804d2d4:	e8 37 b7 ff ff       	call   8048a10 <fwrite@plt>
 804d2d9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d2df:	6a 05                	push   $0x5
 804d2e1:	6a 01                	push   $0x1
 804d2e3:	68 b1 ed 05 08       	push   $0x805edb1
 804d2e8:	e8 23 b7 ff ff       	call   8048a10 <fwrite@plt>
 804d2ed:	83 c4 20             	add    $0x20,%esp
 804d2f0:	68 18 ae 8f 14       	push   $0x148fae18
 804d2f5:	68 09 01 06 08       	push   $0x8060109
 804d2fa:	6a 50                	push   $0x50
 804d2fc:	68 00 89 0c 08       	push   $0x80c8900
 804d301:	e8 fa b7 ff ff       	call   8048b00 <snprintf@plt>
 804d306:	83 c4 10             	add    $0x10,%esp
 804d309:	83 f8 4f             	cmp    $0x4f,%eax
 804d30c:	7e 80                	jle    804d28e <setne_rm_b+0x4e>
 804d30e:	68 88 01 06 08       	push   $0x8060188
 804d313:	6a 08                	push   $0x8
 804d315:	68 14 01 06 08       	push   $0x8060114
 804d31a:	68 40 01 06 08       	push   $0x8060140
 804d31f:	e8 8c b8 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d324:	66 90                	xchg   %ax,%ax
 804d326:	66 90                	xchg   %ax,%ax
 804d328:	66 90                	xchg   %ax,%ax
 804d32a:	66 90                	xchg   %ax,%ax
 804d32c:	66 90                	xchg   %ax,%ax
 804d32e:	66 90                	xchg   %ax,%ax

0804d330 <sete_rm_b>:
	int8_t res = cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d330:	53                   	push   %ebx
 804d331:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d334:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d338:	83 c0 01             	add    $0x1,%eax
 804d33b:	50                   	push   %eax
 804d33c:	e8 ef f7 00 00       	call   805cb30 <decode_rm_b>
 804d341:	89 c3                	mov    %eax,%ebx

#define instr sete

static void do_execute() {
	int8_t res = cpu.ZF;
	OPERAND_W(op_src, res);
 804d343:	58                   	pop    %eax
 804d344:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr sete

static void do_execute() {
	int8_t res = cpu.ZF;
 804d345:	0f b6 15 e4 ae 8f 14 	movzbl 0x148faee4,%edx
 804d34c:	c0 ea 06             	shr    $0x6,%dl
	OPERAND_W(op_src, res);
 804d34f:	83 e2 01             	and    $0x1,%edx
 804d352:	52                   	push   %edx
 804d353:	68 08 ae 8f 14       	push   $0x148fae08
 804d358:	e8 e3 f8 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804d35d:	68 18 ae 8f 14       	push   $0x148fae18
 804d362:	68 93 01 06 08       	push   $0x8060193
 804d367:	6a 50                	push   $0x50
 804d369:	68 00 89 0c 08       	push   $0x80c8900
 804d36e:	e8 8d b7 ff ff       	call   8048b00 <snprintf@plt>
 804d373:	83 c4 20             	add    $0x20,%esp
 804d376:	83 f8 4f             	cmp    $0x4f,%eax
 804d379:	7f 0d                	jg     804d388 <sete_rm_b+0x58>
}

make_instr_helper(rm)
 804d37b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d37e:	8d 43 01             	lea    0x1(%ebx),%eax
 804d381:	5b                   	pop    %ebx
 804d382:	c3                   	ret    
 804d383:	90                   	nop
 804d384:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr sete

static void do_execute() {
	int8_t res = cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d388:	83 ec 0c             	sub    $0xc,%esp
 804d38b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804d391:	e8 ca b5 ff ff       	call   8048960 <fflush@plt>
 804d396:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d39c:	6a 07                	push   $0x7
 804d39e:	6a 01                	push   $0x1
 804d3a0:	68 92 ed 05 08       	push   $0x805ed92
 804d3a5:	e8 66 b6 ff ff       	call   8048a10 <fwrite@plt>
 804d3aa:	83 c4 20             	add    $0x20,%esp
 804d3ad:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d3b3:	6a 10                	push   $0x10
 804d3b5:	6a 01                	push   $0x1
 804d3b7:	68 84 f8 05 08       	push   $0x805f884
 804d3bc:	e8 4f b6 ff ff       	call   8048a10 <fwrite@plt>
 804d3c1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d3c7:	6a 05                	push   $0x5
 804d3c9:	6a 01                	push   $0x1
 804d3cb:	68 b1 ed 05 08       	push   $0x805edb1
 804d3d0:	e8 3b b6 ff ff       	call   8048a10 <fwrite@plt>
 804d3d5:	83 c4 20             	add    $0x20,%esp
 804d3d8:	68 18 ae 8f 14       	push   $0x148fae18
 804d3dd:	68 93 01 06 08       	push   $0x8060193
 804d3e2:	6a 50                	push   $0x50
 804d3e4:	68 00 89 0c 08       	push   $0x80c8900
 804d3e9:	e8 12 b7 ff ff       	call   8048b00 <snprintf@plt>
 804d3ee:	83 c4 10             	add    $0x10,%esp
 804d3f1:	83 f8 4f             	cmp    $0x4f,%eax
 804d3f4:	7e 85                	jle    804d37b <sete_rm_b+0x4b>
 804d3f6:	68 0b 02 06 08       	push   $0x806020b
 804d3fb:	6a 08                	push   $0x8
 804d3fd:	68 9c 01 06 08       	push   $0x806019c
 804d402:	68 c4 01 06 08       	push   $0x80601c4
 804d407:	e8 a4 b7 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d40c:	66 90                	xchg   %ax,%ax
 804d40e:	66 90                	xchg   %ax,%ax

0804d410 <setns_rm_b>:
	int8_t res = !cpu.SF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d410:	53                   	push   %ebx
 804d411:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d414:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d418:	83 c0 01             	add    $0x1,%eax
 804d41b:	50                   	push   %eax
 804d41c:	e8 0f f7 00 00       	call   805cb30 <decode_rm_b>
 804d421:	89 c3                	mov    %eax,%ebx

#define instr setns

static void do_execute() {
	int8_t res = !cpu.SF;
	OPERAND_W(op_src, res);
 804d423:	58                   	pop    %eax
 804d424:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setns

static void do_execute() {
	int8_t res = !cpu.SF;
 804d425:	0f be 15 e4 ae 8f 14 	movsbl 0x148faee4,%edx
 804d42c:	f7 d2                	not    %edx
 804d42e:	c1 ea 1f             	shr    $0x1f,%edx
	OPERAND_W(op_src, res);
 804d431:	52                   	push   %edx
 804d432:	68 08 ae 8f 14       	push   $0x148fae08
 804d437:	e8 04 f8 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804d43c:	68 18 ae 8f 14       	push   $0x148fae18
 804d441:	68 15 02 06 08       	push   $0x8060215
 804d446:	6a 50                	push   $0x50
 804d448:	68 00 89 0c 08       	push   $0x80c8900
 804d44d:	e8 ae b6 ff ff       	call   8048b00 <snprintf@plt>
 804d452:	83 c4 20             	add    $0x20,%esp
 804d455:	83 f8 4f             	cmp    $0x4f,%eax
 804d458:	7f 0e                	jg     804d468 <setns_rm_b+0x58>
}

make_instr_helper(rm)
 804d45a:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d45d:	8d 43 01             	lea    0x1(%ebx),%eax
 804d460:	5b                   	pop    %ebx
 804d461:	c3                   	ret    
 804d462:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define instr setns

static void do_execute() {
	int8_t res = !cpu.SF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d468:	83 ec 0c             	sub    $0xc,%esp
 804d46b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804d471:	e8 ea b4 ff ff       	call   8048960 <fflush@plt>
 804d476:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d47c:	6a 07                	push   $0x7
 804d47e:	6a 01                	push   $0x1
 804d480:	68 92 ed 05 08       	push   $0x805ed92
 804d485:	e8 86 b5 ff ff       	call   8048a10 <fwrite@plt>
 804d48a:	83 c4 20             	add    $0x20,%esp
 804d48d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d493:	6a 10                	push   $0x10
 804d495:	6a 01                	push   $0x1
 804d497:	68 84 f8 05 08       	push   $0x805f884
 804d49c:	e8 6f b5 ff ff       	call   8048a10 <fwrite@plt>
 804d4a1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d4a7:	6a 05                	push   $0x5
 804d4a9:	6a 01                	push   $0x1
 804d4ab:	68 b1 ed 05 08       	push   $0x805edb1
 804d4b0:	e8 5b b5 ff ff       	call   8048a10 <fwrite@plt>
 804d4b5:	83 c4 20             	add    $0x20,%esp
 804d4b8:	68 18 ae 8f 14       	push   $0x148fae18
 804d4bd:	68 15 02 06 08       	push   $0x8060215
 804d4c2:	6a 50                	push   $0x50
 804d4c4:	68 00 89 0c 08       	push   $0x80c8900
 804d4c9:	e8 32 b6 ff ff       	call   8048b00 <snprintf@plt>
 804d4ce:	83 c4 10             	add    $0x10,%esp
 804d4d1:	83 f8 4f             	cmp    $0x4f,%eax
 804d4d4:	7e 84                	jle    804d45a <setns_rm_b+0x4a>
 804d4d6:	68 94 02 06 08       	push   $0x8060294
 804d4db:	6a 08                	push   $0x8
 804d4dd:	68 20 02 06 08       	push   $0x8060220
 804d4e2:	68 4c 02 06 08       	push   $0x806024c
 804d4e7:	e8 c4 b6 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d4ec:	66 90                	xchg   %ax,%ax
 804d4ee:	66 90                	xchg   %ax,%ax

0804d4f0 <setnp_rm_b>:
	int8_t res = !cpu.PF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d4f0:	53                   	push   %ebx
 804d4f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d4f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d4f8:	83 c0 01             	add    $0x1,%eax
 804d4fb:	50                   	push   %eax
 804d4fc:	e8 2f f6 00 00       	call   805cb30 <decode_rm_b>
 804d501:	89 c3                	mov    %eax,%ebx

#define instr setnp

static void do_execute() {
	int8_t res = !cpu.PF;
	OPERAND_W(op_src, res);
 804d503:	58                   	pop    %eax
 804d504:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setnp

static void do_execute() {
	int8_t res = !cpu.PF;
 804d505:	0f b6 15 e4 ae 8f 14 	movzbl 0x148faee4,%edx
 804d50c:	c0 ea 02             	shr    $0x2,%dl
 804d50f:	83 f2 01             	xor    $0x1,%edx
 804d512:	83 e2 01             	and    $0x1,%edx
	OPERAND_W(op_src, res);
 804d515:	52                   	push   %edx
 804d516:	68 08 ae 8f 14       	push   $0x148fae08
 804d51b:	e8 20 f7 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804d520:	68 18 ae 8f 14       	push   $0x148fae18
 804d525:	68 9f 02 06 08       	push   $0x806029f
 804d52a:	6a 50                	push   $0x50
 804d52c:	68 00 89 0c 08       	push   $0x80c8900
 804d531:	e8 ca b5 ff ff       	call   8048b00 <snprintf@plt>
 804d536:	83 c4 20             	add    $0x20,%esp
 804d539:	83 f8 4f             	cmp    $0x4f,%eax
 804d53c:	7f 12                	jg     804d550 <setnp_rm_b+0x60>
}

make_instr_helper(rm)
 804d53e:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d541:	8d 43 01             	lea    0x1(%ebx),%eax
 804d544:	5b                   	pop    %ebx
 804d545:	c3                   	ret    
 804d546:	8d 76 00             	lea    0x0(%esi),%esi
 804d549:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#define instr setnp

static void do_execute() {
	int8_t res = !cpu.PF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d550:	83 ec 0c             	sub    $0xc,%esp
 804d553:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804d559:	e8 02 b4 ff ff       	call   8048960 <fflush@plt>
 804d55e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d564:	6a 07                	push   $0x7
 804d566:	6a 01                	push   $0x1
 804d568:	68 92 ed 05 08       	push   $0x805ed92
 804d56d:	e8 9e b4 ff ff       	call   8048a10 <fwrite@plt>
 804d572:	83 c4 20             	add    $0x20,%esp
 804d575:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d57b:	6a 10                	push   $0x10
 804d57d:	6a 01                	push   $0x1
 804d57f:	68 84 f8 05 08       	push   $0x805f884
 804d584:	e8 87 b4 ff ff       	call   8048a10 <fwrite@plt>
 804d589:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d58f:	6a 05                	push   $0x5
 804d591:	6a 01                	push   $0x1
 804d593:	68 b1 ed 05 08       	push   $0x805edb1
 804d598:	e8 73 b4 ff ff       	call   8048a10 <fwrite@plt>
 804d59d:	83 c4 20             	add    $0x20,%esp
 804d5a0:	68 18 ae 8f 14       	push   $0x148fae18
 804d5a5:	68 9f 02 06 08       	push   $0x806029f
 804d5aa:	6a 50                	push   $0x50
 804d5ac:	68 00 89 0c 08       	push   $0x80c8900
 804d5b1:	e8 4a b5 ff ff       	call   8048b00 <snprintf@plt>
 804d5b6:	83 c4 10             	add    $0x10,%esp
 804d5b9:	83 f8 4f             	cmp    $0x4f,%eax
 804d5bc:	7e 80                	jle    804d53e <setnp_rm_b+0x4e>
 804d5be:	68 20 03 06 08       	push   $0x8060320
 804d5c3:	6a 08                	push   $0x8
 804d5c5:	68 ac 02 06 08       	push   $0x80602ac
 804d5ca:	68 d8 02 06 08       	push   $0x80602d8
 804d5cf:	e8 dc b5 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d5d4:	66 90                	xchg   %ax,%ax
 804d5d6:	66 90                	xchg   %ax,%ax
 804d5d8:	66 90                	xchg   %ax,%ax
 804d5da:	66 90                	xchg   %ax,%ax
 804d5dc:	66 90                	xchg   %ax,%ax
 804d5de:	66 90                	xchg   %ax,%ax

0804d5e0 <setno_rm_b>:
	int8_t res = !cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d5e0:	53                   	push   %ebx
 804d5e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d5e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d5e8:	83 c0 01             	add    $0x1,%eax
 804d5eb:	50                   	push   %eax
 804d5ec:	e8 3f f5 00 00       	call   805cb30 <decode_rm_b>
 804d5f1:	89 c3                	mov    %eax,%ebx

#define instr setno

static void do_execute() {
	int8_t res = !cpu.OF;
	OPERAND_W(op_src, res);
 804d5f3:	58                   	pop    %eax
 804d5f4:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setno

static void do_execute() {
	int8_t res = !cpu.OF;
 804d5f5:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 804d5fc:	c0 ea 03             	shr    $0x3,%dl
 804d5ff:	83 f2 01             	xor    $0x1,%edx
 804d602:	83 e2 01             	and    $0x1,%edx
	OPERAND_W(op_src, res);
 804d605:	52                   	push   %edx
 804d606:	68 08 ae 8f 14       	push   $0x148fae08
 804d60b:	e8 30 f6 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804d610:	68 18 ae 8f 14       	push   $0x148fae18
 804d615:	68 2b 03 06 08       	push   $0x806032b
 804d61a:	6a 50                	push   $0x50
 804d61c:	68 00 89 0c 08       	push   $0x80c8900
 804d621:	e8 da b4 ff ff       	call   8048b00 <snprintf@plt>
 804d626:	83 c4 20             	add    $0x20,%esp
 804d629:	83 f8 4f             	cmp    $0x4f,%eax
 804d62c:	7f 12                	jg     804d640 <setno_rm_b+0x60>
}

make_instr_helper(rm)
 804d62e:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d631:	8d 43 01             	lea    0x1(%ebx),%eax
 804d634:	5b                   	pop    %ebx
 804d635:	c3                   	ret    
 804d636:	8d 76 00             	lea    0x0(%esi),%esi
 804d639:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#define instr setno

static void do_execute() {
	int8_t res = !cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d640:	83 ec 0c             	sub    $0xc,%esp
 804d643:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804d649:	e8 12 b3 ff ff       	call   8048960 <fflush@plt>
 804d64e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d654:	6a 07                	push   $0x7
 804d656:	6a 01                	push   $0x1
 804d658:	68 92 ed 05 08       	push   $0x805ed92
 804d65d:	e8 ae b3 ff ff       	call   8048a10 <fwrite@plt>
 804d662:	83 c4 20             	add    $0x20,%esp
 804d665:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d66b:	6a 10                	push   $0x10
 804d66d:	6a 01                	push   $0x1
 804d66f:	68 84 f8 05 08       	push   $0x805f884
 804d674:	e8 97 b3 ff ff       	call   8048a10 <fwrite@plt>
 804d679:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d67f:	6a 05                	push   $0x5
 804d681:	6a 01                	push   $0x1
 804d683:	68 b1 ed 05 08       	push   $0x805edb1
 804d688:	e8 83 b3 ff ff       	call   8048a10 <fwrite@plt>
 804d68d:	83 c4 20             	add    $0x20,%esp
 804d690:	68 18 ae 8f 14       	push   $0x148fae18
 804d695:	68 2b 03 06 08       	push   $0x806032b
 804d69a:	6a 50                	push   $0x50
 804d69c:	68 00 89 0c 08       	push   $0x80c8900
 804d6a1:	e8 5a b4 ff ff       	call   8048b00 <snprintf@plt>
 804d6a6:	83 c4 10             	add    $0x10,%esp
 804d6a9:	83 f8 4f             	cmp    $0x4f,%eax
 804d6ac:	7e 80                	jle    804d62e <setno_rm_b+0x4e>
 804d6ae:	68 ac 03 06 08       	push   $0x80603ac
 804d6b3:	6a 08                	push   $0x8
 804d6b5:	68 38 03 06 08       	push   $0x8060338
 804d6ba:	68 64 03 06 08       	push   $0x8060364
 804d6bf:	e8 ec b4 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d6c4:	66 90                	xchg   %ax,%ax
 804d6c6:	66 90                	xchg   %ax,%ax
 804d6c8:	66 90                	xchg   %ax,%ax
 804d6ca:	66 90                	xchg   %ax,%ax
 804d6cc:	66 90                	xchg   %ax,%ax
 804d6ce:	66 90                	xchg   %ax,%ax

0804d6d0 <setae_rm_b>:
	int8_t res = !cpu.CF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d6d0:	53                   	push   %ebx
 804d6d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d6d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d6d8:	83 c0 01             	add    $0x1,%eax
 804d6db:	50                   	push   %eax
 804d6dc:	e8 4f f4 00 00       	call   805cb30 <decode_rm_b>
 804d6e1:	89 c3                	mov    %eax,%ebx

#define instr setae

static void do_execute() {
	int8_t res = !cpu.CF;
	OPERAND_W(op_src, res);
 804d6e3:	58                   	pop    %eax
 804d6e4:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setae

static void do_execute() {
	int8_t res = !cpu.CF;
 804d6e5:	0f b6 15 e4 ae 8f 14 	movzbl 0x148faee4,%edx
 804d6ec:	f7 d2                	not    %edx
	OPERAND_W(op_src, res);
 804d6ee:	83 e2 01             	and    $0x1,%edx
 804d6f1:	52                   	push   %edx
 804d6f2:	68 08 ae 8f 14       	push   $0x148fae08
 804d6f7:	e8 44 f5 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804d6fc:	68 18 ae 8f 14       	push   $0x148fae18
 804d701:	68 b7 03 06 08       	push   $0x80603b7
 804d706:	6a 50                	push   $0x50
 804d708:	68 00 89 0c 08       	push   $0x80c8900
 804d70d:	e8 ee b3 ff ff       	call   8048b00 <snprintf@plt>
 804d712:	83 c4 20             	add    $0x20,%esp
 804d715:	83 f8 4f             	cmp    $0x4f,%eax
 804d718:	7f 0e                	jg     804d728 <setae_rm_b+0x58>
}

make_instr_helper(rm)
 804d71a:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d71d:	8d 43 01             	lea    0x1(%ebx),%eax
 804d720:	5b                   	pop    %ebx
 804d721:	c3                   	ret    
 804d722:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define instr setae

static void do_execute() {
	int8_t res = !cpu.CF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d728:	83 ec 0c             	sub    $0xc,%esp
 804d72b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804d731:	e8 2a b2 ff ff       	call   8048960 <fflush@plt>
 804d736:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d73c:	6a 07                	push   $0x7
 804d73e:	6a 01                	push   $0x1
 804d740:	68 92 ed 05 08       	push   $0x805ed92
 804d745:	e8 c6 b2 ff ff       	call   8048a10 <fwrite@plt>
 804d74a:	83 c4 20             	add    $0x20,%esp
 804d74d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d753:	6a 10                	push   $0x10
 804d755:	6a 01                	push   $0x1
 804d757:	68 84 f8 05 08       	push   $0x805f884
 804d75c:	e8 af b2 ff ff       	call   8048a10 <fwrite@plt>
 804d761:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d767:	6a 05                	push   $0x5
 804d769:	6a 01                	push   $0x1
 804d76b:	68 b1 ed 05 08       	push   $0x805edb1
 804d770:	e8 9b b2 ff ff       	call   8048a10 <fwrite@plt>
 804d775:	83 c4 20             	add    $0x20,%esp
 804d778:	68 18 ae 8f 14       	push   $0x148fae18
 804d77d:	68 b7 03 06 08       	push   $0x80603b7
 804d782:	6a 50                	push   $0x50
 804d784:	68 00 89 0c 08       	push   $0x80c8900
 804d789:	e8 72 b3 ff ff       	call   8048b00 <snprintf@plt>
 804d78e:	83 c4 10             	add    $0x10,%esp
 804d791:	83 f8 4f             	cmp    $0x4f,%eax
 804d794:	7e 84                	jle    804d71a <setae_rm_b+0x4a>
 804d796:	68 38 04 06 08       	push   $0x8060438
 804d79b:	6a 08                	push   $0x8
 804d79d:	68 c4 03 06 08       	push   $0x80603c4
 804d7a2:	68 f0 03 06 08       	push   $0x80603f0
 804d7a7:	e8 04 b4 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d7ac:	66 90                	xchg   %ax,%ax
 804d7ae:	66 90                	xchg   %ax,%ax

0804d7b0 <setle_rm_b>:
	int8_t res = cpu.ZF || cpu.SF != cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d7b0:	53                   	push   %ebx
 804d7b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d7b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d7b8:	83 c0 01             	add    $0x1,%eax
 804d7bb:	50                   	push   %eax
 804d7bc:	e8 6f f3 00 00       	call   805cb30 <decode_rm_b>
 804d7c1:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr setle

static void do_execute() {
	int8_t res = cpu.ZF || cpu.SF != cpu.OF;
 804d7c3:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 804d7ca:	83 c4 10             	add    $0x10,%esp
 804d7cd:	ba 01 00 00 00       	mov    $0x1,%edx
 804d7d2:	a8 40                	test   $0x40,%al
 804d7d4:	75 15                	jne    804d7eb <setle_rm_b+0x3b>
 804d7d6:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 804d7dd:	c0 e8 07             	shr    $0x7,%al
 804d7e0:	c0 ea 03             	shr    $0x3,%dl
 804d7e3:	83 e2 01             	and    $0x1,%edx
 804d7e6:	31 c2                	xor    %eax,%edx
 804d7e8:	0f b6 d2             	movzbl %dl,%edx
	OPERAND_W(op_src, res);
 804d7eb:	83 ec 08             	sub    $0x8,%esp
 804d7ee:	52                   	push   %edx
 804d7ef:	68 08 ae 8f 14       	push   $0x148fae08
 804d7f4:	e8 47 f4 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804d7f9:	68 18 ae 8f 14       	push   $0x148fae18
 804d7fe:	68 43 04 06 08       	push   $0x8060443
 804d803:	6a 50                	push   $0x50
 804d805:	68 00 89 0c 08       	push   $0x80c8900
 804d80a:	e8 f1 b2 ff ff       	call   8048b00 <snprintf@plt>
 804d80f:	83 c4 20             	add    $0x20,%esp
 804d812:	83 f8 4f             	cmp    $0x4f,%eax
 804d815:	7f 09                	jg     804d820 <setle_rm_b+0x70>
}

make_instr_helper(rm)
 804d817:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d81a:	8d 43 01             	lea    0x1(%ebx),%eax
 804d81d:	5b                   	pop    %ebx
 804d81e:	c3                   	ret    
 804d81f:	90                   	nop
#define instr setle

static void do_execute() {
	int8_t res = cpu.ZF || cpu.SF != cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d820:	83 ec 0c             	sub    $0xc,%esp
 804d823:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804d829:	e8 32 b1 ff ff       	call   8048960 <fflush@plt>
 804d82e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d834:	6a 07                	push   $0x7
 804d836:	6a 01                	push   $0x1
 804d838:	68 92 ed 05 08       	push   $0x805ed92
 804d83d:	e8 ce b1 ff ff       	call   8048a10 <fwrite@plt>
 804d842:	83 c4 20             	add    $0x20,%esp
 804d845:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d84b:	6a 10                	push   $0x10
 804d84d:	6a 01                	push   $0x1
 804d84f:	68 84 f8 05 08       	push   $0x805f884
 804d854:	e8 b7 b1 ff ff       	call   8048a10 <fwrite@plt>
 804d859:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d85f:	6a 05                	push   $0x5
 804d861:	6a 01                	push   $0x1
 804d863:	68 b1 ed 05 08       	push   $0x805edb1
 804d868:	e8 a3 b1 ff ff       	call   8048a10 <fwrite@plt>
 804d86d:	83 c4 20             	add    $0x20,%esp
 804d870:	68 18 ae 8f 14       	push   $0x148fae18
 804d875:	68 43 04 06 08       	push   $0x8060443
 804d87a:	6a 50                	push   $0x50
 804d87c:	68 00 89 0c 08       	push   $0x80c8900
 804d881:	e8 7a b2 ff ff       	call   8048b00 <snprintf@plt>
 804d886:	83 c4 10             	add    $0x10,%esp
 804d889:	83 f8 4f             	cmp    $0x4f,%eax
 804d88c:	7e 89                	jle    804d817 <setle_rm_b+0x67>
 804d88e:	68 c4 04 06 08       	push   $0x80604c4
 804d893:	6a 08                	push   $0x8
 804d895:	68 50 04 06 08       	push   $0x8060450
 804d89a:	68 7c 04 06 08       	push   $0x806047c
 804d89f:	e8 0c b3 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d8a4:	66 90                	xchg   %ax,%ax
 804d8a6:	66 90                	xchg   %ax,%ax
 804d8a8:	66 90                	xchg   %ax,%ax
 804d8aa:	66 90                	xchg   %ax,%ax
 804d8ac:	66 90                	xchg   %ax,%ax
 804d8ae:	66 90                	xchg   %ax,%ax

0804d8b0 <seta_rm_b>:
	int8_t res = !cpu.CF && !cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d8b0:	53                   	push   %ebx
 804d8b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d8b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d8b8:	83 c0 01             	add    $0x1,%eax
 804d8bb:	50                   	push   %eax
 804d8bc:	e8 6f f2 00 00       	call   805cb30 <decode_rm_b>
 804d8c1:	89 c3                	mov    %eax,%ebx

#define instr seta

static void do_execute() {
	int8_t res = !cpu.CF && !cpu.ZF;
	OPERAND_W(op_src, res);
 804d8c3:	58                   	pop    %eax
#include "cpu/exec/template-start.h"

#define instr seta

static void do_execute() {
	int8_t res = !cpu.CF && !cpu.ZF;
 804d8c4:	31 c0                	xor    %eax,%eax
 804d8c6:	f6 05 e4 ae 8f 14 41 	testb  $0x41,0x148faee4
	OPERAND_W(op_src, res);
 804d8cd:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr seta

static void do_execute() {
	int8_t res = !cpu.CF && !cpu.ZF;
 804d8ce:	0f 94 c0             	sete   %al
	OPERAND_W(op_src, res);
 804d8d1:	50                   	push   %eax
 804d8d2:	68 08 ae 8f 14       	push   $0x148fae08
 804d8d7:	e8 64 f3 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804d8dc:	68 18 ae 8f 14       	push   $0x148fae18
 804d8e1:	68 cf 04 06 08       	push   $0x80604cf
 804d8e6:	6a 50                	push   $0x50
 804d8e8:	68 00 89 0c 08       	push   $0x80c8900
 804d8ed:	e8 0e b2 ff ff       	call   8048b00 <snprintf@plt>
 804d8f2:	83 c4 20             	add    $0x20,%esp
 804d8f5:	83 f8 4f             	cmp    $0x4f,%eax
 804d8f8:	7f 0e                	jg     804d908 <seta_rm_b+0x58>
}

make_instr_helper(rm)
 804d8fa:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d8fd:	8d 43 01             	lea    0x1(%ebx),%eax
 804d900:	5b                   	pop    %ebx
 804d901:	c3                   	ret    
 804d902:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define instr seta

static void do_execute() {
	int8_t res = !cpu.CF && !cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d908:	83 ec 0c             	sub    $0xc,%esp
 804d90b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804d911:	e8 4a b0 ff ff       	call   8048960 <fflush@plt>
 804d916:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d91c:	6a 07                	push   $0x7
 804d91e:	6a 01                	push   $0x1
 804d920:	68 92 ed 05 08       	push   $0x805ed92
 804d925:	e8 e6 b0 ff ff       	call   8048a10 <fwrite@plt>
 804d92a:	83 c4 20             	add    $0x20,%esp
 804d92d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d933:	6a 10                	push   $0x10
 804d935:	6a 01                	push   $0x1
 804d937:	68 84 f8 05 08       	push   $0x805f884
 804d93c:	e8 cf b0 ff ff       	call   8048a10 <fwrite@plt>
 804d941:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d947:	6a 05                	push   $0x5
 804d949:	6a 01                	push   $0x1
 804d94b:	68 b1 ed 05 08       	push   $0x805edb1
 804d950:	e8 bb b0 ff ff       	call   8048a10 <fwrite@plt>
 804d955:	83 c4 20             	add    $0x20,%esp
 804d958:	68 18 ae 8f 14       	push   $0x148fae18
 804d95d:	68 cf 04 06 08       	push   $0x80604cf
 804d962:	6a 50                	push   $0x50
 804d964:	68 00 89 0c 08       	push   $0x80c8900
 804d969:	e8 92 b1 ff ff       	call   8048b00 <snprintf@plt>
 804d96e:	83 c4 10             	add    $0x10,%esp
 804d971:	83 f8 4f             	cmp    $0x4f,%eax
 804d974:	7e 84                	jle    804d8fa <seta_rm_b+0x4a>
 804d976:	68 47 05 06 08       	push   $0x8060547
 804d97b:	6a 08                	push   $0x8
 804d97d:	68 d8 04 06 08       	push   $0x80604d8
 804d982:	68 00 05 06 08       	push   $0x8060500
 804d987:	e8 24 b2 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d98c:	66 90                	xchg   %ax,%ax
 804d98e:	66 90                	xchg   %ax,%ax

0804d990 <setp_rm_b>:
	int8_t res = cpu.PF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d990:	53                   	push   %ebx
 804d991:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d994:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d998:	83 c0 01             	add    $0x1,%eax
 804d99b:	50                   	push   %eax
 804d99c:	e8 8f f1 00 00       	call   805cb30 <decode_rm_b>
 804d9a1:	89 c3                	mov    %eax,%ebx

#define instr setp

static void do_execute() {
	int8_t res = cpu.PF;
	OPERAND_W(op_src, res);
 804d9a3:	58                   	pop    %eax
 804d9a4:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setp

static void do_execute() {
	int8_t res = cpu.PF;
 804d9a5:	0f b6 15 e4 ae 8f 14 	movzbl 0x148faee4,%edx
 804d9ac:	c0 ea 02             	shr    $0x2,%dl
	OPERAND_W(op_src, res);
 804d9af:	83 e2 01             	and    $0x1,%edx
 804d9b2:	52                   	push   %edx
 804d9b3:	68 08 ae 8f 14       	push   $0x148fae08
 804d9b8:	e8 83 f2 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804d9bd:	68 18 ae 8f 14       	push   $0x148fae18
 804d9c2:	68 51 05 06 08       	push   $0x8060551
 804d9c7:	6a 50                	push   $0x50
 804d9c9:	68 00 89 0c 08       	push   $0x80c8900
 804d9ce:	e8 2d b1 ff ff       	call   8048b00 <snprintf@plt>
 804d9d3:	83 c4 20             	add    $0x20,%esp
 804d9d6:	83 f8 4f             	cmp    $0x4f,%eax
 804d9d9:	7f 0d                	jg     804d9e8 <setp_rm_b+0x58>
}

make_instr_helper(rm)
 804d9db:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d9de:	8d 43 01             	lea    0x1(%ebx),%eax
 804d9e1:	5b                   	pop    %ebx
 804d9e2:	c3                   	ret    
 804d9e3:	90                   	nop
 804d9e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr setp

static void do_execute() {
	int8_t res = cpu.PF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d9e8:	83 ec 0c             	sub    $0xc,%esp
 804d9eb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804d9f1:	e8 6a af ff ff       	call   8048960 <fflush@plt>
 804d9f6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804d9fc:	6a 07                	push   $0x7
 804d9fe:	6a 01                	push   $0x1
 804da00:	68 92 ed 05 08       	push   $0x805ed92
 804da05:	e8 06 b0 ff ff       	call   8048a10 <fwrite@plt>
 804da0a:	83 c4 20             	add    $0x20,%esp
 804da0d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804da13:	6a 10                	push   $0x10
 804da15:	6a 01                	push   $0x1
 804da17:	68 84 f8 05 08       	push   $0x805f884
 804da1c:	e8 ef af ff ff       	call   8048a10 <fwrite@plt>
 804da21:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804da27:	6a 05                	push   $0x5
 804da29:	6a 01                	push   $0x1
 804da2b:	68 b1 ed 05 08       	push   $0x805edb1
 804da30:	e8 db af ff ff       	call   8048a10 <fwrite@plt>
 804da35:	83 c4 20             	add    $0x20,%esp
 804da38:	68 18 ae 8f 14       	push   $0x148fae18
 804da3d:	68 51 05 06 08       	push   $0x8060551
 804da42:	6a 50                	push   $0x50
 804da44:	68 00 89 0c 08       	push   $0x80c8900
 804da49:	e8 b2 b0 ff ff       	call   8048b00 <snprintf@plt>
 804da4e:	83 c4 10             	add    $0x10,%esp
 804da51:	83 f8 4f             	cmp    $0x4f,%eax
 804da54:	7e 85                	jle    804d9db <setp_rm_b+0x4b>
 804da56:	68 cb 05 06 08       	push   $0x80605cb
 804da5b:	6a 08                	push   $0x8
 804da5d:	68 5c 05 06 08       	push   $0x806055c
 804da62:	68 84 05 06 08       	push   $0x8060584
 804da67:	e8 44 b1 ff ff       	call   8048bb0 <__assert_fail@plt>
 804da6c:	66 90                	xchg   %ax,%ax
 804da6e:	66 90                	xchg   %ax,%ax

0804da70 <setge_rm_b>:
	int8_t res = cpu.SF == cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804da70:	53                   	push   %ebx
 804da71:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804da74:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804da78:	83 c0 01             	add    $0x1,%eax
 804da7b:	50                   	push   %eax
 804da7c:	e8 af f0 00 00       	call   805cb30 <decode_rm_b>
 804da81:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr setge

static void do_execute() {
	int8_t res = cpu.SF == cpu.OF;
 804da83:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
	OPERAND_W(op_src, res);
 804da8a:	58                   	pop    %eax
 804da8b:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setge

static void do_execute() {
	int8_t res = cpu.SF == cpu.OF;
 804da8c:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 804da93:	31 c0                	xor    %eax,%eax
 804da95:	c0 e9 07             	shr    $0x7,%cl
 804da98:	c0 ea 03             	shr    $0x3,%dl
 804da9b:	83 e2 01             	and    $0x1,%edx
 804da9e:	38 d1                	cmp    %dl,%cl
 804daa0:	0f 94 c0             	sete   %al
	OPERAND_W(op_src, res);
 804daa3:	50                   	push   %eax
 804daa4:	68 08 ae 8f 14       	push   $0x148fae08
 804daa9:	e8 92 f1 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804daae:	68 18 ae 8f 14       	push   $0x148fae18
 804dab3:	68 d5 05 06 08       	push   $0x80605d5
 804dab8:	6a 50                	push   $0x50
 804daba:	68 00 89 0c 08       	push   $0x80c8900
 804dabf:	e8 3c b0 ff ff       	call   8048b00 <snprintf@plt>
 804dac4:	83 c4 20             	add    $0x20,%esp
 804dac7:	83 f8 4f             	cmp    $0x4f,%eax
 804daca:	7f 0c                	jg     804dad8 <setge_rm_b+0x68>
}

make_instr_helper(rm)
 804dacc:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804dacf:	8d 43 01             	lea    0x1(%ebx),%eax
 804dad2:	5b                   	pop    %ebx
 804dad3:	c3                   	ret    
 804dad4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr setge

static void do_execute() {
	int8_t res = cpu.SF == cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804dad8:	83 ec 0c             	sub    $0xc,%esp
 804dadb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804dae1:	e8 7a ae ff ff       	call   8048960 <fflush@plt>
 804dae6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804daec:	6a 07                	push   $0x7
 804daee:	6a 01                	push   $0x1
 804daf0:	68 92 ed 05 08       	push   $0x805ed92
 804daf5:	e8 16 af ff ff       	call   8048a10 <fwrite@plt>
 804dafa:	83 c4 20             	add    $0x20,%esp
 804dafd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804db03:	6a 10                	push   $0x10
 804db05:	6a 01                	push   $0x1
 804db07:	68 84 f8 05 08       	push   $0x805f884
 804db0c:	e8 ff ae ff ff       	call   8048a10 <fwrite@plt>
 804db11:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804db17:	6a 05                	push   $0x5
 804db19:	6a 01                	push   $0x1
 804db1b:	68 b1 ed 05 08       	push   $0x805edb1
 804db20:	e8 eb ae ff ff       	call   8048a10 <fwrite@plt>
 804db25:	83 c4 20             	add    $0x20,%esp
 804db28:	68 18 ae 8f 14       	push   $0x148fae18
 804db2d:	68 d5 05 06 08       	push   $0x80605d5
 804db32:	6a 50                	push   $0x50
 804db34:	68 00 89 0c 08       	push   $0x80c8900
 804db39:	e8 c2 af ff ff       	call   8048b00 <snprintf@plt>
 804db3e:	83 c4 10             	add    $0x10,%esp
 804db41:	83 f8 4f             	cmp    $0x4f,%eax
 804db44:	7e 86                	jle    804dacc <setge_rm_b+0x5c>
 804db46:	68 54 06 06 08       	push   $0x8060654
 804db4b:	6a 08                	push   $0x8
 804db4d:	68 e0 05 06 08       	push   $0x80605e0
 804db52:	68 0c 06 06 08       	push   $0x806060c
 804db57:	e8 54 b0 ff ff       	call   8048bb0 <__assert_fail@plt>
 804db5c:	66 90                	xchg   %ax,%ax
 804db5e:	66 90                	xchg   %ax,%ax

0804db60 <setg_rm_b>:
	int8_t res = !cpu.ZF && cpu.SF == cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804db60:	53                   	push   %ebx
 804db61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804db64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804db68:	83 c0 01             	add    $0x1,%eax
 804db6b:	50                   	push   %eax
 804db6c:	e8 bf ef 00 00       	call   805cb30 <decode_rm_b>
 804db71:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr setg

static void do_execute() {
	int8_t res = !cpu.ZF && cpu.SF == cpu.OF;
 804db73:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 804db7a:	83 c4 10             	add    $0x10,%esp
 804db7d:	31 d2                	xor    %edx,%edx
 804db7f:	a8 40                	test   $0x40,%al
 804db81:	75 18                	jne    804db9b <setg_rm_b+0x3b>
 804db83:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 804db8a:	c0 e8 07             	shr    $0x7,%al
 804db8d:	c0 ea 03             	shr    $0x3,%dl
 804db90:	83 e2 01             	and    $0x1,%edx
 804db93:	38 d0                	cmp    %dl,%al
 804db95:	0f 94 c2             	sete   %dl
 804db98:	0f b6 d2             	movzbl %dl,%edx
	OPERAND_W(op_src, res);
 804db9b:	83 ec 08             	sub    $0x8,%esp
 804db9e:	52                   	push   %edx
 804db9f:	68 08 ae 8f 14       	push   $0x148fae08
 804dba4:	e8 97 f0 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804dba9:	68 18 ae 8f 14       	push   $0x148fae18
 804dbae:	68 5f 06 06 08       	push   $0x806065f
 804dbb3:	6a 50                	push   $0x50
 804dbb5:	68 00 89 0c 08       	push   $0x80c8900
 804dbba:	e8 41 af ff ff       	call   8048b00 <snprintf@plt>
 804dbbf:	83 c4 20             	add    $0x20,%esp
 804dbc2:	83 f8 4f             	cmp    $0x4f,%eax
 804dbc5:	7f 09                	jg     804dbd0 <setg_rm_b+0x70>
}

make_instr_helper(rm)
 804dbc7:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804dbca:	8d 43 01             	lea    0x1(%ebx),%eax
 804dbcd:	5b                   	pop    %ebx
 804dbce:	c3                   	ret    
 804dbcf:	90                   	nop
#define instr setg

static void do_execute() {
	int8_t res = !cpu.ZF && cpu.SF == cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804dbd0:	83 ec 0c             	sub    $0xc,%esp
 804dbd3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804dbd9:	e8 82 ad ff ff       	call   8048960 <fflush@plt>
 804dbde:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804dbe4:	6a 07                	push   $0x7
 804dbe6:	6a 01                	push   $0x1
 804dbe8:	68 92 ed 05 08       	push   $0x805ed92
 804dbed:	e8 1e ae ff ff       	call   8048a10 <fwrite@plt>
 804dbf2:	83 c4 20             	add    $0x20,%esp
 804dbf5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804dbfb:	6a 10                	push   $0x10
 804dbfd:	6a 01                	push   $0x1
 804dbff:	68 84 f8 05 08       	push   $0x805f884
 804dc04:	e8 07 ae ff ff       	call   8048a10 <fwrite@plt>
 804dc09:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804dc0f:	6a 05                	push   $0x5
 804dc11:	6a 01                	push   $0x1
 804dc13:	68 b1 ed 05 08       	push   $0x805edb1
 804dc18:	e8 f3 ad ff ff       	call   8048a10 <fwrite@plt>
 804dc1d:	83 c4 20             	add    $0x20,%esp
 804dc20:	68 18 ae 8f 14       	push   $0x148fae18
 804dc25:	68 5f 06 06 08       	push   $0x806065f
 804dc2a:	6a 50                	push   $0x50
 804dc2c:	68 00 89 0c 08       	push   $0x80c8900
 804dc31:	e8 ca ae ff ff       	call   8048b00 <snprintf@plt>
 804dc36:	83 c4 10             	add    $0x10,%esp
 804dc39:	83 f8 4f             	cmp    $0x4f,%eax
 804dc3c:	7e 89                	jle    804dbc7 <setg_rm_b+0x67>
 804dc3e:	68 d7 06 06 08       	push   $0x80606d7
 804dc43:	6a 08                	push   $0x8
 804dc45:	68 68 06 06 08       	push   $0x8060668
 804dc4a:	68 90 06 06 08       	push   $0x8060690
 804dc4f:	e8 5c af ff ff       	call   8048bb0 <__assert_fail@plt>
 804dc54:	66 90                	xchg   %ax,%ax
 804dc56:	66 90                	xchg   %ax,%ax
 804dc58:	66 90                	xchg   %ax,%ax
 804dc5a:	66 90                	xchg   %ax,%ax
 804dc5c:	66 90                	xchg   %ax,%ax
 804dc5e:	66 90                	xchg   %ax,%ax

0804dc60 <setl_rm_b>:
	int8_t res = cpu.SF != cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804dc60:	53                   	push   %ebx
 804dc61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804dc64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804dc68:	83 c0 01             	add    $0x1,%eax
 804dc6b:	50                   	push   %eax
 804dc6c:	e8 bf ee 00 00       	call   805cb30 <decode_rm_b>
 804dc71:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr setl

static void do_execute() {
	int8_t res = cpu.SF != cpu.OF;
 804dc73:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
	OPERAND_W(op_src, res);
 804dc7a:	58                   	pop    %eax
 804dc7b:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setl

static void do_execute() {
	int8_t res = cpu.SF != cpu.OF;
 804dc7c:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 804dc83:	c0 e9 07             	shr    $0x7,%cl
 804dc86:	c0 ea 03             	shr    $0x3,%dl
 804dc89:	83 e2 01             	and    $0x1,%edx
 804dc8c:	31 ca                	xor    %ecx,%edx
	OPERAND_W(op_src, res);
 804dc8e:	0f b6 d2             	movzbl %dl,%edx
 804dc91:	52                   	push   %edx
 804dc92:	68 08 ae 8f 14       	push   $0x148fae08
 804dc97:	e8 a4 ef 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804dc9c:	68 18 ae 8f 14       	push   $0x148fae18
 804dca1:	68 e1 06 06 08       	push   $0x80606e1
 804dca6:	6a 50                	push   $0x50
 804dca8:	68 00 89 0c 08       	push   $0x80c8900
 804dcad:	e8 4e ae ff ff       	call   8048b00 <snprintf@plt>
 804dcb2:	83 c4 20             	add    $0x20,%esp
 804dcb5:	83 f8 4f             	cmp    $0x4f,%eax
 804dcb8:	7f 0e                	jg     804dcc8 <setl_rm_b+0x68>
}

make_instr_helper(rm)
 804dcba:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804dcbd:	8d 43 01             	lea    0x1(%ebx),%eax
 804dcc0:	5b                   	pop    %ebx
 804dcc1:	c3                   	ret    
 804dcc2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define instr setl

static void do_execute() {
	int8_t res = cpu.SF != cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804dcc8:	83 ec 0c             	sub    $0xc,%esp
 804dccb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804dcd1:	e8 8a ac ff ff       	call   8048960 <fflush@plt>
 804dcd6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804dcdc:	6a 07                	push   $0x7
 804dcde:	6a 01                	push   $0x1
 804dce0:	68 92 ed 05 08       	push   $0x805ed92
 804dce5:	e8 26 ad ff ff       	call   8048a10 <fwrite@plt>
 804dcea:	83 c4 20             	add    $0x20,%esp
 804dced:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804dcf3:	6a 10                	push   $0x10
 804dcf5:	6a 01                	push   $0x1
 804dcf7:	68 84 f8 05 08       	push   $0x805f884
 804dcfc:	e8 0f ad ff ff       	call   8048a10 <fwrite@plt>
 804dd01:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804dd07:	6a 05                	push   $0x5
 804dd09:	6a 01                	push   $0x1
 804dd0b:	68 b1 ed 05 08       	push   $0x805edb1
 804dd10:	e8 fb ac ff ff       	call   8048a10 <fwrite@plt>
 804dd15:	83 c4 20             	add    $0x20,%esp
 804dd18:	68 18 ae 8f 14       	push   $0x148fae18
 804dd1d:	68 e1 06 06 08       	push   $0x80606e1
 804dd22:	6a 50                	push   $0x50
 804dd24:	68 00 89 0c 08       	push   $0x80c8900
 804dd29:	e8 d2 ad ff ff       	call   8048b00 <snprintf@plt>
 804dd2e:	83 c4 10             	add    $0x10,%esp
 804dd31:	83 f8 4f             	cmp    $0x4f,%eax
 804dd34:	7e 84                	jle    804dcba <setl_rm_b+0x5a>
 804dd36:	68 5b 07 06 08       	push   $0x806075b
 804dd3b:	6a 08                	push   $0x8
 804dd3d:	68 ec 06 06 08       	push   $0x80606ec
 804dd42:	68 14 07 06 08       	push   $0x8060714
 804dd47:	e8 64 ae ff ff       	call   8048bb0 <__assert_fail@plt>
 804dd4c:	66 90                	xchg   %ax,%ax
 804dd4e:	66 90                	xchg   %ax,%ax

0804dd50 <seto_rm_b>:
	int8_t res = cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804dd50:	53                   	push   %ebx
 804dd51:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804dd54:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804dd58:	83 c0 01             	add    $0x1,%eax
 804dd5b:	50                   	push   %eax
 804dd5c:	e8 cf ed 00 00       	call   805cb30 <decode_rm_b>
 804dd61:	89 c3                	mov    %eax,%ebx

#define instr seto

static void do_execute() {
	int8_t res = cpu.OF;
	OPERAND_W(op_src, res);
 804dd63:	58                   	pop    %eax
 804dd64:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr seto

static void do_execute() {
	int8_t res = cpu.OF;
 804dd65:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 804dd6c:	c0 ea 03             	shr    $0x3,%dl
	OPERAND_W(op_src, res);
 804dd6f:	83 e2 01             	and    $0x1,%edx
 804dd72:	52                   	push   %edx
 804dd73:	68 08 ae 8f 14       	push   $0x148fae08
 804dd78:	e8 c3 ee 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804dd7d:	68 18 ae 8f 14       	push   $0x148fae18
 804dd82:	68 65 07 06 08       	push   $0x8060765
 804dd87:	6a 50                	push   $0x50
 804dd89:	68 00 89 0c 08       	push   $0x80c8900
 804dd8e:	e8 6d ad ff ff       	call   8048b00 <snprintf@plt>
 804dd93:	83 c4 20             	add    $0x20,%esp
 804dd96:	83 f8 4f             	cmp    $0x4f,%eax
 804dd99:	7f 0d                	jg     804dda8 <seto_rm_b+0x58>
}

make_instr_helper(rm)
 804dd9b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804dd9e:	8d 43 01             	lea    0x1(%ebx),%eax
 804dda1:	5b                   	pop    %ebx
 804dda2:	c3                   	ret    
 804dda3:	90                   	nop
 804dda4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr seto

static void do_execute() {
	int8_t res = cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804dda8:	83 ec 0c             	sub    $0xc,%esp
 804ddab:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804ddb1:	e8 aa ab ff ff       	call   8048960 <fflush@plt>
 804ddb6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804ddbc:	6a 07                	push   $0x7
 804ddbe:	6a 01                	push   $0x1
 804ddc0:	68 92 ed 05 08       	push   $0x805ed92
 804ddc5:	e8 46 ac ff ff       	call   8048a10 <fwrite@plt>
 804ddca:	83 c4 20             	add    $0x20,%esp
 804ddcd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804ddd3:	6a 10                	push   $0x10
 804ddd5:	6a 01                	push   $0x1
 804ddd7:	68 84 f8 05 08       	push   $0x805f884
 804dddc:	e8 2f ac ff ff       	call   8048a10 <fwrite@plt>
 804dde1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804dde7:	6a 05                	push   $0x5
 804dde9:	6a 01                	push   $0x1
 804ddeb:	68 b1 ed 05 08       	push   $0x805edb1
 804ddf0:	e8 1b ac ff ff       	call   8048a10 <fwrite@plt>
 804ddf5:	83 c4 20             	add    $0x20,%esp
 804ddf8:	68 18 ae 8f 14       	push   $0x148fae18
 804ddfd:	68 65 07 06 08       	push   $0x8060765
 804de02:	6a 50                	push   $0x50
 804de04:	68 00 89 0c 08       	push   $0x80c8900
 804de09:	e8 f2 ac ff ff       	call   8048b00 <snprintf@plt>
 804de0e:	83 c4 10             	add    $0x10,%esp
 804de11:	83 f8 4f             	cmp    $0x4f,%eax
 804de14:	7e 85                	jle    804dd9b <seto_rm_b+0x4b>
 804de16:	68 df 07 06 08       	push   $0x80607df
 804de1b:	6a 08                	push   $0x8
 804de1d:	68 70 07 06 08       	push   $0x8060770
 804de22:	68 98 07 06 08       	push   $0x8060798
 804de27:	e8 84 ad ff ff       	call   8048bb0 <__assert_fail@plt>
 804de2c:	66 90                	xchg   %ax,%ax
 804de2e:	66 90                	xchg   %ax,%ax

0804de30 <setbe_rm_b>:
	int8_t res = cpu.CF || cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804de30:	53                   	push   %ebx
 804de31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804de34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804de38:	83 c0 01             	add    $0x1,%eax
 804de3b:	50                   	push   %eax
 804de3c:	e8 ef ec 00 00       	call   805cb30 <decode_rm_b>
 804de41:	89 c3                	mov    %eax,%ebx

#define instr setbe

static void do_execute() {
	int8_t res = cpu.CF || cpu.ZF;
	OPERAND_W(op_src, res);
 804de43:	58                   	pop    %eax
#include "cpu/exec/template-start.h"

#define instr setbe

static void do_execute() {
	int8_t res = cpu.CF || cpu.ZF;
 804de44:	31 c0                	xor    %eax,%eax
 804de46:	f6 05 e4 ae 8f 14 41 	testb  $0x41,0x148faee4
	OPERAND_W(op_src, res);
 804de4d:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setbe

static void do_execute() {
	int8_t res = cpu.CF || cpu.ZF;
 804de4e:	0f 95 c0             	setne  %al
	OPERAND_W(op_src, res);
 804de51:	50                   	push   %eax
 804de52:	68 08 ae 8f 14       	push   $0x148fae08
 804de57:	e8 e4 ed 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 804de5c:	68 18 ae 8f 14       	push   $0x148fae18
 804de61:	68 e9 07 06 08       	push   $0x80607e9
 804de66:	6a 50                	push   $0x50
 804de68:	68 00 89 0c 08       	push   $0x80c8900
 804de6d:	e8 8e ac ff ff       	call   8048b00 <snprintf@plt>
 804de72:	83 c4 20             	add    $0x20,%esp
 804de75:	83 f8 4f             	cmp    $0x4f,%eax
 804de78:	7f 0e                	jg     804de88 <setbe_rm_b+0x58>
}

make_instr_helper(rm)
 804de7a:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804de7d:	8d 43 01             	lea    0x1(%ebx),%eax
 804de80:	5b                   	pop    %ebx
 804de81:	c3                   	ret    
 804de82:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define instr setbe

static void do_execute() {
	int8_t res = cpu.CF || cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804de88:	83 ec 0c             	sub    $0xc,%esp
 804de8b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804de91:	e8 ca aa ff ff       	call   8048960 <fflush@plt>
 804de96:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804de9c:	6a 07                	push   $0x7
 804de9e:	6a 01                	push   $0x1
 804dea0:	68 92 ed 05 08       	push   $0x805ed92
 804dea5:	e8 66 ab ff ff       	call   8048a10 <fwrite@plt>
 804deaa:	83 c4 20             	add    $0x20,%esp
 804dead:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804deb3:	6a 10                	push   $0x10
 804deb5:	6a 01                	push   $0x1
 804deb7:	68 84 f8 05 08       	push   $0x805f884
 804debc:	e8 4f ab ff ff       	call   8048a10 <fwrite@plt>
 804dec1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804dec7:	6a 05                	push   $0x5
 804dec9:	6a 01                	push   $0x1
 804decb:	68 b1 ed 05 08       	push   $0x805edb1
 804ded0:	e8 3b ab ff ff       	call   8048a10 <fwrite@plt>
 804ded5:	83 c4 20             	add    $0x20,%esp
 804ded8:	68 18 ae 8f 14       	push   $0x148fae18
 804dedd:	68 e9 07 06 08       	push   $0x80607e9
 804dee2:	6a 50                	push   $0x50
 804dee4:	68 00 89 0c 08       	push   $0x80c8900
 804dee9:	e8 12 ac ff ff       	call   8048b00 <snprintf@plt>
 804deee:	83 c4 10             	add    $0x10,%esp
 804def1:	83 f8 4f             	cmp    $0x4f,%eax
 804def4:	7e 84                	jle    804de7a <setbe_rm_b+0x4a>
 804def6:	68 68 08 06 08       	push   $0x8060868
 804defb:	6a 08                	push   $0x8
 804defd:	68 f4 07 06 08       	push   $0x80607f4
 804df02:	68 20 08 06 08       	push   $0x8060820
 804df07:	e8 a4 ac ff ff       	call   8048bb0 <__assert_fail@plt>
 804df0c:	66 90                	xchg   %ax,%ax
 804df0e:	66 90                	xchg   %ax,%ax

0804df10 <data_size>:
#include "cpu/exec/helper.h"

make_helper(exec);

make_helper(data_size) {
 804df10:	83 ec 18             	sub    $0x18,%esp
	ops_decoded.is_data_size_16 = true;
 804df13:	c6 05 04 ae 8f 14 01 	movb   $0x1,0x148fae04
	int instr_len = exec(eip + 1);
 804df1a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804df1e:	83 c0 01             	add    $0x1,%eax
 804df21:	50                   	push   %eax
 804df22:	e8 29 f1 ff ff       	call   804d050 <exec>
	ops_decoded.is_data_size_16 = false;
 804df27:	c6 05 04 ae 8f 14 00 	movb   $0x0,0x148fae04
	return instr_len + 1;
 804df2e:	83 c0 01             	add    $0x1,%eax
}
 804df31:	83 c4 1c             	add    $0x1c,%esp
 804df34:	c3                   	ret    
 804df35:	66 90                	xchg   %ax,%ax
 804df37:	66 90                	xchg   %ax,%ax
 804df39:	66 90                	xchg   %ax,%ax
 804df3b:	66 90                	xchg   %ax,%ax
 804df3d:	66 90                	xchg   %ax,%ax
 804df3f:	90                   	nop

0804df40 <jmp_rm_w>:
#endif
	print_asm_template1();
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(jmp_rm_, SUFFIX)) {
 804df40:	83 ec 18             	sub    $0x18,%esp
	concat(decode_rm_, SUFFIX)(eip + 1);
 804df43:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804df47:	83 c0 01             	add    $0x1,%eax
 804df4a:	50                   	push   %eax
 804df4b:	e8 10 ef 00 00       	call   805ce60 <decode_rm_w>
	cpu.eip = op_src->val;
 804df50:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	print_asm_template1();
 804df55:	68 18 ae 8f 14       	push   $0x148fae18
 804df5a:	68 73 08 06 08       	push   $0x8060873
 804df5f:	6a 50                	push   $0x50
 804df61:	68 00 89 0c 08       	push   $0x80c8900
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(jmp_rm_, SUFFIX)) {
	concat(decode_rm_, SUFFIX)(eip + 1);
	cpu.eip = op_src->val;
 804df66:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
	print_asm_template1();
 804df6b:	e8 90 ab ff ff       	call   8048b00 <snprintf@plt>
 804df70:	83 c4 20             	add    $0x20,%esp
 804df73:	83 f8 4f             	cmp    $0x4f,%eax
 804df76:	7f 08                	jg     804df80 <jmp_rm_w+0x40>
	return 0;
}
 804df78:	31 c0                	xor    %eax,%eax
 804df7a:	83 c4 0c             	add    $0xc,%esp
 804df7d:	c3                   	ret    
 804df7e:	66 90                	xchg   %ax,%ax

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(jmp_rm_, SUFFIX)) {
	concat(decode_rm_, SUFFIX)(eip + 1);
	cpu.eip = op_src->val;
	print_asm_template1();
 804df80:	83 ec 0c             	sub    $0xc,%esp
 804df83:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804df89:	e8 d2 a9 ff ff       	call   8048960 <fflush@plt>
 804df8e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804df94:	6a 07                	push   $0x7
 804df96:	6a 01                	push   $0x1
 804df98:	68 92 ed 05 08       	push   $0x805ed92
 804df9d:	e8 6e aa ff ff       	call   8048a10 <fwrite@plt>
 804dfa2:	83 c4 20             	add    $0x20,%esp
 804dfa5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804dfab:	6a 10                	push   $0x10
 804dfad:	6a 01                	push   $0x1
 804dfaf:	68 84 f8 05 08       	push   $0x805f884
 804dfb4:	e8 57 aa ff ff       	call   8048a10 <fwrite@plt>
 804dfb9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804dfbf:	6a 05                	push   $0x5
 804dfc1:	6a 01                	push   $0x1
 804dfc3:	68 b1 ed 05 08       	push   $0x805edb1
 804dfc8:	e8 43 aa ff ff       	call   8048a10 <fwrite@plt>
 804dfcd:	83 c4 20             	add    $0x20,%esp
 804dfd0:	68 18 ae 8f 14       	push   $0x148fae18
 804dfd5:	68 73 08 06 08       	push   $0x8060873
 804dfda:	6a 50                	push   $0x50
 804dfdc:	68 00 89 0c 08       	push   $0x80c8900
 804dfe1:	e8 1a ab ff ff       	call   8048b00 <snprintf@plt>
 804dfe6:	83 c4 10             	add    $0x10,%esp
 804dfe9:	83 f8 4f             	cmp    $0x4f,%eax
 804dfec:	7e 8a                	jle    804df78 <jmp_rm_w+0x38>
 804dfee:	68 a5 09 06 08       	push   $0x80609a5
 804dff3:	6a 16                	push   $0x16
 804dff5:	68 8c 08 06 08       	push   $0x806088c
 804dffa:	68 b4 08 06 08       	push   $0x80608b4
 804dfff:	e8 ac ab ff ff       	call   8048bb0 <__assert_fail@plt>
 804e004:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804e00a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804e010 <jmp_rm_l>:
#endif
	print_asm_template1();
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(jmp_rm_, SUFFIX)) {
 804e010:	83 ec 18             	sub    $0x18,%esp
	concat(decode_rm_, SUFFIX)(eip + 1);
 804e013:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e017:	83 c0 01             	add    $0x1,%eax
 804e01a:	50                   	push   %eax
 804e01b:	e8 10 f2 00 00       	call   805d230 <decode_rm_l>
	cpu.eip = op_src->val;
 804e020:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	print_asm_template1();
 804e025:	68 18 ae 8f 14       	push   $0x148fae18
 804e02a:	68 7b 08 06 08       	push   $0x806087b
 804e02f:	6a 50                	push   $0x50
 804e031:	68 00 89 0c 08       	push   $0x80c8900
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(jmp_rm_, SUFFIX)) {
	concat(decode_rm_, SUFFIX)(eip + 1);
	cpu.eip = op_src->val;
 804e036:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
	print_asm_template1();
 804e03b:	e8 c0 aa ff ff       	call   8048b00 <snprintf@plt>
 804e040:	83 c4 20             	add    $0x20,%esp
 804e043:	83 f8 4f             	cmp    $0x4f,%eax
 804e046:	7f 08                	jg     804e050 <jmp_rm_l+0x40>
	return 0;
}
 804e048:	31 c0                	xor    %eax,%eax
 804e04a:	83 c4 0c             	add    $0xc,%esp
 804e04d:	c3                   	ret    
 804e04e:	66 90                	xchg   %ax,%ax

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(jmp_rm_, SUFFIX)) {
	concat(decode_rm_, SUFFIX)(eip + 1);
	cpu.eip = op_src->val;
	print_asm_template1();
 804e050:	83 ec 0c             	sub    $0xc,%esp
 804e053:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804e059:	e8 02 a9 ff ff       	call   8048960 <fflush@plt>
 804e05e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e064:	6a 07                	push   $0x7
 804e066:	6a 01                	push   $0x1
 804e068:	68 92 ed 05 08       	push   $0x805ed92
 804e06d:	e8 9e a9 ff ff       	call   8048a10 <fwrite@plt>
 804e072:	83 c4 20             	add    $0x20,%esp
 804e075:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e07b:	6a 10                	push   $0x10
 804e07d:	6a 01                	push   $0x1
 804e07f:	68 84 f8 05 08       	push   $0x805f884
 804e084:	e8 87 a9 ff ff       	call   8048a10 <fwrite@plt>
 804e089:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e08f:	6a 05                	push   $0x5
 804e091:	6a 01                	push   $0x1
 804e093:	68 b1 ed 05 08       	push   $0x805edb1
 804e098:	e8 73 a9 ff ff       	call   8048a10 <fwrite@plt>
 804e09d:	83 c4 20             	add    $0x20,%esp
 804e0a0:	68 18 ae 8f 14       	push   $0x148fae18
 804e0a5:	68 7b 08 06 08       	push   $0x806087b
 804e0aa:	6a 50                	push   $0x50
 804e0ac:	68 00 89 0c 08       	push   $0x80c8900
 804e0b1:	e8 4a aa ff ff       	call   8048b00 <snprintf@plt>
 804e0b6:	83 c4 10             	add    $0x10,%esp
 804e0b9:	83 f8 4f             	cmp    $0x4f,%eax
 804e0bc:	7e 8a                	jle    804e048 <jmp_rm_l+0x38>
 804e0be:	68 93 09 06 08       	push   $0x8060993
 804e0c3:	6a 16                	push   $0x16
 804e0c5:	68 8c 08 06 08       	push   $0x806088c
 804e0ca:	68 fc 08 06 08       	push   $0x80608fc
 804e0cf:	e8 dc aa ff ff       	call   8048bb0 <__assert_fail@plt>
 804e0d4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804e0da:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804e0e0 <jmp_i_l>:
	return 0;
}
#endif

make_instr_helper(i)
 804e0e0:	56                   	push   %esi
 804e0e1:	53                   	push   %ebx
 804e0e2:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e0e5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e0e9:	83 c0 01             	add    $0x1,%eax
 804e0ec:	50                   	push   %eax
 804e0ed:	e8 4e ef 00 00       	call   805d040 <decode_i_l>
 804e0f2:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jmp

static void do_execute() {
	int res = op_src->val;
 804e0f4:	8b 35 14 ae 8f 14    	mov    0x148fae14,%esi

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 804e0fa:	58                   	pop    %eax
 804e0fb:	5a                   	pop    %edx
 804e0fc:	6a 01                	push   $0x1
 804e0fe:	ff 35 e0 ae 8f 14    	pushl  0x148faee0
 804e104:	e8 57 ce ff ff       	call   804af60 <swaddr_read>
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
 804e109:	83 c4 10             	add    $0x10,%esp
 804e10c:	3d eb 00 00 00       	cmp    $0xeb,%eax
 804e111:	74 2d                	je     804e140 <jmp_i_l+0x60>
 804e113:	83 ec 08             	sub    $0x8,%esp
 804e116:	6a 01                	push   $0x1
 804e118:	ff 35 e0 ae 8f 14    	pushl  0x148faee0
 804e11e:	e8 3d ce ff ff       	call   804af60 <swaddr_read>
 804e123:	83 c4 10             	add    $0x10,%esp
 804e126:	3d e9 00 00 00       	cmp    $0xe9,%eax
 804e12b:	74 13                	je     804e140 <jmp_i_l+0x60>
		cpu.eip = cpu.eip + res;
	else
		cpu.eip = res - 2;
 804e12d:	83 ee 02             	sub    $0x2,%esi
 804e130:	89 35 e0 ae 8f 14    	mov    %esi,0x148faee0
 804e136:	eb 0e                	jmp    804e146 <jmp_i_l+0x66>
 804e138:	90                   	nop
 804e139:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
		cpu.eip = cpu.eip + res;
 804e140:	01 35 e0 ae 8f 14    	add    %esi,0x148faee0
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804e146:	68 18 ae 8f 14       	push   $0x148fae18
 804e14b:	68 7b 08 06 08       	push   $0x806087b
 804e150:	6a 50                	push   $0x50
 804e152:	68 00 89 0c 08       	push   $0x80c8900
 804e157:	e8 a4 a9 ff ff       	call   8048b00 <snprintf@plt>
 804e15c:	83 c4 10             	add    $0x10,%esp
 804e15f:	83 f8 4f             	cmp    $0x4f,%eax
 804e162:	7f 0c                	jg     804e170 <jmp_i_l+0x90>
	print_asm_template1();
	return 0;
}
#endif

make_instr_helper(i)
 804e164:	83 c4 04             	add    $0x4,%esp
/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
	execute();
	return len + 1;	// "1" for opcode
 804e167:	8d 43 01             	lea    0x1(%ebx),%eax
 804e16a:	5b                   	pop    %ebx
 804e16b:	5e                   	pop    %esi
 804e16c:	c3                   	ret    
 804e16d:	8d 76 00             	lea    0x0(%esi),%esi
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804e170:	83 ec 0c             	sub    $0xc,%esp
 804e173:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804e179:	e8 e2 a7 ff ff       	call   8048960 <fflush@plt>
 804e17e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e184:	6a 07                	push   $0x7
 804e186:	6a 01                	push   $0x1
 804e188:	68 92 ed 05 08       	push   $0x805ed92
 804e18d:	e8 7e a8 ff ff       	call   8048a10 <fwrite@plt>
 804e192:	83 c4 20             	add    $0x20,%esp
 804e195:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e19b:	6a 10                	push   $0x10
 804e19d:	6a 01                	push   $0x1
 804e19f:	68 84 f8 05 08       	push   $0x805f884
 804e1a4:	e8 67 a8 ff ff       	call   8048a10 <fwrite@plt>
 804e1a9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e1af:	6a 05                	push   $0x5
 804e1b1:	6a 01                	push   $0x1
 804e1b3:	68 b1 ed 05 08       	push   $0x805edb1
 804e1b8:	e8 53 a8 ff ff       	call   8048a10 <fwrite@plt>
 804e1bd:	83 c4 20             	add    $0x20,%esp
 804e1c0:	68 18 ae 8f 14       	push   $0x148fae18
 804e1c5:	68 7b 08 06 08       	push   $0x806087b
 804e1ca:	6a 50                	push   $0x50
 804e1cc:	68 00 89 0c 08       	push   $0x80c8900
 804e1d1:	e8 2a a9 ff ff       	call   8048b00 <snprintf@plt>
 804e1d6:	83 c4 10             	add    $0x10,%esp
 804e1d9:	83 f8 4f             	cmp    $0x4f,%eax
 804e1dc:	7e 86                	jle    804e164 <jmp_i_l+0x84>
 804e1de:	68 8a 09 06 08       	push   $0x806098a
 804e1e3:	6a 0f                	push   $0xf
 804e1e5:	68 8c 08 06 08       	push   $0x806088c
 804e1ea:	68 fc 08 06 08       	push   $0x80608fc
 804e1ef:	e8 bc a9 ff ff       	call   8048bb0 <__assert_fail@plt>
 804e1f4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804e1fa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804e200 <jmp_i_w>:
	print_asm_template1();
	return 0;
}
#endif

make_instr_helper(i)
 804e200:	56                   	push   %esi
 804e201:	53                   	push   %ebx
 804e202:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e205:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e209:	83 c0 01             	add    $0x1,%eax
 804e20c:	50                   	push   %eax
 804e20d:	e8 9e ea 00 00       	call   805ccb0 <decode_i_w>
 804e212:	89 c6                	mov    %eax,%esi

#define instr jmp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 804e214:	0f bf 1d 14 ae 8f 14 	movswl 0x148fae14,%ebx

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 804e21b:	58                   	pop    %eax
 804e21c:	5a                   	pop    %edx
 804e21d:	6a 01                	push   $0x1
 804e21f:	ff 35 e0 ae 8f 14    	pushl  0x148faee0
 804e225:	e8 36 cd ff ff       	call   804af60 <swaddr_read>
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
 804e22a:	83 c4 10             	add    $0x10,%esp
 804e22d:	3d eb 00 00 00       	cmp    $0xeb,%eax
 804e232:	74 24                	je     804e258 <jmp_i_w+0x58>
 804e234:	83 ec 08             	sub    $0x8,%esp
 804e237:	6a 01                	push   $0x1
 804e239:	ff 35 e0 ae 8f 14    	pushl  0x148faee0
 804e23f:	e8 1c cd ff ff       	call   804af60 <swaddr_read>
 804e244:	83 c4 10             	add    $0x10,%esp
 804e247:	3d e9 00 00 00       	cmp    $0xe9,%eax
 804e24c:	74 0a                	je     804e258 <jmp_i_w+0x58>
		cpu.eip = cpu.eip + res;
	else
		cpu.eip = res - 2;
 804e24e:	8d 53 fe             	lea    -0x2(%ebx),%edx
 804e251:	eb 0d                	jmp    804e260 <jmp_i_w+0x60>
 804e253:	90                   	nop
 804e254:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
		cpu.eip = cpu.eip + res;
 804e258:	03 1d e0 ae 8f 14    	add    0x148faee0,%ebx
 804e25e:	89 da                	mov    %ebx,%edx
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804e260:	68 18 ae 8f 14       	push   $0x148fae18
 804e265:	68 73 08 06 08       	push   $0x8060873
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
		cpu.eip = cpu.eip + res;
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
 804e26a:	81 e2 ff ff 00 00    	and    $0xffff,%edx
#endif
	print_asm_template1();
 804e270:	6a 50                	push   $0x50
 804e272:	68 00 89 0c 08       	push   $0x80c8900
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
		cpu.eip = cpu.eip + res;
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
 804e277:	89 15 e0 ae 8f 14    	mov    %edx,0x148faee0
#endif
	print_asm_template1();
 804e27d:	e8 7e a8 ff ff       	call   8048b00 <snprintf@plt>
 804e282:	83 c4 10             	add    $0x10,%esp
 804e285:	83 f8 4f             	cmp    $0x4f,%eax
 804e288:	7f 0e                	jg     804e298 <jmp_i_w+0x98>
	print_asm_template1();
	return 0;
}
#endif

make_instr_helper(i)
 804e28a:	83 c4 04             	add    $0x4,%esp
/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
	execute();
	return len + 1;	// "1" for opcode
 804e28d:	8d 46 01             	lea    0x1(%esi),%eax
 804e290:	5b                   	pop    %ebx
 804e291:	5e                   	pop    %esi
 804e292:	c3                   	ret    
 804e293:	90                   	nop
 804e294:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804e298:	83 ec 0c             	sub    $0xc,%esp
 804e29b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804e2a1:	e8 ba a6 ff ff       	call   8048960 <fflush@plt>
 804e2a6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e2ac:	6a 07                	push   $0x7
 804e2ae:	6a 01                	push   $0x1
 804e2b0:	68 92 ed 05 08       	push   $0x805ed92
 804e2b5:	e8 56 a7 ff ff       	call   8048a10 <fwrite@plt>
 804e2ba:	83 c4 20             	add    $0x20,%esp
 804e2bd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e2c3:	6a 10                	push   $0x10
 804e2c5:	6a 01                	push   $0x1
 804e2c7:	68 84 f8 05 08       	push   $0x805f884
 804e2cc:	e8 3f a7 ff ff       	call   8048a10 <fwrite@plt>
 804e2d1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e2d7:	6a 05                	push   $0x5
 804e2d9:	6a 01                	push   $0x1
 804e2db:	68 b1 ed 05 08       	push   $0x805edb1
 804e2e0:	e8 2b a7 ff ff       	call   8048a10 <fwrite@plt>
 804e2e5:	83 c4 20             	add    $0x20,%esp
 804e2e8:	68 18 ae 8f 14       	push   $0x148fae18
 804e2ed:	68 73 08 06 08       	push   $0x8060873
 804e2f2:	6a 50                	push   $0x50
 804e2f4:	68 00 89 0c 08       	push   $0x80c8900
 804e2f9:	e8 02 a8 ff ff       	call   8048b00 <snprintf@plt>
 804e2fe:	83 c4 10             	add    $0x10,%esp
 804e301:	83 f8 4f             	cmp    $0x4f,%eax
 804e304:	7e 84                	jle    804e28a <jmp_i_w+0x8a>
 804e306:	68 9c 09 06 08       	push   $0x806099c
 804e30b:	6a 0f                	push   $0xf
 804e30d:	68 8c 08 06 08       	push   $0x806088c
 804e312:	68 b4 08 06 08       	push   $0x80608b4
 804e317:	e8 94 a8 ff ff       	call   8048bb0 <__assert_fail@plt>
 804e31c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804e320 <jmp_i_b>:
	print_asm_template1();
	return 0;
}
#endif

make_instr_helper(i)
 804e320:	56                   	push   %esi
 804e321:	53                   	push   %ebx
 804e322:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e325:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e329:	83 c0 01             	add    $0x1,%eax
 804e32c:	50                   	push   %eax
 804e32d:	e8 0e e6 00 00       	call   805c940 <decode_i_b>
 804e332:	89 c3                	mov    %eax,%ebx

#define instr jmp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 804e334:	0f be 35 14 ae 8f 14 	movsbl 0x148fae14,%esi

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 804e33b:	58                   	pop    %eax
 804e33c:	5a                   	pop    %edx
 804e33d:	6a 01                	push   $0x1
 804e33f:	ff 35 e0 ae 8f 14    	pushl  0x148faee0
 804e345:	e8 16 cc ff ff       	call   804af60 <swaddr_read>
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
 804e34a:	83 c4 10             	add    $0x10,%esp
 804e34d:	3d eb 00 00 00       	cmp    $0xeb,%eax
 804e352:	74 2c                	je     804e380 <jmp_i_b+0x60>
 804e354:	83 ec 08             	sub    $0x8,%esp
 804e357:	6a 01                	push   $0x1
 804e359:	ff 35 e0 ae 8f 14    	pushl  0x148faee0
 804e35f:	e8 fc cb ff ff       	call   804af60 <swaddr_read>
 804e364:	83 c4 10             	add    $0x10,%esp
 804e367:	3d e9 00 00 00       	cmp    $0xe9,%eax
 804e36c:	74 12                	je     804e380 <jmp_i_b+0x60>
		cpu.eip = cpu.eip + res;
	else
		cpu.eip = res - 2;
 804e36e:	83 ee 02             	sub    $0x2,%esi
 804e371:	89 35 e0 ae 8f 14    	mov    %esi,0x148faee0
 804e377:	eb 0d                	jmp    804e386 <jmp_i_b+0x66>
 804e379:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
		cpu.eip = cpu.eip + res;
 804e380:	01 35 e0 ae 8f 14    	add    %esi,0x148faee0
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804e386:	68 18 ae 8f 14       	push   $0x148fae18
 804e38b:	68 83 08 06 08       	push   $0x8060883
 804e390:	6a 50                	push   $0x50
 804e392:	68 00 89 0c 08       	push   $0x80c8900
 804e397:	e8 64 a7 ff ff       	call   8048b00 <snprintf@plt>
 804e39c:	83 c4 10             	add    $0x10,%esp
 804e39f:	83 f8 4f             	cmp    $0x4f,%eax
 804e3a2:	7f 0c                	jg     804e3b0 <jmp_i_b+0x90>
	print_asm_template1();
	return 0;
}
#endif

make_instr_helper(i)
 804e3a4:	83 c4 04             	add    $0x4,%esp
/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
	execute();
	return len + 1;	// "1" for opcode
 804e3a7:	8d 43 01             	lea    0x1(%ebx),%eax
 804e3aa:	5b                   	pop    %ebx
 804e3ab:	5e                   	pop    %esi
 804e3ac:	c3                   	ret    
 804e3ad:	8d 76 00             	lea    0x0(%esi),%esi
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804e3b0:	83 ec 0c             	sub    $0xc,%esp
 804e3b3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804e3b9:	e8 a2 a5 ff ff       	call   8048960 <fflush@plt>
 804e3be:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e3c4:	6a 07                	push   $0x7
 804e3c6:	6a 01                	push   $0x1
 804e3c8:	68 92 ed 05 08       	push   $0x805ed92
 804e3cd:	e8 3e a6 ff ff       	call   8048a10 <fwrite@plt>
 804e3d2:	83 c4 20             	add    $0x20,%esp
 804e3d5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e3db:	6a 10                	push   $0x10
 804e3dd:	6a 01                	push   $0x1
 804e3df:	68 84 f8 05 08       	push   $0x805f884
 804e3e4:	e8 27 a6 ff ff       	call   8048a10 <fwrite@plt>
 804e3e9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e3ef:	6a 05                	push   $0x5
 804e3f1:	6a 01                	push   $0x1
 804e3f3:	68 b1 ed 05 08       	push   $0x805edb1
 804e3f8:	e8 13 a6 ff ff       	call   8048a10 <fwrite@plt>
 804e3fd:	83 c4 20             	add    $0x20,%esp
 804e400:	68 18 ae 8f 14       	push   $0x148fae18
 804e405:	68 83 08 06 08       	push   $0x8060883
 804e40a:	6a 50                	push   $0x50
 804e40c:	68 00 89 0c 08       	push   $0x80c8900
 804e411:	e8 ea a6 ff ff       	call   8048b00 <snprintf@plt>
 804e416:	83 c4 10             	add    $0x10,%esp
 804e419:	83 f8 4f             	cmp    $0x4f,%eax
 804e41c:	7e 86                	jle    804e3a4 <jmp_i_b+0x84>
 804e41e:	68 ae 09 06 08       	push   $0x80609ae
 804e423:	6a 0f                	push   $0xf
 804e425:	68 8c 08 06 08       	push   $0x806088c
 804e42a:	68 44 09 06 08       	push   $0x8060944
 804e42f:	e8 7c a7 ff ff       	call   8048bb0 <__assert_fail@plt>
 804e434:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804e43a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804e440 <jmp_i_v>:
#include "jmp-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jmp_i)
 804e440:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804e447:	8b 54 24 04          	mov    0x4(%esp),%edx
 804e44b:	b8 00 e2 04 08       	mov    $0x804e200,%eax
 804e450:	75 05                	jne    804e457 <jmp_i_v+0x17>
 804e452:	b8 e0 e0 04 08       	mov    $0x804e0e0,%eax
 804e457:	89 54 24 04          	mov    %edx,0x4(%esp)
 804e45b:	ff e0                	jmp    *%eax
 804e45d:	8d 76 00             	lea    0x0(%esi),%esi

0804e460 <jmp_rm_v>:
make_helper_v(jmp_rm)
 804e460:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804e467:	8b 54 24 04          	mov    0x4(%esp),%edx
 804e46b:	b8 40 df 04 08       	mov    $0x804df40,%eax
 804e470:	75 05                	jne    804e477 <jmp_rm_v+0x17>
 804e472:	b8 10 e0 04 08       	mov    $0x804e010,%eax
 804e477:	89 54 24 04          	mov    %edx,0x4(%esp)
 804e47b:	ff e0                	jmp    *%eax
 804e47d:	66 90                	xchg   %ax,%ax
 804e47f:	90                   	nop

0804e480 <shrdi_w>:
	OPERAND_W(op_src2, out);

	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
}

make_helper(concat(shrdi_, SUFFIX)) {
 804e480:	56                   	push   %esi
 804e481:	53                   	push   %ebx
 804e482:	83 ec 10             	sub    $0x10,%esp
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
 804e485:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e489:	83 c0 01             	add    $0x1,%eax
 804e48c:	50                   	push   %eax
 804e48d:	e8 2e ea 00 00       	call   805cec0 <decode_si_rm2r_w>
 804e492:	89 c6                	mov    %eax,%esi
	op_dest->val = REG(op_dest->reg);
 804e494:	a1 48 ae 8f 14       	mov    0x148fae48,%eax
static inline void init_cpu_state() {
	init_cr0();
}

static inline int check_reg_index(int index) {
	assert(index >= 0 && index < 8);
 804e499:	83 c4 10             	add    $0x10,%esp
 804e49c:	83 f8 07             	cmp    $0x7,%eax
 804e49f:	0f 87 1d 01 00 00    	ja     804e5c2 <shrdi_w+0x142>
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804e4a5:	0f b6 1d 14 ae 8f 14 	movzbl 0x148fae14,%ebx
	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
}

make_helper(concat(shrdi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
 804e4ac:	0f b7 04 85 c0 ae 8f 	movzwl 0x148faec0(,%eax,4),%eax
 804e4b3:	14 
#define instr shrd

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute () {
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;
 804e4b4:	0f b7 15 84 ae 8f 14 	movzwl 0x148fae84,%edx

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804e4bb:	83 e3 1f             	and    $0x1f,%ebx
	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
}

make_helper(concat(shrdi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
 804e4be:	89 c1                	mov    %eax,%ecx
 804e4c0:	a3 4c ae 8f 14       	mov    %eax,0x148fae4c
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804e4c5:	75 0c                	jne    804e4d3 <shrdi_w+0x53>
 804e4c7:	eb 1a                	jmp    804e4e3 <shrdi_w+0x63>
 804e4c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804e4d0:	0f b7 c1             	movzwl %cx,%eax
		out >>= 1;
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
 804e4d3:	c1 e0 0f             	shl    $0xf,%eax
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out >>= 1;
 804e4d6:	66 d1 ea             	shr    %dx
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
		in >>= 1;
 804e4d9:	66 d1 e9             	shr    %cx

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out >>= 1;
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
 804e4dc:	09 c2                	or     %eax,%edx
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804e4de:	80 eb 01             	sub    $0x1,%bl
 804e4e1:	75 ed                	jne    804e4d0 <shrdi_w+0x50>
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
		in >>= 1;
		count --;
	}

	OPERAND_W(op_src2, out);
 804e4e3:	83 ec 08             	sub    $0x8,%esp
 804e4e6:	0f b7 d2             	movzwl %dx,%edx
 804e4e9:	52                   	push   %edx
 804e4ea:	68 78 ae 8f 14       	push   $0x148fae78
 804e4ef:	e8 dc ea 00 00       	call   805cfd0 <write_operand_w>

	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804e4f4:	58                   	pop    %eax
 804e4f5:	5a                   	pop    %edx
 804e4f6:	68 88 ae 8f 14       	push   $0x148fae88
 804e4fb:	68 50 ae 8f 14       	push   $0x148fae50
 804e500:	68 18 ae 8f 14       	push   $0x148fae18
 804e505:	68 b7 09 06 08       	push   $0x80609b7
 804e50a:	6a 50                	push   $0x50
 804e50c:	68 00 89 0c 08       	push   $0x80c8900
 804e511:	e8 ea a5 ff ff       	call   8048b00 <snprintf@plt>
 804e516:	83 c4 20             	add    $0x20,%esp
 804e519:	83 f8 4f             	cmp    $0x4f,%eax
 804e51c:	7f 12                	jg     804e530 <shrdi_w+0xb0>
make_helper(concat(shrdi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
	do_execute();
	return len + 1;
}
 804e51e:	83 c4 04             	add    $0x4,%esp

make_helper(concat(shrdi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
	do_execute();
	return len + 1;
 804e521:	8d 46 01             	lea    0x1(%esi),%eax
}
 804e524:	5b                   	pop    %ebx
 804e525:	5e                   	pop    %esi
 804e526:	c3                   	ret    
 804e527:	89 f6                	mov    %esi,%esi
 804e529:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		count --;
	}

	OPERAND_W(op_src2, out);

	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804e530:	83 ec 0c             	sub    $0xc,%esp
 804e533:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804e539:	e8 22 a4 ff ff       	call   8048960 <fflush@plt>
 804e53e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e544:	6a 07                	push   $0x7
 804e546:	6a 01                	push   $0x1
 804e548:	68 92 ed 05 08       	push   $0x805ed92
 804e54d:	e8 be a4 ff ff       	call   8048a10 <fwrite@plt>
 804e552:	83 c4 20             	add    $0x20,%esp
 804e555:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e55b:	6a 10                	push   $0x10
 804e55d:	6a 01                	push   $0x1
 804e55f:	68 84 f8 05 08       	push   $0x805f884
 804e564:	e8 a7 a4 ff ff       	call   8048a10 <fwrite@plt>
 804e569:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e56f:	6a 05                	push   $0x5
 804e571:	6a 01                	push   $0x1
 804e573:	68 b1 ed 05 08       	push   $0x805edb1
 804e578:	e8 93 a4 ff ff       	call   8048a10 <fwrite@plt>
 804e57d:	83 c4 18             	add    $0x18,%esp
 804e580:	68 88 ae 8f 14       	push   $0x148fae88
 804e585:	68 50 ae 8f 14       	push   $0x148fae50
 804e58a:	68 18 ae 8f 14       	push   $0x148fae18
 804e58f:	68 b7 09 06 08       	push   $0x80609b7
 804e594:	6a 50                	push   $0x50
 804e596:	68 00 89 0c 08       	push   $0x80c8900
 804e59b:	e8 60 a5 ff ff       	call   8048b00 <snprintf@plt>
 804e5a0:	83 c4 20             	add    $0x20,%esp
 804e5a3:	83 f8 4f             	cmp    $0x4f,%eax
 804e5a6:	0f 8e 72 ff ff ff    	jle    804e51e <shrdi_w+0x9e>
 804e5ac:	68 0f 0b 06 08       	push   $0x8060b0f
 804e5b1:	6a 15                	push   $0x15
 804e5b3:	68 d8 09 06 08       	push   $0x80609d8
 804e5b8:	68 00 0a 06 08       	push   $0x8060a00
 804e5bd:	e8 ee a5 ff ff       	call   8048bb0 <__assert_fail@plt>
 804e5c2:	e8 12 a6 ff ff       	call   8048bd9 <check_reg_index.part.0>
 804e5c7:	89 f6                	mov    %esi,%esi
 804e5c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804e5d0 <shrdi_l>:
}

make_helper(concat(shrdi_, SUFFIX)) {
 804e5d0:	56                   	push   %esi
 804e5d1:	53                   	push   %ebx
 804e5d2:	83 ec 10             	sub    $0x10,%esp
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
 804e5d5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e5d9:	83 c0 01             	add    $0x1,%eax
 804e5dc:	50                   	push   %eax
 804e5dd:	e8 ae ec 00 00       	call   805d290 <decode_si_rm2r_l>
 804e5e2:	89 c3                	mov    %eax,%ebx
	op_dest->val = REG(op_dest->reg);
 804e5e4:	a1 48 ae 8f 14       	mov    0x148fae48,%eax
 804e5e9:	83 c4 10             	add    $0x10,%esp
 804e5ec:	83 f8 07             	cmp    $0x7,%eax
 804e5ef:	0f 87 0d 01 00 00    	ja     804e702 <shrdi_l+0x132>
 804e5f5:	8b 0c 85 c0 ae 8f 14 	mov    0x148faec0(,%eax,4),%ecx
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804e5fc:	0f b6 05 14 ae 8f 14 	movzbl 0x148fae14,%eax
#define instr shrd

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute () {
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;
 804e603:	8b 15 84 ae 8f 14    	mov    0x148fae84,%edx
	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
}

make_helper(concat(shrdi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
 804e609:	89 0d 4c ae 8f 14    	mov    %ecx,0x148fae4c
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804e60f:	83 e0 1f             	and    $0x1f,%eax
 804e612:	74 13                	je     804e627 <shrdi_l+0x57>
 804e614:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		out >>= 1;
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
 804e618:	89 ce                	mov    %ecx,%esi
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out >>= 1;
 804e61a:	d1 ea                	shr    %edx
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
		in >>= 1;
 804e61c:	d1 e9                	shr    %ecx

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out >>= 1;
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
 804e61e:	c1 e6 1f             	shl    $0x1f,%esi
 804e621:	09 f2                	or     %esi,%edx
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804e623:	2c 01                	sub    $0x1,%al
 804e625:	75 f1                	jne    804e618 <shrdi_l+0x48>
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
		in >>= 1;
		count --;
	}

	OPERAND_W(op_src2, out);
 804e627:	83 ec 08             	sub    $0x8,%esp
 804e62a:	52                   	push   %edx
 804e62b:	68 78 ae 8f 14       	push   $0x148fae78
 804e630:	e8 6b ed 00 00       	call   805d3a0 <write_operand_l>

	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804e635:	58                   	pop    %eax
 804e636:	5a                   	pop    %edx
 804e637:	68 88 ae 8f 14       	push   $0x148fae88
 804e63c:	68 50 ae 8f 14       	push   $0x148fae50
 804e641:	68 18 ae 8f 14       	push   $0x148fae18
 804e646:	68 c6 09 06 08       	push   $0x80609c6
 804e64b:	6a 50                	push   $0x50
 804e64d:	68 00 89 0c 08       	push   $0x80c8900
 804e652:	e8 a9 a4 ff ff       	call   8048b00 <snprintf@plt>
 804e657:	83 c4 20             	add    $0x20,%esp
 804e65a:	83 f8 4f             	cmp    $0x4f,%eax
 804e65d:	7f 11                	jg     804e670 <shrdi_l+0xa0>
make_helper(concat(shrdi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
	do_execute();
	return len + 1;
}
 804e65f:	83 c4 04             	add    $0x4,%esp

make_helper(concat(shrdi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
	do_execute();
	return len + 1;
 804e662:	8d 43 01             	lea    0x1(%ebx),%eax
}
 804e665:	5b                   	pop    %ebx
 804e666:	5e                   	pop    %esi
 804e667:	c3                   	ret    
 804e668:	90                   	nop
 804e669:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		count --;
	}

	OPERAND_W(op_src2, out);

	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804e670:	83 ec 0c             	sub    $0xc,%esp
 804e673:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804e679:	e8 e2 a2 ff ff       	call   8048960 <fflush@plt>
 804e67e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e684:	6a 07                	push   $0x7
 804e686:	6a 01                	push   $0x1
 804e688:	68 92 ed 05 08       	push   $0x805ed92
 804e68d:	e8 7e a3 ff ff       	call   8048a10 <fwrite@plt>
 804e692:	83 c4 20             	add    $0x20,%esp
 804e695:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e69b:	6a 10                	push   $0x10
 804e69d:	6a 01                	push   $0x1
 804e69f:	68 84 f8 05 08       	push   $0x805f884
 804e6a4:	e8 67 a3 ff ff       	call   8048a10 <fwrite@plt>
 804e6a9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e6af:	6a 05                	push   $0x5
 804e6b1:	6a 01                	push   $0x1
 804e6b3:	68 b1 ed 05 08       	push   $0x805edb1
 804e6b8:	e8 53 a3 ff ff       	call   8048a10 <fwrite@plt>
 804e6bd:	83 c4 18             	add    $0x18,%esp
 804e6c0:	68 88 ae 8f 14       	push   $0x148fae88
 804e6c5:	68 50 ae 8f 14       	push   $0x148fae50
 804e6ca:	68 18 ae 8f 14       	push   $0x148fae18
 804e6cf:	68 c6 09 06 08       	push   $0x80609c6
 804e6d4:	6a 50                	push   $0x50
 804e6d6:	68 00 89 0c 08       	push   $0x80c8900
 804e6db:	e8 20 a4 ff ff       	call   8048b00 <snprintf@plt>
 804e6e0:	83 c4 20             	add    $0x20,%esp
 804e6e3:	83 f8 4f             	cmp    $0x4f,%eax
 804e6e6:	0f 8e 73 ff ff ff    	jle    804e65f <shrdi_l+0x8f>
 804e6ec:	68 05 0b 06 08       	push   $0x8060b05
 804e6f1:	6a 15                	push   $0x15
 804e6f3:	68 d8 09 06 08       	push   $0x80609d8
 804e6f8:	68 84 0a 06 08       	push   $0x8060a84
 804e6fd:	e8 ae a4 ff ff       	call   8048bb0 <__assert_fail@plt>
 804e702:	e8 d2 a4 ff ff       	call   8048bd9 <check_reg_index.part.0>
 804e707:	89 f6                	mov    %esi,%esi
 804e709:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804e710 <shrdi_v>:
#define DATA_BYTE 4
#include "shrd-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */
make_helper_v(shrdi)
 804e710:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804e717:	8b 54 24 04          	mov    0x4(%esp),%edx
 804e71b:	b8 80 e4 04 08       	mov    $0x804e480,%eax
 804e720:	75 05                	jne    804e727 <shrdi_v+0x17>
 804e722:	b8 d0 e5 04 08       	mov    $0x804e5d0,%eax
 804e727:	89 54 24 04          	mov    %edx,0x4(%esp)
 804e72b:	ff e0                	jmp    *%eax
 804e72d:	66 90                	xchg   %ax,%ax
 804e72f:	90                   	nop

0804e730 <do_and_b>:
#include "cpu/exec/template-start.h"

#define instr and

static void do_execute () {
 804e730:	56                   	push   %esi
 804e731:	53                   	push   %ebx
 804e732:	83 ec 0c             	sub    $0xc,%esp
	DATA_TYPE result = op_dest->val & op_src->val;
 804e735:	a1 4c ae 8f 14       	mov    0x148fae4c,%eax
 804e73a:	22 05 14 ae 8f 14    	and    0x148fae14,%al
	OPERAND_W(op_dest, result);
 804e740:	0f b6 d8             	movzbl %al,%ebx
#include "cpu/exec/template-start.h"

#define instr and

static void do_execute () {
	DATA_TYPE result = op_dest->val & op_src->val;
 804e743:	89 c6                	mov    %eax,%esi
	OPERAND_W(op_dest, result);
 804e745:	53                   	push   %ebx
 804e746:	68 40 ae 8f 14       	push   $0x148fae40
 804e74b:	e8 f0 e4 00 00       	call   805cc40 <write_operand_b>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e750:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
	cpu.ZF = !result;
 804e757:	89 f0                	mov    %esi,%eax
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e759:	89 f2                	mov    %esi,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 804e75b:	80 25 e5 ae 8f 14 f7 	andb   $0xf7,0x148faee5
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e762:	83 e2 80             	and    $0xffffff80,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e765:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 804e76c:	68 18 ae 8f 14       	push   $0x148fae18
 804e771:	68 29 0b 06 08       	push   $0x8060b29
 804e776:	6a 50                	push   $0x50
 804e778:	68 00 89 0c 08       	push   $0x80c8900
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e77d:	83 e1 3e             	and    $0x3e,%ecx
	cpu.ZF = !result;
 804e780:	84 c0                	test   %al,%al
 804e782:	0f 94 c0             	sete   %al
 804e785:	09 ca                	or     %ecx,%edx
 804e787:	c1 e0 06             	shl    $0x6,%eax
 804e78a:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804e78c:	89 d8                	mov    %ebx,%eax
 804e78e:	c1 e8 04             	shr    $0x4,%eax
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 804e791:	83 e2 fb             	and    $0xfffffffb,%edx
	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804e794:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 2) ^ pf;
 804e796:	89 d8                	mov    %ebx,%eax
 804e798:	c1 e8 02             	shr    $0x2,%eax
 804e79b:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 804e79d:	89 d8                	mov    %ebx,%eax
 804e79f:	d1 e8                	shr    %eax
 804e7a1:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 804e7a3:	83 e3 01             	and    $0x1,%ebx
 804e7a6:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 804e7ad:	89 d3                	mov    %edx,%ebx
 804e7af:	09 c3                	or     %eax,%ebx
 804e7b1:	88 1d e4 ae 8f 14    	mov    %bl,0x148faee4

	print_asm_template2();
 804e7b7:	e8 44 a3 ff ff       	call   8048b00 <snprintf@plt>
 804e7bc:	83 c4 20             	add    $0x20,%esp
 804e7bf:	83 f8 4f             	cmp    $0x4f,%eax
 804e7c2:	7f 0c                	jg     804e7d0 <do_and_b+0xa0>
}
 804e7c4:	83 c4 04             	add    $0x4,%esp
 804e7c7:	5b                   	pop    %ebx
 804e7c8:	5e                   	pop    %esi
 804e7c9:	c3                   	ret    
 804e7ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e7d0:	83 ec 0c             	sub    $0xc,%esp
 804e7d3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804e7d9:	e8 82 a1 ff ff       	call   8048960 <fflush@plt>
 804e7de:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e7e4:	6a 07                	push   $0x7
 804e7e6:	6a 01                	push   $0x1
 804e7e8:	68 92 ed 05 08       	push   $0x805ed92
 804e7ed:	e8 1e a2 ff ff       	call   8048a10 <fwrite@plt>
 804e7f2:	83 c4 20             	add    $0x20,%esp
 804e7f5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e7fb:	6a 10                	push   $0x10
 804e7fd:	6a 01                	push   $0x1
 804e7ff:	68 84 f8 05 08       	push   $0x805f884
 804e804:	e8 07 a2 ff ff       	call   8048a10 <fwrite@plt>
 804e809:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e80f:	6a 05                	push   $0x5
 804e811:	6a 01                	push   $0x1
 804e813:	68 b1 ed 05 08       	push   $0x805edb1
 804e818:	e8 f3 a1 ff ff       	call   8048a10 <fwrite@plt>
 804e81d:	83 c4 14             	add    $0x14,%esp
 804e820:	68 50 ae 8f 14       	push   $0x148fae50
 804e825:	68 18 ae 8f 14       	push   $0x148fae18
 804e82a:	68 29 0b 06 08       	push   $0x8060b29
 804e82f:	6a 50                	push   $0x50
 804e831:	68 00 89 0c 08       	push   $0x80c8900
 804e836:	e8 c5 a2 ff ff       	call   8048b00 <snprintf@plt>
 804e83b:	83 c4 20             	add    $0x20,%esp
 804e83e:	83 f8 4f             	cmp    $0x4f,%eax
 804e841:	7e 81                	jle    804e7c4 <do_and_b+0x94>
 804e843:	68 b1 0c 06 08       	push   $0x8060cb1
 804e848:	6a 13                	push   $0x13
 804e84a:	68 4c 0b 06 08       	push   $0x8060b4c
 804e84f:	68 74 0b 06 08       	push   $0x8060b74
 804e854:	e8 57 a3 ff ff       	call   8048bb0 <__assert_fail@plt>
 804e859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804e860 <do_and_w>:
#include "cpu/exec/template-start.h"

#define instr and

static void do_execute () {
 804e860:	53                   	push   %ebx
 804e861:	83 ec 10             	sub    $0x10,%esp
	DATA_TYPE result = op_dest->val & op_src->val;
 804e864:	8b 1d 4c ae 8f 14    	mov    0x148fae4c,%ebx
 804e86a:	66 23 1d 14 ae 8f 14 	and    0x148fae14,%bx
	OPERAND_W(op_dest, result);
 804e871:	0f b7 c3             	movzwl %bx,%eax
 804e874:	50                   	push   %eax
 804e875:	68 40 ae 8f 14       	push   $0x148fae40
 804e87a:	e8 51 e7 00 00       	call   805cfd0 <write_operand_w>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e87f:	89 da                	mov    %ebx,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 804e881:	80 25 e5 ae 8f 14 f7 	andb   $0xf7,0x148faee5
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e888:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e88f:	66 c1 ea 0f          	shr    $0xf,%dx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e893:	68 18 ae 8f 14       	push   $0x148fae18
 804e898:	68 34 0b 06 08       	push   $0x8060b34
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e89d:	89 d0                	mov    %edx,%eax
 804e89f:	0f b6 15 e4 ae 8f 14 	movzbl 0x148faee4,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e8a6:	6a 50                	push   $0x50
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e8a8:	c1 e0 07             	shl    $0x7,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e8ab:	68 00 89 0c 08       	push   $0x80c8900
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e8b0:	83 e2 3e             	and    $0x3e,%edx
	cpu.ZF = !result;
 804e8b3:	66 85 db             	test   %bx,%bx
	uint32_t pf = (result & 255);
 804e8b6:	0f b6 db             	movzbl %bl,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804e8b9:	0f 94 c1             	sete   %cl
 804e8bc:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804e8be:	89 d8                	mov    %ebx,%eax
 804e8c0:	c1 e8 04             	shr    $0x4,%eax
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804e8c3:	c1 e1 06             	shl    $0x6,%ecx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804e8c6:	31 c3                	xor    %eax,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804e8c8:	09 ca                	or     %ecx,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804e8ca:	89 d8                	mov    %ebx,%eax
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 804e8cc:	83 e2 fb             	and    $0xfffffffb,%edx
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804e8cf:	c1 e8 02             	shr    $0x2,%eax
 804e8d2:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 804e8d4:	89 d8                	mov    %ebx,%eax
 804e8d6:	d1 e8                	shr    %eax
 804e8d8:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 804e8da:	83 e3 01             	and    $0x1,%ebx
 804e8dd:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 804e8e4:	89 d3                	mov    %edx,%ebx
 804e8e6:	09 c3                	or     %eax,%ebx
 804e8e8:	88 1d e4 ae 8f 14    	mov    %bl,0x148faee4

	print_asm_template2();
 804e8ee:	e8 0d a2 ff ff       	call   8048b00 <snprintf@plt>
 804e8f3:	83 c4 20             	add    $0x20,%esp
 804e8f6:	83 f8 4f             	cmp    $0x4f,%eax
 804e8f9:	7f 05                	jg     804e900 <do_and_w+0xa0>
}
 804e8fb:	83 c4 08             	add    $0x8,%esp
 804e8fe:	5b                   	pop    %ebx
 804e8ff:	c3                   	ret    
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e900:	83 ec 0c             	sub    $0xc,%esp
 804e903:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804e909:	e8 52 a0 ff ff       	call   8048960 <fflush@plt>
 804e90e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e914:	6a 07                	push   $0x7
 804e916:	6a 01                	push   $0x1
 804e918:	68 92 ed 05 08       	push   $0x805ed92
 804e91d:	e8 ee a0 ff ff       	call   8048a10 <fwrite@plt>
 804e922:	83 c4 20             	add    $0x20,%esp
 804e925:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e92b:	6a 10                	push   $0x10
 804e92d:	6a 01                	push   $0x1
 804e92f:	68 84 f8 05 08       	push   $0x805f884
 804e934:	e8 d7 a0 ff ff       	call   8048a10 <fwrite@plt>
 804e939:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804e93f:	6a 05                	push   $0x5
 804e941:	6a 01                	push   $0x1
 804e943:	68 b1 ed 05 08       	push   $0x805edb1
 804e948:	e8 c3 a0 ff ff       	call   8048a10 <fwrite@plt>
 804e94d:	83 c4 14             	add    $0x14,%esp
 804e950:	68 50 ae 8f 14       	push   $0x148fae50
 804e955:	68 18 ae 8f 14       	push   $0x148fae18
 804e95a:	68 34 0b 06 08       	push   $0x8060b34
 804e95f:	6a 50                	push   $0x50
 804e961:	68 00 89 0c 08       	push   $0x80c8900
 804e966:	e8 95 a1 ff ff       	call   8048b00 <snprintf@plt>
 804e96b:	83 c4 20             	add    $0x20,%esp
 804e96e:	83 f8 4f             	cmp    $0x4f,%eax
 804e971:	7e 88                	jle    804e8fb <do_and_w+0x9b>
 804e973:	68 a8 0c 06 08       	push   $0x8060ca8
 804e978:	6a 13                	push   $0x13
 804e97a:	68 4c 0b 06 08       	push   $0x8060b4c
 804e97f:	68 d8 0b 06 08       	push   $0x8060bd8
 804e984:	e8 27 a2 ff ff       	call   8048bb0 <__assert_fail@plt>
 804e989:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804e990 <and_i2a_w>:
}

make_instr_helper(i2a)
 804e990:	53                   	push   %ebx
 804e991:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e994:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e998:	83 c0 01             	add    $0x1,%eax
 804e99b:	50                   	push   %eax
 804e99c:	e8 ef e3 00 00       	call   805cd90 <decode_i2a_w>
 804e9a1:	89 c3                	mov    %eax,%ebx
	execute();
 804e9a3:	e8 b8 fe ff ff       	call   804e860 <do_and_w>
 804e9a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e9ab:	8d 43 01             	lea    0x1(%ebx),%eax
 804e9ae:	5b                   	pop    %ebx
 804e9af:	c3                   	ret    

0804e9b0 <and_i2rm_w>:
make_instr_helper(i2rm)
 804e9b0:	53                   	push   %ebx
 804e9b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e9b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e9b8:	83 c0 01             	add    $0x1,%eax
 804e9bb:	50                   	push   %eax
 804e9bc:	e8 4f e4 00 00       	call   805ce10 <decode_i2rm_w>
 804e9c1:	89 c3                	mov    %eax,%ebx
	execute();
 804e9c3:	e8 98 fe ff ff       	call   804e860 <do_and_w>
 804e9c8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e9cb:	8d 43 01             	lea    0x1(%ebx),%eax
 804e9ce:	5b                   	pop    %ebx
 804e9cf:	c3                   	ret    

0804e9d0 <and_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 804e9d0:	53                   	push   %ebx
 804e9d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e9d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e9d8:	83 c0 01             	add    $0x1,%eax
 804e9db:	50                   	push   %eax
 804e9dc:	e8 af e4 00 00       	call   805ce90 <decode_si2rm_w>
 804e9e1:	89 c3                	mov    %eax,%ebx
	execute();
 804e9e3:	e8 78 fe ff ff       	call   804e860 <do_and_w>
 804e9e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e9eb:	8d 43 01             	lea    0x1(%ebx),%eax
 804e9ee:	5b                   	pop    %ebx
 804e9ef:	c3                   	ret    

0804e9f0 <and_r2rm_w>:
#endif
make_instr_helper(r2rm)
 804e9f0:	53                   	push   %ebx
 804e9f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e9f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e9f8:	83 c0 01             	add    $0x1,%eax
 804e9fb:	50                   	push   %eax
 804e9fc:	e8 4f e3 00 00       	call   805cd50 <decode_r2rm_w>
 804ea01:	89 c3                	mov    %eax,%ebx
	execute();
 804ea03:	e8 58 fe ff ff       	call   804e860 <do_and_w>
 804ea08:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ea0b:	8d 43 01             	lea    0x1(%ebx),%eax
 804ea0e:	5b                   	pop    %ebx
 804ea0f:	c3                   	ret    

0804ea10 <and_rm2r_w>:
make_instr_helper(rm2r)
 804ea10:	53                   	push   %ebx
 804ea11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804ea14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ea18:	83 c0 01             	add    $0x1,%eax
 804ea1b:	50                   	push   %eax
 804ea1c:	e8 4f e3 00 00       	call   805cd70 <decode_rm2r_w>
 804ea21:	89 c3                	mov    %eax,%ebx
	execute();
 804ea23:	e8 38 fe ff ff       	call   804e860 <do_and_w>
 804ea28:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ea2b:	8d 43 01             	lea    0x1(%ebx),%eax
 804ea2e:	5b                   	pop    %ebx
 804ea2f:	c3                   	ret    

0804ea30 <do_and_l>:
#include "cpu/exec/template-start.h"

#define instr and

static void do_execute () {
 804ea30:	53                   	push   %ebx
 804ea31:	83 ec 10             	sub    $0x10,%esp
	DATA_TYPE result = op_dest->val & op_src->val;
 804ea34:	8b 1d 14 ae 8f 14    	mov    0x148fae14,%ebx
 804ea3a:	23 1d 4c ae 8f 14    	and    0x148fae4c,%ebx
	OPERAND_W(op_dest, result);
 804ea40:	53                   	push   %ebx
 804ea41:	68 40 ae 8f 14       	push   $0x148fae40
 804ea46:	e8 55 e9 00 00       	call   805d3a0 <write_operand_l>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804ea4b:	89 da                	mov    %ebx,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 804ea4d:	80 25 e5 ae 8f 14 f7 	andb   $0xf7,0x148faee5
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804ea54:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804ea5b:	c1 ea 1f             	shr    $0x1f,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804ea5e:	68 18 ae 8f 14       	push   $0x148fae18
 804ea63:	68 3f 0b 06 08       	push   $0x8060b3f
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804ea68:	89 d0                	mov    %edx,%eax
 804ea6a:	0f b6 15 e4 ae 8f 14 	movzbl 0x148faee4,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804ea71:	6a 50                	push   $0x50
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804ea73:	c1 e0 07             	shl    $0x7,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804ea76:	68 00 89 0c 08       	push   $0x80c8900
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804ea7b:	83 e2 3e             	and    $0x3e,%edx
	cpu.ZF = !result;
 804ea7e:	85 db                	test   %ebx,%ebx
	uint32_t pf = (result & 255);
 804ea80:	0f b6 db             	movzbl %bl,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804ea83:	0f 94 c1             	sete   %cl
 804ea86:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804ea88:	89 d8                	mov    %ebx,%eax
 804ea8a:	c1 e8 04             	shr    $0x4,%eax
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804ea8d:	c1 e1 06             	shl    $0x6,%ecx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804ea90:	31 c3                	xor    %eax,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804ea92:	09 ca                	or     %ecx,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804ea94:	89 d8                	mov    %ebx,%eax
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 804ea96:	83 e2 fb             	and    $0xfffffffb,%edx
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804ea99:	c1 e8 02             	shr    $0x2,%eax
 804ea9c:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 804ea9e:	89 d8                	mov    %ebx,%eax
 804eaa0:	d1 e8                	shr    %eax
 804eaa2:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 804eaa4:	83 e3 01             	and    $0x1,%ebx
 804eaa7:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 804eaae:	89 d3                	mov    %edx,%ebx
 804eab0:	09 c3                	or     %eax,%ebx
 804eab2:	88 1d e4 ae 8f 14    	mov    %bl,0x148faee4

	print_asm_template2();
 804eab8:	e8 43 a0 ff ff       	call   8048b00 <snprintf@plt>
 804eabd:	83 c4 20             	add    $0x20,%esp
 804eac0:	83 f8 4f             	cmp    $0x4f,%eax
 804eac3:	7f 0b                	jg     804ead0 <do_and_l+0xa0>
}
 804eac5:	83 c4 08             	add    $0x8,%esp
 804eac8:	5b                   	pop    %ebx
 804eac9:	c3                   	ret    
 804eaca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804ead0:	83 ec 0c             	sub    $0xc,%esp
 804ead3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804ead9:	e8 82 9e ff ff       	call   8048960 <fflush@plt>
 804eade:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804eae4:	6a 07                	push   $0x7
 804eae6:	6a 01                	push   $0x1
 804eae8:	68 92 ed 05 08       	push   $0x805ed92
 804eaed:	e8 1e 9f ff ff       	call   8048a10 <fwrite@plt>
 804eaf2:	83 c4 20             	add    $0x20,%esp
 804eaf5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804eafb:	6a 10                	push   $0x10
 804eafd:	6a 01                	push   $0x1
 804eaff:	68 84 f8 05 08       	push   $0x805f884
 804eb04:	e8 07 9f ff ff       	call   8048a10 <fwrite@plt>
 804eb09:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804eb0f:	6a 05                	push   $0x5
 804eb11:	6a 01                	push   $0x1
 804eb13:	68 b1 ed 05 08       	push   $0x805edb1
 804eb18:	e8 f3 9e ff ff       	call   8048a10 <fwrite@plt>
 804eb1d:	83 c4 14             	add    $0x14,%esp
 804eb20:	68 50 ae 8f 14       	push   $0x148fae50
 804eb25:	68 18 ae 8f 14       	push   $0x148fae18
 804eb2a:	68 3f 0b 06 08       	push   $0x8060b3f
 804eb2f:	6a 50                	push   $0x50
 804eb31:	68 00 89 0c 08       	push   $0x80c8900
 804eb36:	e8 c5 9f ff ff       	call   8048b00 <snprintf@plt>
 804eb3b:	83 c4 20             	add    $0x20,%esp
 804eb3e:	83 f8 4f             	cmp    $0x4f,%eax
 804eb41:	7e 82                	jle    804eac5 <do_and_l+0x95>
 804eb43:	68 9f 0c 06 08       	push   $0x8060c9f
 804eb48:	6a 13                	push   $0x13
 804eb4a:	68 4c 0b 06 08       	push   $0x8060b4c
 804eb4f:	68 3c 0c 06 08       	push   $0x8060c3c
 804eb54:	e8 57 a0 ff ff       	call   8048bb0 <__assert_fail@plt>
 804eb59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804eb60 <and_i2a_l>:
}

make_instr_helper(i2a)
 804eb60:	53                   	push   %ebx
 804eb61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804eb64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804eb68:	83 c0 01             	add    $0x1,%eax
 804eb6b:	50                   	push   %eax
 804eb6c:	e8 ef e5 00 00       	call   805d160 <decode_i2a_l>
 804eb71:	89 c3                	mov    %eax,%ebx
	execute();
 804eb73:	e8 b8 fe ff ff       	call   804ea30 <do_and_l>
 804eb78:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804eb7b:	8d 43 01             	lea    0x1(%ebx),%eax
 804eb7e:	5b                   	pop    %ebx
 804eb7f:	c3                   	ret    

0804eb80 <and_i2rm_l>:
make_instr_helper(i2rm)
 804eb80:	53                   	push   %ebx
 804eb81:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804eb84:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804eb88:	83 c0 01             	add    $0x1,%eax
 804eb8b:	50                   	push   %eax
 804eb8c:	e8 4f e6 00 00       	call   805d1e0 <decode_i2rm_l>
 804eb91:	89 c3                	mov    %eax,%ebx
	execute();
 804eb93:	e8 98 fe ff ff       	call   804ea30 <do_and_l>
 804eb98:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804eb9b:	8d 43 01             	lea    0x1(%ebx),%eax
 804eb9e:	5b                   	pop    %ebx
 804eb9f:	c3                   	ret    

0804eba0 <and_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 804eba0:	53                   	push   %ebx
 804eba1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804eba4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804eba8:	83 c0 01             	add    $0x1,%eax
 804ebab:	50                   	push   %eax
 804ebac:	e8 af e6 00 00       	call   805d260 <decode_si2rm_l>
 804ebb1:	89 c3                	mov    %eax,%ebx
	execute();
 804ebb3:	e8 78 fe ff ff       	call   804ea30 <do_and_l>
 804ebb8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ebbb:	8d 43 01             	lea    0x1(%ebx),%eax
 804ebbe:	5b                   	pop    %ebx
 804ebbf:	c3                   	ret    

0804ebc0 <and_r2rm_l>:
#endif
make_instr_helper(r2rm)
 804ebc0:	53                   	push   %ebx
 804ebc1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804ebc4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ebc8:	83 c0 01             	add    $0x1,%eax
 804ebcb:	50                   	push   %eax
 804ebcc:	e8 4f e5 00 00       	call   805d120 <decode_r2rm_l>
 804ebd1:	89 c3                	mov    %eax,%ebx
	execute();
 804ebd3:	e8 58 fe ff ff       	call   804ea30 <do_and_l>
 804ebd8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ebdb:	8d 43 01             	lea    0x1(%ebx),%eax
 804ebde:	5b                   	pop    %ebx
 804ebdf:	c3                   	ret    

0804ebe0 <and_rm2r_l>:
make_instr_helper(rm2r)
 804ebe0:	53                   	push   %ebx
 804ebe1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804ebe4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ebe8:	83 c0 01             	add    $0x1,%eax
 804ebeb:	50                   	push   %eax
 804ebec:	e8 4f e5 00 00       	call   805d140 <decode_rm2r_l>
 804ebf1:	89 c3                	mov    %eax,%ebx
	execute();
 804ebf3:	e8 38 fe ff ff       	call   804ea30 <do_and_l>
 804ebf8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ebfb:	8d 43 01             	lea    0x1(%ebx),%eax
 804ebfe:	5b                   	pop    %ebx
 804ebff:	c3                   	ret    

0804ec00 <and_i2a_b>:
	cpu.PF = pf & 1;

	print_asm_template2();
}

make_instr_helper(i2a)
 804ec00:	53                   	push   %ebx
 804ec01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804ec04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ec08:	83 c0 01             	add    $0x1,%eax
 804ec0b:	50                   	push   %eax
 804ec0c:	e8 4f de 00 00       	call   805ca60 <decode_i2a_b>
 804ec11:	89 c3                	mov    %eax,%ebx
	execute();
 804ec13:	e8 18 fb ff ff       	call   804e730 <do_and_b>
 804ec18:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ec1b:	8d 43 01             	lea    0x1(%ebx),%eax
 804ec1e:	5b                   	pop    %ebx
 804ec1f:	c3                   	ret    

0804ec20 <and_i2rm_b>:
make_instr_helper(i2rm)
 804ec20:	53                   	push   %ebx
 804ec21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804ec24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ec28:	83 c0 01             	add    $0x1,%eax
 804ec2b:	50                   	push   %eax
 804ec2c:	e8 af de 00 00       	call   805cae0 <decode_i2rm_b>
 804ec31:	89 c3                	mov    %eax,%ebx
	execute();
 804ec33:	e8 f8 fa ff ff       	call   804e730 <do_and_b>
 804ec38:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ec3b:	8d 43 01             	lea    0x1(%ebx),%eax
 804ec3e:	5b                   	pop    %ebx
 804ec3f:	c3                   	ret    

0804ec40 <and_r2rm_b>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
#endif
make_instr_helper(r2rm)
 804ec40:	53                   	push   %ebx
 804ec41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804ec44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ec48:	83 c0 01             	add    $0x1,%eax
 804ec4b:	50                   	push   %eax
 804ec4c:	e8 cf dd 00 00       	call   805ca20 <decode_r2rm_b>
 804ec51:	89 c3                	mov    %eax,%ebx
	execute();
 804ec53:	e8 d8 fa ff ff       	call   804e730 <do_and_b>
 804ec58:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ec5b:	8d 43 01             	lea    0x1(%ebx),%eax
 804ec5e:	5b                   	pop    %ebx
 804ec5f:	c3                   	ret    

0804ec60 <and_rm2r_b>:
make_instr_helper(rm2r)
 804ec60:	53                   	push   %ebx
 804ec61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804ec64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ec68:	83 c0 01             	add    $0x1,%eax
 804ec6b:	50                   	push   %eax
 804ec6c:	e8 cf dd 00 00       	call   805ca40 <decode_rm2r_b>
 804ec71:	89 c3                	mov    %eax,%ebx
	execute();
 804ec73:	e8 b8 fa ff ff       	call   804e730 <do_and_b>
 804ec78:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ec7b:	8d 43 01             	lea    0x1(%ebx),%eax
 804ec7e:	5b                   	pop    %ebx
 804ec7f:	c3                   	ret    

0804ec80 <and_i2a_v>:
#include "and-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(and_i2a)
 804ec80:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804ec87:	8b 54 24 04          	mov    0x4(%esp),%edx
 804ec8b:	b8 90 e9 04 08       	mov    $0x804e990,%eax
 804ec90:	75 05                	jne    804ec97 <and_i2a_v+0x17>
 804ec92:	b8 60 eb 04 08       	mov    $0x804eb60,%eax
 804ec97:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ec9b:	ff e0                	jmp    *%eax
 804ec9d:	8d 76 00             	lea    0x0(%esi),%esi

0804eca0 <and_i2rm_v>:
make_helper_v(and_i2rm)
 804eca0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804eca7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804ecab:	b8 b0 e9 04 08       	mov    $0x804e9b0,%eax
 804ecb0:	75 05                	jne    804ecb7 <and_i2rm_v+0x17>
 804ecb2:	b8 80 eb 04 08       	mov    $0x804eb80,%eax
 804ecb7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ecbb:	ff e0                	jmp    *%eax
 804ecbd:	8d 76 00             	lea    0x0(%esi),%esi

0804ecc0 <and_si2rm_v>:
make_helper_v(and_si2rm)
 804ecc0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804ecc7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804eccb:	b8 d0 e9 04 08       	mov    $0x804e9d0,%eax
 804ecd0:	75 05                	jne    804ecd7 <and_si2rm_v+0x17>
 804ecd2:	b8 a0 eb 04 08       	mov    $0x804eba0,%eax
 804ecd7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ecdb:	ff e0                	jmp    *%eax
 804ecdd:	8d 76 00             	lea    0x0(%esi),%esi

0804ece0 <and_r2rm_v>:
make_helper_v(and_r2rm)
 804ece0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804ece7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804eceb:	b8 f0 e9 04 08       	mov    $0x804e9f0,%eax
 804ecf0:	75 05                	jne    804ecf7 <and_r2rm_v+0x17>
 804ecf2:	b8 c0 eb 04 08       	mov    $0x804ebc0,%eax
 804ecf7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ecfb:	ff e0                	jmp    *%eax
 804ecfd:	8d 76 00             	lea    0x0(%esi),%esi

0804ed00 <and_rm2r_v>:
make_helper_v(and_rm2r)
 804ed00:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804ed07:	8b 54 24 04          	mov    0x4(%esp),%edx
 804ed0b:	b8 10 ea 04 08       	mov    $0x804ea10,%eax
 804ed10:	75 05                	jne    804ed17 <and_rm2r_v+0x17>
 804ed12:	b8 e0 eb 04 08       	mov    $0x804ebe0,%eax
 804ed17:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ed1b:	ff e0                	jmp    *%eax
 804ed1d:	66 90                	xchg   %ax,%ax
 804ed1f:	90                   	nop

0804ed20 <do_shl_b>:
#include "cpu/exec/template-start.h"

#define instr shl

static void do_execute () {
 804ed20:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804ed23:	0f b6 0d 14 ae 8f 14 	movzbl 0x148fae14,%ecx
 804ed2a:	0f b6 05 4c ae 8f 14 	movzbl 0x148fae4c,%eax
 804ed31:	83 e1 1f             	and    $0x1f,%ecx
	dest <<= count;
 804ed34:	d3 e0                	shl    %cl,%eax
	OPERAND_W(op_dest, dest);
 804ed36:	0f b6 c0             	movzbl %al,%eax
 804ed39:	50                   	push   %eax
 804ed3a:	68 40 ae 8f 14       	push   $0x148fae40
 804ed3f:	e8 fc de 00 00       	call   805cc40 <write_operand_b>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804ed44:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 804ed4b:	68 18 ae 8f 14       	push   $0x148fae18
 804ed50:	68 ba 0c 06 08       	push   $0x8060cba
 804ed55:	6a 50                	push   $0x50
 804ed57:	68 00 89 0c 08       	push   $0x80c8900
 804ed5c:	e8 9f 9d ff ff       	call   8048b00 <snprintf@plt>
 804ed61:	83 c4 20             	add    $0x20,%esp
 804ed64:	83 f8 4f             	cmp    $0x4f,%eax
 804ed67:	7f 07                	jg     804ed70 <do_shl_b+0x50>
}
 804ed69:	83 c4 0c             	add    $0xc,%esp
 804ed6c:	c3                   	ret    
 804ed6d:	8d 76 00             	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804ed70:	83 ec 0c             	sub    $0xc,%esp
 804ed73:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804ed79:	e8 e2 9b ff ff       	call   8048960 <fflush@plt>
 804ed7e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804ed84:	6a 07                	push   $0x7
 804ed86:	6a 01                	push   $0x1
 804ed88:	68 92 ed 05 08       	push   $0x805ed92
 804ed8d:	e8 7e 9c ff ff       	call   8048a10 <fwrite@plt>
 804ed92:	83 c4 20             	add    $0x20,%esp
 804ed95:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804ed9b:	6a 10                	push   $0x10
 804ed9d:	6a 01                	push   $0x1
 804ed9f:	68 84 f8 05 08       	push   $0x805f884
 804eda4:	e8 67 9c ff ff       	call   8048a10 <fwrite@plt>
 804eda9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804edaf:	6a 05                	push   $0x5
 804edb1:	6a 01                	push   $0x1
 804edb3:	68 b1 ed 05 08       	push   $0x805edb1
 804edb8:	e8 53 9c ff ff       	call   8048a10 <fwrite@plt>
 804edbd:	83 c4 14             	add    $0x14,%esp
 804edc0:	68 50 ae 8f 14       	push   $0x148fae50
 804edc5:	68 18 ae 8f 14       	push   $0x148fae18
 804edca:	68 ba 0c 06 08       	push   $0x8060cba
 804edcf:	6a 50                	push   $0x50
 804edd1:	68 00 89 0c 08       	push   $0x80c8900
 804edd6:	e8 25 9d ff ff       	call   8048b00 <snprintf@plt>
 804eddb:	83 c4 20             	add    $0x20,%esp
 804edde:	83 f8 4f             	cmp    $0x4f,%eax
 804ede1:	7e 86                	jle    804ed69 <do_shl_b+0x49>
 804ede3:	68 41 0e 06 08       	push   $0x8060e41
 804ede8:	6a 11                	push   $0x11
 804edea:	68 dc 0c 06 08       	push   $0x8060cdc
 804edef:	68 04 0d 06 08       	push   $0x8060d04
 804edf4:	e8 b7 9d ff ff       	call   8048bb0 <__assert_fail@plt>
 804edf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804ee00 <do_shl_w>:
#include "cpu/exec/template-start.h"

#define instr shl

static void do_execute () {
 804ee00:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804ee03:	0f b6 0d 14 ae 8f 14 	movzbl 0x148fae14,%ecx
 804ee0a:	0f b7 05 4c ae 8f 14 	movzwl 0x148fae4c,%eax
 804ee11:	83 e1 1f             	and    $0x1f,%ecx
	dest <<= count;
 804ee14:	d3 e0                	shl    %cl,%eax
	OPERAND_W(op_dest, dest);
 804ee16:	0f b7 c0             	movzwl %ax,%eax
 804ee19:	50                   	push   %eax
 804ee1a:	68 40 ae 8f 14       	push   $0x148fae40
 804ee1f:	e8 ac e1 00 00       	call   805cfd0 <write_operand_w>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804ee24:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 804ee2b:	68 18 ae 8f 14       	push   $0x148fae18
 804ee30:	68 c5 0c 06 08       	push   $0x8060cc5
 804ee35:	6a 50                	push   $0x50
 804ee37:	68 00 89 0c 08       	push   $0x80c8900
 804ee3c:	e8 bf 9c ff ff       	call   8048b00 <snprintf@plt>
 804ee41:	83 c4 20             	add    $0x20,%esp
 804ee44:	83 f8 4f             	cmp    $0x4f,%eax
 804ee47:	7f 07                	jg     804ee50 <do_shl_w+0x50>
}
 804ee49:	83 c4 0c             	add    $0xc,%esp
 804ee4c:	c3                   	ret    
 804ee4d:	8d 76 00             	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804ee50:	83 ec 0c             	sub    $0xc,%esp
 804ee53:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804ee59:	e8 02 9b ff ff       	call   8048960 <fflush@plt>
 804ee5e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804ee64:	6a 07                	push   $0x7
 804ee66:	6a 01                	push   $0x1
 804ee68:	68 92 ed 05 08       	push   $0x805ed92
 804ee6d:	e8 9e 9b ff ff       	call   8048a10 <fwrite@plt>
 804ee72:	83 c4 20             	add    $0x20,%esp
 804ee75:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804ee7b:	6a 10                	push   $0x10
 804ee7d:	6a 01                	push   $0x1
 804ee7f:	68 84 f8 05 08       	push   $0x805f884
 804ee84:	e8 87 9b ff ff       	call   8048a10 <fwrite@plt>
 804ee89:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804ee8f:	6a 05                	push   $0x5
 804ee91:	6a 01                	push   $0x1
 804ee93:	68 b1 ed 05 08       	push   $0x805edb1
 804ee98:	e8 73 9b ff ff       	call   8048a10 <fwrite@plt>
 804ee9d:	83 c4 14             	add    $0x14,%esp
 804eea0:	68 50 ae 8f 14       	push   $0x148fae50
 804eea5:	68 18 ae 8f 14       	push   $0x148fae18
 804eeaa:	68 c5 0c 06 08       	push   $0x8060cc5
 804eeaf:	6a 50                	push   $0x50
 804eeb1:	68 00 89 0c 08       	push   $0x80c8900
 804eeb6:	e8 45 9c ff ff       	call   8048b00 <snprintf@plt>
 804eebb:	83 c4 20             	add    $0x20,%esp
 804eebe:	83 f8 4f             	cmp    $0x4f,%eax
 804eec1:	7e 86                	jle    804ee49 <do_shl_w+0x49>
 804eec3:	68 38 0e 06 08       	push   $0x8060e38
 804eec8:	6a 11                	push   $0x11
 804eeca:	68 dc 0c 06 08       	push   $0x8060cdc
 804eecf:	68 68 0d 06 08       	push   $0x8060d68
 804eed4:	e8 d7 9c ff ff       	call   8048bb0 <__assert_fail@plt>
 804eed9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804eee0 <shl_rm_1_w>:
}

make_instr_helper(rm_1)
 804eee0:	53                   	push   %ebx
 804eee1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804eee4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804eee8:	83 c0 01             	add    $0x1,%eax
 804eeeb:	50                   	push   %eax
 804eeec:	e8 ff df 00 00       	call   805cef0 <decode_rm_1_w>
 804eef1:	89 c3                	mov    %eax,%ebx
	execute();
 804eef3:	e8 08 ff ff ff       	call   804ee00 <do_shl_w>
 804eef8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804eefb:	8d 43 01             	lea    0x1(%ebx),%eax
 804eefe:	5b                   	pop    %ebx
 804eeff:	c3                   	ret    

0804ef00 <shl_rm_cl_w>:
make_instr_helper(rm_cl)
 804ef00:	53                   	push   %ebx
 804ef01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804ef04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ef08:	83 c0 01             	add    $0x1,%eax
 804ef0b:	50                   	push   %eax
 804ef0c:	e8 2f e0 00 00       	call   805cf40 <decode_rm_cl_w>
 804ef11:	89 c3                	mov    %eax,%ebx
	execute();
 804ef13:	e8 e8 fe ff ff       	call   804ee00 <do_shl_w>
 804ef18:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ef1b:	8d 43 01             	lea    0x1(%ebx),%eax
 804ef1e:	5b                   	pop    %ebx
 804ef1f:	c3                   	ret    

0804ef20 <shl_rm_imm_w>:
make_instr_helper(rm_imm)
 804ef20:	53                   	push   %ebx
 804ef21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804ef24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ef28:	83 c0 01             	add    $0x1,%eax
 804ef2b:	50                   	push   %eax
 804ef2c:	e8 6f e0 00 00       	call   805cfa0 <decode_rm_imm_w>
 804ef31:	89 c3                	mov    %eax,%ebx
	execute();
 804ef33:	e8 c8 fe ff ff       	call   804ee00 <do_shl_w>
 804ef38:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ef3b:	8d 43 01             	lea    0x1(%ebx),%eax
 804ef3e:	5b                   	pop    %ebx
 804ef3f:	c3                   	ret    

0804ef40 <do_shl_l>:
#include "cpu/exec/template-start.h"

#define instr shl

static void do_execute () {
 804ef40:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804ef43:	0f b6 0d 14 ae 8f 14 	movzbl 0x148fae14,%ecx
	dest <<= count;
 804ef4a:	a1 4c ae 8f 14       	mov    0x148fae4c,%eax

static void do_execute () {
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804ef4f:	83 e1 1f             	and    $0x1f,%ecx
	dest <<= count;
 804ef52:	d3 e0                	shl    %cl,%eax
	OPERAND_W(op_dest, dest);
 804ef54:	50                   	push   %eax
 804ef55:	68 40 ae 8f 14       	push   $0x148fae40
 804ef5a:	e8 41 e4 00 00       	call   805d3a0 <write_operand_l>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804ef5f:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 804ef66:	68 18 ae 8f 14       	push   $0x148fae18
 804ef6b:	68 d0 0c 06 08       	push   $0x8060cd0
 804ef70:	6a 50                	push   $0x50
 804ef72:	68 00 89 0c 08       	push   $0x80c8900
 804ef77:	e8 84 9b ff ff       	call   8048b00 <snprintf@plt>
 804ef7c:	83 c4 20             	add    $0x20,%esp
 804ef7f:	83 f8 4f             	cmp    $0x4f,%eax
 804ef82:	7f 0c                	jg     804ef90 <do_shl_l+0x50>
}
 804ef84:	83 c4 0c             	add    $0xc,%esp
 804ef87:	c3                   	ret    
 804ef88:	90                   	nop
 804ef89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804ef90:	83 ec 0c             	sub    $0xc,%esp
 804ef93:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804ef99:	e8 c2 99 ff ff       	call   8048960 <fflush@plt>
 804ef9e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804efa4:	6a 07                	push   $0x7
 804efa6:	6a 01                	push   $0x1
 804efa8:	68 92 ed 05 08       	push   $0x805ed92
 804efad:	e8 5e 9a ff ff       	call   8048a10 <fwrite@plt>
 804efb2:	83 c4 20             	add    $0x20,%esp
 804efb5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804efbb:	6a 10                	push   $0x10
 804efbd:	6a 01                	push   $0x1
 804efbf:	68 84 f8 05 08       	push   $0x805f884
 804efc4:	e8 47 9a ff ff       	call   8048a10 <fwrite@plt>
 804efc9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804efcf:	6a 05                	push   $0x5
 804efd1:	6a 01                	push   $0x1
 804efd3:	68 b1 ed 05 08       	push   $0x805edb1
 804efd8:	e8 33 9a ff ff       	call   8048a10 <fwrite@plt>
 804efdd:	83 c4 14             	add    $0x14,%esp
 804efe0:	68 50 ae 8f 14       	push   $0x148fae50
 804efe5:	68 18 ae 8f 14       	push   $0x148fae18
 804efea:	68 d0 0c 06 08       	push   $0x8060cd0
 804efef:	6a 50                	push   $0x50
 804eff1:	68 00 89 0c 08       	push   $0x80c8900
 804eff6:	e8 05 9b ff ff       	call   8048b00 <snprintf@plt>
 804effb:	83 c4 20             	add    $0x20,%esp
 804effe:	83 f8 4f             	cmp    $0x4f,%eax
 804f001:	7e 81                	jle    804ef84 <do_shl_l+0x44>
 804f003:	68 2f 0e 06 08       	push   $0x8060e2f
 804f008:	6a 11                	push   $0x11
 804f00a:	68 dc 0c 06 08       	push   $0x8060cdc
 804f00f:	68 cc 0d 06 08       	push   $0x8060dcc
 804f014:	e8 97 9b ff ff       	call   8048bb0 <__assert_fail@plt>
 804f019:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804f020 <shl_rm_1_l>:
}

make_instr_helper(rm_1)
 804f020:	53                   	push   %ebx
 804f021:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f024:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f028:	83 c0 01             	add    $0x1,%eax
 804f02b:	50                   	push   %eax
 804f02c:	e8 8f e2 00 00       	call   805d2c0 <decode_rm_1_l>
 804f031:	89 c3                	mov    %eax,%ebx
	execute();
 804f033:	e8 08 ff ff ff       	call   804ef40 <do_shl_l>
 804f038:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f03b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f03e:	5b                   	pop    %ebx
 804f03f:	c3                   	ret    

0804f040 <shl_rm_cl_l>:
make_instr_helper(rm_cl)
 804f040:	53                   	push   %ebx
 804f041:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f044:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f048:	83 c0 01             	add    $0x1,%eax
 804f04b:	50                   	push   %eax
 804f04c:	e8 bf e2 00 00       	call   805d310 <decode_rm_cl_l>
 804f051:	89 c3                	mov    %eax,%ebx
	execute();
 804f053:	e8 e8 fe ff ff       	call   804ef40 <do_shl_l>
 804f058:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f05b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f05e:	5b                   	pop    %ebx
 804f05f:	c3                   	ret    

0804f060 <shl_rm_imm_l>:
make_instr_helper(rm_imm)
 804f060:	53                   	push   %ebx
 804f061:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f064:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f068:	83 c0 01             	add    $0x1,%eax
 804f06b:	50                   	push   %eax
 804f06c:	e8 ff e2 00 00       	call   805d370 <decode_rm_imm_l>
 804f071:	89 c3                	mov    %eax,%ebx
	execute();
 804f073:	e8 c8 fe ff ff       	call   804ef40 <do_shl_l>
 804f078:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f07b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f07e:	5b                   	pop    %ebx
 804f07f:	c3                   	ret    

0804f080 <shl_rm_1_b>:
	 */

	print_asm_template2();
}

make_instr_helper(rm_1)
 804f080:	53                   	push   %ebx
 804f081:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f084:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f088:	83 c0 01             	add    $0x1,%eax
 804f08b:	50                   	push   %eax
 804f08c:	e8 cf da 00 00       	call   805cb60 <decode_rm_1_b>
 804f091:	89 c3                	mov    %eax,%ebx
	execute();
 804f093:	e8 88 fc ff ff       	call   804ed20 <do_shl_b>
 804f098:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f09b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f09e:	5b                   	pop    %ebx
 804f09f:	c3                   	ret    

0804f0a0 <shl_rm_cl_b>:
make_instr_helper(rm_cl)
 804f0a0:	53                   	push   %ebx
 804f0a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f0a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f0a8:	83 c0 01             	add    $0x1,%eax
 804f0ab:	50                   	push   %eax
 804f0ac:	e8 ff da 00 00       	call   805cbb0 <decode_rm_cl_b>
 804f0b1:	89 c3                	mov    %eax,%ebx
	execute();
 804f0b3:	e8 68 fc ff ff       	call   804ed20 <do_shl_b>
 804f0b8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f0bb:	8d 43 01             	lea    0x1(%ebx),%eax
 804f0be:	5b                   	pop    %ebx
 804f0bf:	c3                   	ret    

0804f0c0 <shl_rm_imm_b>:
make_instr_helper(rm_imm)
 804f0c0:	53                   	push   %ebx
 804f0c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f0c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f0c8:	83 c0 01             	add    $0x1,%eax
 804f0cb:	50                   	push   %eax
 804f0cc:	e8 3f db 00 00       	call   805cc10 <decode_rm_imm_b>
 804f0d1:	89 c3                	mov    %eax,%ebx
	execute();
 804f0d3:	e8 48 fc ff ff       	call   804ed20 <do_shl_b>
 804f0d8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f0db:	8d 43 01             	lea    0x1(%ebx),%eax
 804f0de:	5b                   	pop    %ebx
 804f0df:	c3                   	ret    

0804f0e0 <shl_rm_1_v>:
#define DATA_BYTE 4
#include "shl-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */
make_helper_v(shl_rm_1)
 804f0e0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804f0e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f0eb:	b8 e0 ee 04 08       	mov    $0x804eee0,%eax
 804f0f0:	75 05                	jne    804f0f7 <shl_rm_1_v+0x17>
 804f0f2:	b8 20 f0 04 08       	mov    $0x804f020,%eax
 804f0f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f0fb:	ff e0                	jmp    *%eax
 804f0fd:	8d 76 00             	lea    0x0(%esi),%esi

0804f100 <shl_rm_cl_v>:
make_helper_v(shl_rm_cl)
 804f100:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804f107:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f10b:	b8 00 ef 04 08       	mov    $0x804ef00,%eax
 804f110:	75 05                	jne    804f117 <shl_rm_cl_v+0x17>
 804f112:	b8 40 f0 04 08       	mov    $0x804f040,%eax
 804f117:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f11b:	ff e0                	jmp    *%eax
 804f11d:	8d 76 00             	lea    0x0(%esi),%esi

0804f120 <shl_rm_imm_v>:
make_helper_v(shl_rm_imm)
 804f120:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804f127:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f12b:	b8 20 ef 04 08       	mov    $0x804ef20,%eax
 804f130:	75 05                	jne    804f137 <shl_rm_imm_v+0x17>
 804f132:	b8 60 f0 04 08       	mov    $0x804f060,%eax
 804f137:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f13b:	ff e0                	jmp    *%eax
 804f13d:	66 90                	xchg   %ax,%ax
 804f13f:	90                   	nop

0804f140 <do_shld_w>:
#include "cpu/exec/template-start.h"

#define instr shld

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute () {
 804f140:	53                   	push   %ebx
 804f141:	83 ec 08             	sub    $0x8,%esp
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804f144:	0f b6 15 14 ae 8f 14 	movzbl 0x148fae14,%edx

#define instr shld

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute () {
	DATA_TYPE in = op_dest->val;
 804f14b:	0f b7 0d 4c ae 8f 14 	movzwl 0x148fae4c,%ecx
	DATA_TYPE out = op_src2->val;
 804f152:	0f b7 05 84 ae 8f 14 	movzwl 0x148fae84,%eax

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804f159:	83 e2 1f             	and    $0x1f,%edx
 804f15c:	74 13                	je     804f171 <do_shld_w+0x31>
 804f15e:	66 90                	xchg   %ax,%ax
		out <<= 1;
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
 804f160:	89 cb                	mov    %ecx,%ebx
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out <<= 1;
 804f162:	01 c0                	add    %eax,%eax
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
		in <<= 1;
 804f164:	01 c9                	add    %ecx,%ecx

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out <<= 1;
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
 804f166:	66 c1 eb 0f          	shr    $0xf,%bx
 804f16a:	09 d8                	or     %ebx,%eax
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804f16c:	80 ea 01             	sub    $0x1,%dl
 804f16f:	75 ef                	jne    804f160 <do_shld_w+0x20>
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
		in <<= 1;
		count --;
	}

	OPERAND_W(op_src2, out);
 804f171:	83 ec 08             	sub    $0x8,%esp
 804f174:	0f b7 c0             	movzwl %ax,%eax
 804f177:	50                   	push   %eax
 804f178:	68 78 ae 8f 14       	push   $0x148fae78
 804f17d:	e8 4e de 00 00       	call   805cfd0 <write_operand_w>

	print_asm("shld" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804f182:	58                   	pop    %eax
 804f183:	5a                   	pop    %edx
 804f184:	68 88 ae 8f 14       	push   $0x148fae88
 804f189:	68 50 ae 8f 14       	push   $0x148fae50
 804f18e:	68 18 ae 8f 14       	push   $0x148fae18
 804f193:	68 4a 0e 06 08       	push   $0x8060e4a
 804f198:	6a 50                	push   $0x50
 804f19a:	68 00 89 0c 08       	push   $0x80c8900
 804f19f:	e8 5c 99 ff ff       	call   8048b00 <snprintf@plt>
 804f1a4:	83 c4 20             	add    $0x20,%esp
 804f1a7:	83 f8 4f             	cmp    $0x4f,%eax
 804f1aa:	7f 0c                	jg     804f1b8 <do_shld_w+0x78>
}
 804f1ac:	83 c4 08             	add    $0x8,%esp
 804f1af:	5b                   	pop    %ebx
 804f1b0:	c3                   	ret    
 804f1b1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		count --;
	}

	OPERAND_W(op_src2, out);

	print_asm("shld" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804f1b8:	83 ec 0c             	sub    $0xc,%esp
 804f1bb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804f1c1:	e8 9a 97 ff ff       	call   8048960 <fflush@plt>
 804f1c6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f1cc:	6a 07                	push   $0x7
 804f1ce:	6a 01                	push   $0x1
 804f1d0:	68 92 ed 05 08       	push   $0x805ed92
 804f1d5:	e8 36 98 ff ff       	call   8048a10 <fwrite@plt>
 804f1da:	83 c4 20             	add    $0x20,%esp
 804f1dd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f1e3:	6a 10                	push   $0x10
 804f1e5:	6a 01                	push   $0x1
 804f1e7:	68 84 f8 05 08       	push   $0x805f884
 804f1ec:	e8 1f 98 ff ff       	call   8048a10 <fwrite@plt>
 804f1f1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f1f7:	6a 05                	push   $0x5
 804f1f9:	6a 01                	push   $0x1
 804f1fb:	68 b1 ed 05 08       	push   $0x805edb1
 804f200:	e8 0b 98 ff ff       	call   8048a10 <fwrite@plt>
 804f205:	83 c4 18             	add    $0x18,%esp
 804f208:	68 88 ae 8f 14       	push   $0x148fae88
 804f20d:	68 50 ae 8f 14       	push   $0x148fae50
 804f212:	68 18 ae 8f 14       	push   $0x148fae18
 804f217:	68 4a 0e 06 08       	push   $0x8060e4a
 804f21c:	6a 50                	push   $0x50
 804f21e:	68 00 89 0c 08       	push   $0x80c8900
 804f223:	e8 d8 98 ff ff       	call   8048b00 <snprintf@plt>
 804f228:	83 c4 20             	add    $0x20,%esp
 804f22b:	83 f8 4f             	cmp    $0x4f,%eax
 804f22e:	0f 8e 78 ff ff ff    	jle    804f1ac <do_shld_w+0x6c>
 804f234:	68 9f 0f 06 08       	push   $0x8060f9f
 804f239:	6a 15                	push   $0x15
 804f23b:	68 68 0e 06 08       	push   $0x8060e68
 804f240:	68 90 0e 06 08       	push   $0x8060e90
 804f245:	e8 66 99 ff ff       	call   8048bb0 <__assert_fail@plt>
 804f24a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804f250 <shldi_w>:
}

make_helper(concat(shldi_, SUFFIX)) {
 804f250:	53                   	push   %ebx
 804f251:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
 804f254:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f258:	83 c0 01             	add    $0x1,%eax
 804f25b:	50                   	push   %eax
 804f25c:	e8 5f dc 00 00       	call   805cec0 <decode_si_rm2r_w>
 804f261:	89 c3                	mov    %eax,%ebx
	op_dest->val = REG(op_dest->reg);
 804f263:	a1 48 ae 8f 14       	mov    0x148fae48,%eax
 804f268:	83 c4 10             	add    $0x10,%esp
 804f26b:	83 f8 07             	cmp    $0x7,%eax
 804f26e:	77 1a                	ja     804f28a <shldi_w+0x3a>
 804f270:	0f b7 04 85 c0 ae 8f 	movzwl 0x148faec0(,%eax,4),%eax
 804f277:	14 
 804f278:	a3 4c ae 8f 14       	mov    %eax,0x148fae4c
	do_execute();
 804f27d:	e8 be fe ff ff       	call   804f140 <do_shld_w>
	return len + 1;
}
 804f282:	83 c4 08             	add    $0x8,%esp

make_helper(concat(shldi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
	do_execute();
	return len + 1;
 804f285:	8d 43 01             	lea    0x1(%ebx),%eax
}
 804f288:	5b                   	pop    %ebx
 804f289:	c3                   	ret    
 804f28a:	e8 63 99 ff ff       	call   8048bf2 <check_reg_index.part.0>
 804f28f:	90                   	nop

0804f290 <shld_w>:

make_helper(concat(shld_, SUFFIX)) {
 804f290:	53                   	push   %ebx
 804f291:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
 804f294:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f298:	83 c0 01             	add    $0x1,%eax
 804f29b:	50                   	push   %eax
 804f29c:	e8 cf da 00 00       	call   805cd70 <decode_rm2r_w>
 804f2a1:	89 c3                	mov    %eax,%ebx
	op_dest->val = REG(op_dest->reg);
 804f2a3:	a1 48 ae 8f 14       	mov    0x148fae48,%eax
 804f2a8:	83 c4 10             	add    $0x10,%esp
 804f2ab:	83 f8 07             	cmp    $0x7,%eax
 804f2ae:	77 4e                	ja     804f2fe <shld_w+0x6e>
 804f2b0:	0f b7 04 85 c0 ae 8f 	movzwl 0x148faec0(,%eax,4),%eax
 804f2b7:	14 
 804f2b8:	a3 4c ae 8f 14       	mov    %eax,0x148fae4c
	op_src2->val = op_src->val;
 804f2bd:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
 804f2c2:	a3 84 ae 8f 14       	mov    %eax,0x148fae84
	op_src2->imm = op_src->imm;
 804f2c7:	a1 10 ae 8f 14       	mov    0x148fae10,%eax
 804f2cc:	a3 80 ae 8f 14       	mov    %eax,0x148fae80
	op_src2->type = op_src->type;
 804f2d1:	a1 08 ae 8f 14       	mov    0x148fae08,%eax
 804f2d6:	a3 78 ae 8f 14       	mov    %eax,0x148fae78
	op_src2->size = op_src->size;
 804f2db:	a1 0c ae 8f 14       	mov    0x148fae0c,%eax
 804f2e0:	a3 7c ae 8f 14       	mov    %eax,0x148fae7c
	op_src->val = reg_b(R_CL);
 804f2e5:	0f b6 05 c4 ae 8f 14 	movzbl 0x148faec4,%eax
 804f2ec:	a3 14 ae 8f 14       	mov    %eax,0x148fae14
	do_execute();
 804f2f1:	e8 4a fe ff ff       	call   804f140 <do_shld_w>
	return len + 1;
}
 804f2f6:	83 c4 08             	add    $0x8,%esp
	op_src2->imm = op_src->imm;
	op_src2->type = op_src->type;
	op_src2->size = op_src->size;
	op_src->val = reg_b(R_CL);
	do_execute();
	return len + 1;
 804f2f9:	8d 43 01             	lea    0x1(%ebx),%eax
}
 804f2fc:	5b                   	pop    %ebx
 804f2fd:	c3                   	ret    
 804f2fe:	e8 ef 98 ff ff       	call   8048bf2 <check_reg_index.part.0>
 804f303:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804f309:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804f310 <do_shld_l>:
#include "cpu/exec/template-start.h"

#define instr shld

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute () {
 804f310:	53                   	push   %ebx
 804f311:	83 ec 08             	sub    $0x8,%esp
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804f314:	0f b6 15 14 ae 8f 14 	movzbl 0x148fae14,%edx

#define instr shld

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute () {
	DATA_TYPE in = op_dest->val;
 804f31b:	8b 0d 4c ae 8f 14    	mov    0x148fae4c,%ecx
	DATA_TYPE out = op_src2->val;
 804f321:	a1 84 ae 8f 14       	mov    0x148fae84,%eax

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804f326:	83 e2 1f             	and    $0x1f,%edx
 804f329:	74 15                	je     804f340 <do_shld_l+0x30>
 804f32b:	90                   	nop
 804f32c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		out <<= 1;
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
 804f330:	89 cb                	mov    %ecx,%ebx
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out <<= 1;
 804f332:	01 c0                	add    %eax,%eax
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
		in <<= 1;
 804f334:	01 c9                	add    %ecx,%ecx

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out <<= 1;
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
 804f336:	c1 eb 1f             	shr    $0x1f,%ebx
 804f339:	09 d8                	or     %ebx,%eax
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804f33b:	80 ea 01             	sub    $0x1,%dl
 804f33e:	75 f0                	jne    804f330 <do_shld_l+0x20>
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
		in <<= 1;
		count --;
	}

	OPERAND_W(op_src2, out);
 804f340:	83 ec 08             	sub    $0x8,%esp
 804f343:	50                   	push   %eax
 804f344:	68 78 ae 8f 14       	push   $0x148fae78
 804f349:	e8 52 e0 00 00       	call   805d3a0 <write_operand_l>

	print_asm("shld" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804f34e:	58                   	pop    %eax
 804f34f:	5a                   	pop    %edx
 804f350:	68 88 ae 8f 14       	push   $0x148fae88
 804f355:	68 50 ae 8f 14       	push   $0x148fae50
 804f35a:	68 18 ae 8f 14       	push   $0x148fae18
 804f35f:	68 59 0e 06 08       	push   $0x8060e59
 804f364:	6a 50                	push   $0x50
 804f366:	68 00 89 0c 08       	push   $0x80c8900
 804f36b:	e8 90 97 ff ff       	call   8048b00 <snprintf@plt>
 804f370:	83 c4 20             	add    $0x20,%esp
 804f373:	83 f8 4f             	cmp    $0x4f,%eax
 804f376:	7f 08                	jg     804f380 <do_shld_l+0x70>
}
 804f378:	83 c4 08             	add    $0x8,%esp
 804f37b:	5b                   	pop    %ebx
 804f37c:	c3                   	ret    
 804f37d:	8d 76 00             	lea    0x0(%esi),%esi
		count --;
	}

	OPERAND_W(op_src2, out);

	print_asm("shld" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804f380:	83 ec 0c             	sub    $0xc,%esp
 804f383:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804f389:	e8 d2 95 ff ff       	call   8048960 <fflush@plt>
 804f38e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f394:	6a 07                	push   $0x7
 804f396:	6a 01                	push   $0x1
 804f398:	68 92 ed 05 08       	push   $0x805ed92
 804f39d:	e8 6e 96 ff ff       	call   8048a10 <fwrite@plt>
 804f3a2:	83 c4 20             	add    $0x20,%esp
 804f3a5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f3ab:	6a 10                	push   $0x10
 804f3ad:	6a 01                	push   $0x1
 804f3af:	68 84 f8 05 08       	push   $0x805f884
 804f3b4:	e8 57 96 ff ff       	call   8048a10 <fwrite@plt>
 804f3b9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f3bf:	6a 05                	push   $0x5
 804f3c1:	6a 01                	push   $0x1
 804f3c3:	68 b1 ed 05 08       	push   $0x805edb1
 804f3c8:	e8 43 96 ff ff       	call   8048a10 <fwrite@plt>
 804f3cd:	83 c4 18             	add    $0x18,%esp
 804f3d0:	68 88 ae 8f 14       	push   $0x148fae88
 804f3d5:	68 50 ae 8f 14       	push   $0x148fae50
 804f3da:	68 18 ae 8f 14       	push   $0x148fae18
 804f3df:	68 59 0e 06 08       	push   $0x8060e59
 804f3e4:	6a 50                	push   $0x50
 804f3e6:	68 00 89 0c 08       	push   $0x80c8900
 804f3eb:	e8 10 97 ff ff       	call   8048b00 <snprintf@plt>
 804f3f0:	83 c4 20             	add    $0x20,%esp
 804f3f3:	83 f8 4f             	cmp    $0x4f,%eax
 804f3f6:	7e 80                	jle    804f378 <do_shld_l+0x68>
 804f3f8:	68 95 0f 06 08       	push   $0x8060f95
 804f3fd:	6a 15                	push   $0x15
 804f3ff:	68 68 0e 06 08       	push   $0x8060e68
 804f404:	68 14 0f 06 08       	push   $0x8060f14
 804f409:	e8 a2 97 ff ff       	call   8048bb0 <__assert_fail@plt>
 804f40e:	66 90                	xchg   %ax,%ax

0804f410 <shldi_l>:
}

make_helper(concat(shldi_, SUFFIX)) {
 804f410:	53                   	push   %ebx
 804f411:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
 804f414:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f418:	83 c0 01             	add    $0x1,%eax
 804f41b:	50                   	push   %eax
 804f41c:	e8 6f de 00 00       	call   805d290 <decode_si_rm2r_l>
 804f421:	89 c3                	mov    %eax,%ebx
	op_dest->val = REG(op_dest->reg);
 804f423:	a1 48 ae 8f 14       	mov    0x148fae48,%eax
 804f428:	83 c4 10             	add    $0x10,%esp
 804f42b:	83 f8 07             	cmp    $0x7,%eax
 804f42e:	77 19                	ja     804f449 <shldi_l+0x39>
 804f430:	8b 04 85 c0 ae 8f 14 	mov    0x148faec0(,%eax,4),%eax
 804f437:	a3 4c ae 8f 14       	mov    %eax,0x148fae4c
	do_execute();
 804f43c:	e8 cf fe ff ff       	call   804f310 <do_shld_l>
	return len + 1;
}
 804f441:	83 c4 08             	add    $0x8,%esp

make_helper(concat(shldi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
	do_execute();
	return len + 1;
 804f444:	8d 43 01             	lea    0x1(%ebx),%eax
}
 804f447:	5b                   	pop    %ebx
 804f448:	c3                   	ret    
 804f449:	e8 a4 97 ff ff       	call   8048bf2 <check_reg_index.part.0>
 804f44e:	66 90                	xchg   %ax,%ax

0804f450 <shld_l>:

make_helper(concat(shld_, SUFFIX)) {
 804f450:	53                   	push   %ebx
 804f451:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
 804f454:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f458:	83 c0 01             	add    $0x1,%eax
 804f45b:	50                   	push   %eax
 804f45c:	e8 df dc 00 00       	call   805d140 <decode_rm2r_l>
 804f461:	89 c3                	mov    %eax,%ebx
	op_dest->val = REG(op_dest->reg);
 804f463:	a1 48 ae 8f 14       	mov    0x148fae48,%eax
 804f468:	83 c4 10             	add    $0x10,%esp
 804f46b:	83 f8 07             	cmp    $0x7,%eax
 804f46e:	77 4d                	ja     804f4bd <shld_l+0x6d>
 804f470:	8b 04 85 c0 ae 8f 14 	mov    0x148faec0(,%eax,4),%eax
 804f477:	a3 4c ae 8f 14       	mov    %eax,0x148fae4c
	op_src2->val = op_src->val;
 804f47c:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
 804f481:	a3 84 ae 8f 14       	mov    %eax,0x148fae84
	op_src2->imm = op_src->imm;
 804f486:	a1 10 ae 8f 14       	mov    0x148fae10,%eax
 804f48b:	a3 80 ae 8f 14       	mov    %eax,0x148fae80
	op_src2->type = op_src->type;
 804f490:	a1 08 ae 8f 14       	mov    0x148fae08,%eax
 804f495:	a3 78 ae 8f 14       	mov    %eax,0x148fae78
	op_src2->size = op_src->size;
 804f49a:	a1 0c ae 8f 14       	mov    0x148fae0c,%eax
 804f49f:	a3 7c ae 8f 14       	mov    %eax,0x148fae7c
	op_src->val = reg_b(R_CL);
 804f4a4:	0f b6 05 c4 ae 8f 14 	movzbl 0x148faec4,%eax
 804f4ab:	a3 14 ae 8f 14       	mov    %eax,0x148fae14
	do_execute();
 804f4b0:	e8 5b fe ff ff       	call   804f310 <do_shld_l>
	return len + 1;
}
 804f4b5:	83 c4 08             	add    $0x8,%esp
	op_src2->imm = op_src->imm;
	op_src2->type = op_src->type;
	op_src2->size = op_src->size;
	op_src->val = reg_b(R_CL);
	do_execute();
	return len + 1;
 804f4b8:	8d 43 01             	lea    0x1(%ebx),%eax
}
 804f4bb:	5b                   	pop    %ebx
 804f4bc:	c3                   	ret    
 804f4bd:	e8 30 97 ff ff       	call   8048bf2 <check_reg_index.part.0>
 804f4c2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804f4c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804f4d0 <shldi_v>:
#define DATA_BYTE 4
#include "shld-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */
make_helper_v(shldi)
 804f4d0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804f4d7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f4db:	b8 50 f2 04 08       	mov    $0x804f250,%eax
 804f4e0:	75 05                	jne    804f4e7 <shldi_v+0x17>
 804f4e2:	b8 10 f4 04 08       	mov    $0x804f410,%eax
 804f4e7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f4eb:	ff e0                	jmp    *%eax
 804f4ed:	8d 76 00             	lea    0x0(%esi),%esi

0804f4f0 <shld_v>:
make_helper_v(shld)
 804f4f0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804f4f7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f4fb:	b8 90 f2 04 08       	mov    $0x804f290,%eax
 804f500:	75 05                	jne    804f507 <shld_v+0x17>
 804f502:	b8 50 f4 04 08       	mov    $0x804f450,%eax
 804f507:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f50b:	ff e0                	jmp    *%eax
 804f50d:	66 90                	xchg   %ax,%ax
 804f50f:	90                   	nop

0804f510 <do_sar_b>:
#include "cpu/exec/template-start.h"

#define instr sar

static void do_execute () {
 804f510:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE_S dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804f513:	0f b6 0d 14 ae 8f 14 	movzbl 0x148fae14,%ecx
	dest >>= count;
 804f51a:	0f be 05 4c ae 8f 14 	movsbl 0x148fae4c,%eax

static void do_execute () {
	DATA_TYPE src = op_src->val;
	DATA_TYPE_S dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804f521:	83 e1 1f             	and    $0x1f,%ecx
	dest >>= count;
 804f524:	d3 f8                	sar    %cl,%eax
	OPERAND_W(op_dest, dest);
 804f526:	0f b6 c0             	movzbl %al,%eax
 804f529:	50                   	push   %eax
 804f52a:	68 40 ae 8f 14       	push   $0x148fae40
 804f52f:	e8 0c d7 00 00       	call   805cc40 <write_operand_b>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804f534:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 804f53b:	68 18 ae 8f 14       	push   $0x148fae18
 804f540:	68 b9 0f 06 08       	push   $0x8060fb9
 804f545:	6a 50                	push   $0x50
 804f547:	68 00 89 0c 08       	push   $0x80c8900
 804f54c:	e8 af 95 ff ff       	call   8048b00 <snprintf@plt>
 804f551:	83 c4 20             	add    $0x20,%esp
 804f554:	83 f8 4f             	cmp    $0x4f,%eax
 804f557:	7f 07                	jg     804f560 <do_sar_b+0x50>
}
 804f559:	83 c4 0c             	add    $0xc,%esp
 804f55c:	c3                   	ret    
 804f55d:	8d 76 00             	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804f560:	83 ec 0c             	sub    $0xc,%esp
 804f563:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804f569:	e8 f2 93 ff ff       	call   8048960 <fflush@plt>
 804f56e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f574:	6a 07                	push   $0x7
 804f576:	6a 01                	push   $0x1
 804f578:	68 92 ed 05 08       	push   $0x805ed92
 804f57d:	e8 8e 94 ff ff       	call   8048a10 <fwrite@plt>
 804f582:	83 c4 20             	add    $0x20,%esp
 804f585:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f58b:	6a 10                	push   $0x10
 804f58d:	6a 01                	push   $0x1
 804f58f:	68 84 f8 05 08       	push   $0x805f884
 804f594:	e8 77 94 ff ff       	call   8048a10 <fwrite@plt>
 804f599:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f59f:	6a 05                	push   $0x5
 804f5a1:	6a 01                	push   $0x1
 804f5a3:	68 b1 ed 05 08       	push   $0x805edb1
 804f5a8:	e8 63 94 ff ff       	call   8048a10 <fwrite@plt>
 804f5ad:	83 c4 14             	add    $0x14,%esp
 804f5b0:	68 50 ae 8f 14       	push   $0x148fae50
 804f5b5:	68 18 ae 8f 14       	push   $0x148fae18
 804f5ba:	68 b9 0f 06 08       	push   $0x8060fb9
 804f5bf:	6a 50                	push   $0x50
 804f5c1:	68 00 89 0c 08       	push   $0x80c8900
 804f5c6:	e8 35 95 ff ff       	call   8048b00 <snprintf@plt>
 804f5cb:	83 c4 20             	add    $0x20,%esp
 804f5ce:	83 f8 4f             	cmp    $0x4f,%eax
 804f5d1:	7e 86                	jle    804f559 <do_sar_b+0x49>
 804f5d3:	68 41 11 06 08       	push   $0x8061141
 804f5d8:	6a 11                	push   $0x11
 804f5da:	68 dc 0f 06 08       	push   $0x8060fdc
 804f5df:	68 04 10 06 08       	push   $0x8061004
 804f5e4:	e8 c7 95 ff ff       	call   8048bb0 <__assert_fail@plt>
 804f5e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804f5f0 <do_sar_w>:
#include "cpu/exec/template-start.h"

#define instr sar

static void do_execute () {
 804f5f0:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE_S dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804f5f3:	0f b6 0d 14 ae 8f 14 	movzbl 0x148fae14,%ecx
	dest >>= count;
 804f5fa:	0f bf 05 4c ae 8f 14 	movswl 0x148fae4c,%eax

static void do_execute () {
	DATA_TYPE src = op_src->val;
	DATA_TYPE_S dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804f601:	83 e1 1f             	and    $0x1f,%ecx
	dest >>= count;
 804f604:	d3 f8                	sar    %cl,%eax
	OPERAND_W(op_dest, dest);
 804f606:	0f b7 c0             	movzwl %ax,%eax
 804f609:	50                   	push   %eax
 804f60a:	68 40 ae 8f 14       	push   $0x148fae40
 804f60f:	e8 bc d9 00 00       	call   805cfd0 <write_operand_w>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804f614:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 804f61b:	68 18 ae 8f 14       	push   $0x148fae18
 804f620:	68 c4 0f 06 08       	push   $0x8060fc4
 804f625:	6a 50                	push   $0x50
 804f627:	68 00 89 0c 08       	push   $0x80c8900
 804f62c:	e8 cf 94 ff ff       	call   8048b00 <snprintf@plt>
 804f631:	83 c4 20             	add    $0x20,%esp
 804f634:	83 f8 4f             	cmp    $0x4f,%eax
 804f637:	7f 07                	jg     804f640 <do_sar_w+0x50>
}
 804f639:	83 c4 0c             	add    $0xc,%esp
 804f63c:	c3                   	ret    
 804f63d:	8d 76 00             	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804f640:	83 ec 0c             	sub    $0xc,%esp
 804f643:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804f649:	e8 12 93 ff ff       	call   8048960 <fflush@plt>
 804f64e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f654:	6a 07                	push   $0x7
 804f656:	6a 01                	push   $0x1
 804f658:	68 92 ed 05 08       	push   $0x805ed92
 804f65d:	e8 ae 93 ff ff       	call   8048a10 <fwrite@plt>
 804f662:	83 c4 20             	add    $0x20,%esp
 804f665:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f66b:	6a 10                	push   $0x10
 804f66d:	6a 01                	push   $0x1
 804f66f:	68 84 f8 05 08       	push   $0x805f884
 804f674:	e8 97 93 ff ff       	call   8048a10 <fwrite@plt>
 804f679:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f67f:	6a 05                	push   $0x5
 804f681:	6a 01                	push   $0x1
 804f683:	68 b1 ed 05 08       	push   $0x805edb1
 804f688:	e8 83 93 ff ff       	call   8048a10 <fwrite@plt>
 804f68d:	83 c4 14             	add    $0x14,%esp
 804f690:	68 50 ae 8f 14       	push   $0x148fae50
 804f695:	68 18 ae 8f 14       	push   $0x148fae18
 804f69a:	68 c4 0f 06 08       	push   $0x8060fc4
 804f69f:	6a 50                	push   $0x50
 804f6a1:	68 00 89 0c 08       	push   $0x80c8900
 804f6a6:	e8 55 94 ff ff       	call   8048b00 <snprintf@plt>
 804f6ab:	83 c4 20             	add    $0x20,%esp
 804f6ae:	83 f8 4f             	cmp    $0x4f,%eax
 804f6b1:	7e 86                	jle    804f639 <do_sar_w+0x49>
 804f6b3:	68 38 11 06 08       	push   $0x8061138
 804f6b8:	6a 11                	push   $0x11
 804f6ba:	68 dc 0f 06 08       	push   $0x8060fdc
 804f6bf:	68 68 10 06 08       	push   $0x8061068
 804f6c4:	e8 e7 94 ff ff       	call   8048bb0 <__assert_fail@plt>
 804f6c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804f6d0 <sar_rm_1_w>:
}

make_instr_helper(rm_1)
 804f6d0:	53                   	push   %ebx
 804f6d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f6d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f6d8:	83 c0 01             	add    $0x1,%eax
 804f6db:	50                   	push   %eax
 804f6dc:	e8 0f d8 00 00       	call   805cef0 <decode_rm_1_w>
 804f6e1:	89 c3                	mov    %eax,%ebx
	execute();
 804f6e3:	e8 08 ff ff ff       	call   804f5f0 <do_sar_w>
 804f6e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f6eb:	8d 43 01             	lea    0x1(%ebx),%eax
 804f6ee:	5b                   	pop    %ebx
 804f6ef:	c3                   	ret    

0804f6f0 <sar_rm_cl_w>:
make_instr_helper(rm_cl)
 804f6f0:	53                   	push   %ebx
 804f6f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f6f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f6f8:	83 c0 01             	add    $0x1,%eax
 804f6fb:	50                   	push   %eax
 804f6fc:	e8 3f d8 00 00       	call   805cf40 <decode_rm_cl_w>
 804f701:	89 c3                	mov    %eax,%ebx
	execute();
 804f703:	e8 e8 fe ff ff       	call   804f5f0 <do_sar_w>
 804f708:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f70b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f70e:	5b                   	pop    %ebx
 804f70f:	c3                   	ret    

0804f710 <sar_rm_imm_w>:
make_instr_helper(rm_imm)
 804f710:	53                   	push   %ebx
 804f711:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f714:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f718:	83 c0 01             	add    $0x1,%eax
 804f71b:	50                   	push   %eax
 804f71c:	e8 7f d8 00 00       	call   805cfa0 <decode_rm_imm_w>
 804f721:	89 c3                	mov    %eax,%ebx
	execute();
 804f723:	e8 c8 fe ff ff       	call   804f5f0 <do_sar_w>
 804f728:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f72b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f72e:	5b                   	pop    %ebx
 804f72f:	c3                   	ret    

0804f730 <do_sar_l>:
#include "cpu/exec/template-start.h"

#define instr sar

static void do_execute () {
 804f730:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE_S dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804f733:	0f b6 0d 14 ae 8f 14 	movzbl 0x148fae14,%ecx
	dest >>= count;
 804f73a:	a1 4c ae 8f 14       	mov    0x148fae4c,%eax

static void do_execute () {
	DATA_TYPE src = op_src->val;
	DATA_TYPE_S dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804f73f:	83 e1 1f             	and    $0x1f,%ecx
	dest >>= count;
 804f742:	d3 f8                	sar    %cl,%eax
	OPERAND_W(op_dest, dest);
 804f744:	50                   	push   %eax
 804f745:	68 40 ae 8f 14       	push   $0x148fae40
 804f74a:	e8 51 dc 00 00       	call   805d3a0 <write_operand_l>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804f74f:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 804f756:	68 18 ae 8f 14       	push   $0x148fae18
 804f75b:	68 cf 0f 06 08       	push   $0x8060fcf
 804f760:	6a 50                	push   $0x50
 804f762:	68 00 89 0c 08       	push   $0x80c8900
 804f767:	e8 94 93 ff ff       	call   8048b00 <snprintf@plt>
 804f76c:	83 c4 20             	add    $0x20,%esp
 804f76f:	83 f8 4f             	cmp    $0x4f,%eax
 804f772:	7f 0c                	jg     804f780 <do_sar_l+0x50>
}
 804f774:	83 c4 0c             	add    $0xc,%esp
 804f777:	c3                   	ret    
 804f778:	90                   	nop
 804f779:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804f780:	83 ec 0c             	sub    $0xc,%esp
 804f783:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804f789:	e8 d2 91 ff ff       	call   8048960 <fflush@plt>
 804f78e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f794:	6a 07                	push   $0x7
 804f796:	6a 01                	push   $0x1
 804f798:	68 92 ed 05 08       	push   $0x805ed92
 804f79d:	e8 6e 92 ff ff       	call   8048a10 <fwrite@plt>
 804f7a2:	83 c4 20             	add    $0x20,%esp
 804f7a5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f7ab:	6a 10                	push   $0x10
 804f7ad:	6a 01                	push   $0x1
 804f7af:	68 84 f8 05 08       	push   $0x805f884
 804f7b4:	e8 57 92 ff ff       	call   8048a10 <fwrite@plt>
 804f7b9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f7bf:	6a 05                	push   $0x5
 804f7c1:	6a 01                	push   $0x1
 804f7c3:	68 b1 ed 05 08       	push   $0x805edb1
 804f7c8:	e8 43 92 ff ff       	call   8048a10 <fwrite@plt>
 804f7cd:	83 c4 14             	add    $0x14,%esp
 804f7d0:	68 50 ae 8f 14       	push   $0x148fae50
 804f7d5:	68 18 ae 8f 14       	push   $0x148fae18
 804f7da:	68 cf 0f 06 08       	push   $0x8060fcf
 804f7df:	6a 50                	push   $0x50
 804f7e1:	68 00 89 0c 08       	push   $0x80c8900
 804f7e6:	e8 15 93 ff ff       	call   8048b00 <snprintf@plt>
 804f7eb:	83 c4 20             	add    $0x20,%esp
 804f7ee:	83 f8 4f             	cmp    $0x4f,%eax
 804f7f1:	7e 81                	jle    804f774 <do_sar_l+0x44>
 804f7f3:	68 2f 11 06 08       	push   $0x806112f
 804f7f8:	6a 11                	push   $0x11
 804f7fa:	68 dc 0f 06 08       	push   $0x8060fdc
 804f7ff:	68 cc 10 06 08       	push   $0x80610cc
 804f804:	e8 a7 93 ff ff       	call   8048bb0 <__assert_fail@plt>
 804f809:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804f810 <sar_rm_1_l>:
}

make_instr_helper(rm_1)
 804f810:	53                   	push   %ebx
 804f811:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f814:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f818:	83 c0 01             	add    $0x1,%eax
 804f81b:	50                   	push   %eax
 804f81c:	e8 9f da 00 00       	call   805d2c0 <decode_rm_1_l>
 804f821:	89 c3                	mov    %eax,%ebx
	execute();
 804f823:	e8 08 ff ff ff       	call   804f730 <do_sar_l>
 804f828:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f82b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f82e:	5b                   	pop    %ebx
 804f82f:	c3                   	ret    

0804f830 <sar_rm_cl_l>:
make_instr_helper(rm_cl)
 804f830:	53                   	push   %ebx
 804f831:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f834:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f838:	83 c0 01             	add    $0x1,%eax
 804f83b:	50                   	push   %eax
 804f83c:	e8 cf da 00 00       	call   805d310 <decode_rm_cl_l>
 804f841:	89 c3                	mov    %eax,%ebx
	execute();
 804f843:	e8 e8 fe ff ff       	call   804f730 <do_sar_l>
 804f848:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f84b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f84e:	5b                   	pop    %ebx
 804f84f:	c3                   	ret    

0804f850 <sar_rm_imm_l>:
make_instr_helper(rm_imm)
 804f850:	53                   	push   %ebx
 804f851:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f854:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f858:	83 c0 01             	add    $0x1,%eax
 804f85b:	50                   	push   %eax
 804f85c:	e8 0f db 00 00       	call   805d370 <decode_rm_imm_l>
 804f861:	89 c3                	mov    %eax,%ebx
	execute();
 804f863:	e8 c8 fe ff ff       	call   804f730 <do_sar_l>
 804f868:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f86b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f86e:	5b                   	pop    %ebx
 804f86f:	c3                   	ret    

0804f870 <sar_rm_1_b>:
	 */

	print_asm_template2();
}

make_instr_helper(rm_1)
 804f870:	53                   	push   %ebx
 804f871:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f874:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f878:	83 c0 01             	add    $0x1,%eax
 804f87b:	50                   	push   %eax
 804f87c:	e8 df d2 00 00       	call   805cb60 <decode_rm_1_b>
 804f881:	89 c3                	mov    %eax,%ebx
	execute();
 804f883:	e8 88 fc ff ff       	call   804f510 <do_sar_b>
 804f888:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f88b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f88e:	5b                   	pop    %ebx
 804f88f:	c3                   	ret    

0804f890 <sar_rm_cl_b>:
make_instr_helper(rm_cl)
 804f890:	53                   	push   %ebx
 804f891:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f894:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f898:	83 c0 01             	add    $0x1,%eax
 804f89b:	50                   	push   %eax
 804f89c:	e8 0f d3 00 00       	call   805cbb0 <decode_rm_cl_b>
 804f8a1:	89 c3                	mov    %eax,%ebx
	execute();
 804f8a3:	e8 68 fc ff ff       	call   804f510 <do_sar_b>
 804f8a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f8ab:	8d 43 01             	lea    0x1(%ebx),%eax
 804f8ae:	5b                   	pop    %ebx
 804f8af:	c3                   	ret    

0804f8b0 <sar_rm_imm_b>:
make_instr_helper(rm_imm)
 804f8b0:	53                   	push   %ebx
 804f8b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f8b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f8b8:	83 c0 01             	add    $0x1,%eax
 804f8bb:	50                   	push   %eax
 804f8bc:	e8 4f d3 00 00       	call   805cc10 <decode_rm_imm_b>
 804f8c1:	89 c3                	mov    %eax,%ebx
	execute();
 804f8c3:	e8 48 fc ff ff       	call   804f510 <do_sar_b>
 804f8c8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f8cb:	8d 43 01             	lea    0x1(%ebx),%eax
 804f8ce:	5b                   	pop    %ebx
 804f8cf:	c3                   	ret    

0804f8d0 <sar_rm_1_v>:
#define DATA_BYTE 4
#include "sar-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */
make_helper_v(sar_rm_1)
 804f8d0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804f8d7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f8db:	b8 d0 f6 04 08       	mov    $0x804f6d0,%eax
 804f8e0:	75 05                	jne    804f8e7 <sar_rm_1_v+0x17>
 804f8e2:	b8 10 f8 04 08       	mov    $0x804f810,%eax
 804f8e7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f8eb:	ff e0                	jmp    *%eax
 804f8ed:	8d 76 00             	lea    0x0(%esi),%esi

0804f8f0 <sar_rm_cl_v>:
make_helper_v(sar_rm_cl)
 804f8f0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804f8f7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f8fb:	b8 f0 f6 04 08       	mov    $0x804f6f0,%eax
 804f900:	75 05                	jne    804f907 <sar_rm_cl_v+0x17>
 804f902:	b8 30 f8 04 08       	mov    $0x804f830,%eax
 804f907:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f90b:	ff e0                	jmp    *%eax
 804f90d:	8d 76 00             	lea    0x0(%esi),%esi

0804f910 <sar_rm_imm_v>:
make_helper_v(sar_rm_imm)
 804f910:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804f917:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f91b:	b8 10 f7 04 08       	mov    $0x804f710,%eax
 804f920:	75 05                	jne    804f927 <sar_rm_imm_v+0x17>
 804f922:	b8 50 f8 04 08       	mov    $0x804f850,%eax
 804f927:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f92b:	ff e0                	jmp    *%eax
 804f92d:	66 90                	xchg   %ax,%ax
 804f92f:	90                   	nop

0804f930 <do_or_b>:
#include "cpu/exec/template-start.h"

#define instr or

static void do_execute () {
 804f930:	56                   	push   %esi
 804f931:	53                   	push   %ebx
 804f932:	83 ec 0c             	sub    $0xc,%esp
	DATA_TYPE result = op_dest->val | op_src->val;
 804f935:	a1 4c ae 8f 14       	mov    0x148fae4c,%eax
 804f93a:	0a 05 14 ae 8f 14    	or     0x148fae14,%al
	OPERAND_W(op_dest, result);
 804f940:	0f b6 d8             	movzbl %al,%ebx
#include "cpu/exec/template-start.h"

#define instr or

static void do_execute () {
	DATA_TYPE result = op_dest->val | op_src->val;
 804f943:	89 c6                	mov    %eax,%esi
	OPERAND_W(op_dest, result);
 804f945:	53                   	push   %ebx
 804f946:	68 40 ae 8f 14       	push   $0x148fae40
 804f94b:	e8 f0 d2 00 00       	call   805cc40 <write_operand_b>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f950:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
	cpu.ZF = !result;
 804f957:	89 f0                	mov    %esi,%eax
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f959:	89 f2                	mov    %esi,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 804f95b:	80 25 e5 ae 8f 14 f7 	andb   $0xf7,0x148faee5
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f962:	83 e2 80             	and    $0xffffff80,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804f965:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 804f96c:	68 18 ae 8f 14       	push   $0x148fae18
 804f971:	68 7a 15 06 08       	push   $0x806157a
 804f976:	6a 50                	push   $0x50
 804f978:	68 00 89 0c 08       	push   $0x80c8900
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f97d:	83 e1 3e             	and    $0x3e,%ecx
	cpu.ZF = !result;
 804f980:	84 c0                	test   %al,%al
 804f982:	0f 94 c0             	sete   %al
 804f985:	09 ca                	or     %ecx,%edx
 804f987:	c1 e0 06             	shl    $0x6,%eax
 804f98a:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804f98c:	89 d8                	mov    %ebx,%eax
 804f98e:	c1 e8 04             	shr    $0x4,%eax
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 804f991:	83 e2 fb             	and    $0xfffffffb,%edx
	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804f994:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 2) ^ pf;
 804f996:	89 d8                	mov    %ebx,%eax
 804f998:	c1 e8 02             	shr    $0x2,%eax
 804f99b:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 804f99d:	89 d8                	mov    %ebx,%eax
 804f99f:	d1 e8                	shr    %eax
 804f9a1:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 804f9a3:	83 e3 01             	and    $0x1,%ebx
 804f9a6:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 804f9ad:	89 d3                	mov    %edx,%ebx
 804f9af:	09 c3                	or     %eax,%ebx
 804f9b1:	88 1d e4 ae 8f 14    	mov    %bl,0x148faee4

	print_asm_template2();
 804f9b7:	e8 44 91 ff ff       	call   8048b00 <snprintf@plt>
 804f9bc:	83 c4 20             	add    $0x20,%esp
 804f9bf:	83 f8 4f             	cmp    $0x4f,%eax
 804f9c2:	7f 0c                	jg     804f9d0 <do_or_b+0xa0>
}
 804f9c4:	83 c4 04             	add    $0x4,%esp
 804f9c7:	5b                   	pop    %ebx
 804f9c8:	5e                   	pop    %esi
 804f9c9:	c3                   	ret    
 804f9ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804f9d0:	83 ec 0c             	sub    $0xc,%esp
 804f9d3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804f9d9:	e8 82 8f ff ff       	call   8048960 <fflush@plt>
 804f9de:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f9e4:	6a 07                	push   $0x7
 804f9e6:	6a 01                	push   $0x1
 804f9e8:	68 92 ed 05 08       	push   $0x805ed92
 804f9ed:	e8 1e 90 ff ff       	call   8048a10 <fwrite@plt>
 804f9f2:	83 c4 20             	add    $0x20,%esp
 804f9f5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804f9fb:	6a 10                	push   $0x10
 804f9fd:	6a 01                	push   $0x1
 804f9ff:	68 84 f8 05 08       	push   $0x805f884
 804fa04:	e8 07 90 ff ff       	call   8048a10 <fwrite@plt>
 804fa09:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804fa0f:	6a 05                	push   $0x5
 804fa11:	6a 01                	push   $0x1
 804fa13:	68 b1 ed 05 08       	push   $0x805edb1
 804fa18:	e8 f3 8f ff ff       	call   8048a10 <fwrite@plt>
 804fa1d:	83 c4 14             	add    $0x14,%esp
 804fa20:	68 50 ae 8f 14       	push   $0x148fae50
 804fa25:	68 18 ae 8f 14       	push   $0x148fae18
 804fa2a:	68 7a 15 06 08       	push   $0x806157a
 804fa2f:	6a 50                	push   $0x50
 804fa31:	68 00 89 0c 08       	push   $0x80c8900
 804fa36:	e8 c5 90 ff ff       	call   8048b00 <snprintf@plt>
 804fa3b:	83 c4 20             	add    $0x20,%esp
 804fa3e:	83 f8 4f             	cmp    $0x4f,%eax
 804fa41:	7e 81                	jle    804f9c4 <do_or_b+0x94>
 804fa43:	68 ae 12 06 08       	push   $0x80612ae
 804fa48:	6a 13                	push   $0x13
 804fa4a:	68 4c 11 06 08       	push   $0x806114c
 804fa4f:	68 74 11 06 08       	push   $0x8061174
 804fa54:	e8 57 91 ff ff       	call   8048bb0 <__assert_fail@plt>
 804fa59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804fa60 <do_or_w>:
#include "cpu/exec/template-start.h"

#define instr or

static void do_execute () {
 804fa60:	53                   	push   %ebx
 804fa61:	83 ec 10             	sub    $0x10,%esp
	DATA_TYPE result = op_dest->val | op_src->val;
 804fa64:	8b 1d 4c ae 8f 14    	mov    0x148fae4c,%ebx
 804fa6a:	66 0b 1d 14 ae 8f 14 	or     0x148fae14,%bx
	OPERAND_W(op_dest, result);
 804fa71:	0f b7 c3             	movzwl %bx,%eax
 804fa74:	50                   	push   %eax
 804fa75:	68 40 ae 8f 14       	push   $0x148fae40
 804fa7a:	e8 51 d5 00 00       	call   805cfd0 <write_operand_w>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804fa7f:	89 da                	mov    %ebx,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 804fa81:	80 25 e5 ae 8f 14 f7 	andb   $0xf7,0x148faee5
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804fa88:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804fa8f:	66 c1 ea 0f          	shr    $0xf,%dx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804fa93:	68 18 ae 8f 14       	push   $0x148fae18
 804fa98:	68 85 15 06 08       	push   $0x8061585
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804fa9d:	89 d0                	mov    %edx,%eax
 804fa9f:	0f b6 15 e4 ae 8f 14 	movzbl 0x148faee4,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804faa6:	6a 50                	push   $0x50
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804faa8:	c1 e0 07             	shl    $0x7,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804faab:	68 00 89 0c 08       	push   $0x80c8900
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804fab0:	83 e2 3e             	and    $0x3e,%edx
	cpu.ZF = !result;
 804fab3:	66 85 db             	test   %bx,%bx
	uint32_t pf = (result & 255);
 804fab6:	0f b6 db             	movzbl %bl,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804fab9:	0f 94 c1             	sete   %cl
 804fabc:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804fabe:	89 d8                	mov    %ebx,%eax
 804fac0:	c1 e8 04             	shr    $0x4,%eax
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804fac3:	c1 e1 06             	shl    $0x6,%ecx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804fac6:	31 c3                	xor    %eax,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804fac8:	09 ca                	or     %ecx,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804faca:	89 d8                	mov    %ebx,%eax
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 804facc:	83 e2 fb             	and    $0xfffffffb,%edx
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804facf:	c1 e8 02             	shr    $0x2,%eax
 804fad2:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 804fad4:	89 d8                	mov    %ebx,%eax
 804fad6:	d1 e8                	shr    %eax
 804fad8:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 804fada:	83 e3 01             	and    $0x1,%ebx
 804fadd:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 804fae4:	89 d3                	mov    %edx,%ebx
 804fae6:	09 c3                	or     %eax,%ebx
 804fae8:	88 1d e4 ae 8f 14    	mov    %bl,0x148faee4

	print_asm_template2();
 804faee:	e8 0d 90 ff ff       	call   8048b00 <snprintf@plt>
 804faf3:	83 c4 20             	add    $0x20,%esp
 804faf6:	83 f8 4f             	cmp    $0x4f,%eax
 804faf9:	7f 05                	jg     804fb00 <do_or_w+0xa0>
}
 804fafb:	83 c4 08             	add    $0x8,%esp
 804fafe:	5b                   	pop    %ebx
 804faff:	c3                   	ret    
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804fb00:	83 ec 0c             	sub    $0xc,%esp
 804fb03:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804fb09:	e8 52 8e ff ff       	call   8048960 <fflush@plt>
 804fb0e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804fb14:	6a 07                	push   $0x7
 804fb16:	6a 01                	push   $0x1
 804fb18:	68 92 ed 05 08       	push   $0x805ed92
 804fb1d:	e8 ee 8e ff ff       	call   8048a10 <fwrite@plt>
 804fb22:	83 c4 20             	add    $0x20,%esp
 804fb25:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804fb2b:	6a 10                	push   $0x10
 804fb2d:	6a 01                	push   $0x1
 804fb2f:	68 84 f8 05 08       	push   $0x805f884
 804fb34:	e8 d7 8e ff ff       	call   8048a10 <fwrite@plt>
 804fb39:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804fb3f:	6a 05                	push   $0x5
 804fb41:	6a 01                	push   $0x1
 804fb43:	68 b1 ed 05 08       	push   $0x805edb1
 804fb48:	e8 c3 8e ff ff       	call   8048a10 <fwrite@plt>
 804fb4d:	83 c4 14             	add    $0x14,%esp
 804fb50:	68 50 ae 8f 14       	push   $0x148fae50
 804fb55:	68 18 ae 8f 14       	push   $0x148fae18
 804fb5a:	68 85 15 06 08       	push   $0x8061585
 804fb5f:	6a 50                	push   $0x50
 804fb61:	68 00 89 0c 08       	push   $0x80c8900
 804fb66:	e8 95 8f ff ff       	call   8048b00 <snprintf@plt>
 804fb6b:	83 c4 20             	add    $0x20,%esp
 804fb6e:	83 f8 4f             	cmp    $0x4f,%eax
 804fb71:	7e 88                	jle    804fafb <do_or_w+0x9b>
 804fb73:	68 a6 12 06 08       	push   $0x80612a6
 804fb78:	6a 13                	push   $0x13
 804fb7a:	68 4c 11 06 08       	push   $0x806114c
 804fb7f:	68 d8 11 06 08       	push   $0x80611d8
 804fb84:	e8 27 90 ff ff       	call   8048bb0 <__assert_fail@plt>
 804fb89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804fb90 <or_i2a_w>:
}

make_instr_helper(i2a)
 804fb90:	53                   	push   %ebx
 804fb91:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fb94:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fb98:	83 c0 01             	add    $0x1,%eax
 804fb9b:	50                   	push   %eax
 804fb9c:	e8 ef d1 00 00       	call   805cd90 <decode_i2a_w>
 804fba1:	89 c3                	mov    %eax,%ebx
	execute();
 804fba3:	e8 b8 fe ff ff       	call   804fa60 <do_or_w>
 804fba8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fbab:	8d 43 01             	lea    0x1(%ebx),%eax
 804fbae:	5b                   	pop    %ebx
 804fbaf:	c3                   	ret    

0804fbb0 <or_i2rm_w>:
make_instr_helper(i2rm)
 804fbb0:	53                   	push   %ebx
 804fbb1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fbb4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fbb8:	83 c0 01             	add    $0x1,%eax
 804fbbb:	50                   	push   %eax
 804fbbc:	e8 4f d2 00 00       	call   805ce10 <decode_i2rm_w>
 804fbc1:	89 c3                	mov    %eax,%ebx
	execute();
 804fbc3:	e8 98 fe ff ff       	call   804fa60 <do_or_w>
 804fbc8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fbcb:	8d 43 01             	lea    0x1(%ebx),%eax
 804fbce:	5b                   	pop    %ebx
 804fbcf:	c3                   	ret    

0804fbd0 <or_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 804fbd0:	53                   	push   %ebx
 804fbd1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fbd4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fbd8:	83 c0 01             	add    $0x1,%eax
 804fbdb:	50                   	push   %eax
 804fbdc:	e8 af d2 00 00       	call   805ce90 <decode_si2rm_w>
 804fbe1:	89 c3                	mov    %eax,%ebx
	execute();
 804fbe3:	e8 78 fe ff ff       	call   804fa60 <do_or_w>
 804fbe8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fbeb:	8d 43 01             	lea    0x1(%ebx),%eax
 804fbee:	5b                   	pop    %ebx
 804fbef:	c3                   	ret    

0804fbf0 <or_r2rm_w>:
#endif
make_instr_helper(r2rm)
 804fbf0:	53                   	push   %ebx
 804fbf1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fbf4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fbf8:	83 c0 01             	add    $0x1,%eax
 804fbfb:	50                   	push   %eax
 804fbfc:	e8 4f d1 00 00       	call   805cd50 <decode_r2rm_w>
 804fc01:	89 c3                	mov    %eax,%ebx
	execute();
 804fc03:	e8 58 fe ff ff       	call   804fa60 <do_or_w>
 804fc08:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fc0b:	8d 43 01             	lea    0x1(%ebx),%eax
 804fc0e:	5b                   	pop    %ebx
 804fc0f:	c3                   	ret    

0804fc10 <or_rm2r_w>:
make_instr_helper(rm2r)
 804fc10:	53                   	push   %ebx
 804fc11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fc14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fc18:	83 c0 01             	add    $0x1,%eax
 804fc1b:	50                   	push   %eax
 804fc1c:	e8 4f d1 00 00       	call   805cd70 <decode_rm2r_w>
 804fc21:	89 c3                	mov    %eax,%ebx
	execute();
 804fc23:	e8 38 fe ff ff       	call   804fa60 <do_or_w>
 804fc28:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fc2b:	8d 43 01             	lea    0x1(%ebx),%eax
 804fc2e:	5b                   	pop    %ebx
 804fc2f:	c3                   	ret    

0804fc30 <do_or_l>:
#include "cpu/exec/template-start.h"

#define instr or

static void do_execute () {
 804fc30:	53                   	push   %ebx
 804fc31:	83 ec 10             	sub    $0x10,%esp
	DATA_TYPE result = op_dest->val | op_src->val;
 804fc34:	8b 1d 14 ae 8f 14    	mov    0x148fae14,%ebx
 804fc3a:	0b 1d 4c ae 8f 14    	or     0x148fae4c,%ebx
	OPERAND_W(op_dest, result);
 804fc40:	53                   	push   %ebx
 804fc41:	68 40 ae 8f 14       	push   $0x148fae40
 804fc46:	e8 55 d7 00 00       	call   805d3a0 <write_operand_l>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804fc4b:	89 da                	mov    %ebx,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 804fc4d:	80 25 e5 ae 8f 14 f7 	andb   $0xf7,0x148faee5
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804fc54:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804fc5b:	c1 ea 1f             	shr    $0x1f,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804fc5e:	68 18 ae 8f 14       	push   $0x148fae18
 804fc63:	68 90 15 06 08       	push   $0x8061590
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804fc68:	89 d0                	mov    %edx,%eax
 804fc6a:	0f b6 15 e4 ae 8f 14 	movzbl 0x148faee4,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804fc71:	6a 50                	push   $0x50
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804fc73:	c1 e0 07             	shl    $0x7,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804fc76:	68 00 89 0c 08       	push   $0x80c8900
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804fc7b:	83 e2 3e             	and    $0x3e,%edx
	cpu.ZF = !result;
 804fc7e:	85 db                	test   %ebx,%ebx
	uint32_t pf = (result & 255);
 804fc80:	0f b6 db             	movzbl %bl,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804fc83:	0f 94 c1             	sete   %cl
 804fc86:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804fc88:	89 d8                	mov    %ebx,%eax
 804fc8a:	c1 e8 04             	shr    $0x4,%eax
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804fc8d:	c1 e1 06             	shl    $0x6,%ecx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804fc90:	31 c3                	xor    %eax,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804fc92:	09 ca                	or     %ecx,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804fc94:	89 d8                	mov    %ebx,%eax
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 804fc96:	83 e2 fb             	and    $0xfffffffb,%edx
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804fc99:	c1 e8 02             	shr    $0x2,%eax
 804fc9c:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 804fc9e:	89 d8                	mov    %ebx,%eax
 804fca0:	d1 e8                	shr    %eax
 804fca2:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 804fca4:	83 e3 01             	and    $0x1,%ebx
 804fca7:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 804fcae:	89 d3                	mov    %edx,%ebx
 804fcb0:	09 c3                	or     %eax,%ebx
 804fcb2:	88 1d e4 ae 8f 14    	mov    %bl,0x148faee4

	print_asm_template2();
 804fcb8:	e8 43 8e ff ff       	call   8048b00 <snprintf@plt>
 804fcbd:	83 c4 20             	add    $0x20,%esp
 804fcc0:	83 f8 4f             	cmp    $0x4f,%eax
 804fcc3:	7f 0b                	jg     804fcd0 <do_or_l+0xa0>
}
 804fcc5:	83 c4 08             	add    $0x8,%esp
 804fcc8:	5b                   	pop    %ebx
 804fcc9:	c3                   	ret    
 804fcca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804fcd0:	83 ec 0c             	sub    $0xc,%esp
 804fcd3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804fcd9:	e8 82 8c ff ff       	call   8048960 <fflush@plt>
 804fcde:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804fce4:	6a 07                	push   $0x7
 804fce6:	6a 01                	push   $0x1
 804fce8:	68 92 ed 05 08       	push   $0x805ed92
 804fced:	e8 1e 8d ff ff       	call   8048a10 <fwrite@plt>
 804fcf2:	83 c4 20             	add    $0x20,%esp
 804fcf5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804fcfb:	6a 10                	push   $0x10
 804fcfd:	6a 01                	push   $0x1
 804fcff:	68 84 f8 05 08       	push   $0x805f884
 804fd04:	e8 07 8d ff ff       	call   8048a10 <fwrite@plt>
 804fd09:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804fd0f:	6a 05                	push   $0x5
 804fd11:	6a 01                	push   $0x1
 804fd13:	68 b1 ed 05 08       	push   $0x805edb1
 804fd18:	e8 f3 8c ff ff       	call   8048a10 <fwrite@plt>
 804fd1d:	83 c4 14             	add    $0x14,%esp
 804fd20:	68 50 ae 8f 14       	push   $0x148fae50
 804fd25:	68 18 ae 8f 14       	push   $0x148fae18
 804fd2a:	68 90 15 06 08       	push   $0x8061590
 804fd2f:	6a 50                	push   $0x50
 804fd31:	68 00 89 0c 08       	push   $0x80c8900
 804fd36:	e8 c5 8d ff ff       	call   8048b00 <snprintf@plt>
 804fd3b:	83 c4 20             	add    $0x20,%esp
 804fd3e:	83 f8 4f             	cmp    $0x4f,%eax
 804fd41:	7e 82                	jle    804fcc5 <do_or_l+0x95>
 804fd43:	68 9e 12 06 08       	push   $0x806129e
 804fd48:	6a 13                	push   $0x13
 804fd4a:	68 4c 11 06 08       	push   $0x806114c
 804fd4f:	68 3c 12 06 08       	push   $0x806123c
 804fd54:	e8 57 8e ff ff       	call   8048bb0 <__assert_fail@plt>
 804fd59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804fd60 <or_i2a_l>:
}

make_instr_helper(i2a)
 804fd60:	53                   	push   %ebx
 804fd61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fd64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fd68:	83 c0 01             	add    $0x1,%eax
 804fd6b:	50                   	push   %eax
 804fd6c:	e8 ef d3 00 00       	call   805d160 <decode_i2a_l>
 804fd71:	89 c3                	mov    %eax,%ebx
	execute();
 804fd73:	e8 b8 fe ff ff       	call   804fc30 <do_or_l>
 804fd78:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fd7b:	8d 43 01             	lea    0x1(%ebx),%eax
 804fd7e:	5b                   	pop    %ebx
 804fd7f:	c3                   	ret    

0804fd80 <or_i2rm_l>:
make_instr_helper(i2rm)
 804fd80:	53                   	push   %ebx
 804fd81:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fd84:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fd88:	83 c0 01             	add    $0x1,%eax
 804fd8b:	50                   	push   %eax
 804fd8c:	e8 4f d4 00 00       	call   805d1e0 <decode_i2rm_l>
 804fd91:	89 c3                	mov    %eax,%ebx
	execute();
 804fd93:	e8 98 fe ff ff       	call   804fc30 <do_or_l>
 804fd98:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fd9b:	8d 43 01             	lea    0x1(%ebx),%eax
 804fd9e:	5b                   	pop    %ebx
 804fd9f:	c3                   	ret    

0804fda0 <or_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 804fda0:	53                   	push   %ebx
 804fda1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fda4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fda8:	83 c0 01             	add    $0x1,%eax
 804fdab:	50                   	push   %eax
 804fdac:	e8 af d4 00 00       	call   805d260 <decode_si2rm_l>
 804fdb1:	89 c3                	mov    %eax,%ebx
	execute();
 804fdb3:	e8 78 fe ff ff       	call   804fc30 <do_or_l>
 804fdb8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fdbb:	8d 43 01             	lea    0x1(%ebx),%eax
 804fdbe:	5b                   	pop    %ebx
 804fdbf:	c3                   	ret    

0804fdc0 <or_r2rm_l>:
#endif
make_instr_helper(r2rm)
 804fdc0:	53                   	push   %ebx
 804fdc1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fdc4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fdc8:	83 c0 01             	add    $0x1,%eax
 804fdcb:	50                   	push   %eax
 804fdcc:	e8 4f d3 00 00       	call   805d120 <decode_r2rm_l>
 804fdd1:	89 c3                	mov    %eax,%ebx
	execute();
 804fdd3:	e8 58 fe ff ff       	call   804fc30 <do_or_l>
 804fdd8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fddb:	8d 43 01             	lea    0x1(%ebx),%eax
 804fdde:	5b                   	pop    %ebx
 804fddf:	c3                   	ret    

0804fde0 <or_rm2r_l>:
make_instr_helper(rm2r)
 804fde0:	53                   	push   %ebx
 804fde1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fde4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fde8:	83 c0 01             	add    $0x1,%eax
 804fdeb:	50                   	push   %eax
 804fdec:	e8 4f d3 00 00       	call   805d140 <decode_rm2r_l>
 804fdf1:	89 c3                	mov    %eax,%ebx
	execute();
 804fdf3:	e8 38 fe ff ff       	call   804fc30 <do_or_l>
 804fdf8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fdfb:	8d 43 01             	lea    0x1(%ebx),%eax
 804fdfe:	5b                   	pop    %ebx
 804fdff:	c3                   	ret    

0804fe00 <or_i2a_b>:
	cpu.PF = pf & 1;

	print_asm_template2();
}

make_instr_helper(i2a)
 804fe00:	53                   	push   %ebx
 804fe01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fe04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fe08:	83 c0 01             	add    $0x1,%eax
 804fe0b:	50                   	push   %eax
 804fe0c:	e8 4f cc 00 00       	call   805ca60 <decode_i2a_b>
 804fe11:	89 c3                	mov    %eax,%ebx
	execute();
 804fe13:	e8 18 fb ff ff       	call   804f930 <do_or_b>
 804fe18:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fe1b:	8d 43 01             	lea    0x1(%ebx),%eax
 804fe1e:	5b                   	pop    %ebx
 804fe1f:	c3                   	ret    

0804fe20 <or_i2rm_b>:
make_instr_helper(i2rm)
 804fe20:	53                   	push   %ebx
 804fe21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fe24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fe28:	83 c0 01             	add    $0x1,%eax
 804fe2b:	50                   	push   %eax
 804fe2c:	e8 af cc 00 00       	call   805cae0 <decode_i2rm_b>
 804fe31:	89 c3                	mov    %eax,%ebx
	execute();
 804fe33:	e8 f8 fa ff ff       	call   804f930 <do_or_b>
 804fe38:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fe3b:	8d 43 01             	lea    0x1(%ebx),%eax
 804fe3e:	5b                   	pop    %ebx
 804fe3f:	c3                   	ret    

0804fe40 <or_r2rm_b>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
#endif
make_instr_helper(r2rm)
 804fe40:	53                   	push   %ebx
 804fe41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fe44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fe48:	83 c0 01             	add    $0x1,%eax
 804fe4b:	50                   	push   %eax
 804fe4c:	e8 cf cb 00 00       	call   805ca20 <decode_r2rm_b>
 804fe51:	89 c3                	mov    %eax,%ebx
	execute();
 804fe53:	e8 d8 fa ff ff       	call   804f930 <do_or_b>
 804fe58:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fe5b:	8d 43 01             	lea    0x1(%ebx),%eax
 804fe5e:	5b                   	pop    %ebx
 804fe5f:	c3                   	ret    

0804fe60 <or_rm2r_b>:
make_instr_helper(rm2r)
 804fe60:	53                   	push   %ebx
 804fe61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fe64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fe68:	83 c0 01             	add    $0x1,%eax
 804fe6b:	50                   	push   %eax
 804fe6c:	e8 cf cb 00 00       	call   805ca40 <decode_rm2r_b>
 804fe71:	89 c3                	mov    %eax,%ebx
	execute();
 804fe73:	e8 b8 fa ff ff       	call   804f930 <do_or_b>
 804fe78:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fe7b:	8d 43 01             	lea    0x1(%ebx),%eax
 804fe7e:	5b                   	pop    %ebx
 804fe7f:	c3                   	ret    

0804fe80 <or_i2a_v>:
#include "or-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(or_i2a)
 804fe80:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804fe87:	8b 54 24 04          	mov    0x4(%esp),%edx
 804fe8b:	b8 90 fb 04 08       	mov    $0x804fb90,%eax
 804fe90:	75 05                	jne    804fe97 <or_i2a_v+0x17>
 804fe92:	b8 60 fd 04 08       	mov    $0x804fd60,%eax
 804fe97:	89 54 24 04          	mov    %edx,0x4(%esp)
 804fe9b:	ff e0                	jmp    *%eax
 804fe9d:	8d 76 00             	lea    0x0(%esi),%esi

0804fea0 <or_i2rm_v>:
make_helper_v(or_i2rm)
 804fea0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804fea7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804feab:	b8 b0 fb 04 08       	mov    $0x804fbb0,%eax
 804feb0:	75 05                	jne    804feb7 <or_i2rm_v+0x17>
 804feb2:	b8 80 fd 04 08       	mov    $0x804fd80,%eax
 804feb7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804febb:	ff e0                	jmp    *%eax
 804febd:	8d 76 00             	lea    0x0(%esi),%esi

0804fec0 <or_si2rm_v>:
make_helper_v(or_si2rm)
 804fec0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804fec7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804fecb:	b8 d0 fb 04 08       	mov    $0x804fbd0,%eax
 804fed0:	75 05                	jne    804fed7 <or_si2rm_v+0x17>
 804fed2:	b8 a0 fd 04 08       	mov    $0x804fda0,%eax
 804fed7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804fedb:	ff e0                	jmp    *%eax
 804fedd:	8d 76 00             	lea    0x0(%esi),%esi

0804fee0 <or_r2rm_v>:
make_helper_v(or_r2rm)
 804fee0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804fee7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804feeb:	b8 f0 fb 04 08       	mov    $0x804fbf0,%eax
 804fef0:	75 05                	jne    804fef7 <or_r2rm_v+0x17>
 804fef2:	b8 c0 fd 04 08       	mov    $0x804fdc0,%eax
 804fef7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804fefb:	ff e0                	jmp    *%eax
 804fefd:	8d 76 00             	lea    0x0(%esi),%esi

0804ff00 <or_rm2r_v>:
make_helper_v(or_rm2r)
 804ff00:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 804ff07:	8b 54 24 04          	mov    0x4(%esp),%edx
 804ff0b:	b8 10 fc 04 08       	mov    $0x804fc10,%eax
 804ff10:	75 05                	jne    804ff17 <or_rm2r_v+0x17>
 804ff12:	b8 e0 fd 04 08       	mov    $0x804fde0,%eax
 804ff17:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ff1b:	ff e0                	jmp    *%eax
 804ff1d:	66 90                	xchg   %ax,%ax
 804ff1f:	90                   	nop

0804ff20 <do_shr_b>:
#include "cpu/exec/template-start.h"

#define instr shr

static void do_execute () {
 804ff20:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804ff23:	0f b6 0d 14 ae 8f 14 	movzbl 0x148fae14,%ecx
 804ff2a:	0f b6 05 4c ae 8f 14 	movzbl 0x148fae4c,%eax
 804ff31:	83 e1 1f             	and    $0x1f,%ecx
	dest >>= count;
 804ff34:	d3 f8                	sar    %cl,%eax
	OPERAND_W(op_dest, dest);
 804ff36:	50                   	push   %eax
 804ff37:	68 40 ae 8f 14       	push   $0x148fae40
 804ff3c:	e8 ff cc 00 00       	call   805cc40 <write_operand_b>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804ff41:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 804ff48:	68 18 ae 8f 14       	push   $0x148fae18
 804ff4d:	68 b6 12 06 08       	push   $0x80612b6
 804ff52:	6a 50                	push   $0x50
 804ff54:	68 00 89 0c 08       	push   $0x80c8900
 804ff59:	e8 a2 8b ff ff       	call   8048b00 <snprintf@plt>
 804ff5e:	83 c4 20             	add    $0x20,%esp
 804ff61:	83 f8 4f             	cmp    $0x4f,%eax
 804ff64:	7f 0a                	jg     804ff70 <do_shr_b+0x50>
}
 804ff66:	83 c4 0c             	add    $0xc,%esp
 804ff69:	c3                   	ret    
 804ff6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804ff70:	83 ec 0c             	sub    $0xc,%esp
 804ff73:	ff 35 20 5c 07 08    	pushl  0x8075c20
 804ff79:	e8 e2 89 ff ff       	call   8048960 <fflush@plt>
 804ff7e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804ff84:	6a 07                	push   $0x7
 804ff86:	6a 01                	push   $0x1
 804ff88:	68 92 ed 05 08       	push   $0x805ed92
 804ff8d:	e8 7e 8a ff ff       	call   8048a10 <fwrite@plt>
 804ff92:	83 c4 20             	add    $0x20,%esp
 804ff95:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804ff9b:	6a 10                	push   $0x10
 804ff9d:	6a 01                	push   $0x1
 804ff9f:	68 84 f8 05 08       	push   $0x805f884
 804ffa4:	e8 67 8a ff ff       	call   8048a10 <fwrite@plt>
 804ffa9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 804ffaf:	6a 05                	push   $0x5
 804ffb1:	6a 01                	push   $0x1
 804ffb3:	68 b1 ed 05 08       	push   $0x805edb1
 804ffb8:	e8 53 8a ff ff       	call   8048a10 <fwrite@plt>
 804ffbd:	83 c4 14             	add    $0x14,%esp
 804ffc0:	68 50 ae 8f 14       	push   $0x148fae50
 804ffc5:	68 18 ae 8f 14       	push   $0x148fae18
 804ffca:	68 b6 12 06 08       	push   $0x80612b6
 804ffcf:	6a 50                	push   $0x50
 804ffd1:	68 00 89 0c 08       	push   $0x80c8900
 804ffd6:	e8 25 8b ff ff       	call   8048b00 <snprintf@plt>
 804ffdb:	83 c4 20             	add    $0x20,%esp
 804ffde:	83 f8 4f             	cmp    $0x4f,%eax
 804ffe1:	7e 83                	jle    804ff66 <do_shr_b+0x46>
 804ffe3:	68 3d 14 06 08       	push   $0x806143d
 804ffe8:	6a 11                	push   $0x11
 804ffea:	68 d8 12 06 08       	push   $0x80612d8
 804ffef:	68 00 13 06 08       	push   $0x8061300
 804fff4:	e8 b7 8b ff ff       	call   8048bb0 <__assert_fail@plt>
 804fff9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08050000 <do_shr_w>:
#include "cpu/exec/template-start.h"

#define instr shr

static void do_execute () {
 8050000:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 8050003:	0f b6 0d 14 ae 8f 14 	movzbl 0x148fae14,%ecx
 805000a:	0f b7 05 4c ae 8f 14 	movzwl 0x148fae4c,%eax
 8050011:	83 e1 1f             	and    $0x1f,%ecx
	dest >>= count;
 8050014:	d3 f8                	sar    %cl,%eax
	OPERAND_W(op_dest, dest);
 8050016:	50                   	push   %eax
 8050017:	68 40 ae 8f 14       	push   $0x148fae40
 805001c:	e8 af cf 00 00       	call   805cfd0 <write_operand_w>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 8050021:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8050028:	68 18 ae 8f 14       	push   $0x148fae18
 805002d:	68 c1 12 06 08       	push   $0x80612c1
 8050032:	6a 50                	push   $0x50
 8050034:	68 00 89 0c 08       	push   $0x80c8900
 8050039:	e8 c2 8a ff ff       	call   8048b00 <snprintf@plt>
 805003e:	83 c4 20             	add    $0x20,%esp
 8050041:	83 f8 4f             	cmp    $0x4f,%eax
 8050044:	7f 0a                	jg     8050050 <do_shr_w+0x50>
}
 8050046:	83 c4 0c             	add    $0xc,%esp
 8050049:	c3                   	ret    
 805004a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 8050050:	83 ec 0c             	sub    $0xc,%esp
 8050053:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8050059:	e8 02 89 ff ff       	call   8048960 <fflush@plt>
 805005e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8050064:	6a 07                	push   $0x7
 8050066:	6a 01                	push   $0x1
 8050068:	68 92 ed 05 08       	push   $0x805ed92
 805006d:	e8 9e 89 ff ff       	call   8048a10 <fwrite@plt>
 8050072:	83 c4 20             	add    $0x20,%esp
 8050075:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805007b:	6a 10                	push   $0x10
 805007d:	6a 01                	push   $0x1
 805007f:	68 84 f8 05 08       	push   $0x805f884
 8050084:	e8 87 89 ff ff       	call   8048a10 <fwrite@plt>
 8050089:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805008f:	6a 05                	push   $0x5
 8050091:	6a 01                	push   $0x1
 8050093:	68 b1 ed 05 08       	push   $0x805edb1
 8050098:	e8 73 89 ff ff       	call   8048a10 <fwrite@plt>
 805009d:	83 c4 14             	add    $0x14,%esp
 80500a0:	68 50 ae 8f 14       	push   $0x148fae50
 80500a5:	68 18 ae 8f 14       	push   $0x148fae18
 80500aa:	68 c1 12 06 08       	push   $0x80612c1
 80500af:	6a 50                	push   $0x50
 80500b1:	68 00 89 0c 08       	push   $0x80c8900
 80500b6:	e8 45 8a ff ff       	call   8048b00 <snprintf@plt>
 80500bb:	83 c4 20             	add    $0x20,%esp
 80500be:	83 f8 4f             	cmp    $0x4f,%eax
 80500c1:	7e 83                	jle    8050046 <do_shr_w+0x46>
 80500c3:	68 34 14 06 08       	push   $0x8061434
 80500c8:	6a 11                	push   $0x11
 80500ca:	68 d8 12 06 08       	push   $0x80612d8
 80500cf:	68 64 13 06 08       	push   $0x8061364
 80500d4:	e8 d7 8a ff ff       	call   8048bb0 <__assert_fail@plt>
 80500d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

080500e0 <shr_rm_1_w>:
}

make_instr_helper(rm_1)
 80500e0:	53                   	push   %ebx
 80500e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80500e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80500e8:	83 c0 01             	add    $0x1,%eax
 80500eb:	50                   	push   %eax
 80500ec:	e8 ff cd 00 00       	call   805cef0 <decode_rm_1_w>
 80500f1:	89 c3                	mov    %eax,%ebx
	execute();
 80500f3:	e8 08 ff ff ff       	call   8050000 <do_shr_w>
 80500f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80500fb:	8d 43 01             	lea    0x1(%ebx),%eax
 80500fe:	5b                   	pop    %ebx
 80500ff:	c3                   	ret    

08050100 <shr_rm_cl_w>:
make_instr_helper(rm_cl)
 8050100:	53                   	push   %ebx
 8050101:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050104:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050108:	83 c0 01             	add    $0x1,%eax
 805010b:	50                   	push   %eax
 805010c:	e8 2f ce 00 00       	call   805cf40 <decode_rm_cl_w>
 8050111:	89 c3                	mov    %eax,%ebx
	execute();
 8050113:	e8 e8 fe ff ff       	call   8050000 <do_shr_w>
 8050118:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805011b:	8d 43 01             	lea    0x1(%ebx),%eax
 805011e:	5b                   	pop    %ebx
 805011f:	c3                   	ret    

08050120 <shr_rm_imm_w>:
make_instr_helper(rm_imm)
 8050120:	53                   	push   %ebx
 8050121:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050124:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050128:	83 c0 01             	add    $0x1,%eax
 805012b:	50                   	push   %eax
 805012c:	e8 6f ce 00 00       	call   805cfa0 <decode_rm_imm_w>
 8050131:	89 c3                	mov    %eax,%ebx
	execute();
 8050133:	e8 c8 fe ff ff       	call   8050000 <do_shr_w>
 8050138:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805013b:	8d 43 01             	lea    0x1(%ebx),%eax
 805013e:	5b                   	pop    %ebx
 805013f:	c3                   	ret    

08050140 <do_shr_l>:
#include "cpu/exec/template-start.h"

#define instr shr

static void do_execute () {
 8050140:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 8050143:	0f b6 0d 14 ae 8f 14 	movzbl 0x148fae14,%ecx
	dest >>= count;
 805014a:	a1 4c ae 8f 14       	mov    0x148fae4c,%eax

static void do_execute () {
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 805014f:	83 e1 1f             	and    $0x1f,%ecx
	dest >>= count;
 8050152:	d3 e8                	shr    %cl,%eax
	OPERAND_W(op_dest, dest);
 8050154:	50                   	push   %eax
 8050155:	68 40 ae 8f 14       	push   $0x148fae40
 805015a:	e8 41 d2 00 00       	call   805d3a0 <write_operand_l>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 805015f:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8050166:	68 18 ae 8f 14       	push   $0x148fae18
 805016b:	68 cc 12 06 08       	push   $0x80612cc
 8050170:	6a 50                	push   $0x50
 8050172:	68 00 89 0c 08       	push   $0x80c8900
 8050177:	e8 84 89 ff ff       	call   8048b00 <snprintf@plt>
 805017c:	83 c4 20             	add    $0x20,%esp
 805017f:	83 f8 4f             	cmp    $0x4f,%eax
 8050182:	7f 0c                	jg     8050190 <do_shr_l+0x50>
}
 8050184:	83 c4 0c             	add    $0xc,%esp
 8050187:	c3                   	ret    
 8050188:	90                   	nop
 8050189:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 8050190:	83 ec 0c             	sub    $0xc,%esp
 8050193:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8050199:	e8 c2 87 ff ff       	call   8048960 <fflush@plt>
 805019e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80501a4:	6a 07                	push   $0x7
 80501a6:	6a 01                	push   $0x1
 80501a8:	68 92 ed 05 08       	push   $0x805ed92
 80501ad:	e8 5e 88 ff ff       	call   8048a10 <fwrite@plt>
 80501b2:	83 c4 20             	add    $0x20,%esp
 80501b5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80501bb:	6a 10                	push   $0x10
 80501bd:	6a 01                	push   $0x1
 80501bf:	68 84 f8 05 08       	push   $0x805f884
 80501c4:	e8 47 88 ff ff       	call   8048a10 <fwrite@plt>
 80501c9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80501cf:	6a 05                	push   $0x5
 80501d1:	6a 01                	push   $0x1
 80501d3:	68 b1 ed 05 08       	push   $0x805edb1
 80501d8:	e8 33 88 ff ff       	call   8048a10 <fwrite@plt>
 80501dd:	83 c4 14             	add    $0x14,%esp
 80501e0:	68 50 ae 8f 14       	push   $0x148fae50
 80501e5:	68 18 ae 8f 14       	push   $0x148fae18
 80501ea:	68 cc 12 06 08       	push   $0x80612cc
 80501ef:	6a 50                	push   $0x50
 80501f1:	68 00 89 0c 08       	push   $0x80c8900
 80501f6:	e8 05 89 ff ff       	call   8048b00 <snprintf@plt>
 80501fb:	83 c4 20             	add    $0x20,%esp
 80501fe:	83 f8 4f             	cmp    $0x4f,%eax
 8050201:	7e 81                	jle    8050184 <do_shr_l+0x44>
 8050203:	68 2b 14 06 08       	push   $0x806142b
 8050208:	6a 11                	push   $0x11
 805020a:	68 d8 12 06 08       	push   $0x80612d8
 805020f:	68 c8 13 06 08       	push   $0x80613c8
 8050214:	e8 97 89 ff ff       	call   8048bb0 <__assert_fail@plt>
 8050219:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08050220 <shr_rm_1_l>:
}

make_instr_helper(rm_1)
 8050220:	53                   	push   %ebx
 8050221:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050224:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050228:	83 c0 01             	add    $0x1,%eax
 805022b:	50                   	push   %eax
 805022c:	e8 8f d0 00 00       	call   805d2c0 <decode_rm_1_l>
 8050231:	89 c3                	mov    %eax,%ebx
	execute();
 8050233:	e8 08 ff ff ff       	call   8050140 <do_shr_l>
 8050238:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805023b:	8d 43 01             	lea    0x1(%ebx),%eax
 805023e:	5b                   	pop    %ebx
 805023f:	c3                   	ret    

08050240 <shr_rm_cl_l>:
make_instr_helper(rm_cl)
 8050240:	53                   	push   %ebx
 8050241:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050244:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050248:	83 c0 01             	add    $0x1,%eax
 805024b:	50                   	push   %eax
 805024c:	e8 bf d0 00 00       	call   805d310 <decode_rm_cl_l>
 8050251:	89 c3                	mov    %eax,%ebx
	execute();
 8050253:	e8 e8 fe ff ff       	call   8050140 <do_shr_l>
 8050258:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805025b:	8d 43 01             	lea    0x1(%ebx),%eax
 805025e:	5b                   	pop    %ebx
 805025f:	c3                   	ret    

08050260 <shr_rm_imm_l>:
make_instr_helper(rm_imm)
 8050260:	53                   	push   %ebx
 8050261:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050264:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050268:	83 c0 01             	add    $0x1,%eax
 805026b:	50                   	push   %eax
 805026c:	e8 ff d0 00 00       	call   805d370 <decode_rm_imm_l>
 8050271:	89 c3                	mov    %eax,%ebx
	execute();
 8050273:	e8 c8 fe ff ff       	call   8050140 <do_shr_l>
 8050278:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805027b:	8d 43 01             	lea    0x1(%ebx),%eax
 805027e:	5b                   	pop    %ebx
 805027f:	c3                   	ret    

08050280 <shr_rm_1_b>:
	 */

	print_asm_template2();
}

make_instr_helper(rm_1)
 8050280:	53                   	push   %ebx
 8050281:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050284:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050288:	83 c0 01             	add    $0x1,%eax
 805028b:	50                   	push   %eax
 805028c:	e8 cf c8 00 00       	call   805cb60 <decode_rm_1_b>
 8050291:	89 c3                	mov    %eax,%ebx
	execute();
 8050293:	e8 88 fc ff ff       	call   804ff20 <do_shr_b>
 8050298:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805029b:	8d 43 01             	lea    0x1(%ebx),%eax
 805029e:	5b                   	pop    %ebx
 805029f:	c3                   	ret    

080502a0 <shr_rm_cl_b>:
make_instr_helper(rm_cl)
 80502a0:	53                   	push   %ebx
 80502a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80502a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80502a8:	83 c0 01             	add    $0x1,%eax
 80502ab:	50                   	push   %eax
 80502ac:	e8 ff c8 00 00       	call   805cbb0 <decode_rm_cl_b>
 80502b1:	89 c3                	mov    %eax,%ebx
	execute();
 80502b3:	e8 68 fc ff ff       	call   804ff20 <do_shr_b>
 80502b8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80502bb:	8d 43 01             	lea    0x1(%ebx),%eax
 80502be:	5b                   	pop    %ebx
 80502bf:	c3                   	ret    

080502c0 <shr_rm_imm_b>:
make_instr_helper(rm_imm)
 80502c0:	53                   	push   %ebx
 80502c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80502c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80502c8:	83 c0 01             	add    $0x1,%eax
 80502cb:	50                   	push   %eax
 80502cc:	e8 3f c9 00 00       	call   805cc10 <decode_rm_imm_b>
 80502d1:	89 c3                	mov    %eax,%ebx
	execute();
 80502d3:	e8 48 fc ff ff       	call   804ff20 <do_shr_b>
 80502d8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80502db:	8d 43 01             	lea    0x1(%ebx),%eax
 80502de:	5b                   	pop    %ebx
 80502df:	c3                   	ret    

080502e0 <shr_rm_1_v>:
#define DATA_BYTE 4
#include "shr-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */
make_helper_v(shr_rm_1)
 80502e0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80502e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80502eb:	b8 e0 00 05 08       	mov    $0x80500e0,%eax
 80502f0:	75 05                	jne    80502f7 <shr_rm_1_v+0x17>
 80502f2:	b8 20 02 05 08       	mov    $0x8050220,%eax
 80502f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80502fb:	ff e0                	jmp    *%eax
 80502fd:	8d 76 00             	lea    0x0(%esi),%esi

08050300 <shr_rm_cl_v>:
make_helper_v(shr_rm_cl)
 8050300:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8050307:	8b 54 24 04          	mov    0x4(%esp),%edx
 805030b:	b8 00 01 05 08       	mov    $0x8050100,%eax
 8050310:	75 05                	jne    8050317 <shr_rm_cl_v+0x17>
 8050312:	b8 40 02 05 08       	mov    $0x8050240,%eax
 8050317:	89 54 24 04          	mov    %edx,0x4(%esp)
 805031b:	ff e0                	jmp    *%eax
 805031d:	8d 76 00             	lea    0x0(%esi),%esi

08050320 <shr_rm_imm_v>:
make_helper_v(shr_rm_imm)
 8050320:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8050327:	8b 54 24 04          	mov    0x4(%esp),%edx
 805032b:	b8 20 01 05 08       	mov    $0x8050120,%eax
 8050330:	75 05                	jne    8050337 <shr_rm_imm_v+0x17>
 8050332:	b8 60 02 05 08       	mov    $0x8050260,%eax
 8050337:	89 54 24 04          	mov    %edx,0x4(%esp)
 805033b:	ff e0                	jmp    *%eax
 805033d:	66 90                	xchg   %ax,%ax
 805033f:	90                   	nop

08050340 <not_rm_l>:
	DATA_TYPE result = ~op_src->val;
	OPERAND_W(op_src, result);
	print_asm_template1();
}

make_instr_helper(rm)
 8050340:	53                   	push   %ebx
 8050341:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050344:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050348:	83 c0 01             	add    $0x1,%eax
 805034b:	50                   	push   %eax
 805034c:	e8 df ce 00 00       	call   805d230 <decode_rm_l>
 8050351:	89 c3                	mov    %eax,%ebx

#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
	OPERAND_W(op_src, result);
 8050353:	58                   	pop    %eax
 8050354:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
 8050355:	8b 15 14 ae 8f 14    	mov    0x148fae14,%edx
 805035b:	f7 d2                	not    %edx
	OPERAND_W(op_src, result);
 805035d:	52                   	push   %edx
 805035e:	68 08 ae 8f 14       	push   $0x148fae08
 8050363:	e8 38 d0 00 00       	call   805d3a0 <write_operand_l>
	print_asm_template1();
 8050368:	68 18 ae 8f 14       	push   $0x148fae18
 805036d:	68 46 14 06 08       	push   $0x8061446
 8050372:	6a 50                	push   $0x50
 8050374:	68 00 89 0c 08       	push   $0x80c8900
 8050379:	e8 82 87 ff ff       	call   8048b00 <snprintf@plt>
 805037e:	83 c4 20             	add    $0x20,%esp
 8050381:	83 f8 4f             	cmp    $0x4f,%eax
 8050384:	7f 0a                	jg     8050390 <not_rm_l+0x50>
}

make_instr_helper(rm)
 8050386:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8050389:	8d 43 01             	lea    0x1(%ebx),%eax
 805038c:	5b                   	pop    %ebx
 805038d:	c3                   	ret    
 805038e:	66 90                	xchg   %ax,%ax
#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
	OPERAND_W(op_src, result);
	print_asm_template1();
 8050390:	83 ec 0c             	sub    $0xc,%esp
 8050393:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8050399:	e8 c2 85 ff ff       	call   8048960 <fflush@plt>
 805039e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80503a4:	6a 07                	push   $0x7
 80503a6:	6a 01                	push   $0x1
 80503a8:	68 92 ed 05 08       	push   $0x805ed92
 80503ad:	e8 5e 86 ff ff       	call   8048a10 <fwrite@plt>
 80503b2:	83 c4 20             	add    $0x20,%esp
 80503b5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80503bb:	6a 10                	push   $0x10
 80503bd:	6a 01                	push   $0x1
 80503bf:	68 84 f8 05 08       	push   $0x805f884
 80503c4:	e8 47 86 ff ff       	call   8048a10 <fwrite@plt>
 80503c9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80503cf:	6a 05                	push   $0x5
 80503d1:	6a 01                	push   $0x1
 80503d3:	68 b1 ed 05 08       	push   $0x805edb1
 80503d8:	e8 33 86 ff ff       	call   8048a10 <fwrite@plt>
 80503dd:	83 c4 20             	add    $0x20,%esp
 80503e0:	68 18 ae 8f 14       	push   $0x148fae18
 80503e5:	68 46 14 06 08       	push   $0x8061446
 80503ea:	6a 50                	push   $0x50
 80503ec:	68 00 89 0c 08       	push   $0x80c8900
 80503f1:	e8 0a 87 ff ff       	call   8048b00 <snprintf@plt>
 80503f6:	83 c4 10             	add    $0x10,%esp
 80503f9:	83 f8 4f             	cmp    $0x4f,%eax
 80503fc:	7e 88                	jle    8050386 <not_rm_l+0x46>
 80503fe:	68 5e 15 06 08       	push   $0x806155e
 8050403:	6a 08                	push   $0x8
 8050405:	68 60 14 06 08       	push   $0x8061460
 805040a:	68 88 14 06 08       	push   $0x8061488
 805040f:	e8 9c 87 ff ff       	call   8048bb0 <__assert_fail@plt>
 8050414:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805041a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08050420 <not_rm_w>:
}

make_instr_helper(rm)
 8050420:	53                   	push   %ebx
 8050421:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050424:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050428:	83 c0 01             	add    $0x1,%eax
 805042b:	50                   	push   %eax
 805042c:	e8 2f ca 00 00       	call   805ce60 <decode_rm_w>
 8050431:	89 c3                	mov    %eax,%ebx

#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
	OPERAND_W(op_src, result);
 8050433:	58                   	pop    %eax
 8050434:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
 8050435:	0f b7 15 14 ae 8f 14 	movzwl 0x148fae14,%edx
 805043c:	f7 d2                	not    %edx
	OPERAND_W(op_src, result);
 805043e:	0f b7 d2             	movzwl %dx,%edx
 8050441:	52                   	push   %edx
 8050442:	68 08 ae 8f 14       	push   $0x148fae08
 8050447:	e8 84 cb 00 00       	call   805cfd0 <write_operand_w>
	print_asm_template1();
 805044c:	68 18 ae 8f 14       	push   $0x148fae18
 8050451:	68 4e 14 06 08       	push   $0x806144e
 8050456:	6a 50                	push   $0x50
 8050458:	68 00 89 0c 08       	push   $0x80c8900
 805045d:	e8 9e 86 ff ff       	call   8048b00 <snprintf@plt>
 8050462:	83 c4 20             	add    $0x20,%esp
 8050465:	83 f8 4f             	cmp    $0x4f,%eax
 8050468:	7f 0e                	jg     8050478 <not_rm_w+0x58>
}

make_instr_helper(rm)
 805046a:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805046d:	8d 43 01             	lea    0x1(%ebx),%eax
 8050470:	5b                   	pop    %ebx
 8050471:	c3                   	ret    
 8050472:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
	OPERAND_W(op_src, result);
	print_asm_template1();
 8050478:	83 ec 0c             	sub    $0xc,%esp
 805047b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8050481:	e8 da 84 ff ff       	call   8048960 <fflush@plt>
 8050486:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805048c:	6a 07                	push   $0x7
 805048e:	6a 01                	push   $0x1
 8050490:	68 92 ed 05 08       	push   $0x805ed92
 8050495:	e8 76 85 ff ff       	call   8048a10 <fwrite@plt>
 805049a:	83 c4 20             	add    $0x20,%esp
 805049d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80504a3:	6a 10                	push   $0x10
 80504a5:	6a 01                	push   $0x1
 80504a7:	68 84 f8 05 08       	push   $0x805f884
 80504ac:	e8 5f 85 ff ff       	call   8048a10 <fwrite@plt>
 80504b1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80504b7:	6a 05                	push   $0x5
 80504b9:	6a 01                	push   $0x1
 80504bb:	68 b1 ed 05 08       	push   $0x805edb1
 80504c0:	e8 4b 85 ff ff       	call   8048a10 <fwrite@plt>
 80504c5:	83 c4 20             	add    $0x20,%esp
 80504c8:	68 18 ae 8f 14       	push   $0x148fae18
 80504cd:	68 4e 14 06 08       	push   $0x806144e
 80504d2:	6a 50                	push   $0x50
 80504d4:	68 00 89 0c 08       	push   $0x80c8900
 80504d9:	e8 22 86 ff ff       	call   8048b00 <snprintf@plt>
 80504de:	83 c4 10             	add    $0x10,%esp
 80504e1:	83 f8 4f             	cmp    $0x4f,%eax
 80504e4:	7e 84                	jle    805046a <not_rm_w+0x4a>
 80504e6:	68 67 15 06 08       	push   $0x8061567
 80504eb:	6a 08                	push   $0x8
 80504ed:	68 60 14 06 08       	push   $0x8061460
 80504f2:	68 d0 14 06 08       	push   $0x80614d0
 80504f7:	e8 b4 86 ff ff       	call   8048bb0 <__assert_fail@plt>
 80504fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08050500 <not_rm_b>:
}

make_instr_helper(rm)
 8050500:	53                   	push   %ebx
 8050501:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050504:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050508:	83 c0 01             	add    $0x1,%eax
 805050b:	50                   	push   %eax
 805050c:	e8 1f c6 00 00       	call   805cb30 <decode_rm_b>
 8050511:	89 c3                	mov    %eax,%ebx

#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
	OPERAND_W(op_src, result);
 8050513:	58                   	pop    %eax
 8050514:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
 8050515:	0f b6 15 14 ae 8f 14 	movzbl 0x148fae14,%edx
 805051c:	f7 d2                	not    %edx
	OPERAND_W(op_src, result);
 805051e:	0f b6 d2             	movzbl %dl,%edx
 8050521:	52                   	push   %edx
 8050522:	68 08 ae 8f 14       	push   $0x148fae08
 8050527:	e8 14 c7 00 00       	call   805cc40 <write_operand_b>
	print_asm_template1();
 805052c:	68 18 ae 8f 14       	push   $0x148fae18
 8050531:	68 56 14 06 08       	push   $0x8061456
 8050536:	6a 50                	push   $0x50
 8050538:	68 00 89 0c 08       	push   $0x80c8900
 805053d:	e8 be 85 ff ff       	call   8048b00 <snprintf@plt>
 8050542:	83 c4 20             	add    $0x20,%esp
 8050545:	83 f8 4f             	cmp    $0x4f,%eax
 8050548:	7f 0e                	jg     8050558 <not_rm_b+0x58>
}

make_instr_helper(rm)
 805054a:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805054d:	8d 43 01             	lea    0x1(%ebx),%eax
 8050550:	5b                   	pop    %ebx
 8050551:	c3                   	ret    
 8050552:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
	OPERAND_W(op_src, result);
	print_asm_template1();
 8050558:	83 ec 0c             	sub    $0xc,%esp
 805055b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8050561:	e8 fa 83 ff ff       	call   8048960 <fflush@plt>
 8050566:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805056c:	6a 07                	push   $0x7
 805056e:	6a 01                	push   $0x1
 8050570:	68 92 ed 05 08       	push   $0x805ed92
 8050575:	e8 96 84 ff ff       	call   8048a10 <fwrite@plt>
 805057a:	83 c4 20             	add    $0x20,%esp
 805057d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8050583:	6a 10                	push   $0x10
 8050585:	6a 01                	push   $0x1
 8050587:	68 84 f8 05 08       	push   $0x805f884
 805058c:	e8 7f 84 ff ff       	call   8048a10 <fwrite@plt>
 8050591:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8050597:	6a 05                	push   $0x5
 8050599:	6a 01                	push   $0x1
 805059b:	68 b1 ed 05 08       	push   $0x805edb1
 80505a0:	e8 6b 84 ff ff       	call   8048a10 <fwrite@plt>
 80505a5:	83 c4 20             	add    $0x20,%esp
 80505a8:	68 18 ae 8f 14       	push   $0x148fae18
 80505ad:	68 56 14 06 08       	push   $0x8061456
 80505b2:	6a 50                	push   $0x50
 80505b4:	68 00 89 0c 08       	push   $0x80c8900
 80505b9:	e8 42 85 ff ff       	call   8048b00 <snprintf@plt>
 80505be:	83 c4 10             	add    $0x10,%esp
 80505c1:	83 f8 4f             	cmp    $0x4f,%eax
 80505c4:	7e 84                	jle    805054a <not_rm_b+0x4a>
 80505c6:	68 70 15 06 08       	push   $0x8061570
 80505cb:	6a 08                	push   $0x8
 80505cd:	68 60 14 06 08       	push   $0x8061460
 80505d2:	68 18 15 06 08       	push   $0x8061518
 80505d7:	e8 d4 85 ff ff       	call   8048bb0 <__assert_fail@plt>
 80505dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080505e0 <not_rm_v>:
#define DATA_BYTE 4
#include "not-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */
make_helper_v(not_rm)
 80505e0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80505e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80505eb:	b8 20 04 05 08       	mov    $0x8050420,%eax
 80505f0:	75 05                	jne    80505f7 <not_rm_v+0x17>
 80505f2:	b8 40 03 05 08       	mov    $0x8050340,%eax
 80505f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80505fb:	ff e0                	jmp    *%eax
 80505fd:	66 90                	xchg   %ax,%ax
 80505ff:	90                   	nop

08050600 <do_xor_b>:
#include "cpu/exec/template-start.h"

#define instr xor

static void do_execute () {
 8050600:	56                   	push   %esi
 8050601:	53                   	push   %ebx
 8050602:	83 ec 0c             	sub    $0xc,%esp
	DATA_TYPE result = op_dest->val ^ op_src->val;
 8050605:	a1 4c ae 8f 14       	mov    0x148fae4c,%eax
 805060a:	32 05 14 ae 8f 14    	xor    0x148fae14,%al
	OPERAND_W(op_dest, result);
 8050610:	0f b6 d8             	movzbl %al,%ebx
#include "cpu/exec/template-start.h"

#define instr xor

static void do_execute () {
	DATA_TYPE result = op_dest->val ^ op_src->val;
 8050613:	89 c6                	mov    %eax,%esi
	OPERAND_W(op_dest, result);
 8050615:	53                   	push   %ebx
 8050616:	68 40 ae 8f 14       	push   $0x148fae40
 805061b:	e8 20 c6 00 00       	call   805cc40 <write_operand_b>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 8050620:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
	cpu.ZF = !result;
 8050627:	89 f0                	mov    %esi,%eax
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 8050629:	89 f2                	mov    %esi,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 805062b:	80 25 e5 ae 8f 14 f7 	andb   $0xf7,0x148faee5
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 8050632:	83 e2 80             	and    $0xffffff80,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 8050635:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 805063c:	68 18 ae 8f 14       	push   $0x148fae18
 8050641:	68 79 15 06 08       	push   $0x8061579
 8050646:	6a 50                	push   $0x50
 8050648:	68 00 89 0c 08       	push   $0x80c8900
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 805064d:	83 e1 3e             	and    $0x3e,%ecx
	cpu.ZF = !result;
 8050650:	84 c0                	test   %al,%al
 8050652:	0f 94 c0             	sete   %al
 8050655:	09 ca                	or     %ecx,%edx
 8050657:	c1 e0 06             	shl    $0x6,%eax
 805065a:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805065c:	89 d8                	mov    %ebx,%eax
 805065e:	c1 e8 04             	shr    $0x4,%eax
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 8050661:	83 e2 fb             	and    $0xfffffffb,%edx
	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 8050664:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 2) ^ pf;
 8050666:	89 d8                	mov    %ebx,%eax
 8050668:	c1 e8 02             	shr    $0x2,%eax
 805066b:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 805066d:	89 d8                	mov    %ebx,%eax
 805066f:	d1 e8                	shr    %eax
 8050671:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 8050673:	83 e3 01             	and    $0x1,%ebx
 8050676:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 805067d:	89 d3                	mov    %edx,%ebx
 805067f:	09 c3                	or     %eax,%ebx
 8050681:	88 1d e4 ae 8f 14    	mov    %bl,0x148faee4

	print_asm_template2();
 8050687:	e8 74 84 ff ff       	call   8048b00 <snprintf@plt>
 805068c:	83 c4 20             	add    $0x20,%esp
 805068f:	83 f8 4f             	cmp    $0x4f,%eax
 8050692:	7f 0c                	jg     80506a0 <do_xor_b+0xa0>
}
 8050694:	83 c4 04             	add    $0x4,%esp
 8050697:	5b                   	pop    %ebx
 8050698:	5e                   	pop    %esi
 8050699:	c3                   	ret    
 805069a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 80506a0:	83 ec 0c             	sub    $0xc,%esp
 80506a3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80506a9:	e8 b2 82 ff ff       	call   8048960 <fflush@plt>
 80506ae:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80506b4:	6a 07                	push   $0x7
 80506b6:	6a 01                	push   $0x1
 80506b8:	68 92 ed 05 08       	push   $0x805ed92
 80506bd:	e8 4e 83 ff ff       	call   8048a10 <fwrite@plt>
 80506c2:	83 c4 20             	add    $0x20,%esp
 80506c5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80506cb:	6a 10                	push   $0x10
 80506cd:	6a 01                	push   $0x1
 80506cf:	68 84 f8 05 08       	push   $0x805f884
 80506d4:	e8 37 83 ff ff       	call   8048a10 <fwrite@plt>
 80506d9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80506df:	6a 05                	push   $0x5
 80506e1:	6a 01                	push   $0x1
 80506e3:	68 b1 ed 05 08       	push   $0x805edb1
 80506e8:	e8 23 83 ff ff       	call   8048a10 <fwrite@plt>
 80506ed:	83 c4 14             	add    $0x14,%esp
 80506f0:	68 50 ae 8f 14       	push   $0x148fae50
 80506f5:	68 18 ae 8f 14       	push   $0x148fae18
 80506fa:	68 79 15 06 08       	push   $0x8061579
 80506ff:	6a 50                	push   $0x50
 8050701:	68 00 89 0c 08       	push   $0x80c8900
 8050706:	e8 f5 83 ff ff       	call   8048b00 <snprintf@plt>
 805070b:	83 c4 20             	add    $0x20,%esp
 805070e:	83 f8 4f             	cmp    $0x4f,%eax
 8050711:	7e 81                	jle    8050694 <do_xor_b+0x94>
 8050713:	68 01 17 06 08       	push   $0x8061701
 8050718:	6a 13                	push   $0x13
 805071a:	68 9c 15 06 08       	push   $0x806159c
 805071f:	68 c4 15 06 08       	push   $0x80615c4
 8050724:	e8 87 84 ff ff       	call   8048bb0 <__assert_fail@plt>
 8050729:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08050730 <do_xor_w>:
#include "cpu/exec/template-start.h"

#define instr xor

static void do_execute () {
 8050730:	53                   	push   %ebx
 8050731:	83 ec 10             	sub    $0x10,%esp
	DATA_TYPE result = op_dest->val ^ op_src->val;
 8050734:	8b 1d 4c ae 8f 14    	mov    0x148fae4c,%ebx
 805073a:	66 33 1d 14 ae 8f 14 	xor    0x148fae14,%bx
	OPERAND_W(op_dest, result);
 8050741:	0f b7 c3             	movzwl %bx,%eax
 8050744:	50                   	push   %eax
 8050745:	68 40 ae 8f 14       	push   $0x148fae40
 805074a:	e8 81 c8 00 00       	call   805cfd0 <write_operand_w>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 805074f:	89 da                	mov    %ebx,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 8050751:	80 25 e5 ae 8f 14 f7 	andb   $0xf7,0x148faee5
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 8050758:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 805075f:	66 c1 ea 0f          	shr    $0xf,%dx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 8050763:	68 18 ae 8f 14       	push   $0x148fae18
 8050768:	68 84 15 06 08       	push   $0x8061584
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 805076d:	89 d0                	mov    %edx,%eax
 805076f:	0f b6 15 e4 ae 8f 14 	movzbl 0x148faee4,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 8050776:	6a 50                	push   $0x50
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 8050778:	c1 e0 07             	shl    $0x7,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 805077b:	68 00 89 0c 08       	push   $0x80c8900
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 8050780:	83 e2 3e             	and    $0x3e,%edx
	cpu.ZF = !result;
 8050783:	66 85 db             	test   %bx,%bx
	uint32_t pf = (result & 255);
 8050786:	0f b6 db             	movzbl %bl,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 8050789:	0f 94 c1             	sete   %cl
 805078c:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805078e:	89 d8                	mov    %ebx,%eax
 8050790:	c1 e8 04             	shr    $0x4,%eax
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 8050793:	c1 e1 06             	shl    $0x6,%ecx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 8050796:	31 c3                	xor    %eax,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 8050798:	09 ca                	or     %ecx,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 805079a:	89 d8                	mov    %ebx,%eax
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 805079c:	83 e2 fb             	and    $0xfffffffb,%edx
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 805079f:	c1 e8 02             	shr    $0x2,%eax
 80507a2:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 80507a4:	89 d8                	mov    %ebx,%eax
 80507a6:	d1 e8                	shr    %eax
 80507a8:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 80507aa:	83 e3 01             	and    $0x1,%ebx
 80507ad:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 80507b4:	89 d3                	mov    %edx,%ebx
 80507b6:	09 c3                	or     %eax,%ebx
 80507b8:	88 1d e4 ae 8f 14    	mov    %bl,0x148faee4

	print_asm_template2();
 80507be:	e8 3d 83 ff ff       	call   8048b00 <snprintf@plt>
 80507c3:	83 c4 20             	add    $0x20,%esp
 80507c6:	83 f8 4f             	cmp    $0x4f,%eax
 80507c9:	7f 05                	jg     80507d0 <do_xor_w+0xa0>
}
 80507cb:	83 c4 08             	add    $0x8,%esp
 80507ce:	5b                   	pop    %ebx
 80507cf:	c3                   	ret    
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 80507d0:	83 ec 0c             	sub    $0xc,%esp
 80507d3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80507d9:	e8 82 81 ff ff       	call   8048960 <fflush@plt>
 80507de:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80507e4:	6a 07                	push   $0x7
 80507e6:	6a 01                	push   $0x1
 80507e8:	68 92 ed 05 08       	push   $0x805ed92
 80507ed:	e8 1e 82 ff ff       	call   8048a10 <fwrite@plt>
 80507f2:	83 c4 20             	add    $0x20,%esp
 80507f5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80507fb:	6a 10                	push   $0x10
 80507fd:	6a 01                	push   $0x1
 80507ff:	68 84 f8 05 08       	push   $0x805f884
 8050804:	e8 07 82 ff ff       	call   8048a10 <fwrite@plt>
 8050809:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805080f:	6a 05                	push   $0x5
 8050811:	6a 01                	push   $0x1
 8050813:	68 b1 ed 05 08       	push   $0x805edb1
 8050818:	e8 f3 81 ff ff       	call   8048a10 <fwrite@plt>
 805081d:	83 c4 14             	add    $0x14,%esp
 8050820:	68 50 ae 8f 14       	push   $0x148fae50
 8050825:	68 18 ae 8f 14       	push   $0x148fae18
 805082a:	68 84 15 06 08       	push   $0x8061584
 805082f:	6a 50                	push   $0x50
 8050831:	68 00 89 0c 08       	push   $0x80c8900
 8050836:	e8 c5 82 ff ff       	call   8048b00 <snprintf@plt>
 805083b:	83 c4 20             	add    $0x20,%esp
 805083e:	83 f8 4f             	cmp    $0x4f,%eax
 8050841:	7e 88                	jle    80507cb <do_xor_w+0x9b>
 8050843:	68 f8 16 06 08       	push   $0x80616f8
 8050848:	6a 13                	push   $0x13
 805084a:	68 9c 15 06 08       	push   $0x806159c
 805084f:	68 28 16 06 08       	push   $0x8061628
 8050854:	e8 57 83 ff ff       	call   8048bb0 <__assert_fail@plt>
 8050859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08050860 <xor_i2a_w>:
}

make_instr_helper(i2a)
 8050860:	53                   	push   %ebx
 8050861:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050864:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050868:	83 c0 01             	add    $0x1,%eax
 805086b:	50                   	push   %eax
 805086c:	e8 1f c5 00 00       	call   805cd90 <decode_i2a_w>
 8050871:	89 c3                	mov    %eax,%ebx
	execute();
 8050873:	e8 b8 fe ff ff       	call   8050730 <do_xor_w>
 8050878:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805087b:	8d 43 01             	lea    0x1(%ebx),%eax
 805087e:	5b                   	pop    %ebx
 805087f:	c3                   	ret    

08050880 <xor_i2rm_w>:
make_instr_helper(i2rm)
 8050880:	53                   	push   %ebx
 8050881:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050884:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050888:	83 c0 01             	add    $0x1,%eax
 805088b:	50                   	push   %eax
 805088c:	e8 7f c5 00 00       	call   805ce10 <decode_i2rm_w>
 8050891:	89 c3                	mov    %eax,%ebx
	execute();
 8050893:	e8 98 fe ff ff       	call   8050730 <do_xor_w>
 8050898:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805089b:	8d 43 01             	lea    0x1(%ebx),%eax
 805089e:	5b                   	pop    %ebx
 805089f:	c3                   	ret    

080508a0 <xor_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 80508a0:	53                   	push   %ebx
 80508a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80508a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80508a8:	83 c0 01             	add    $0x1,%eax
 80508ab:	50                   	push   %eax
 80508ac:	e8 df c5 00 00       	call   805ce90 <decode_si2rm_w>
 80508b1:	89 c3                	mov    %eax,%ebx
	execute();
 80508b3:	e8 78 fe ff ff       	call   8050730 <do_xor_w>
 80508b8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80508bb:	8d 43 01             	lea    0x1(%ebx),%eax
 80508be:	5b                   	pop    %ebx
 80508bf:	c3                   	ret    

080508c0 <xor_r2rm_w>:
#endif
make_instr_helper(r2rm)
 80508c0:	53                   	push   %ebx
 80508c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80508c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80508c8:	83 c0 01             	add    $0x1,%eax
 80508cb:	50                   	push   %eax
 80508cc:	e8 7f c4 00 00       	call   805cd50 <decode_r2rm_w>
 80508d1:	89 c3                	mov    %eax,%ebx
	execute();
 80508d3:	e8 58 fe ff ff       	call   8050730 <do_xor_w>
 80508d8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80508db:	8d 43 01             	lea    0x1(%ebx),%eax
 80508de:	5b                   	pop    %ebx
 80508df:	c3                   	ret    

080508e0 <xor_rm2r_w>:
make_instr_helper(rm2r)
 80508e0:	53                   	push   %ebx
 80508e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80508e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80508e8:	83 c0 01             	add    $0x1,%eax
 80508eb:	50                   	push   %eax
 80508ec:	e8 7f c4 00 00       	call   805cd70 <decode_rm2r_w>
 80508f1:	89 c3                	mov    %eax,%ebx
	execute();
 80508f3:	e8 38 fe ff ff       	call   8050730 <do_xor_w>
 80508f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80508fb:	8d 43 01             	lea    0x1(%ebx),%eax
 80508fe:	5b                   	pop    %ebx
 80508ff:	c3                   	ret    

08050900 <do_xor_l>:
#include "cpu/exec/template-start.h"

#define instr xor

static void do_execute () {
 8050900:	53                   	push   %ebx
 8050901:	83 ec 10             	sub    $0x10,%esp
	DATA_TYPE result = op_dest->val ^ op_src->val;
 8050904:	8b 1d 14 ae 8f 14    	mov    0x148fae14,%ebx
 805090a:	33 1d 4c ae 8f 14    	xor    0x148fae4c,%ebx
	OPERAND_W(op_dest, result);
 8050910:	53                   	push   %ebx
 8050911:	68 40 ae 8f 14       	push   $0x148fae40
 8050916:	e8 85 ca 00 00       	call   805d3a0 <write_operand_l>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 805091b:	89 da                	mov    %ebx,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 805091d:	80 25 e5 ae 8f 14 f7 	andb   $0xf7,0x148faee5
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 8050924:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 805092b:	c1 ea 1f             	shr    $0x1f,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 805092e:	68 18 ae 8f 14       	push   $0x148fae18
 8050933:	68 8f 15 06 08       	push   $0x806158f
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 8050938:	89 d0                	mov    %edx,%eax
 805093a:	0f b6 15 e4 ae 8f 14 	movzbl 0x148faee4,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 8050941:	6a 50                	push   $0x50
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 8050943:	c1 e0 07             	shl    $0x7,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 8050946:	68 00 89 0c 08       	push   $0x80c8900
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 805094b:	83 e2 3e             	and    $0x3e,%edx
	cpu.ZF = !result;
 805094e:	85 db                	test   %ebx,%ebx
	uint32_t pf = (result & 255);
 8050950:	0f b6 db             	movzbl %bl,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 8050953:	0f 94 c1             	sete   %cl
 8050956:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 8050958:	89 d8                	mov    %ebx,%eax
 805095a:	c1 e8 04             	shr    $0x4,%eax
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 805095d:	c1 e1 06             	shl    $0x6,%ecx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 8050960:	31 c3                	xor    %eax,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 8050962:	09 ca                	or     %ecx,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 8050964:	89 d8                	mov    %ebx,%eax
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 8050966:	83 e2 fb             	and    $0xfffffffb,%edx
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 8050969:	c1 e8 02             	shr    $0x2,%eax
 805096c:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 805096e:	89 d8                	mov    %ebx,%eax
 8050970:	d1 e8                	shr    %eax
 8050972:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 8050974:	83 e3 01             	and    $0x1,%ebx
 8050977:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 805097e:	89 d3                	mov    %edx,%ebx
 8050980:	09 c3                	or     %eax,%ebx
 8050982:	88 1d e4 ae 8f 14    	mov    %bl,0x148faee4

	print_asm_template2();
 8050988:	e8 73 81 ff ff       	call   8048b00 <snprintf@plt>
 805098d:	83 c4 20             	add    $0x20,%esp
 8050990:	83 f8 4f             	cmp    $0x4f,%eax
 8050993:	7f 0b                	jg     80509a0 <do_xor_l+0xa0>
}
 8050995:	83 c4 08             	add    $0x8,%esp
 8050998:	5b                   	pop    %ebx
 8050999:	c3                   	ret    
 805099a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 80509a0:	83 ec 0c             	sub    $0xc,%esp
 80509a3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80509a9:	e8 b2 7f ff ff       	call   8048960 <fflush@plt>
 80509ae:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80509b4:	6a 07                	push   $0x7
 80509b6:	6a 01                	push   $0x1
 80509b8:	68 92 ed 05 08       	push   $0x805ed92
 80509bd:	e8 4e 80 ff ff       	call   8048a10 <fwrite@plt>
 80509c2:	83 c4 20             	add    $0x20,%esp
 80509c5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80509cb:	6a 10                	push   $0x10
 80509cd:	6a 01                	push   $0x1
 80509cf:	68 84 f8 05 08       	push   $0x805f884
 80509d4:	e8 37 80 ff ff       	call   8048a10 <fwrite@plt>
 80509d9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80509df:	6a 05                	push   $0x5
 80509e1:	6a 01                	push   $0x1
 80509e3:	68 b1 ed 05 08       	push   $0x805edb1
 80509e8:	e8 23 80 ff ff       	call   8048a10 <fwrite@plt>
 80509ed:	83 c4 14             	add    $0x14,%esp
 80509f0:	68 50 ae 8f 14       	push   $0x148fae50
 80509f5:	68 18 ae 8f 14       	push   $0x148fae18
 80509fa:	68 8f 15 06 08       	push   $0x806158f
 80509ff:	6a 50                	push   $0x50
 8050a01:	68 00 89 0c 08       	push   $0x80c8900
 8050a06:	e8 f5 80 ff ff       	call   8048b00 <snprintf@plt>
 8050a0b:	83 c4 20             	add    $0x20,%esp
 8050a0e:	83 f8 4f             	cmp    $0x4f,%eax
 8050a11:	7e 82                	jle    8050995 <do_xor_l+0x95>
 8050a13:	68 ef 16 06 08       	push   $0x80616ef
 8050a18:	6a 13                	push   $0x13
 8050a1a:	68 9c 15 06 08       	push   $0x806159c
 8050a1f:	68 8c 16 06 08       	push   $0x806168c
 8050a24:	e8 87 81 ff ff       	call   8048bb0 <__assert_fail@plt>
 8050a29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08050a30 <xor_i2a_l>:
}

make_instr_helper(i2a)
 8050a30:	53                   	push   %ebx
 8050a31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050a34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050a38:	83 c0 01             	add    $0x1,%eax
 8050a3b:	50                   	push   %eax
 8050a3c:	e8 1f c7 00 00       	call   805d160 <decode_i2a_l>
 8050a41:	89 c3                	mov    %eax,%ebx
	execute();
 8050a43:	e8 b8 fe ff ff       	call   8050900 <do_xor_l>
 8050a48:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050a4b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050a4e:	5b                   	pop    %ebx
 8050a4f:	c3                   	ret    

08050a50 <xor_i2rm_l>:
make_instr_helper(i2rm)
 8050a50:	53                   	push   %ebx
 8050a51:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050a54:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050a58:	83 c0 01             	add    $0x1,%eax
 8050a5b:	50                   	push   %eax
 8050a5c:	e8 7f c7 00 00       	call   805d1e0 <decode_i2rm_l>
 8050a61:	89 c3                	mov    %eax,%ebx
	execute();
 8050a63:	e8 98 fe ff ff       	call   8050900 <do_xor_l>
 8050a68:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050a6b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050a6e:	5b                   	pop    %ebx
 8050a6f:	c3                   	ret    

08050a70 <xor_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8050a70:	53                   	push   %ebx
 8050a71:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050a74:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050a78:	83 c0 01             	add    $0x1,%eax
 8050a7b:	50                   	push   %eax
 8050a7c:	e8 df c7 00 00       	call   805d260 <decode_si2rm_l>
 8050a81:	89 c3                	mov    %eax,%ebx
	execute();
 8050a83:	e8 78 fe ff ff       	call   8050900 <do_xor_l>
 8050a88:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050a8b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050a8e:	5b                   	pop    %ebx
 8050a8f:	c3                   	ret    

08050a90 <xor_r2rm_l>:
#endif
make_instr_helper(r2rm)
 8050a90:	53                   	push   %ebx
 8050a91:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050a94:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050a98:	83 c0 01             	add    $0x1,%eax
 8050a9b:	50                   	push   %eax
 8050a9c:	e8 7f c6 00 00       	call   805d120 <decode_r2rm_l>
 8050aa1:	89 c3                	mov    %eax,%ebx
	execute();
 8050aa3:	e8 58 fe ff ff       	call   8050900 <do_xor_l>
 8050aa8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050aab:	8d 43 01             	lea    0x1(%ebx),%eax
 8050aae:	5b                   	pop    %ebx
 8050aaf:	c3                   	ret    

08050ab0 <xor_rm2r_l>:
make_instr_helper(rm2r)
 8050ab0:	53                   	push   %ebx
 8050ab1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050ab4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050ab8:	83 c0 01             	add    $0x1,%eax
 8050abb:	50                   	push   %eax
 8050abc:	e8 7f c6 00 00       	call   805d140 <decode_rm2r_l>
 8050ac1:	89 c3                	mov    %eax,%ebx
	execute();
 8050ac3:	e8 38 fe ff ff       	call   8050900 <do_xor_l>
 8050ac8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050acb:	8d 43 01             	lea    0x1(%ebx),%eax
 8050ace:	5b                   	pop    %ebx
 8050acf:	c3                   	ret    

08050ad0 <xor_i2a_b>:
	cpu.PF = pf & 1;

	print_asm_template2();
}

make_instr_helper(i2a)
 8050ad0:	53                   	push   %ebx
 8050ad1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050ad4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050ad8:	83 c0 01             	add    $0x1,%eax
 8050adb:	50                   	push   %eax
 8050adc:	e8 7f bf 00 00       	call   805ca60 <decode_i2a_b>
 8050ae1:	89 c3                	mov    %eax,%ebx
	execute();
 8050ae3:	e8 18 fb ff ff       	call   8050600 <do_xor_b>
 8050ae8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050aeb:	8d 43 01             	lea    0x1(%ebx),%eax
 8050aee:	5b                   	pop    %ebx
 8050aef:	c3                   	ret    

08050af0 <xor_i2rm_b>:
make_instr_helper(i2rm)
 8050af0:	53                   	push   %ebx
 8050af1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050af4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050af8:	83 c0 01             	add    $0x1,%eax
 8050afb:	50                   	push   %eax
 8050afc:	e8 df bf 00 00       	call   805cae0 <decode_i2rm_b>
 8050b01:	89 c3                	mov    %eax,%ebx
	execute();
 8050b03:	e8 f8 fa ff ff       	call   8050600 <do_xor_b>
 8050b08:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050b0b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050b0e:	5b                   	pop    %ebx
 8050b0f:	c3                   	ret    

08050b10 <xor_r2rm_b>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
#endif
make_instr_helper(r2rm)
 8050b10:	53                   	push   %ebx
 8050b11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050b14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050b18:	83 c0 01             	add    $0x1,%eax
 8050b1b:	50                   	push   %eax
 8050b1c:	e8 ff be 00 00       	call   805ca20 <decode_r2rm_b>
 8050b21:	89 c3                	mov    %eax,%ebx
	execute();
 8050b23:	e8 d8 fa ff ff       	call   8050600 <do_xor_b>
 8050b28:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050b2b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050b2e:	5b                   	pop    %ebx
 8050b2f:	c3                   	ret    

08050b30 <xor_rm2r_b>:
make_instr_helper(rm2r)
 8050b30:	53                   	push   %ebx
 8050b31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050b34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050b38:	83 c0 01             	add    $0x1,%eax
 8050b3b:	50                   	push   %eax
 8050b3c:	e8 ff be 00 00       	call   805ca40 <decode_rm2r_b>
 8050b41:	89 c3                	mov    %eax,%ebx
	execute();
 8050b43:	e8 b8 fa ff ff       	call   8050600 <do_xor_b>
 8050b48:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050b4b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050b4e:	5b                   	pop    %ebx
 8050b4f:	c3                   	ret    

08050b50 <xor_i2a_v>:
#include "xor-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(xor_i2a)
 8050b50:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8050b57:	8b 54 24 04          	mov    0x4(%esp),%edx
 8050b5b:	b8 60 08 05 08       	mov    $0x8050860,%eax
 8050b60:	75 05                	jne    8050b67 <xor_i2a_v+0x17>
 8050b62:	b8 30 0a 05 08       	mov    $0x8050a30,%eax
 8050b67:	89 54 24 04          	mov    %edx,0x4(%esp)
 8050b6b:	ff e0                	jmp    *%eax
 8050b6d:	8d 76 00             	lea    0x0(%esi),%esi

08050b70 <xor_i2rm_v>:
make_helper_v(xor_i2rm)
 8050b70:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8050b77:	8b 54 24 04          	mov    0x4(%esp),%edx
 8050b7b:	b8 80 08 05 08       	mov    $0x8050880,%eax
 8050b80:	75 05                	jne    8050b87 <xor_i2rm_v+0x17>
 8050b82:	b8 50 0a 05 08       	mov    $0x8050a50,%eax
 8050b87:	89 54 24 04          	mov    %edx,0x4(%esp)
 8050b8b:	ff e0                	jmp    *%eax
 8050b8d:	8d 76 00             	lea    0x0(%esi),%esi

08050b90 <xor_si2rm_v>:
make_helper_v(xor_si2rm)
 8050b90:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8050b97:	8b 54 24 04          	mov    0x4(%esp),%edx
 8050b9b:	b8 a0 08 05 08       	mov    $0x80508a0,%eax
 8050ba0:	75 05                	jne    8050ba7 <xor_si2rm_v+0x17>
 8050ba2:	b8 70 0a 05 08       	mov    $0x8050a70,%eax
 8050ba7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8050bab:	ff e0                	jmp    *%eax
 8050bad:	8d 76 00             	lea    0x0(%esi),%esi

08050bb0 <xor_r2rm_v>:
make_helper_v(xor_r2rm)
 8050bb0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8050bb7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8050bbb:	b8 c0 08 05 08       	mov    $0x80508c0,%eax
 8050bc0:	75 05                	jne    8050bc7 <xor_r2rm_v+0x17>
 8050bc2:	b8 90 0a 05 08       	mov    $0x8050a90,%eax
 8050bc7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8050bcb:	ff e0                	jmp    *%eax
 8050bcd:	8d 76 00             	lea    0x0(%esi),%esi

08050bd0 <xor_rm2r_v>:
make_helper_v(xor_rm2r)
 8050bd0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8050bd7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8050bdb:	b8 e0 08 05 08       	mov    $0x80508e0,%eax
 8050be0:	75 05                	jne    8050be7 <xor_rm2r_v+0x17>
 8050be2:	b8 b0 0a 05 08       	mov    $0x8050ab0,%eax
 8050be7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8050beb:	ff e0                	jmp    *%eax
 8050bed:	66 90                	xchg   %ax,%ax
 8050bef:	90                   	nop

08050bf0 <rep>:
#include "cpu/exec/helper.h"

make_helper(exec);

make_helper(rep) {
 8050bf0:	57                   	push   %edi
 8050bf1:	56                   	push   %esi
 8050bf2:	53                   	push   %ebx
 8050bf3:	83 ec 58             	sub    $0x58,%esp
 8050bf6:	8b 7c 24 68          	mov    0x68(%esp),%edi

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 8050bfa:	6a 01                	push   $0x1
	int len;
	int count = 0;
	if(instr_fetch(eip + 1, 1) == 0xc3) {
 8050bfc:	8d 77 01             	lea    0x1(%edi),%esi
 8050bff:	56                   	push   %esi
 8050c00:	e8 5b a3 ff ff       	call   804af60 <swaddr_read>
 8050c05:	83 c4 10             	add    $0x10,%esp
 8050c08:	3d c3 00 00 00       	cmp    $0xc3,%eax
 8050c0d:	0f 84 d4 00 00 00    	je     8050ce7 <rep+0xf7>
 8050c13:	8b 15 c4 ae 8f 14    	mov    0x148faec4,%edx
 8050c19:	31 db                	xor    %ebx,%ebx
 8050c1b:	90                   	nop
 8050c1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		/* repz ret */
		exec(eip + 1);
		len = 0;
	}
	else {
		while(cpu.ecx) {
 8050c20:	85 d2                	test   %edx,%edx
 8050c22:	74 76                	je     8050c9a <rep+0xaa>
			exec(eip + 1);
 8050c24:	83 ec 0c             	sub    $0xc,%esp
		//	if(ops_decoded.opcode == 0) {
		//		return 2;
		//	}
		//	printf("eip = %u, opcode = %u\n", eip, ops_decoded.opcode);
			count ++;
 8050c27:	83 c3 01             	add    $0x1,%ebx
		exec(eip + 1);
		len = 0;
	}
	else {
		while(cpu.ecx) {
			exec(eip + 1);
 8050c2a:	56                   	push   %esi
 8050c2b:	e8 20 c4 ff ff       	call   804d050 <exec>
		//	if(ops_decoded.opcode == 0) {
		//		return 2;
		//	}
		//	printf("eip = %u, opcode = %u\n", eip, ops_decoded.opcode);
			count ++;
			cpu.ecx --;
 8050c30:	a1 c4 ae 8f 14       	mov    0x148faec4,%eax
			assert(ops_decoded.opcode == 0xa4	// movsb
 8050c35:	83 c4 10             	add    $0x10,%esp
		//	if(ops_decoded.opcode == 0) {
		//		return 2;
		//	}
		//	printf("eip = %u, opcode = %u\n", eip, ops_decoded.opcode);
			count ++;
			cpu.ecx --;
 8050c38:	8d 50 ff             	lea    -0x1(%eax),%edx
			assert(ops_decoded.opcode == 0xa4	// movsb
 8050c3b:	a1 00 ae 8f 14       	mov    0x148fae00,%eax
		//	if(ops_decoded.opcode == 0) {
		//		return 2;
		//	}
		//	printf("eip = %u, opcode = %u\n", eip, ops_decoded.opcode);
			count ++;
			cpu.ecx --;
 8050c40:	89 15 c4 ae 8f 14    	mov    %edx,0x148faec4
			assert(ops_decoded.opcode == 0xa4	// movsb
 8050c46:	89 c1                	mov    %eax,%ecx
 8050c48:	83 e1 fb             	and    $0xfffffffb,%ecx
 8050c4b:	81 e9 aa 00 00 00    	sub    $0xaa,%ecx
 8050c51:	83 f9 01             	cmp    $0x1,%ecx
 8050c54:	76 0f                	jbe    8050c65 <rep+0x75>
 8050c56:	8d 88 5c ff ff ff    	lea    -0xa4(%eax),%ecx
 8050c5c:	83 f9 03             	cmp    $0x3,%ecx
 8050c5f:	0f 87 97 00 00 00    	ja     8050cfc <rep+0x10c>
				);

			/* TODO: Jump out of the while loop if necessary. */
			if(ops_decoded.opcode == 0xa6		// cmpsb
				|| ops_decoded.opcode == 0xa7	// cmpsw
				|| ops_decoded.opcode == 0xae	// scasb
 8050c65:	83 e0 f7             	and    $0xfffffff7,%eax
 8050c68:	2d a6 00 00 00       	sub    $0xa6,%eax
				|| ops_decoded.opcode == 0xaf	// scasw
 8050c6d:	83 f8 01             	cmp    $0x1,%eax
 8050c70:	77 ae                	ja     8050c20 <rep+0x30>
			  ) {
				if(cpu.ZF) {
 8050c72:	f6 05 e4 ae 8f 14 40 	testb  $0x40,0x148faee4
 8050c79:	74 55                	je     8050cd0 <rep+0xe0>
 8050c7b:	83 ec 08             	sub    $0x8,%esp
 8050c7e:	6a 01                	push   $0x1
 8050c80:	57                   	push   %edi
 8050c81:	e8 da a2 ff ff       	call   804af60 <swaddr_read>
					if(instr_fetch(eip, 1) == 0xf3) break;
 8050c86:	83 c4 10             	add    $0x10,%esp
 8050c89:	3d f3 00 00 00       	cmp    $0xf3,%eax
 8050c8e:	74 0a                	je     8050c9a <rep+0xaa>
 8050c90:	8b 15 c4 ae 8f 14    	mov    0x148faec4,%edx
		/* repz ret */
		exec(eip + 1);
		len = 0;
	}
	else {
		while(cpu.ecx) {
 8050c96:	85 d2                	test   %edx,%edx
 8050c98:	75 8a                	jne    8050c24 <rep+0x34>
 8050c9a:	bf 02 00 00 00       	mov    $0x2,%edi
		len = 1;
	}

#ifdef DEBUG
	char temp[80];
	sprintf(temp, "rep %s", assembly);
 8050c9f:	83 ec 04             	sub    $0x4,%esp
 8050ca2:	68 00 89 0c 08       	push   $0x80c8900
 8050ca7:	68 19 18 06 08       	push   $0x8061819
 8050cac:	8d 74 24 0c          	lea    0xc(%esp),%esi
 8050cb0:	56                   	push   %esi
 8050cb1:	e8 da 7e ff ff       	call   8048b90 <sprintf@plt>
	sprintf(assembly, "%s[cnt = %d]", temp, count);
 8050cb6:	53                   	push   %ebx
 8050cb7:	56                   	push   %esi
 8050cb8:	68 20 18 06 08       	push   $0x8061820
 8050cbd:	68 00 89 0c 08       	push   $0x80c8900
 8050cc2:	e8 c9 7e ff ff       	call   8048b90 <sprintf@plt>
#endif
	
	return len + 1;
}
 8050cc7:	83 c4 70             	add    $0x70,%esp
 8050cca:	89 f8                	mov    %edi,%eax
 8050ccc:	5b                   	pop    %ebx
 8050ccd:	5e                   	pop    %esi
 8050cce:	5f                   	pop    %edi
 8050ccf:	c3                   	ret    
 8050cd0:	83 ec 08             	sub    $0x8,%esp
 8050cd3:	6a 01                	push   $0x1
 8050cd5:	57                   	push   %edi
 8050cd6:	e8 85 a2 ff ff       	call   804af60 <swaddr_read>
			  ) {
				if(cpu.ZF) {
					if(instr_fetch(eip, 1) == 0xf3) break;
				}
				else {
					if(instr_fetch(eip, 1) == 0xf2) break;
 8050cdb:	83 c4 10             	add    $0x10,%esp
 8050cde:	3d f2 00 00 00       	cmp    $0xf2,%eax
 8050ce3:	75 ab                	jne    8050c90 <rep+0xa0>
 8050ce5:	eb b3                	jmp    8050c9a <rep+0xaa>
make_helper(rep) {
	int len;
	int count = 0;
	if(instr_fetch(eip + 1, 1) == 0xc3) {
		/* repz ret */
		exec(eip + 1);
 8050ce7:	83 ec 0c             	sub    $0xc,%esp
 8050cea:	bf 01 00 00 00       	mov    $0x1,%edi

make_helper(exec);

make_helper(rep) {
	int len;
	int count = 0;
 8050cef:	31 db                	xor    %ebx,%ebx
	if(instr_fetch(eip + 1, 1) == 0xc3) {
		/* repz ret */
		exec(eip + 1);
 8050cf1:	56                   	push   %esi
 8050cf2:	e8 59 c3 ff ff       	call   804d050 <exec>
 8050cf7:	83 c4 10             	add    $0x10,%esp
 8050cfa:	eb a3                	jmp    8050c9f <rep+0xaf>
		//		return 2;
		//	}
		//	printf("eip = %u, opcode = %u\n", eip, ops_decoded.opcode);
			count ++;
			cpu.ecx --;
			assert(ops_decoded.opcode == 0xa4	// movsb
 8050cfc:	68 2d 18 06 08       	push   $0x806182d
 8050d01:	6a 1e                	push   $0x1e
 8050d03:	68 0c 17 06 08       	push   $0x806170c
 8050d08:	68 2c 17 06 08       	push   $0x806172c
 8050d0d:	e8 9e 7e ff ff       	call   8048bb0 <__assert_fail@plt>
 8050d12:	66 90                	xchg   %ax,%ax
 8050d14:	66 90                	xchg   %ax,%ax
 8050d16:	66 90                	xchg   %ax,%ax
 8050d18:	66 90                	xchg   %ax,%ax
 8050d1a:	66 90                	xchg   %ax,%ax
 8050d1c:	66 90                	xchg   %ax,%ax
 8050d1e:	66 90                	xchg   %ax,%ax

08050d20 <do_pop_b>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr pop

static void do_execute() {
 8050d20:	83 ec 14             	sub    $0x14,%esp
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
 8050d23:	6a 01                	push   $0x1
 8050d25:	ff 35 d0 ae 8f 14    	pushl  0x148faed0
 8050d2b:	e8 30 a2 ff ff       	call   804af60 <swaddr_read>
 8050d30:	5a                   	pop    %edx
 8050d31:	59                   	pop    %ecx
 8050d32:	0f b6 c0             	movzbl %al,%eax
 8050d35:	50                   	push   %eax
 8050d36:	68 08 ae 8f 14       	push   $0x148fae08
 8050d3b:	e8 00 bf 00 00       	call   805cc40 <write_operand_b>
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
	print_asm_template1();
 8050d40:	68 18 ae 8f 14       	push   $0x148fae18
 8050d45:	68 31 18 06 08       	push   $0x8061831
 8050d4a:	6a 50                	push   $0x50
 8050d4c:	68 00 89 0c 08       	push   $0x80c8900
#endif
#define instr pop

static void do_execute() {
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
 8050d51:	83 05 d0 ae 8f 14 01 	addl   $0x1,0x148faed0
	print_asm_template1();
 8050d58:	e8 a3 7d ff ff       	call   8048b00 <snprintf@plt>
 8050d5d:	83 c4 20             	add    $0x20,%esp
 8050d60:	83 f8 4f             	cmp    $0x4f,%eax
 8050d63:	7f 0b                	jg     8050d70 <do_pop_b+0x50>
}
 8050d65:	83 c4 0c             	add    $0xc,%esp
 8050d68:	c3                   	ret    
 8050d69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#define instr pop

static void do_execute() {
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
	print_asm_template1();
 8050d70:	83 ec 0c             	sub    $0xc,%esp
 8050d73:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8050d79:	e8 e2 7b ff ff       	call   8048960 <fflush@plt>
 8050d7e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8050d84:	6a 07                	push   $0x7
 8050d86:	6a 01                	push   $0x1
 8050d88:	68 92 ed 05 08       	push   $0x805ed92
 8050d8d:	e8 7e 7c ff ff       	call   8048a10 <fwrite@plt>
 8050d92:	83 c4 20             	add    $0x20,%esp
 8050d95:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8050d9b:	6a 10                	push   $0x10
 8050d9d:	6a 01                	push   $0x1
 8050d9f:	68 84 f8 05 08       	push   $0x805f884
 8050da4:	e8 67 7c ff ff       	call   8048a10 <fwrite@plt>
 8050da9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8050daf:	6a 05                	push   $0x5
 8050db1:	6a 01                	push   $0x1
 8050db3:	68 b1 ed 05 08       	push   $0x805edb1
 8050db8:	e8 53 7c ff ff       	call   8048a10 <fwrite@plt>
 8050dbd:	83 c4 20             	add    $0x20,%esp
 8050dc0:	68 18 ae 8f 14       	push   $0x148fae18
 8050dc5:	68 31 18 06 08       	push   $0x8061831
 8050dca:	6a 50                	push   $0x50
 8050dcc:	68 00 89 0c 08       	push   $0x80c8900
 8050dd1:	e8 2a 7d ff ff       	call   8048b00 <snprintf@plt>
 8050dd6:	83 c4 10             	add    $0x10,%esp
 8050dd9:	83 f8 4f             	cmp    $0x4f,%eax
 8050ddc:	7e 87                	jle    8050d65 <do_pop_b+0x45>
 8050dde:	68 5c 19 06 08       	push   $0x806195c
 8050de3:	6a 0f                	push   $0xf
 8050de5:	68 4c 18 06 08       	push   $0x806184c
 8050dea:	68 74 18 06 08       	push   $0x8061874
 8050def:	e8 bc 7d ff ff       	call   8048bb0 <__assert_fail@plt>
 8050df4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8050dfa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08050e00 <do_pop_w>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr pop

static void do_execute() {
 8050e00:	83 ec 14             	sub    $0x14,%esp
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
 8050e03:	6a 02                	push   $0x2
 8050e05:	ff 35 d0 ae 8f 14    	pushl  0x148faed0
 8050e0b:	e8 50 a1 ff ff       	call   804af60 <swaddr_read>
 8050e10:	5a                   	pop    %edx
 8050e11:	59                   	pop    %ecx
 8050e12:	0f b7 c0             	movzwl %ax,%eax
 8050e15:	50                   	push   %eax
 8050e16:	68 08 ae 8f 14       	push   $0x148fae08
 8050e1b:	e8 b0 c1 00 00       	call   805cfd0 <write_operand_w>
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
	print_asm_template1();
 8050e20:	68 18 ae 8f 14       	push   $0x148fae18
 8050e25:	68 39 18 06 08       	push   $0x8061839
 8050e2a:	6a 50                	push   $0x50
 8050e2c:	68 00 89 0c 08       	push   $0x80c8900
#endif
#define instr pop

static void do_execute() {
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
 8050e31:	83 05 d0 ae 8f 14 02 	addl   $0x2,0x148faed0
	print_asm_template1();
 8050e38:	e8 c3 7c ff ff       	call   8048b00 <snprintf@plt>
 8050e3d:	83 c4 20             	add    $0x20,%esp
 8050e40:	83 f8 4f             	cmp    $0x4f,%eax
 8050e43:	7f 0b                	jg     8050e50 <do_pop_w+0x50>
}
 8050e45:	83 c4 0c             	add    $0xc,%esp
 8050e48:	c3                   	ret    
 8050e49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#define instr pop

static void do_execute() {
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
	print_asm_template1();
 8050e50:	83 ec 0c             	sub    $0xc,%esp
 8050e53:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8050e59:	e8 02 7b ff ff       	call   8048960 <fflush@plt>
 8050e5e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8050e64:	6a 07                	push   $0x7
 8050e66:	6a 01                	push   $0x1
 8050e68:	68 92 ed 05 08       	push   $0x805ed92
 8050e6d:	e8 9e 7b ff ff       	call   8048a10 <fwrite@plt>
 8050e72:	83 c4 20             	add    $0x20,%esp
 8050e75:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8050e7b:	6a 10                	push   $0x10
 8050e7d:	6a 01                	push   $0x1
 8050e7f:	68 84 f8 05 08       	push   $0x805f884
 8050e84:	e8 87 7b ff ff       	call   8048a10 <fwrite@plt>
 8050e89:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8050e8f:	6a 05                	push   $0x5
 8050e91:	6a 01                	push   $0x1
 8050e93:	68 b1 ed 05 08       	push   $0x805edb1
 8050e98:	e8 73 7b ff ff       	call   8048a10 <fwrite@plt>
 8050e9d:	83 c4 20             	add    $0x20,%esp
 8050ea0:	68 18 ae 8f 14       	push   $0x148fae18
 8050ea5:	68 39 18 06 08       	push   $0x8061839
 8050eaa:	6a 50                	push   $0x50
 8050eac:	68 00 89 0c 08       	push   $0x80c8900
 8050eb1:	e8 4a 7c ff ff       	call   8048b00 <snprintf@plt>
 8050eb6:	83 c4 10             	add    $0x10,%esp
 8050eb9:	83 f8 4f             	cmp    $0x4f,%eax
 8050ebc:	7e 87                	jle    8050e45 <do_pop_w+0x45>
 8050ebe:	68 53 19 06 08       	push   $0x8061953
 8050ec3:	6a 0f                	push   $0xf
 8050ec5:	68 4c 18 06 08       	push   $0x806184c
 8050eca:	68 bc 18 06 08       	push   $0x80618bc
 8050ecf:	e8 dc 7c ff ff       	call   8048bb0 <__assert_fail@plt>
 8050ed4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8050eda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08050ee0 <pop_r_w>:
}

make_instr_helper(r)
 8050ee0:	53                   	push   %ebx
 8050ee1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050ee4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050ee8:	83 c0 01             	add    $0x1,%eax
 8050eeb:	50                   	push   %eax
 8050eec:	e8 8f bf 00 00       	call   805ce80 <decode_r_w>
 8050ef1:	89 c3                	mov    %eax,%ebx
	execute();
 8050ef3:	e8 08 ff ff ff       	call   8050e00 <do_pop_w>
 8050ef8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050efb:	8d 43 01             	lea    0x1(%ebx),%eax
 8050efe:	5b                   	pop    %ebx
 8050eff:	c3                   	ret    

08050f00 <pop_m_w>:
make_instr_helper(m)
 8050f00:	53                   	push   %ebx
 8050f01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050f04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050f08:	83 c0 01             	add    $0x1,%eax
 8050f0b:	50                   	push   %eax
 8050f0c:	e8 2f be 00 00       	call   805cd40 <decode_m_w>
 8050f11:	89 c3                	mov    %eax,%ebx
	execute();
 8050f13:	e8 e8 fe ff ff       	call   8050e00 <do_pop_w>
 8050f18:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050f1b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050f1e:	5b                   	pop    %ebx
 8050f1f:	c3                   	ret    

08050f20 <do_pop_l>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr pop

static void do_execute() {
 8050f20:	83 ec 14             	sub    $0x14,%esp
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
 8050f23:	6a 04                	push   $0x4
 8050f25:	ff 35 d0 ae 8f 14    	pushl  0x148faed0
 8050f2b:	e8 30 a0 ff ff       	call   804af60 <swaddr_read>
 8050f30:	5a                   	pop    %edx
 8050f31:	59                   	pop    %ecx
 8050f32:	50                   	push   %eax
 8050f33:	68 08 ae 8f 14       	push   $0x148fae08
 8050f38:	e8 63 c4 00 00       	call   805d3a0 <write_operand_l>
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
	print_asm_template1();
 8050f3d:	68 18 ae 8f 14       	push   $0x148fae18
 8050f42:	68 41 18 06 08       	push   $0x8061841
 8050f47:	6a 50                	push   $0x50
 8050f49:	68 00 89 0c 08       	push   $0x80c8900
#endif
#define instr pop

static void do_execute() {
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
 8050f4e:	83 05 d0 ae 8f 14 04 	addl   $0x4,0x148faed0
	print_asm_template1();
 8050f55:	e8 a6 7b ff ff       	call   8048b00 <snprintf@plt>
 8050f5a:	83 c4 20             	add    $0x20,%esp
 8050f5d:	83 f8 4f             	cmp    $0x4f,%eax
 8050f60:	7f 0e                	jg     8050f70 <do_pop_l+0x50>
}
 8050f62:	83 c4 0c             	add    $0xc,%esp
 8050f65:	c3                   	ret    
 8050f66:	8d 76 00             	lea    0x0(%esi),%esi
 8050f69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#define instr pop

static void do_execute() {
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
	print_asm_template1();
 8050f70:	83 ec 0c             	sub    $0xc,%esp
 8050f73:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8050f79:	e8 e2 79 ff ff       	call   8048960 <fflush@plt>
 8050f7e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8050f84:	6a 07                	push   $0x7
 8050f86:	6a 01                	push   $0x1
 8050f88:	68 92 ed 05 08       	push   $0x805ed92
 8050f8d:	e8 7e 7a ff ff       	call   8048a10 <fwrite@plt>
 8050f92:	83 c4 20             	add    $0x20,%esp
 8050f95:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8050f9b:	6a 10                	push   $0x10
 8050f9d:	6a 01                	push   $0x1
 8050f9f:	68 84 f8 05 08       	push   $0x805f884
 8050fa4:	e8 67 7a ff ff       	call   8048a10 <fwrite@plt>
 8050fa9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8050faf:	6a 05                	push   $0x5
 8050fb1:	6a 01                	push   $0x1
 8050fb3:	68 b1 ed 05 08       	push   $0x805edb1
 8050fb8:	e8 53 7a ff ff       	call   8048a10 <fwrite@plt>
 8050fbd:	83 c4 20             	add    $0x20,%esp
 8050fc0:	68 18 ae 8f 14       	push   $0x148fae18
 8050fc5:	68 41 18 06 08       	push   $0x8061841
 8050fca:	6a 50                	push   $0x50
 8050fcc:	68 00 89 0c 08       	push   $0x80c8900
 8050fd1:	e8 2a 7b ff ff       	call   8048b00 <snprintf@plt>
 8050fd6:	83 c4 10             	add    $0x10,%esp
 8050fd9:	83 f8 4f             	cmp    $0x4f,%eax
 8050fdc:	7e 84                	jle    8050f62 <do_pop_l+0x42>
 8050fde:	68 4a 19 06 08       	push   $0x806194a
 8050fe3:	6a 0f                	push   $0xf
 8050fe5:	68 4c 18 06 08       	push   $0x806184c
 8050fea:	68 04 19 06 08       	push   $0x8061904
 8050fef:	e8 bc 7b ff ff       	call   8048bb0 <__assert_fail@plt>
 8050ff4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8050ffa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08051000 <pop_r_l>:
}

make_instr_helper(r)
 8051000:	53                   	push   %ebx
 8051001:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051004:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051008:	83 c0 01             	add    $0x1,%eax
 805100b:	50                   	push   %eax
 805100c:	e8 3f c2 00 00       	call   805d250 <decode_r_l>
 8051011:	89 c3                	mov    %eax,%ebx
	execute();
 8051013:	e8 08 ff ff ff       	call   8050f20 <do_pop_l>
 8051018:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805101b:	8d 43 01             	lea    0x1(%ebx),%eax
 805101e:	5b                   	pop    %ebx
 805101f:	c3                   	ret    

08051020 <pop_m_l>:
make_instr_helper(m)
 8051020:	53                   	push   %ebx
 8051021:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051024:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051028:	83 c0 01             	add    $0x1,%eax
 805102b:	50                   	push   %eax
 805102c:	e8 df c0 00 00       	call   805d110 <decode_m_l>
 8051031:	89 c3                	mov    %eax,%ebx
	execute();
 8051033:	e8 e8 fe ff ff       	call   8050f20 <do_pop_l>
 8051038:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805103b:	8d 43 01             	lea    0x1(%ebx),%eax
 805103e:	5b                   	pop    %ebx
 805103f:	c3                   	ret    

08051040 <pop_r_b>:
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
	print_asm_template1();
}

make_instr_helper(r)
 8051040:	53                   	push   %ebx
 8051041:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051044:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051048:	83 c0 01             	add    $0x1,%eax
 805104b:	50                   	push   %eax
 805104c:	e8 ff ba 00 00       	call   805cb50 <decode_r_b>
 8051051:	89 c3                	mov    %eax,%ebx
	execute();
 8051053:	e8 c8 fc ff ff       	call   8050d20 <do_pop_b>
 8051058:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805105b:	8d 43 01             	lea    0x1(%ebx),%eax
 805105e:	5b                   	pop    %ebx
 805105f:	c3                   	ret    

08051060 <pop_m_b>:
make_instr_helper(m)
 8051060:	53                   	push   %ebx
 8051061:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051064:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051068:	83 c0 01             	add    $0x1,%eax
 805106b:	50                   	push   %eax
 805106c:	e8 9f b9 00 00       	call   805ca10 <decode_m_b>
 8051071:	89 c3                	mov    %eax,%ebx
	execute();
 8051073:	e8 a8 fc ff ff       	call   8050d20 <do_pop_b>
 8051078:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805107b:	8d 43 01             	lea    0x1(%ebx),%eax
 805107e:	5b                   	pop    %ebx
 805107f:	c3                   	ret    

08051080 <pop_r_v>:
#include "pop-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(pop_r)
 8051080:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8051087:	8b 54 24 04          	mov    0x4(%esp),%edx
 805108b:	b8 e0 0e 05 08       	mov    $0x8050ee0,%eax
 8051090:	75 05                	jne    8051097 <pop_r_v+0x17>
 8051092:	b8 00 10 05 08       	mov    $0x8051000,%eax
 8051097:	89 54 24 04          	mov    %edx,0x4(%esp)
 805109b:	ff e0                	jmp    *%eax
 805109d:	8d 76 00             	lea    0x0(%esi),%esi

080510a0 <pop_m_v>:
make_helper_v(pop_m)
 80510a0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80510a7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80510ab:	b8 00 0f 05 08       	mov    $0x8050f00,%eax
 80510b0:	75 05                	jne    80510b7 <pop_m_v+0x17>
 80510b2:	b8 20 10 05 08       	mov    $0x8051020,%eax
 80510b7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80510bb:	ff e0                	jmp    *%eax
 80510bd:	66 90                	xchg   %ax,%ax
 80510bf:	90                   	nop

080510c0 <do_push_b>:
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
 80510c0:	83 ec 10             	sub    $0x10,%esp
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 80510c3:	a1 d0 ae 8f 14       	mov    0x148faed0,%eax
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 80510c8:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 80510ce:	6a 04                	push   $0x4
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 80510d0:	83 e8 04             	sub    $0x4,%eax
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 80510d3:	50                   	push   %eax
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 80510d4:	a3 d0 ae 8f 14       	mov    %eax,0x148faed0
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 80510d9:	e8 d2 9e ff ff       	call   804afb0 <swaddr_write>
	print_asm_template1();
 80510de:	68 18 ae 8f 14       	push   $0x148fae18
 80510e3:	68 65 19 06 08       	push   $0x8061965
 80510e8:	6a 50                	push   $0x50
 80510ea:	68 00 89 0c 08       	push   $0x80c8900
 80510ef:	e8 0c 7a ff ff       	call   8048b00 <snprintf@plt>
 80510f4:	83 c4 20             	add    $0x20,%esp
 80510f7:	83 f8 4f             	cmp    $0x4f,%eax
 80510fa:	7f 04                	jg     8051100 <do_push_b+0x40>
}
 80510fc:	83 c4 0c             	add    $0xc,%esp
 80510ff:	c3                   	ret    
#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
	print_asm_template1();
 8051100:	83 ec 0c             	sub    $0xc,%esp
 8051103:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8051109:	e8 52 78 ff ff       	call   8048960 <fflush@plt>
 805110e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051114:	6a 07                	push   $0x7
 8051116:	6a 01                	push   $0x1
 8051118:	68 92 ed 05 08       	push   $0x805ed92
 805111d:	e8 ee 78 ff ff       	call   8048a10 <fwrite@plt>
 8051122:	83 c4 20             	add    $0x20,%esp
 8051125:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805112b:	6a 10                	push   $0x10
 805112d:	6a 01                	push   $0x1
 805112f:	68 84 f8 05 08       	push   $0x805f884
 8051134:	e8 d7 78 ff ff       	call   8048a10 <fwrite@plt>
 8051139:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805113f:	6a 05                	push   $0x5
 8051141:	6a 01                	push   $0x1
 8051143:	68 b1 ed 05 08       	push   $0x805edb1
 8051148:	e8 c3 78 ff ff       	call   8048a10 <fwrite@plt>
 805114d:	83 c4 20             	add    $0x20,%esp
 8051150:	68 18 ae 8f 14       	push   $0x148fae18
 8051155:	68 65 19 06 08       	push   $0x8061965
 805115a:	6a 50                	push   $0x50
 805115c:	68 00 89 0c 08       	push   $0x80c8900
 8051161:	e8 9a 79 ff ff       	call   8048b00 <snprintf@plt>
 8051166:	83 c4 10             	add    $0x10,%esp
 8051169:	83 f8 4f             	cmp    $0x4f,%eax
 805116c:	7e 8e                	jle    80510fc <do_push_b+0x3c>
 805116e:	68 93 1a 06 08       	push   $0x8061a93
 8051173:	6a 08                	push   $0x8
 8051175:	68 80 19 06 08       	push   $0x8061980
 805117a:	68 a8 19 06 08       	push   $0x80619a8
 805117f:	e8 2c 7a ff ff       	call   8048bb0 <__assert_fail@plt>
 8051184:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805118a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08051190 <do_push_w>:
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
 8051190:	83 ec 10             	sub    $0x10,%esp
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 8051193:	a1 d0 ae 8f 14       	mov    0x148faed0,%eax
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 8051198:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 805119e:	6a 02                	push   $0x2
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 80511a0:	83 e8 02             	sub    $0x2,%eax
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 80511a3:	50                   	push   %eax
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 80511a4:	a3 d0 ae 8f 14       	mov    %eax,0x148faed0
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 80511a9:	e8 02 9e ff ff       	call   804afb0 <swaddr_write>
	print_asm_template1();
 80511ae:	68 18 ae 8f 14       	push   $0x148fae18
 80511b3:	68 6e 19 06 08       	push   $0x806196e
 80511b8:	6a 50                	push   $0x50
 80511ba:	68 00 89 0c 08       	push   $0x80c8900
 80511bf:	e8 3c 79 ff ff       	call   8048b00 <snprintf@plt>
 80511c4:	83 c4 20             	add    $0x20,%esp
 80511c7:	83 f8 4f             	cmp    $0x4f,%eax
 80511ca:	7f 04                	jg     80511d0 <do_push_w+0x40>
}
 80511cc:	83 c4 0c             	add    $0xc,%esp
 80511cf:	c3                   	ret    
#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
	print_asm_template1();
 80511d0:	83 ec 0c             	sub    $0xc,%esp
 80511d3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80511d9:	e8 82 77 ff ff       	call   8048960 <fflush@plt>
 80511de:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80511e4:	6a 07                	push   $0x7
 80511e6:	6a 01                	push   $0x1
 80511e8:	68 92 ed 05 08       	push   $0x805ed92
 80511ed:	e8 1e 78 ff ff       	call   8048a10 <fwrite@plt>
 80511f2:	83 c4 20             	add    $0x20,%esp
 80511f5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80511fb:	6a 10                	push   $0x10
 80511fd:	6a 01                	push   $0x1
 80511ff:	68 84 f8 05 08       	push   $0x805f884
 8051204:	e8 07 78 ff ff       	call   8048a10 <fwrite@plt>
 8051209:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805120f:	6a 05                	push   $0x5
 8051211:	6a 01                	push   $0x1
 8051213:	68 b1 ed 05 08       	push   $0x805edb1
 8051218:	e8 f3 77 ff ff       	call   8048a10 <fwrite@plt>
 805121d:	83 c4 20             	add    $0x20,%esp
 8051220:	68 18 ae 8f 14       	push   $0x148fae18
 8051225:	68 6e 19 06 08       	push   $0x806196e
 805122a:	6a 50                	push   $0x50
 805122c:	68 00 89 0c 08       	push   $0x80c8900
 8051231:	e8 ca 78 ff ff       	call   8048b00 <snprintf@plt>
 8051236:	83 c4 10             	add    $0x10,%esp
 8051239:	83 f8 4f             	cmp    $0x4f,%eax
 805123c:	7e 8e                	jle    80511cc <do_push_w+0x3c>
 805123e:	68 89 1a 06 08       	push   $0x8061a89
 8051243:	6a 08                	push   $0x8
 8051245:	68 80 19 06 08       	push   $0x8061980
 805124a:	68 f0 19 06 08       	push   $0x80619f0
 805124f:	e8 5c 79 ff ff       	call   8048bb0 <__assert_fail@plt>
 8051254:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805125a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08051260 <push_i_w>:
}

make_instr_helper(i)
 8051260:	53                   	push   %ebx
 8051261:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051264:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051268:	83 c0 01             	add    $0x1,%eax
 805126b:	50                   	push   %eax
 805126c:	e8 3f ba 00 00       	call   805ccb0 <decode_i_w>
 8051271:	89 c3                	mov    %eax,%ebx
	execute();
 8051273:	e8 18 ff ff ff       	call   8051190 <do_push_w>
 8051278:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805127b:	8d 43 01             	lea    0x1(%ebx),%eax
 805127e:	5b                   	pop    %ebx
 805127f:	c3                   	ret    

08051280 <push_r_w>:
make_instr_helper(r)
 8051280:	53                   	push   %ebx
 8051281:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051284:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051288:	83 c0 01             	add    $0x1,%eax
 805128b:	50                   	push   %eax
 805128c:	e8 ef bb 00 00       	call   805ce80 <decode_r_w>
 8051291:	89 c3                	mov    %eax,%ebx
	execute();
 8051293:	e8 f8 fe ff ff       	call   8051190 <do_push_w>
 8051298:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805129b:	8d 43 01             	lea    0x1(%ebx),%eax
 805129e:	5b                   	pop    %ebx
 805129f:	c3                   	ret    

080512a0 <push_rm_w>:
make_instr_helper(rm)
 80512a0:	53                   	push   %ebx
 80512a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80512a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80512a8:	83 c0 01             	add    $0x1,%eax
 80512ab:	50                   	push   %eax
 80512ac:	e8 af bb 00 00       	call   805ce60 <decode_rm_w>
 80512b1:	89 c3                	mov    %eax,%ebx
	execute();
 80512b3:	e8 d8 fe ff ff       	call   8051190 <do_push_w>
 80512b8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80512bb:	8d 43 01             	lea    0x1(%ebx),%eax
 80512be:	5b                   	pop    %ebx
 80512bf:	c3                   	ret    

080512c0 <do_push_l>:
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
 80512c0:	83 ec 10             	sub    $0x10,%esp
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 80512c3:	a1 d0 ae 8f 14       	mov    0x148faed0,%eax
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 80512c8:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 80512ce:	6a 04                	push   $0x4
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 80512d0:	83 e8 04             	sub    $0x4,%eax
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 80512d3:	50                   	push   %eax
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 80512d4:	a3 d0 ae 8f 14       	mov    %eax,0x148faed0
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 80512d9:	e8 d2 9c ff ff       	call   804afb0 <swaddr_write>
	print_asm_template1();
 80512de:	68 18 ae 8f 14       	push   $0x148fae18
 80512e3:	68 77 19 06 08       	push   $0x8061977
 80512e8:	6a 50                	push   $0x50
 80512ea:	68 00 89 0c 08       	push   $0x80c8900
 80512ef:	e8 0c 78 ff ff       	call   8048b00 <snprintf@plt>
 80512f4:	83 c4 20             	add    $0x20,%esp
 80512f7:	83 f8 4f             	cmp    $0x4f,%eax
 80512fa:	7f 04                	jg     8051300 <do_push_l+0x40>
}
 80512fc:	83 c4 0c             	add    $0xc,%esp
 80512ff:	c3                   	ret    
#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
	print_asm_template1();
 8051300:	83 ec 0c             	sub    $0xc,%esp
 8051303:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8051309:	e8 52 76 ff ff       	call   8048960 <fflush@plt>
 805130e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051314:	6a 07                	push   $0x7
 8051316:	6a 01                	push   $0x1
 8051318:	68 92 ed 05 08       	push   $0x805ed92
 805131d:	e8 ee 76 ff ff       	call   8048a10 <fwrite@plt>
 8051322:	83 c4 20             	add    $0x20,%esp
 8051325:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805132b:	6a 10                	push   $0x10
 805132d:	6a 01                	push   $0x1
 805132f:	68 84 f8 05 08       	push   $0x805f884
 8051334:	e8 d7 76 ff ff       	call   8048a10 <fwrite@plt>
 8051339:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805133f:	6a 05                	push   $0x5
 8051341:	6a 01                	push   $0x1
 8051343:	68 b1 ed 05 08       	push   $0x805edb1
 8051348:	e8 c3 76 ff ff       	call   8048a10 <fwrite@plt>
 805134d:	83 c4 20             	add    $0x20,%esp
 8051350:	68 18 ae 8f 14       	push   $0x148fae18
 8051355:	68 77 19 06 08       	push   $0x8061977
 805135a:	6a 50                	push   $0x50
 805135c:	68 00 89 0c 08       	push   $0x80c8900
 8051361:	e8 9a 77 ff ff       	call   8048b00 <snprintf@plt>
 8051366:	83 c4 10             	add    $0x10,%esp
 8051369:	83 f8 4f             	cmp    $0x4f,%eax
 805136c:	7e 8e                	jle    80512fc <do_push_l+0x3c>
 805136e:	68 7f 1a 06 08       	push   $0x8061a7f
 8051373:	6a 08                	push   $0x8
 8051375:	68 80 19 06 08       	push   $0x8061980
 805137a:	68 38 1a 06 08       	push   $0x8061a38
 805137f:	e8 2c 78 ff ff       	call   8048bb0 <__assert_fail@plt>
 8051384:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805138a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08051390 <push_i_l>:
}

make_instr_helper(i)
 8051390:	53                   	push   %ebx
 8051391:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051394:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051398:	83 c0 01             	add    $0x1,%eax
 805139b:	50                   	push   %eax
 805139c:	e8 9f bc 00 00       	call   805d040 <decode_i_l>
 80513a1:	89 c3                	mov    %eax,%ebx
	execute();
 80513a3:	e8 18 ff ff ff       	call   80512c0 <do_push_l>
 80513a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80513ab:	8d 43 01             	lea    0x1(%ebx),%eax
 80513ae:	5b                   	pop    %ebx
 80513af:	c3                   	ret    

080513b0 <push_r_l>:
make_instr_helper(r)
 80513b0:	53                   	push   %ebx
 80513b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80513b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80513b8:	83 c0 01             	add    $0x1,%eax
 80513bb:	50                   	push   %eax
 80513bc:	e8 8f be 00 00       	call   805d250 <decode_r_l>
 80513c1:	89 c3                	mov    %eax,%ebx
	execute();
 80513c3:	e8 f8 fe ff ff       	call   80512c0 <do_push_l>
 80513c8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80513cb:	8d 43 01             	lea    0x1(%ebx),%eax
 80513ce:	5b                   	pop    %ebx
 80513cf:	c3                   	ret    

080513d0 <push_rm_l>:
make_instr_helper(rm)
 80513d0:	53                   	push   %ebx
 80513d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80513d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80513d8:	83 c0 01             	add    $0x1,%eax
 80513db:	50                   	push   %eax
 80513dc:	e8 4f be 00 00       	call   805d230 <decode_rm_l>
 80513e1:	89 c3                	mov    %eax,%ebx
	execute();
 80513e3:	e8 d8 fe ff ff       	call   80512c0 <do_push_l>
 80513e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80513eb:	8d 43 01             	lea    0x1(%ebx),%eax
 80513ee:	5b                   	pop    %ebx
 80513ef:	c3                   	ret    

080513f0 <push_i_b>:
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
	print_asm_template1();
}

make_instr_helper(i)
 80513f0:	53                   	push   %ebx
 80513f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80513f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80513f8:	83 c0 01             	add    $0x1,%eax
 80513fb:	50                   	push   %eax
 80513fc:	e8 3f b5 00 00       	call   805c940 <decode_i_b>
 8051401:	89 c3                	mov    %eax,%ebx
	execute();
 8051403:	e8 b8 fc ff ff       	call   80510c0 <do_push_b>
 8051408:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805140b:	8d 43 01             	lea    0x1(%ebx),%eax
 805140e:	5b                   	pop    %ebx
 805140f:	c3                   	ret    

08051410 <push_r_b>:
make_instr_helper(r)
 8051410:	53                   	push   %ebx
 8051411:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051414:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051418:	83 c0 01             	add    $0x1,%eax
 805141b:	50                   	push   %eax
 805141c:	e8 2f b7 00 00       	call   805cb50 <decode_r_b>
 8051421:	89 c3                	mov    %eax,%ebx
	execute();
 8051423:	e8 98 fc ff ff       	call   80510c0 <do_push_b>
 8051428:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805142b:	8d 43 01             	lea    0x1(%ebx),%eax
 805142e:	5b                   	pop    %ebx
 805142f:	c3                   	ret    

08051430 <push_rm_b>:
make_instr_helper(rm)
 8051430:	53                   	push   %ebx
 8051431:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051434:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051438:	83 c0 01             	add    $0x1,%eax
 805143b:	50                   	push   %eax
 805143c:	e8 ef b6 00 00       	call   805cb30 <decode_rm_b>
 8051441:	89 c3                	mov    %eax,%ebx
	execute();
 8051443:	e8 78 fc ff ff       	call   80510c0 <do_push_b>
 8051448:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805144b:	8d 43 01             	lea    0x1(%ebx),%eax
 805144e:	5b                   	pop    %ebx
 805144f:	c3                   	ret    

08051450 <push_i_v>:
#include "push-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(push_i)
 8051450:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8051457:	8b 54 24 04          	mov    0x4(%esp),%edx
 805145b:	b8 60 12 05 08       	mov    $0x8051260,%eax
 8051460:	75 05                	jne    8051467 <push_i_v+0x17>
 8051462:	b8 90 13 05 08       	mov    $0x8051390,%eax
 8051467:	89 54 24 04          	mov    %edx,0x4(%esp)
 805146b:	ff e0                	jmp    *%eax
 805146d:	8d 76 00             	lea    0x0(%esi),%esi

08051470 <push_r_v>:
make_helper_v(push_r)
 8051470:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8051477:	8b 54 24 04          	mov    0x4(%esp),%edx
 805147b:	b8 80 12 05 08       	mov    $0x8051280,%eax
 8051480:	75 05                	jne    8051487 <push_r_v+0x17>
 8051482:	b8 b0 13 05 08       	mov    $0x80513b0,%eax
 8051487:	89 54 24 04          	mov    %edx,0x4(%esp)
 805148b:	ff e0                	jmp    *%eax
 805148d:	8d 76 00             	lea    0x0(%esi),%esi

08051490 <push_rm_v>:
make_helper_v(push_rm)
 8051490:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8051497:	8b 54 24 04          	mov    0x4(%esp),%edx
 805149b:	b8 a0 12 05 08       	mov    $0x80512a0,%eax
 80514a0:	75 05                	jne    80514a7 <push_rm_v+0x17>
 80514a2:	b8 d0 13 05 08       	mov    $0x80513d0,%eax
 80514a7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80514ab:	ff e0                	jmp    *%eax
 80514ad:	66 90                	xchg   %ax,%ax
 80514af:	90                   	nop

080514b0 <cmovge_rm2r_l>:
static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
}

make_instr_helper(rm2r)
 80514b0:	53                   	push   %ebx
 80514b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80514b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80514b8:	83 c0 01             	add    $0x1,%eax
 80514bb:	50                   	push   %eax
 80514bc:	e8 7f bc 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80514c1:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 80514c8:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 80514cf:	83 c4 10             	add    $0x10,%esp
 80514d2:	89 c3                	mov    %eax,%ebx
 80514d4:	c0 ea 03             	shr    $0x3,%dl
 80514d7:	c0 e9 07             	shr    $0x7,%cl
 80514da:	83 e2 01             	and    $0x1,%edx
 80514dd:	38 d1                	cmp    %dl,%cl
 80514df:	0f 84 c3 00 00 00    	je     80515a8 <cmovge_rm2r_l+0xf8>
	print_asm_template2();
 80514e5:	83 ec 0c             	sub    $0xc,%esp
 80514e8:	68 50 ae 8f 14       	push   $0x148fae50
 80514ed:	68 18 ae 8f 14       	push   $0x148fae18
 80514f2:	68 9d 1a 06 08       	push   $0x8061a9d
 80514f7:	6a 50                	push   $0x50
 80514f9:	68 00 89 0c 08       	push   $0x80c8900
 80514fe:	e8 fd 75 ff ff       	call   8048b00 <snprintf@plt>
 8051503:	83 c4 20             	add    $0x20,%esp
 8051506:	83 f8 4f             	cmp    $0x4f,%eax
 8051509:	7f 0d                	jg     8051518 <cmovge_rm2r_l+0x68>
}

make_instr_helper(rm2r)
 805150b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805150e:	8d 43 01             	lea    0x1(%ebx),%eax
 8051511:	5b                   	pop    %ebx
 8051512:	c3                   	ret    
 8051513:	90                   	nop
 8051514:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051518:	83 ec 0c             	sub    $0xc,%esp
 805151b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8051521:	e8 3a 74 ff ff       	call   8048960 <fflush@plt>
 8051526:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805152c:	6a 07                	push   $0x7
 805152e:	6a 01                	push   $0x1
 8051530:	68 92 ed 05 08       	push   $0x805ed92
 8051535:	e8 d6 74 ff ff       	call   8048a10 <fwrite@plt>
 805153a:	83 c4 20             	add    $0x20,%esp
 805153d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051543:	6a 10                	push   $0x10
 8051545:	6a 01                	push   $0x1
 8051547:	68 84 f8 05 08       	push   $0x805f884
 805154c:	e8 bf 74 ff ff       	call   8048a10 <fwrite@plt>
 8051551:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051557:	6a 05                	push   $0x5
 8051559:	6a 01                	push   $0x1
 805155b:	68 b1 ed 05 08       	push   $0x805edb1
 8051560:	e8 ab 74 ff ff       	call   8048a10 <fwrite@plt>
 8051565:	83 c4 14             	add    $0x14,%esp
 8051568:	68 50 ae 8f 14       	push   $0x148fae50
 805156d:	68 18 ae 8f 14       	push   $0x148fae18
 8051572:	68 9d 1a 06 08       	push   $0x8061a9d
 8051577:	6a 50                	push   $0x50
 8051579:	68 00 89 0c 08       	push   $0x80c8900
 805157e:	e8 7d 75 ff ff       	call   8048b00 <snprintf@plt>
 8051583:	83 c4 20             	add    $0x20,%esp
 8051586:	83 f8 4f             	cmp    $0x4f,%eax
 8051589:	7e 80                	jle    805150b <cmovge_rm2r_l+0x5b>
 805158b:	68 e2 29 06 08       	push   $0x80629e2
 8051590:	6a 06                	push   $0x6
 8051592:	68 50 1c 06 08       	push   $0x8061c50
 8051597:	68 7c 1c 06 08       	push   $0x8061c7c
 805159c:	e8 0f 76 ff ff       	call   8048bb0 <__assert_fail@plt>
 80515a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80515a8:	83 ec 08             	sub    $0x8,%esp
 80515ab:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 80515b1:	68 40 ae 8f 14       	push   $0x148fae40
 80515b6:	e8 e5 bd 00 00       	call   805d3a0 <write_operand_l>
 80515bb:	83 c4 10             	add    $0x10,%esp
 80515be:	e9 22 ff ff ff       	jmp    80514e5 <cmovge_rm2r_l+0x35>
 80515c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80515c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080515d0 <cmovne_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80515d0:	53                   	push   %ebx
 80515d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80515d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80515d8:	83 c0 01             	add    $0x1,%eax
 80515db:	50                   	push   %eax
 80515dc:	e8 5f bb 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80515e1:	83 c4 10             	add    $0x10,%esp
 80515e4:	f6 05 e4 ae 8f 14 40 	testb  $0x40,0x148faee4
 80515eb:	89 c3                	mov    %eax,%ebx
 80515ed:	0f 84 c5 00 00 00    	je     80516b8 <cmovne_rm2r_l+0xe8>
	print_asm_template2();
 80515f3:	83 ec 0c             	sub    $0xc,%esp
 80515f6:	68 50 ae 8f 14       	push   $0x148fae50
 80515fb:	68 18 ae 8f 14       	push   $0x148fae18
 8051600:	68 ab 1a 06 08       	push   $0x8061aab
 8051605:	6a 50                	push   $0x50
 8051607:	68 00 89 0c 08       	push   $0x80c8900
 805160c:	e8 ef 74 ff ff       	call   8048b00 <snprintf@plt>
 8051611:	83 c4 20             	add    $0x20,%esp
 8051614:	83 f8 4f             	cmp    $0x4f,%eax
 8051617:	7f 0f                	jg     8051628 <cmovne_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051619:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805161c:	8d 43 01             	lea    0x1(%ebx),%eax
 805161f:	5b                   	pop    %ebx
 8051620:	c3                   	ret    
 8051621:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051628:	83 ec 0c             	sub    $0xc,%esp
 805162b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8051631:	e8 2a 73 ff ff       	call   8048960 <fflush@plt>
 8051636:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805163c:	6a 07                	push   $0x7
 805163e:	6a 01                	push   $0x1
 8051640:	68 92 ed 05 08       	push   $0x805ed92
 8051645:	e8 c6 73 ff ff       	call   8048a10 <fwrite@plt>
 805164a:	83 c4 20             	add    $0x20,%esp
 805164d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051653:	6a 10                	push   $0x10
 8051655:	6a 01                	push   $0x1
 8051657:	68 84 f8 05 08       	push   $0x805f884
 805165c:	e8 af 73 ff ff       	call   8048a10 <fwrite@plt>
 8051661:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051667:	6a 05                	push   $0x5
 8051669:	6a 01                	push   $0x1
 805166b:	68 b1 ed 05 08       	push   $0x805edb1
 8051670:	e8 9b 73 ff ff       	call   8048a10 <fwrite@plt>
 8051675:	83 c4 14             	add    $0x14,%esp
 8051678:	68 50 ae 8f 14       	push   $0x148fae50
 805167d:	68 18 ae 8f 14       	push   $0x148fae18
 8051682:	68 ab 1a 06 08       	push   $0x8061aab
 8051687:	6a 50                	push   $0x50
 8051689:	68 00 89 0c 08       	push   $0x80c8900
 805168e:	e8 6d 74 ff ff       	call   8048b00 <snprintf@plt>
 8051693:	83 c4 20             	add    $0x20,%esp
 8051696:	83 f8 4f             	cmp    $0x4f,%eax
 8051699:	0f 8e 7a ff ff ff    	jle    8051619 <cmovne_rm2r_l+0x49>
 805169f:	68 bf 29 06 08       	push   $0x80629bf
 80516a4:	6a 06                	push   $0x6
 80516a6:	68 50 1c 06 08       	push   $0x8061c50
 80516ab:	68 e4 1c 06 08       	push   $0x8061ce4
 80516b0:	e8 fb 74 ff ff       	call   8048bb0 <__assert_fail@plt>
 80516b5:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80516b8:	83 ec 08             	sub    $0x8,%esp
 80516bb:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 80516c1:	68 40 ae 8f 14       	push   $0x148fae40
 80516c6:	e8 d5 bc 00 00       	call   805d3a0 <write_operand_l>
 80516cb:	83 c4 10             	add    $0x10,%esp
 80516ce:	e9 20 ff ff ff       	jmp    80515f3 <cmovne_rm2r_l+0x23>
 80516d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80516d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080516e0 <cmovno_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80516e0:	53                   	push   %ebx
 80516e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80516e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80516e8:	83 c0 01             	add    $0x1,%eax
 80516eb:	50                   	push   %eax
 80516ec:	e8 4f ba 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80516f1:	83 c4 10             	add    $0x10,%esp
 80516f4:	f6 05 e5 ae 8f 14 08 	testb  $0x8,0x148faee5
 80516fb:	89 c3                	mov    %eax,%ebx
 80516fd:	0f 84 c5 00 00 00    	je     80517c8 <cmovno_rm2r_l+0xe8>
	print_asm_template2();
 8051703:	83 ec 0c             	sub    $0xc,%esp
 8051706:	68 50 ae 8f 14       	push   $0x148fae50
 805170b:	68 18 ae 8f 14       	push   $0x148fae18
 8051710:	68 b9 1a 06 08       	push   $0x8061ab9
 8051715:	6a 50                	push   $0x50
 8051717:	68 00 89 0c 08       	push   $0x80c8900
 805171c:	e8 df 73 ff ff       	call   8048b00 <snprintf@plt>
 8051721:	83 c4 20             	add    $0x20,%esp
 8051724:	83 f8 4f             	cmp    $0x4f,%eax
 8051727:	7f 0f                	jg     8051738 <cmovno_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051729:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805172c:	8d 43 01             	lea    0x1(%ebx),%eax
 805172f:	5b                   	pop    %ebx
 8051730:	c3                   	ret    
 8051731:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051738:	83 ec 0c             	sub    $0xc,%esp
 805173b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8051741:	e8 1a 72 ff ff       	call   8048960 <fflush@plt>
 8051746:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805174c:	6a 07                	push   $0x7
 805174e:	6a 01                	push   $0x1
 8051750:	68 92 ed 05 08       	push   $0x805ed92
 8051755:	e8 b6 72 ff ff       	call   8048a10 <fwrite@plt>
 805175a:	83 c4 20             	add    $0x20,%esp
 805175d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051763:	6a 10                	push   $0x10
 8051765:	6a 01                	push   $0x1
 8051767:	68 84 f8 05 08       	push   $0x805f884
 805176c:	e8 9f 72 ff ff       	call   8048a10 <fwrite@plt>
 8051771:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051777:	6a 05                	push   $0x5
 8051779:	6a 01                	push   $0x1
 805177b:	68 b1 ed 05 08       	push   $0x805edb1
 8051780:	e8 8b 72 ff ff       	call   8048a10 <fwrite@plt>
 8051785:	83 c4 14             	add    $0x14,%esp
 8051788:	68 50 ae 8f 14       	push   $0x148fae50
 805178d:	68 18 ae 8f 14       	push   $0x148fae18
 8051792:	68 b9 1a 06 08       	push   $0x8061ab9
 8051797:	6a 50                	push   $0x50
 8051799:	68 00 89 0c 08       	push   $0x80c8900
 805179e:	e8 5d 73 ff ff       	call   8048b00 <snprintf@plt>
 80517a3:	83 c4 20             	add    $0x20,%esp
 80517a6:	83 f8 4f             	cmp    $0x4f,%eax
 80517a9:	0f 8e 7a ff ff ff    	jle    8051729 <cmovno_rm2r_l+0x49>
 80517af:	68 b3 29 06 08       	push   $0x80629b3
 80517b4:	6a 06                	push   $0x6
 80517b6:	68 50 1c 06 08       	push   $0x8061c50
 80517bb:	68 4c 1d 06 08       	push   $0x8061d4c
 80517c0:	e8 eb 73 ff ff       	call   8048bb0 <__assert_fail@plt>
 80517c5:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80517c8:	83 ec 08             	sub    $0x8,%esp
 80517cb:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 80517d1:	68 40 ae 8f 14       	push   $0x148fae40
 80517d6:	e8 c5 bb 00 00       	call   805d3a0 <write_operand_l>
 80517db:	83 c4 10             	add    $0x10,%esp
 80517de:	e9 20 ff ff ff       	jmp    8051703 <cmovno_rm2r_l+0x23>
 80517e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80517e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080517f0 <cmovns_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80517f0:	53                   	push   %ebx
 80517f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80517f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80517f8:	83 c0 01             	add    $0x1,%eax
 80517fb:	50                   	push   %eax
 80517fc:	e8 3f b9 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051801:	83 c4 10             	add    $0x10,%esp
 8051804:	80 3d e4 ae 8f 14 00 	cmpb   $0x0,0x148faee4
 805180b:	89 c3                	mov    %eax,%ebx
 805180d:	0f 89 c5 00 00 00    	jns    80518d8 <cmovns_rm2r_l+0xe8>
	print_asm_template2();
 8051813:	83 ec 0c             	sub    $0xc,%esp
 8051816:	68 50 ae 8f 14       	push   $0x148fae50
 805181b:	68 18 ae 8f 14       	push   $0x148fae18
 8051820:	68 c7 1a 06 08       	push   $0x8061ac7
 8051825:	6a 50                	push   $0x50
 8051827:	68 00 89 0c 08       	push   $0x80c8900
 805182c:	e8 cf 72 ff ff       	call   8048b00 <snprintf@plt>
 8051831:	83 c4 20             	add    $0x20,%esp
 8051834:	83 f8 4f             	cmp    $0x4f,%eax
 8051837:	7f 0f                	jg     8051848 <cmovns_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051839:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805183c:	8d 43 01             	lea    0x1(%ebx),%eax
 805183f:	5b                   	pop    %ebx
 8051840:	c3                   	ret    
 8051841:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051848:	83 ec 0c             	sub    $0xc,%esp
 805184b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8051851:	e8 0a 71 ff ff       	call   8048960 <fflush@plt>
 8051856:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805185c:	6a 07                	push   $0x7
 805185e:	6a 01                	push   $0x1
 8051860:	68 92 ed 05 08       	push   $0x805ed92
 8051865:	e8 a6 71 ff ff       	call   8048a10 <fwrite@plt>
 805186a:	83 c4 20             	add    $0x20,%esp
 805186d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051873:	6a 10                	push   $0x10
 8051875:	6a 01                	push   $0x1
 8051877:	68 84 f8 05 08       	push   $0x805f884
 805187c:	e8 8f 71 ff ff       	call   8048a10 <fwrite@plt>
 8051881:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051887:	6a 05                	push   $0x5
 8051889:	6a 01                	push   $0x1
 805188b:	68 b1 ed 05 08       	push   $0x805edb1
 8051890:	e8 7b 71 ff ff       	call   8048a10 <fwrite@plt>
 8051895:	83 c4 14             	add    $0x14,%esp
 8051898:	68 50 ae 8f 14       	push   $0x148fae50
 805189d:	68 18 ae 8f 14       	push   $0x148fae18
 80518a2:	68 c7 1a 06 08       	push   $0x8061ac7
 80518a7:	6a 50                	push   $0x50
 80518a9:	68 00 89 0c 08       	push   $0x80c8900
 80518ae:	e8 4d 72 ff ff       	call   8048b00 <snprintf@plt>
 80518b3:	83 c4 20             	add    $0x20,%esp
 80518b6:	83 f8 4f             	cmp    $0x4f,%eax
 80518b9:	0f 8e 7a ff ff ff    	jle    8051839 <cmovns_rm2r_l+0x49>
 80518bf:	68 9b 29 06 08       	push   $0x806299b
 80518c4:	6a 06                	push   $0x6
 80518c6:	68 50 1c 06 08       	push   $0x8061c50
 80518cb:	68 b4 1d 06 08       	push   $0x8061db4
 80518d0:	e8 db 72 ff ff       	call   8048bb0 <__assert_fail@plt>
 80518d5:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80518d8:	83 ec 08             	sub    $0x8,%esp
 80518db:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 80518e1:	68 40 ae 8f 14       	push   $0x148fae40
 80518e6:	e8 b5 ba 00 00       	call   805d3a0 <write_operand_l>
 80518eb:	83 c4 10             	add    $0x10,%esp
 80518ee:	e9 20 ff ff ff       	jmp    8051813 <cmovns_rm2r_l+0x23>
 80518f3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80518f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051900 <cmovnp_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051900:	53                   	push   %ebx
 8051901:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051904:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051908:	83 c0 01             	add    $0x1,%eax
 805190b:	50                   	push   %eax
 805190c:	e8 2f b8 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051911:	83 c4 10             	add    $0x10,%esp
 8051914:	f6 05 e4 ae 8f 14 04 	testb  $0x4,0x148faee4
 805191b:	89 c3                	mov    %eax,%ebx
 805191d:	0f 84 c5 00 00 00    	je     80519e8 <cmovnp_rm2r_l+0xe8>
	print_asm_template2();
 8051923:	83 ec 0c             	sub    $0xc,%esp
 8051926:	68 50 ae 8f 14       	push   $0x148fae50
 805192b:	68 18 ae 8f 14       	push   $0x148fae18
 8051930:	68 d5 1a 06 08       	push   $0x8061ad5
 8051935:	6a 50                	push   $0x50
 8051937:	68 00 89 0c 08       	push   $0x80c8900
 805193c:	e8 bf 71 ff ff       	call   8048b00 <snprintf@plt>
 8051941:	83 c4 20             	add    $0x20,%esp
 8051944:	83 f8 4f             	cmp    $0x4f,%eax
 8051947:	7f 0f                	jg     8051958 <cmovnp_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051949:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805194c:	8d 43 01             	lea    0x1(%ebx),%eax
 805194f:	5b                   	pop    %ebx
 8051950:	c3                   	ret    
 8051951:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051958:	83 ec 0c             	sub    $0xc,%esp
 805195b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8051961:	e8 fa 6f ff ff       	call   8048960 <fflush@plt>
 8051966:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805196c:	6a 07                	push   $0x7
 805196e:	6a 01                	push   $0x1
 8051970:	68 92 ed 05 08       	push   $0x805ed92
 8051975:	e8 96 70 ff ff       	call   8048a10 <fwrite@plt>
 805197a:	83 c4 20             	add    $0x20,%esp
 805197d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051983:	6a 10                	push   $0x10
 8051985:	6a 01                	push   $0x1
 8051987:	68 84 f8 05 08       	push   $0x805f884
 805198c:	e8 7f 70 ff ff       	call   8048a10 <fwrite@plt>
 8051991:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051997:	6a 05                	push   $0x5
 8051999:	6a 01                	push   $0x1
 805199b:	68 b1 ed 05 08       	push   $0x805edb1
 80519a0:	e8 6b 70 ff ff       	call   8048a10 <fwrite@plt>
 80519a5:	83 c4 14             	add    $0x14,%esp
 80519a8:	68 50 ae 8f 14       	push   $0x148fae50
 80519ad:	68 18 ae 8f 14       	push   $0x148fae18
 80519b2:	68 d5 1a 06 08       	push   $0x8061ad5
 80519b7:	6a 50                	push   $0x50
 80519b9:	68 00 89 0c 08       	push   $0x80c8900
 80519be:	e8 3d 71 ff ff       	call   8048b00 <snprintf@plt>
 80519c3:	83 c4 20             	add    $0x20,%esp
 80519c6:	83 f8 4f             	cmp    $0x4f,%eax
 80519c9:	0f 8e 7a ff ff ff    	jle    8051949 <cmovnp_rm2r_l+0x49>
 80519cf:	68 a7 29 06 08       	push   $0x80629a7
 80519d4:	6a 06                	push   $0x6
 80519d6:	68 50 1c 06 08       	push   $0x8061c50
 80519db:	68 1c 1e 06 08       	push   $0x8061e1c
 80519e0:	e8 cb 71 ff ff       	call   8048bb0 <__assert_fail@plt>
 80519e5:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80519e8:	83 ec 08             	sub    $0x8,%esp
 80519eb:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 80519f1:	68 40 ae 8f 14       	push   $0x148fae40
 80519f6:	e8 a5 b9 00 00       	call   805d3a0 <write_operand_l>
 80519fb:	83 c4 10             	add    $0x10,%esp
 80519fe:	e9 20 ff ff ff       	jmp    8051923 <cmovnp_rm2r_l+0x23>
 8051a03:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051a09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051a10 <cmovo_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051a10:	53                   	push   %ebx
 8051a11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051a14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051a18:	83 c0 01             	add    $0x1,%eax
 8051a1b:	50                   	push   %eax
 8051a1c:	e8 1f b7 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051a21:	83 c4 10             	add    $0x10,%esp
 8051a24:	f6 05 e5 ae 8f 14 08 	testb  $0x8,0x148faee5
 8051a2b:	89 c3                	mov    %eax,%ebx
 8051a2d:	0f 85 c5 00 00 00    	jne    8051af8 <cmovo_rm2r_l+0xe8>
	print_asm_template2();
 8051a33:	83 ec 0c             	sub    $0xc,%esp
 8051a36:	68 50 ae 8f 14       	push   $0x148fae50
 8051a3b:	68 18 ae 8f 14       	push   $0x148fae18
 8051a40:	68 e3 1a 06 08       	push   $0x8061ae3
 8051a45:	6a 50                	push   $0x50
 8051a47:	68 00 89 0c 08       	push   $0x80c8900
 8051a4c:	e8 af 70 ff ff       	call   8048b00 <snprintf@plt>
 8051a51:	83 c4 20             	add    $0x20,%esp
 8051a54:	83 f8 4f             	cmp    $0x4f,%eax
 8051a57:	7f 0f                	jg     8051a68 <cmovo_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051a59:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8051a5c:	8d 43 01             	lea    0x1(%ebx),%eax
 8051a5f:	5b                   	pop    %ebx
 8051a60:	c3                   	ret    
 8051a61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051a68:	83 ec 0c             	sub    $0xc,%esp
 8051a6b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8051a71:	e8 ea 6e ff ff       	call   8048960 <fflush@plt>
 8051a76:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051a7c:	6a 07                	push   $0x7
 8051a7e:	6a 01                	push   $0x1
 8051a80:	68 92 ed 05 08       	push   $0x805ed92
 8051a85:	e8 86 6f ff ff       	call   8048a10 <fwrite@plt>
 8051a8a:	83 c4 20             	add    $0x20,%esp
 8051a8d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051a93:	6a 10                	push   $0x10
 8051a95:	6a 01                	push   $0x1
 8051a97:	68 84 f8 05 08       	push   $0x805f884
 8051a9c:	e8 6f 6f ff ff       	call   8048a10 <fwrite@plt>
 8051aa1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051aa7:	6a 05                	push   $0x5
 8051aa9:	6a 01                	push   $0x1
 8051aab:	68 b1 ed 05 08       	push   $0x805edb1
 8051ab0:	e8 5b 6f ff ff       	call   8048a10 <fwrite@plt>
 8051ab5:	83 c4 14             	add    $0x14,%esp
 8051ab8:	68 50 ae 8f 14       	push   $0x148fae50
 8051abd:	68 18 ae 8f 14       	push   $0x148fae18
 8051ac2:	68 e3 1a 06 08       	push   $0x8061ae3
 8051ac7:	6a 50                	push   $0x50
 8051ac9:	68 00 89 0c 08       	push   $0x80c8900
 8051ace:	e8 2d 70 ff ff       	call   8048b00 <snprintf@plt>
 8051ad3:	83 c4 20             	add    $0x20,%esp
 8051ad6:	83 f8 4f             	cmp    $0x4f,%eax
 8051ad9:	0f 8e 7a ff ff ff    	jle    8051a59 <cmovo_rm2r_l+0x49>
 8051adf:	68 90 29 06 08       	push   $0x8062990
 8051ae4:	6a 06                	push   $0x6
 8051ae6:	68 50 1c 06 08       	push   $0x8061c50
 8051aeb:	68 84 1e 06 08       	push   $0x8061e84
 8051af0:	e8 bb 70 ff ff       	call   8048bb0 <__assert_fail@plt>
 8051af5:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051af8:	83 ec 08             	sub    $0x8,%esp
 8051afb:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 8051b01:	68 40 ae 8f 14       	push   $0x148fae40
 8051b06:	e8 95 b8 00 00       	call   805d3a0 <write_operand_l>
 8051b0b:	83 c4 10             	add    $0x10,%esp
 8051b0e:	e9 20 ff ff ff       	jmp    8051a33 <cmovo_rm2r_l+0x23>
 8051b13:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051b19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051b20 <cmovp_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051b20:	53                   	push   %ebx
 8051b21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051b24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051b28:	83 c0 01             	add    $0x1,%eax
 8051b2b:	50                   	push   %eax
 8051b2c:	e8 0f b6 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051b31:	83 c4 10             	add    $0x10,%esp
 8051b34:	f6 05 e4 ae 8f 14 04 	testb  $0x4,0x148faee4
 8051b3b:	89 c3                	mov    %eax,%ebx
 8051b3d:	0f 85 c5 00 00 00    	jne    8051c08 <cmovp_rm2r_l+0xe8>
	print_asm_template2();
 8051b43:	83 ec 0c             	sub    $0xc,%esp
 8051b46:	68 50 ae 8f 14       	push   $0x148fae50
 8051b4b:	68 18 ae 8f 14       	push   $0x148fae18
 8051b50:	68 f0 1a 06 08       	push   $0x8061af0
 8051b55:	6a 50                	push   $0x50
 8051b57:	68 00 89 0c 08       	push   $0x80c8900
 8051b5c:	e8 9f 6f ff ff       	call   8048b00 <snprintf@plt>
 8051b61:	83 c4 20             	add    $0x20,%esp
 8051b64:	83 f8 4f             	cmp    $0x4f,%eax
 8051b67:	7f 0f                	jg     8051b78 <cmovp_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051b69:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8051b6c:	8d 43 01             	lea    0x1(%ebx),%eax
 8051b6f:	5b                   	pop    %ebx
 8051b70:	c3                   	ret    
 8051b71:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051b78:	83 ec 0c             	sub    $0xc,%esp
 8051b7b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8051b81:	e8 da 6d ff ff       	call   8048960 <fflush@plt>
 8051b86:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051b8c:	6a 07                	push   $0x7
 8051b8e:	6a 01                	push   $0x1
 8051b90:	68 92 ed 05 08       	push   $0x805ed92
 8051b95:	e8 76 6e ff ff       	call   8048a10 <fwrite@plt>
 8051b9a:	83 c4 20             	add    $0x20,%esp
 8051b9d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051ba3:	6a 10                	push   $0x10
 8051ba5:	6a 01                	push   $0x1
 8051ba7:	68 84 f8 05 08       	push   $0x805f884
 8051bac:	e8 5f 6e ff ff       	call   8048a10 <fwrite@plt>
 8051bb1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051bb7:	6a 05                	push   $0x5
 8051bb9:	6a 01                	push   $0x1
 8051bbb:	68 b1 ed 05 08       	push   $0x805edb1
 8051bc0:	e8 4b 6e ff ff       	call   8048a10 <fwrite@plt>
 8051bc5:	83 c4 14             	add    $0x14,%esp
 8051bc8:	68 50 ae 8f 14       	push   $0x148fae50
 8051bcd:	68 18 ae 8f 14       	push   $0x148fae18
 8051bd2:	68 f0 1a 06 08       	push   $0x8061af0
 8051bd7:	6a 50                	push   $0x50
 8051bd9:	68 00 89 0c 08       	push   $0x80c8900
 8051bde:	e8 1d 6f ff ff       	call   8048b00 <snprintf@plt>
 8051be3:	83 c4 20             	add    $0x20,%esp
 8051be6:	83 f8 4f             	cmp    $0x4f,%eax
 8051be9:	0f 8e 7a ff ff ff    	jle    8051b69 <cmovp_rm2r_l+0x49>
 8051bef:	68 85 29 06 08       	push   $0x8062985
 8051bf4:	6a 06                	push   $0x6
 8051bf6:	68 50 1c 06 08       	push   $0x8061c50
 8051bfb:	68 ec 1e 06 08       	push   $0x8061eec
 8051c00:	e8 ab 6f ff ff       	call   8048bb0 <__assert_fail@plt>
 8051c05:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051c08:	83 ec 08             	sub    $0x8,%esp
 8051c0b:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 8051c11:	68 40 ae 8f 14       	push   $0x148fae40
 8051c16:	e8 85 b7 00 00       	call   805d3a0 <write_operand_l>
 8051c1b:	83 c4 10             	add    $0x10,%esp
 8051c1e:	e9 20 ff ff ff       	jmp    8051b43 <cmovp_rm2r_l+0x23>
 8051c23:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051c29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051c30 <cmovs_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051c30:	53                   	push   %ebx
 8051c31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051c34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051c38:	83 c0 01             	add    $0x1,%eax
 8051c3b:	50                   	push   %eax
 8051c3c:	e8 ff b4 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051c41:	83 c4 10             	add    $0x10,%esp
 8051c44:	80 3d e4 ae 8f 14 00 	cmpb   $0x0,0x148faee4
 8051c4b:	89 c3                	mov    %eax,%ebx
 8051c4d:	0f 88 c5 00 00 00    	js     8051d18 <cmovs_rm2r_l+0xe8>
	print_asm_template2();
 8051c53:	83 ec 0c             	sub    $0xc,%esp
 8051c56:	68 50 ae 8f 14       	push   $0x148fae50
 8051c5b:	68 18 ae 8f 14       	push   $0x148fae18
 8051c60:	68 fd 1a 06 08       	push   $0x8061afd
 8051c65:	6a 50                	push   $0x50
 8051c67:	68 00 89 0c 08       	push   $0x80c8900
 8051c6c:	e8 8f 6e ff ff       	call   8048b00 <snprintf@plt>
 8051c71:	83 c4 20             	add    $0x20,%esp
 8051c74:	83 f8 4f             	cmp    $0x4f,%eax
 8051c77:	7f 0f                	jg     8051c88 <cmovs_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051c79:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8051c7c:	8d 43 01             	lea    0x1(%ebx),%eax
 8051c7f:	5b                   	pop    %ebx
 8051c80:	c3                   	ret    
 8051c81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051c88:	83 ec 0c             	sub    $0xc,%esp
 8051c8b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8051c91:	e8 ca 6c ff ff       	call   8048960 <fflush@plt>
 8051c96:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051c9c:	6a 07                	push   $0x7
 8051c9e:	6a 01                	push   $0x1
 8051ca0:	68 92 ed 05 08       	push   $0x805ed92
 8051ca5:	e8 66 6d ff ff       	call   8048a10 <fwrite@plt>
 8051caa:	83 c4 20             	add    $0x20,%esp
 8051cad:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051cb3:	6a 10                	push   $0x10
 8051cb5:	6a 01                	push   $0x1
 8051cb7:	68 84 f8 05 08       	push   $0x805f884
 8051cbc:	e8 4f 6d ff ff       	call   8048a10 <fwrite@plt>
 8051cc1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051cc7:	6a 05                	push   $0x5
 8051cc9:	6a 01                	push   $0x1
 8051ccb:	68 b1 ed 05 08       	push   $0x805edb1
 8051cd0:	e8 3b 6d ff ff       	call   8048a10 <fwrite@plt>
 8051cd5:	83 c4 14             	add    $0x14,%esp
 8051cd8:	68 50 ae 8f 14       	push   $0x148fae50
 8051cdd:	68 18 ae 8f 14       	push   $0x148fae18
 8051ce2:	68 fd 1a 06 08       	push   $0x8061afd
 8051ce7:	6a 50                	push   $0x50
 8051ce9:	68 00 89 0c 08       	push   $0x80c8900
 8051cee:	e8 0d 6e ff ff       	call   8048b00 <snprintf@plt>
 8051cf3:	83 c4 20             	add    $0x20,%esp
 8051cf6:	83 f8 4f             	cmp    $0x4f,%eax
 8051cf9:	0f 8e 7a ff ff ff    	jle    8051c79 <cmovs_rm2r_l+0x49>
 8051cff:	68 7a 29 06 08       	push   $0x806297a
 8051d04:	6a 06                	push   $0x6
 8051d06:	68 50 1c 06 08       	push   $0x8061c50
 8051d0b:	68 54 1f 06 08       	push   $0x8061f54
 8051d10:	e8 9b 6e ff ff       	call   8048bb0 <__assert_fail@plt>
 8051d15:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051d18:	83 ec 08             	sub    $0x8,%esp
 8051d1b:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 8051d21:	68 40 ae 8f 14       	push   $0x148fae40
 8051d26:	e8 75 b6 00 00       	call   805d3a0 <write_operand_l>
 8051d2b:	83 c4 10             	add    $0x10,%esp
 8051d2e:	e9 20 ff ff ff       	jmp    8051c53 <cmovs_rm2r_l+0x23>
 8051d33:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051d39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051d40 <cmova_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051d40:	53                   	push   %ebx
 8051d41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051d44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051d48:	83 c0 01             	add    $0x1,%eax
 8051d4b:	50                   	push   %eax
 8051d4c:	e8 ef b3 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051d51:	83 c4 10             	add    $0x10,%esp
 8051d54:	f6 05 e4 ae 8f 14 41 	testb  $0x41,0x148faee4
 8051d5b:	89 c3                	mov    %eax,%ebx
 8051d5d:	0f 84 c5 00 00 00    	je     8051e28 <cmova_rm2r_l+0xe8>
	print_asm_template2();
 8051d63:	83 ec 0c             	sub    $0xc,%esp
 8051d66:	68 50 ae 8f 14       	push   $0x148fae50
 8051d6b:	68 18 ae 8f 14       	push   $0x148fae18
 8051d70:	68 0a 1b 06 08       	push   $0x8061b0a
 8051d75:	6a 50                	push   $0x50
 8051d77:	68 00 89 0c 08       	push   $0x80c8900
 8051d7c:	e8 7f 6d ff ff       	call   8048b00 <snprintf@plt>
 8051d81:	83 c4 20             	add    $0x20,%esp
 8051d84:	83 f8 4f             	cmp    $0x4f,%eax
 8051d87:	7f 0f                	jg     8051d98 <cmova_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051d89:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8051d8c:	8d 43 01             	lea    0x1(%ebx),%eax
 8051d8f:	5b                   	pop    %ebx
 8051d90:	c3                   	ret    
 8051d91:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051d98:	83 ec 0c             	sub    $0xc,%esp
 8051d9b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8051da1:	e8 ba 6b ff ff       	call   8048960 <fflush@plt>
 8051da6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051dac:	6a 07                	push   $0x7
 8051dae:	6a 01                	push   $0x1
 8051db0:	68 92 ed 05 08       	push   $0x805ed92
 8051db5:	e8 56 6c ff ff       	call   8048a10 <fwrite@plt>
 8051dba:	83 c4 20             	add    $0x20,%esp
 8051dbd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051dc3:	6a 10                	push   $0x10
 8051dc5:	6a 01                	push   $0x1
 8051dc7:	68 84 f8 05 08       	push   $0x805f884
 8051dcc:	e8 3f 6c ff ff       	call   8048a10 <fwrite@plt>
 8051dd1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051dd7:	6a 05                	push   $0x5
 8051dd9:	6a 01                	push   $0x1
 8051ddb:	68 b1 ed 05 08       	push   $0x805edb1
 8051de0:	e8 2b 6c ff ff       	call   8048a10 <fwrite@plt>
 8051de5:	83 c4 14             	add    $0x14,%esp
 8051de8:	68 50 ae 8f 14       	push   $0x148fae50
 8051ded:	68 18 ae 8f 14       	push   $0x148fae18
 8051df2:	68 0a 1b 06 08       	push   $0x8061b0a
 8051df7:	6a 50                	push   $0x50
 8051df9:	68 00 89 0c 08       	push   $0x80c8900
 8051dfe:	e8 fd 6c ff ff       	call   8048b00 <snprintf@plt>
 8051e03:	83 c4 20             	add    $0x20,%esp
 8051e06:	83 f8 4f             	cmp    $0x4f,%eax
 8051e09:	0f 8e 7a ff ff ff    	jle    8051d89 <cmova_rm2r_l+0x49>
 8051e0f:	68 27 2a 06 08       	push   $0x8062a27
 8051e14:	6a 06                	push   $0x6
 8051e16:	68 50 1c 06 08       	push   $0x8061c50
 8051e1b:	68 bc 1f 06 08       	push   $0x8061fbc
 8051e20:	e8 8b 6d ff ff       	call   8048bb0 <__assert_fail@plt>
 8051e25:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051e28:	83 ec 08             	sub    $0x8,%esp
 8051e2b:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 8051e31:	68 40 ae 8f 14       	push   $0x148fae40
 8051e36:	e8 65 b5 00 00       	call   805d3a0 <write_operand_l>
 8051e3b:	83 c4 10             	add    $0x10,%esp
 8051e3e:	e9 20 ff ff ff       	jmp    8051d63 <cmova_rm2r_l+0x23>
 8051e43:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051e49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051e50 <cmovb_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051e50:	53                   	push   %ebx
 8051e51:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051e54:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051e58:	83 c0 01             	add    $0x1,%eax
 8051e5b:	50                   	push   %eax
 8051e5c:	e8 df b2 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051e61:	83 c4 10             	add    $0x10,%esp
 8051e64:	f6 05 e4 ae 8f 14 01 	testb  $0x1,0x148faee4
 8051e6b:	89 c3                	mov    %eax,%ebx
 8051e6d:	0f 85 c5 00 00 00    	jne    8051f38 <cmovb_rm2r_l+0xe8>
	print_asm_template2();
 8051e73:	83 ec 0c             	sub    $0xc,%esp
 8051e76:	68 50 ae 8f 14       	push   $0x148fae50
 8051e7b:	68 18 ae 8f 14       	push   $0x148fae18
 8051e80:	68 17 1b 06 08       	push   $0x8061b17
 8051e85:	6a 50                	push   $0x50
 8051e87:	68 00 89 0c 08       	push   $0x80c8900
 8051e8c:	e8 6f 6c ff ff       	call   8048b00 <snprintf@plt>
 8051e91:	83 c4 20             	add    $0x20,%esp
 8051e94:	83 f8 4f             	cmp    $0x4f,%eax
 8051e97:	7f 0f                	jg     8051ea8 <cmovb_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051e99:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8051e9c:	8d 43 01             	lea    0x1(%ebx),%eax
 8051e9f:	5b                   	pop    %ebx
 8051ea0:	c3                   	ret    
 8051ea1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051ea8:	83 ec 0c             	sub    $0xc,%esp
 8051eab:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8051eb1:	e8 aa 6a ff ff       	call   8048960 <fflush@plt>
 8051eb6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051ebc:	6a 07                	push   $0x7
 8051ebe:	6a 01                	push   $0x1
 8051ec0:	68 92 ed 05 08       	push   $0x805ed92
 8051ec5:	e8 46 6b ff ff       	call   8048a10 <fwrite@plt>
 8051eca:	83 c4 20             	add    $0x20,%esp
 8051ecd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051ed3:	6a 10                	push   $0x10
 8051ed5:	6a 01                	push   $0x1
 8051ed7:	68 84 f8 05 08       	push   $0x805f884
 8051edc:	e8 2f 6b ff ff       	call   8048a10 <fwrite@plt>
 8051ee1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051ee7:	6a 05                	push   $0x5
 8051ee9:	6a 01                	push   $0x1
 8051eeb:	68 b1 ed 05 08       	push   $0x805edb1
 8051ef0:	e8 1b 6b ff ff       	call   8048a10 <fwrite@plt>
 8051ef5:	83 c4 14             	add    $0x14,%esp
 8051ef8:	68 50 ae 8f 14       	push   $0x148fae50
 8051efd:	68 18 ae 8f 14       	push   $0x148fae18
 8051f02:	68 17 1b 06 08       	push   $0x8061b17
 8051f07:	6a 50                	push   $0x50
 8051f09:	68 00 89 0c 08       	push   $0x80c8900
 8051f0e:	e8 ed 6b ff ff       	call   8048b00 <snprintf@plt>
 8051f13:	83 c4 20             	add    $0x20,%esp
 8051f16:	83 f8 4f             	cmp    $0x4f,%eax
 8051f19:	0f 8e 7a ff ff ff    	jle    8051e99 <cmovb_rm2r_l+0x49>
 8051f1f:	68 10 2a 06 08       	push   $0x8062a10
 8051f24:	6a 06                	push   $0x6
 8051f26:	68 50 1c 06 08       	push   $0x8061c50
 8051f2b:	68 24 20 06 08       	push   $0x8062024
 8051f30:	e8 7b 6c ff ff       	call   8048bb0 <__assert_fail@plt>
 8051f35:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051f38:	83 ec 08             	sub    $0x8,%esp
 8051f3b:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 8051f41:	68 40 ae 8f 14       	push   $0x148fae40
 8051f46:	e8 55 b4 00 00       	call   805d3a0 <write_operand_l>
 8051f4b:	83 c4 10             	add    $0x10,%esp
 8051f4e:	e9 20 ff ff ff       	jmp    8051e73 <cmovb_rm2r_l+0x23>
 8051f53:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051f59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051f60 <cmovae_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051f60:	53                   	push   %ebx
 8051f61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051f64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051f68:	83 c0 01             	add    $0x1,%eax
 8051f6b:	50                   	push   %eax
 8051f6c:	e8 cf b1 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051f71:	83 c4 10             	add    $0x10,%esp
 8051f74:	f6 05 e4 ae 8f 14 01 	testb  $0x1,0x148faee4
 8051f7b:	89 c3                	mov    %eax,%ebx
 8051f7d:	0f 84 c5 00 00 00    	je     8052048 <cmovae_rm2r_l+0xe8>
	print_asm_template2();
 8051f83:	83 ec 0c             	sub    $0xc,%esp
 8051f86:	68 50 ae 8f 14       	push   $0x148fae50
 8051f8b:	68 18 ae 8f 14       	push   $0x148fae18
 8051f90:	68 24 1b 06 08       	push   $0x8061b24
 8051f95:	6a 50                	push   $0x50
 8051f97:	68 00 89 0c 08       	push   $0x80c8900
 8051f9c:	e8 5f 6b ff ff       	call   8048b00 <snprintf@plt>
 8051fa1:	83 c4 20             	add    $0x20,%esp
 8051fa4:	83 f8 4f             	cmp    $0x4f,%eax
 8051fa7:	7f 0f                	jg     8051fb8 <cmovae_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051fa9:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8051fac:	8d 43 01             	lea    0x1(%ebx),%eax
 8051faf:	5b                   	pop    %ebx
 8051fb0:	c3                   	ret    
 8051fb1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051fb8:	83 ec 0c             	sub    $0xc,%esp
 8051fbb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8051fc1:	e8 9a 69 ff ff       	call   8048960 <fflush@plt>
 8051fc6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051fcc:	6a 07                	push   $0x7
 8051fce:	6a 01                	push   $0x1
 8051fd0:	68 92 ed 05 08       	push   $0x805ed92
 8051fd5:	e8 36 6a ff ff       	call   8048a10 <fwrite@plt>
 8051fda:	83 c4 20             	add    $0x20,%esp
 8051fdd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051fe3:	6a 10                	push   $0x10
 8051fe5:	6a 01                	push   $0x1
 8051fe7:	68 84 f8 05 08       	push   $0x805f884
 8051fec:	e8 1f 6a ff ff       	call   8048a10 <fwrite@plt>
 8051ff1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8051ff7:	6a 05                	push   $0x5
 8051ff9:	6a 01                	push   $0x1
 8051ffb:	68 b1 ed 05 08       	push   $0x805edb1
 8052000:	e8 0b 6a ff ff       	call   8048a10 <fwrite@plt>
 8052005:	83 c4 14             	add    $0x14,%esp
 8052008:	68 50 ae 8f 14       	push   $0x148fae50
 805200d:	68 18 ae 8f 14       	push   $0x148fae18
 8052012:	68 24 1b 06 08       	push   $0x8061b24
 8052017:	6a 50                	push   $0x50
 8052019:	68 00 89 0c 08       	push   $0x80c8900
 805201e:	e8 dd 6a ff ff       	call   8048b00 <snprintf@plt>
 8052023:	83 c4 20             	add    $0x20,%esp
 8052026:	83 f8 4f             	cmp    $0x4f,%eax
 8052029:	0f 8e 7a ff ff ff    	jle    8051fa9 <cmovae_rm2r_l+0x49>
 805202f:	68 1b 2a 06 08       	push   $0x8062a1b
 8052034:	6a 06                	push   $0x6
 8052036:	68 50 1c 06 08       	push   $0x8061c50
 805203b:	68 8c 20 06 08       	push   $0x806208c
 8052040:	e8 6b 6b ff ff       	call   8048bb0 <__assert_fail@plt>
 8052045:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052048:	83 ec 08             	sub    $0x8,%esp
 805204b:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 8052051:	68 40 ae 8f 14       	push   $0x148fae40
 8052056:	e8 45 b3 00 00       	call   805d3a0 <write_operand_l>
 805205b:	83 c4 10             	add    $0x10,%esp
 805205e:	e9 20 ff ff ff       	jmp    8051f83 <cmovae_rm2r_l+0x23>
 8052063:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8052069:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052070 <cmove_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052070:	53                   	push   %ebx
 8052071:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052074:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052078:	83 c0 01             	add    $0x1,%eax
 805207b:	50                   	push   %eax
 805207c:	e8 bf b0 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052081:	83 c4 10             	add    $0x10,%esp
 8052084:	f6 05 e4 ae 8f 14 40 	testb  $0x40,0x148faee4
 805208b:	89 c3                	mov    %eax,%ebx
 805208d:	0f 85 c5 00 00 00    	jne    8052158 <cmove_rm2r_l+0xe8>
	print_asm_template2();
 8052093:	83 ec 0c             	sub    $0xc,%esp
 8052096:	68 50 ae 8f 14       	push   $0x148fae50
 805209b:	68 18 ae 8f 14       	push   $0x148fae18
 80520a0:	68 32 1b 06 08       	push   $0x8061b32
 80520a5:	6a 50                	push   $0x50
 80520a7:	68 00 89 0c 08       	push   $0x80c8900
 80520ac:	e8 4f 6a ff ff       	call   8048b00 <snprintf@plt>
 80520b1:	83 c4 20             	add    $0x20,%esp
 80520b4:	83 f8 4f             	cmp    $0x4f,%eax
 80520b7:	7f 0f                	jg     80520c8 <cmove_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 80520b9:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80520bc:	8d 43 01             	lea    0x1(%ebx),%eax
 80520bf:	5b                   	pop    %ebx
 80520c0:	c3                   	ret    
 80520c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 80520c8:	83 ec 0c             	sub    $0xc,%esp
 80520cb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80520d1:	e8 8a 68 ff ff       	call   8048960 <fflush@plt>
 80520d6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80520dc:	6a 07                	push   $0x7
 80520de:	6a 01                	push   $0x1
 80520e0:	68 92 ed 05 08       	push   $0x805ed92
 80520e5:	e8 26 69 ff ff       	call   8048a10 <fwrite@plt>
 80520ea:	83 c4 20             	add    $0x20,%esp
 80520ed:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80520f3:	6a 10                	push   $0x10
 80520f5:	6a 01                	push   $0x1
 80520f7:	68 84 f8 05 08       	push   $0x805f884
 80520fc:	e8 0f 69 ff ff       	call   8048a10 <fwrite@plt>
 8052101:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052107:	6a 05                	push   $0x5
 8052109:	6a 01                	push   $0x1
 805210b:	68 b1 ed 05 08       	push   $0x805edb1
 8052110:	e8 fb 68 ff ff       	call   8048a10 <fwrite@plt>
 8052115:	83 c4 14             	add    $0x14,%esp
 8052118:	68 50 ae 8f 14       	push   $0x148fae50
 805211d:	68 18 ae 8f 14       	push   $0x148fae18
 8052122:	68 32 1b 06 08       	push   $0x8061b32
 8052127:	6a 50                	push   $0x50
 8052129:	68 00 89 0c 08       	push   $0x80c8900
 805212e:	e8 cd 69 ff ff       	call   8048b00 <snprintf@plt>
 8052133:	83 c4 20             	add    $0x20,%esp
 8052136:	83 f8 4f             	cmp    $0x4f,%eax
 8052139:	0f 8e 7a ff ff ff    	jle    80520b9 <cmove_rm2r_l+0x49>
 805213f:	68 f9 29 06 08       	push   $0x80629f9
 8052144:	6a 06                	push   $0x6
 8052146:	68 50 1c 06 08       	push   $0x8061c50
 805214b:	68 f4 20 06 08       	push   $0x80620f4
 8052150:	e8 5b 6a ff ff       	call   8048bb0 <__assert_fail@plt>
 8052155:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052158:	83 ec 08             	sub    $0x8,%esp
 805215b:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 8052161:	68 40 ae 8f 14       	push   $0x148fae40
 8052166:	e8 35 b2 00 00       	call   805d3a0 <write_operand_l>
 805216b:	83 c4 10             	add    $0x10,%esp
 805216e:	e9 20 ff ff ff       	jmp    8052093 <cmove_rm2r_l+0x23>
 8052173:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8052179:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052180 <cmovbe_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052180:	53                   	push   %ebx
 8052181:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052184:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052188:	83 c0 01             	add    $0x1,%eax
 805218b:	50                   	push   %eax
 805218c:	e8 af af 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052191:	83 c4 10             	add    $0x10,%esp
 8052194:	f6 05 e4 ae 8f 14 41 	testb  $0x41,0x148faee4
 805219b:	89 c3                	mov    %eax,%ebx
 805219d:	0f 85 c5 00 00 00    	jne    8052268 <cmovbe_rm2r_l+0xe8>
	print_asm_template2();
 80521a3:	83 ec 0c             	sub    $0xc,%esp
 80521a6:	68 50 ae 8f 14       	push   $0x148fae50
 80521ab:	68 18 ae 8f 14       	push   $0x148fae18
 80521b0:	68 3f 1b 06 08       	push   $0x8061b3f
 80521b5:	6a 50                	push   $0x50
 80521b7:	68 00 89 0c 08       	push   $0x80c8900
 80521bc:	e8 3f 69 ff ff       	call   8048b00 <snprintf@plt>
 80521c1:	83 c4 20             	add    $0x20,%esp
 80521c4:	83 f8 4f             	cmp    $0x4f,%eax
 80521c7:	7f 0f                	jg     80521d8 <cmovbe_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 80521c9:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80521cc:	8d 43 01             	lea    0x1(%ebx),%eax
 80521cf:	5b                   	pop    %ebx
 80521d0:	c3                   	ret    
 80521d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 80521d8:	83 ec 0c             	sub    $0xc,%esp
 80521db:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80521e1:	e8 7a 67 ff ff       	call   8048960 <fflush@plt>
 80521e6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80521ec:	6a 07                	push   $0x7
 80521ee:	6a 01                	push   $0x1
 80521f0:	68 92 ed 05 08       	push   $0x805ed92
 80521f5:	e8 16 68 ff ff       	call   8048a10 <fwrite@plt>
 80521fa:	83 c4 20             	add    $0x20,%esp
 80521fd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052203:	6a 10                	push   $0x10
 8052205:	6a 01                	push   $0x1
 8052207:	68 84 f8 05 08       	push   $0x805f884
 805220c:	e8 ff 67 ff ff       	call   8048a10 <fwrite@plt>
 8052211:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052217:	6a 05                	push   $0x5
 8052219:	6a 01                	push   $0x1
 805221b:	68 b1 ed 05 08       	push   $0x805edb1
 8052220:	e8 eb 67 ff ff       	call   8048a10 <fwrite@plt>
 8052225:	83 c4 14             	add    $0x14,%esp
 8052228:	68 50 ae 8f 14       	push   $0x148fae50
 805222d:	68 18 ae 8f 14       	push   $0x148fae18
 8052232:	68 3f 1b 06 08       	push   $0x8061b3f
 8052237:	6a 50                	push   $0x50
 8052239:	68 00 89 0c 08       	push   $0x80c8900
 805223e:	e8 bd 68 ff ff       	call   8048b00 <snprintf@plt>
 8052243:	83 c4 20             	add    $0x20,%esp
 8052246:	83 f8 4f             	cmp    $0x4f,%eax
 8052249:	0f 8e 7a ff ff ff    	jle    80521c9 <cmovbe_rm2r_l+0x49>
 805224f:	68 04 2a 06 08       	push   $0x8062a04
 8052254:	6a 06                	push   $0x6
 8052256:	68 50 1c 06 08       	push   $0x8061c50
 805225b:	68 5c 21 06 08       	push   $0x806215c
 8052260:	e8 4b 69 ff ff       	call   8048bb0 <__assert_fail@plt>
 8052265:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052268:	83 ec 08             	sub    $0x8,%esp
 805226b:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 8052271:	68 40 ae 8f 14       	push   $0x148fae40
 8052276:	e8 25 b1 00 00       	call   805d3a0 <write_operand_l>
 805227b:	83 c4 10             	add    $0x10,%esp
 805227e:	e9 20 ff ff ff       	jmp    80521a3 <cmovbe_rm2r_l+0x23>
 8052283:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8052289:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052290 <cmovge_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052290:	53                   	push   %ebx
 8052291:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052294:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052298:	83 c0 01             	add    $0x1,%eax
 805229b:	50                   	push   %eax
 805229c:	e8 cf aa 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80522a1:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 80522a8:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 80522af:	83 c4 10             	add    $0x10,%esp
 80522b2:	89 c3                	mov    %eax,%ebx
 80522b4:	c0 ea 03             	shr    $0x3,%dl
 80522b7:	c0 e9 07             	shr    $0x7,%cl
 80522ba:	83 e2 01             	and    $0x1,%edx
 80522bd:	38 d1                	cmp    %dl,%cl
 80522bf:	0f 84 c3 00 00 00    	je     8052388 <cmovge_rm2r_w+0xf8>
	print_asm_template2();
 80522c5:	83 ec 0c             	sub    $0xc,%esp
 80522c8:	68 50 ae 8f 14       	push   $0x148fae50
 80522cd:	68 18 ae 8f 14       	push   $0x148fae18
 80522d2:	68 4d 1b 06 08       	push   $0x8061b4d
 80522d7:	6a 50                	push   $0x50
 80522d9:	68 00 89 0c 08       	push   $0x80c8900
 80522de:	e8 1d 68 ff ff       	call   8048b00 <snprintf@plt>
 80522e3:	83 c4 20             	add    $0x20,%esp
 80522e6:	83 f8 4f             	cmp    $0x4f,%eax
 80522e9:	7f 0d                	jg     80522f8 <cmovge_rm2r_w+0x68>
}

make_instr_helper(rm2r)
 80522eb:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80522ee:	8d 43 01             	lea    0x1(%ebx),%eax
 80522f1:	5b                   	pop    %ebx
 80522f2:	c3                   	ret    
 80522f3:	90                   	nop
 80522f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 80522f8:	83 ec 0c             	sub    $0xc,%esp
 80522fb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8052301:	e8 5a 66 ff ff       	call   8048960 <fflush@plt>
 8052306:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805230c:	6a 07                	push   $0x7
 805230e:	6a 01                	push   $0x1
 8052310:	68 92 ed 05 08       	push   $0x805ed92
 8052315:	e8 f6 66 ff ff       	call   8048a10 <fwrite@plt>
 805231a:	83 c4 20             	add    $0x20,%esp
 805231d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052323:	6a 10                	push   $0x10
 8052325:	6a 01                	push   $0x1
 8052327:	68 84 f8 05 08       	push   $0x805f884
 805232c:	e8 df 66 ff ff       	call   8048a10 <fwrite@plt>
 8052331:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052337:	6a 05                	push   $0x5
 8052339:	6a 01                	push   $0x1
 805233b:	68 b1 ed 05 08       	push   $0x805edb1
 8052340:	e8 cb 66 ff ff       	call   8048a10 <fwrite@plt>
 8052345:	83 c4 14             	add    $0x14,%esp
 8052348:	68 50 ae 8f 14       	push   $0x148fae50
 805234d:	68 18 ae 8f 14       	push   $0x148fae18
 8052352:	68 4d 1b 06 08       	push   $0x8061b4d
 8052357:	6a 50                	push   $0x50
 8052359:	68 00 89 0c 08       	push   $0x80c8900
 805235e:	e8 9d 67 ff ff       	call   8048b00 <snprintf@plt>
 8052363:	83 c4 20             	add    $0x20,%esp
 8052366:	83 f8 4f             	cmp    $0x4f,%eax
 8052369:	7e 80                	jle    80522eb <cmovge_rm2r_w+0x5b>
 805236b:	68 9a 2a 06 08       	push   $0x8062a9a
 8052370:	6a 06                	push   $0x6
 8052372:	68 50 1c 06 08       	push   $0x8061c50
 8052377:	68 c4 21 06 08       	push   $0x80621c4
 805237c:	e8 2f 68 ff ff       	call   8048bb0 <__assert_fail@plt>
 8052381:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8052388:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 805238f:	83 ec 08             	sub    $0x8,%esp
 8052392:	50                   	push   %eax
 8052393:	68 40 ae 8f 14       	push   $0x148fae40
 8052398:	e8 33 ac 00 00       	call   805cfd0 <write_operand_w>
 805239d:	83 c4 10             	add    $0x10,%esp
 80523a0:	e9 20 ff ff ff       	jmp    80522c5 <cmovge_rm2r_w+0x35>
 80523a5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80523a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080523b0 <cmovl_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80523b0:	53                   	push   %ebx
 80523b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80523b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80523b8:	83 c0 01             	add    $0x1,%eax
 80523bb:	50                   	push   %eax
 80523bc:	e8 7f ad 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80523c1:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 80523c8:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 80523cf:	83 c4 10             	add    $0x10,%esp
 80523d2:	89 c3                	mov    %eax,%ebx
 80523d4:	c0 ea 03             	shr    $0x3,%dl
 80523d7:	c0 e9 07             	shr    $0x7,%cl
 80523da:	83 e2 01             	and    $0x1,%edx
 80523dd:	38 d1                	cmp    %dl,%cl
 80523df:	74 16                	je     80523f7 <cmovl_rm2r_l+0x47>
 80523e1:	83 ec 08             	sub    $0x8,%esp
 80523e4:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 80523ea:	68 40 ae 8f 14       	push   $0x148fae40
 80523ef:	e8 ac af 00 00       	call   805d3a0 <write_operand_l>
 80523f4:	83 c4 10             	add    $0x10,%esp
	print_asm_template2();
 80523f7:	83 ec 0c             	sub    $0xc,%esp
 80523fa:	68 50 ae 8f 14       	push   $0x148fae50
 80523ff:	68 18 ae 8f 14       	push   $0x148fae18
 8052404:	68 5b 1b 06 08       	push   $0x8061b5b
 8052409:	6a 50                	push   $0x50
 805240b:	68 00 89 0c 08       	push   $0x80c8900
 8052410:	e8 eb 66 ff ff       	call   8048b00 <snprintf@plt>
 8052415:	83 c4 20             	add    $0x20,%esp
 8052418:	83 f8 4f             	cmp    $0x4f,%eax
 805241b:	7f 0b                	jg     8052428 <cmovl_rm2r_l+0x78>
}

make_instr_helper(rm2r)
 805241d:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8052420:	8d 43 01             	lea    0x1(%ebx),%eax
 8052423:	5b                   	pop    %ebx
 8052424:	c3                   	ret    
 8052425:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052428:	83 ec 0c             	sub    $0xc,%esp
 805242b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8052431:	e8 2a 65 ff ff       	call   8048960 <fflush@plt>
 8052436:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805243c:	6a 07                	push   $0x7
 805243e:	6a 01                	push   $0x1
 8052440:	68 92 ed 05 08       	push   $0x805ed92
 8052445:	e8 c6 65 ff ff       	call   8048a10 <fwrite@plt>
 805244a:	83 c4 20             	add    $0x20,%esp
 805244d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052453:	6a 10                	push   $0x10
 8052455:	6a 01                	push   $0x1
 8052457:	68 84 f8 05 08       	push   $0x805f884
 805245c:	e8 af 65 ff ff       	call   8048a10 <fwrite@plt>
 8052461:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052467:	6a 05                	push   $0x5
 8052469:	6a 01                	push   $0x1
 805246b:	68 b1 ed 05 08       	push   $0x805edb1
 8052470:	e8 9b 65 ff ff       	call   8048a10 <fwrite@plt>
 8052475:	83 c4 14             	add    $0x14,%esp
 8052478:	68 50 ae 8f 14       	push   $0x148fae50
 805247d:	68 18 ae 8f 14       	push   $0x148fae18
 8052482:	68 5b 1b 06 08       	push   $0x8061b5b
 8052487:	6a 50                	push   $0x50
 8052489:	68 00 89 0c 08       	push   $0x80c8900
 805248e:	e8 6d 66 ff ff       	call   8048b00 <snprintf@plt>
 8052493:	83 c4 20             	add    $0x20,%esp
 8052496:	83 f8 4f             	cmp    $0x4f,%eax
 8052499:	7e 82                	jle    805241d <cmovl_rm2r_l+0x6d>
 805249b:	68 d7 29 06 08       	push   $0x80629d7
 80524a0:	6a 06                	push   $0x6
 80524a2:	68 50 1c 06 08       	push   $0x8061c50
 80524a7:	68 2c 22 06 08       	push   $0x806222c
 80524ac:	e8 ff 66 ff ff       	call   8048bb0 <__assert_fail@plt>
 80524b1:	eb 0d                	jmp    80524c0 <cmovb_rm2r_w>
 80524b3:	90                   	nop
 80524b4:	90                   	nop
 80524b5:	90                   	nop
 80524b6:	90                   	nop
 80524b7:	90                   	nop
 80524b8:	90                   	nop
 80524b9:	90                   	nop
 80524ba:	90                   	nop
 80524bb:	90                   	nop
 80524bc:	90                   	nop
 80524bd:	90                   	nop
 80524be:	90                   	nop
 80524bf:	90                   	nop

080524c0 <cmovb_rm2r_w>:
}

make_instr_helper(rm2r)
 80524c0:	53                   	push   %ebx
 80524c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80524c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80524c8:	83 c0 01             	add    $0x1,%eax
 80524cb:	50                   	push   %eax
 80524cc:	e8 9f a8 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80524d1:	83 c4 10             	add    $0x10,%esp
 80524d4:	f6 05 e4 ae 8f 14 01 	testb  $0x1,0x148faee4
 80524db:	89 c3                	mov    %eax,%ebx
 80524dd:	0f 85 c5 00 00 00    	jne    80525a8 <cmovb_rm2r_w+0xe8>
	print_asm_template2();
 80524e3:	83 ec 0c             	sub    $0xc,%esp
 80524e6:	68 50 ae 8f 14       	push   $0x148fae50
 80524eb:	68 18 ae 8f 14       	push   $0x148fae18
 80524f0:	68 68 1b 06 08       	push   $0x8061b68
 80524f5:	6a 50                	push   $0x50
 80524f7:	68 00 89 0c 08       	push   $0x80c8900
 80524fc:	e8 ff 65 ff ff       	call   8048b00 <snprintf@plt>
 8052501:	83 c4 20             	add    $0x20,%esp
 8052504:	83 f8 4f             	cmp    $0x4f,%eax
 8052507:	7f 0f                	jg     8052518 <cmovb_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052509:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805250c:	8d 43 01             	lea    0x1(%ebx),%eax
 805250f:	5b                   	pop    %ebx
 8052510:	c3                   	ret    
 8052511:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052518:	83 ec 0c             	sub    $0xc,%esp
 805251b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8052521:	e8 3a 64 ff ff       	call   8048960 <fflush@plt>
 8052526:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805252c:	6a 07                	push   $0x7
 805252e:	6a 01                	push   $0x1
 8052530:	68 92 ed 05 08       	push   $0x805ed92
 8052535:	e8 d6 64 ff ff       	call   8048a10 <fwrite@plt>
 805253a:	83 c4 20             	add    $0x20,%esp
 805253d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052543:	6a 10                	push   $0x10
 8052545:	6a 01                	push   $0x1
 8052547:	68 84 f8 05 08       	push   $0x805f884
 805254c:	e8 bf 64 ff ff       	call   8048a10 <fwrite@plt>
 8052551:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052557:	6a 05                	push   $0x5
 8052559:	6a 01                	push   $0x1
 805255b:	68 b1 ed 05 08       	push   $0x805edb1
 8052560:	e8 ab 64 ff ff       	call   8048a10 <fwrite@plt>
 8052565:	83 c4 14             	add    $0x14,%esp
 8052568:	68 50 ae 8f 14       	push   $0x148fae50
 805256d:	68 18 ae 8f 14       	push   $0x148fae18
 8052572:	68 68 1b 06 08       	push   $0x8061b68
 8052577:	6a 50                	push   $0x50
 8052579:	68 00 89 0c 08       	push   $0x80c8900
 805257e:	e8 7d 65 ff ff       	call   8048b00 <snprintf@plt>
 8052583:	83 c4 20             	add    $0x20,%esp
 8052586:	83 f8 4f             	cmp    $0x4f,%eax
 8052589:	0f 8e 7a ff ff ff    	jle    8052509 <cmovb_rm2r_w+0x49>
 805258f:	68 c8 2a 06 08       	push   $0x8062ac8
 8052594:	6a 06                	push   $0x6
 8052596:	68 50 1c 06 08       	push   $0x8061c50
 805259b:	68 94 22 06 08       	push   $0x8062294
 80525a0:	e8 0b 66 ff ff       	call   8048bb0 <__assert_fail@plt>
 80525a5:	8d 76 00             	lea    0x0(%esi),%esi
 80525a8:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80525af:	83 ec 08             	sub    $0x8,%esp
 80525b2:	50                   	push   %eax
 80525b3:	68 40 ae 8f 14       	push   $0x148fae40
 80525b8:	e8 13 aa 00 00       	call   805cfd0 <write_operand_w>
 80525bd:	83 c4 10             	add    $0x10,%esp
 80525c0:	e9 1e ff ff ff       	jmp    80524e3 <cmovb_rm2r_w+0x23>
 80525c5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80525c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080525d0 <cmova_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80525d0:	53                   	push   %ebx
 80525d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80525d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80525d8:	83 c0 01             	add    $0x1,%eax
 80525db:	50                   	push   %eax
 80525dc:	e8 8f a7 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80525e1:	83 c4 10             	add    $0x10,%esp
 80525e4:	f6 05 e4 ae 8f 14 41 	testb  $0x41,0x148faee4
 80525eb:	89 c3                	mov    %eax,%ebx
 80525ed:	0f 84 c5 00 00 00    	je     80526b8 <cmova_rm2r_w+0xe8>
	print_asm_template2();
 80525f3:	83 ec 0c             	sub    $0xc,%esp
 80525f6:	68 50 ae 8f 14       	push   $0x148fae50
 80525fb:	68 18 ae 8f 14       	push   $0x148fae18
 8052600:	68 75 1b 06 08       	push   $0x8061b75
 8052605:	6a 50                	push   $0x50
 8052607:	68 00 89 0c 08       	push   $0x80c8900
 805260c:	e8 ef 64 ff ff       	call   8048b00 <snprintf@plt>
 8052611:	83 c4 20             	add    $0x20,%esp
 8052614:	83 f8 4f             	cmp    $0x4f,%eax
 8052617:	7f 0f                	jg     8052628 <cmova_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052619:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805261c:	8d 43 01             	lea    0x1(%ebx),%eax
 805261f:	5b                   	pop    %ebx
 8052620:	c3                   	ret    
 8052621:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052628:	83 ec 0c             	sub    $0xc,%esp
 805262b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8052631:	e8 2a 63 ff ff       	call   8048960 <fflush@plt>
 8052636:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805263c:	6a 07                	push   $0x7
 805263e:	6a 01                	push   $0x1
 8052640:	68 92 ed 05 08       	push   $0x805ed92
 8052645:	e8 c6 63 ff ff       	call   8048a10 <fwrite@plt>
 805264a:	83 c4 20             	add    $0x20,%esp
 805264d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052653:	6a 10                	push   $0x10
 8052655:	6a 01                	push   $0x1
 8052657:	68 84 f8 05 08       	push   $0x805f884
 805265c:	e8 af 63 ff ff       	call   8048a10 <fwrite@plt>
 8052661:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052667:	6a 05                	push   $0x5
 8052669:	6a 01                	push   $0x1
 805266b:	68 b1 ed 05 08       	push   $0x805edb1
 8052670:	e8 9b 63 ff ff       	call   8048a10 <fwrite@plt>
 8052675:	83 c4 14             	add    $0x14,%esp
 8052678:	68 50 ae 8f 14       	push   $0x148fae50
 805267d:	68 18 ae 8f 14       	push   $0x148fae18
 8052682:	68 75 1b 06 08       	push   $0x8061b75
 8052687:	6a 50                	push   $0x50
 8052689:	68 00 89 0c 08       	push   $0x80c8900
 805268e:	e8 6d 64 ff ff       	call   8048b00 <snprintf@plt>
 8052693:	83 c4 20             	add    $0x20,%esp
 8052696:	83 f8 4f             	cmp    $0x4f,%eax
 8052699:	0f 8e 7a ff ff ff    	jle    8052619 <cmova_rm2r_w+0x49>
 805269f:	68 df 2a 06 08       	push   $0x8062adf
 80526a4:	6a 06                	push   $0x6
 80526a6:	68 50 1c 06 08       	push   $0x8061c50
 80526ab:	68 fc 22 06 08       	push   $0x80622fc
 80526b0:	e8 fb 64 ff ff       	call   8048bb0 <__assert_fail@plt>
 80526b5:	8d 76 00             	lea    0x0(%esi),%esi
 80526b8:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80526bf:	83 ec 08             	sub    $0x8,%esp
 80526c2:	50                   	push   %eax
 80526c3:	68 40 ae 8f 14       	push   $0x148fae40
 80526c8:	e8 03 a9 00 00       	call   805cfd0 <write_operand_w>
 80526cd:	83 c4 10             	add    $0x10,%esp
 80526d0:	e9 1e ff ff ff       	jmp    80525f3 <cmova_rm2r_w+0x23>
 80526d5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80526d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080526e0 <cmove_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80526e0:	53                   	push   %ebx
 80526e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80526e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80526e8:	83 c0 01             	add    $0x1,%eax
 80526eb:	50                   	push   %eax
 80526ec:	e8 7f a6 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80526f1:	83 c4 10             	add    $0x10,%esp
 80526f4:	f6 05 e4 ae 8f 14 40 	testb  $0x40,0x148faee4
 80526fb:	89 c3                	mov    %eax,%ebx
 80526fd:	0f 85 c5 00 00 00    	jne    80527c8 <cmove_rm2r_w+0xe8>
	print_asm_template2();
 8052703:	83 ec 0c             	sub    $0xc,%esp
 8052706:	68 50 ae 8f 14       	push   $0x148fae50
 805270b:	68 18 ae 8f 14       	push   $0x148fae18
 8052710:	68 82 1b 06 08       	push   $0x8061b82
 8052715:	6a 50                	push   $0x50
 8052717:	68 00 89 0c 08       	push   $0x80c8900
 805271c:	e8 df 63 ff ff       	call   8048b00 <snprintf@plt>
 8052721:	83 c4 20             	add    $0x20,%esp
 8052724:	83 f8 4f             	cmp    $0x4f,%eax
 8052727:	7f 0f                	jg     8052738 <cmove_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052729:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805272c:	8d 43 01             	lea    0x1(%ebx),%eax
 805272f:	5b                   	pop    %ebx
 8052730:	c3                   	ret    
 8052731:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052738:	83 ec 0c             	sub    $0xc,%esp
 805273b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8052741:	e8 1a 62 ff ff       	call   8048960 <fflush@plt>
 8052746:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805274c:	6a 07                	push   $0x7
 805274e:	6a 01                	push   $0x1
 8052750:	68 92 ed 05 08       	push   $0x805ed92
 8052755:	e8 b6 62 ff ff       	call   8048a10 <fwrite@plt>
 805275a:	83 c4 20             	add    $0x20,%esp
 805275d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052763:	6a 10                	push   $0x10
 8052765:	6a 01                	push   $0x1
 8052767:	68 84 f8 05 08       	push   $0x805f884
 805276c:	e8 9f 62 ff ff       	call   8048a10 <fwrite@plt>
 8052771:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052777:	6a 05                	push   $0x5
 8052779:	6a 01                	push   $0x1
 805277b:	68 b1 ed 05 08       	push   $0x805edb1
 8052780:	e8 8b 62 ff ff       	call   8048a10 <fwrite@plt>
 8052785:	83 c4 14             	add    $0x14,%esp
 8052788:	68 50 ae 8f 14       	push   $0x148fae50
 805278d:	68 18 ae 8f 14       	push   $0x148fae18
 8052792:	68 82 1b 06 08       	push   $0x8061b82
 8052797:	6a 50                	push   $0x50
 8052799:	68 00 89 0c 08       	push   $0x80c8900
 805279e:	e8 5d 63 ff ff       	call   8048b00 <snprintf@plt>
 80527a3:	83 c4 20             	add    $0x20,%esp
 80527a6:	83 f8 4f             	cmp    $0x4f,%eax
 80527a9:	0f 8e 7a ff ff ff    	jle    8052729 <cmove_rm2r_w+0x49>
 80527af:	68 b1 2a 06 08       	push   $0x8062ab1
 80527b4:	6a 06                	push   $0x6
 80527b6:	68 50 1c 06 08       	push   $0x8061c50
 80527bb:	68 64 23 06 08       	push   $0x8062364
 80527c0:	e8 eb 63 ff ff       	call   8048bb0 <__assert_fail@plt>
 80527c5:	8d 76 00             	lea    0x0(%esi),%esi
 80527c8:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80527cf:	83 ec 08             	sub    $0x8,%esp
 80527d2:	50                   	push   %eax
 80527d3:	68 40 ae 8f 14       	push   $0x148fae40
 80527d8:	e8 f3 a7 00 00       	call   805cfd0 <write_operand_w>
 80527dd:	83 c4 10             	add    $0x10,%esp
 80527e0:	e9 1e ff ff ff       	jmp    8052703 <cmove_rm2r_w+0x23>
 80527e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80527e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080527f0 <cmovae_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80527f0:	53                   	push   %ebx
 80527f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80527f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80527f8:	83 c0 01             	add    $0x1,%eax
 80527fb:	50                   	push   %eax
 80527fc:	e8 6f a5 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052801:	83 c4 10             	add    $0x10,%esp
 8052804:	f6 05 e4 ae 8f 14 01 	testb  $0x1,0x148faee4
 805280b:	89 c3                	mov    %eax,%ebx
 805280d:	0f 84 c5 00 00 00    	je     80528d8 <cmovae_rm2r_w+0xe8>
	print_asm_template2();
 8052813:	83 ec 0c             	sub    $0xc,%esp
 8052816:	68 50 ae 8f 14       	push   $0x148fae50
 805281b:	68 18 ae 8f 14       	push   $0x148fae18
 8052820:	68 8f 1b 06 08       	push   $0x8061b8f
 8052825:	6a 50                	push   $0x50
 8052827:	68 00 89 0c 08       	push   $0x80c8900
 805282c:	e8 cf 62 ff ff       	call   8048b00 <snprintf@plt>
 8052831:	83 c4 20             	add    $0x20,%esp
 8052834:	83 f8 4f             	cmp    $0x4f,%eax
 8052837:	7f 0f                	jg     8052848 <cmovae_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052839:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805283c:	8d 43 01             	lea    0x1(%ebx),%eax
 805283f:	5b                   	pop    %ebx
 8052840:	c3                   	ret    
 8052841:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052848:	83 ec 0c             	sub    $0xc,%esp
 805284b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8052851:	e8 0a 61 ff ff       	call   8048960 <fflush@plt>
 8052856:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805285c:	6a 07                	push   $0x7
 805285e:	6a 01                	push   $0x1
 8052860:	68 92 ed 05 08       	push   $0x805ed92
 8052865:	e8 a6 61 ff ff       	call   8048a10 <fwrite@plt>
 805286a:	83 c4 20             	add    $0x20,%esp
 805286d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052873:	6a 10                	push   $0x10
 8052875:	6a 01                	push   $0x1
 8052877:	68 84 f8 05 08       	push   $0x805f884
 805287c:	e8 8f 61 ff ff       	call   8048a10 <fwrite@plt>
 8052881:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052887:	6a 05                	push   $0x5
 8052889:	6a 01                	push   $0x1
 805288b:	68 b1 ed 05 08       	push   $0x805edb1
 8052890:	e8 7b 61 ff ff       	call   8048a10 <fwrite@plt>
 8052895:	83 c4 14             	add    $0x14,%esp
 8052898:	68 50 ae 8f 14       	push   $0x148fae50
 805289d:	68 18 ae 8f 14       	push   $0x148fae18
 80528a2:	68 8f 1b 06 08       	push   $0x8061b8f
 80528a7:	6a 50                	push   $0x50
 80528a9:	68 00 89 0c 08       	push   $0x80c8900
 80528ae:	e8 4d 62 ff ff       	call   8048b00 <snprintf@plt>
 80528b3:	83 c4 20             	add    $0x20,%esp
 80528b6:	83 f8 4f             	cmp    $0x4f,%eax
 80528b9:	0f 8e 7a ff ff ff    	jle    8052839 <cmovae_rm2r_w+0x49>
 80528bf:	68 d3 2a 06 08       	push   $0x8062ad3
 80528c4:	6a 06                	push   $0x6
 80528c6:	68 50 1c 06 08       	push   $0x8061c50
 80528cb:	68 cc 23 06 08       	push   $0x80623cc
 80528d0:	e8 db 62 ff ff       	call   8048bb0 <__assert_fail@plt>
 80528d5:	8d 76 00             	lea    0x0(%esi),%esi
 80528d8:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80528df:	83 ec 08             	sub    $0x8,%esp
 80528e2:	50                   	push   %eax
 80528e3:	68 40 ae 8f 14       	push   $0x148fae40
 80528e8:	e8 e3 a6 00 00       	call   805cfd0 <write_operand_w>
 80528ed:	83 c4 10             	add    $0x10,%esp
 80528f0:	e9 1e ff ff ff       	jmp    8052813 <cmovae_rm2r_w+0x23>
 80528f5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80528f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052900 <cmovbe_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052900:	53                   	push   %ebx
 8052901:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052904:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052908:	83 c0 01             	add    $0x1,%eax
 805290b:	50                   	push   %eax
 805290c:	e8 5f a4 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052911:	83 c4 10             	add    $0x10,%esp
 8052914:	f6 05 e4 ae 8f 14 41 	testb  $0x41,0x148faee4
 805291b:	89 c3                	mov    %eax,%ebx
 805291d:	0f 85 c5 00 00 00    	jne    80529e8 <cmovbe_rm2r_w+0xe8>
	print_asm_template2();
 8052923:	83 ec 0c             	sub    $0xc,%esp
 8052926:	68 50 ae 8f 14       	push   $0x148fae50
 805292b:	68 18 ae 8f 14       	push   $0x148fae18
 8052930:	68 9d 1b 06 08       	push   $0x8061b9d
 8052935:	6a 50                	push   $0x50
 8052937:	68 00 89 0c 08       	push   $0x80c8900
 805293c:	e8 bf 61 ff ff       	call   8048b00 <snprintf@plt>
 8052941:	83 c4 20             	add    $0x20,%esp
 8052944:	83 f8 4f             	cmp    $0x4f,%eax
 8052947:	7f 0f                	jg     8052958 <cmovbe_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052949:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805294c:	8d 43 01             	lea    0x1(%ebx),%eax
 805294f:	5b                   	pop    %ebx
 8052950:	c3                   	ret    
 8052951:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052958:	83 ec 0c             	sub    $0xc,%esp
 805295b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8052961:	e8 fa 5f ff ff       	call   8048960 <fflush@plt>
 8052966:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805296c:	6a 07                	push   $0x7
 805296e:	6a 01                	push   $0x1
 8052970:	68 92 ed 05 08       	push   $0x805ed92
 8052975:	e8 96 60 ff ff       	call   8048a10 <fwrite@plt>
 805297a:	83 c4 20             	add    $0x20,%esp
 805297d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052983:	6a 10                	push   $0x10
 8052985:	6a 01                	push   $0x1
 8052987:	68 84 f8 05 08       	push   $0x805f884
 805298c:	e8 7f 60 ff ff       	call   8048a10 <fwrite@plt>
 8052991:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052997:	6a 05                	push   $0x5
 8052999:	6a 01                	push   $0x1
 805299b:	68 b1 ed 05 08       	push   $0x805edb1
 80529a0:	e8 6b 60 ff ff       	call   8048a10 <fwrite@plt>
 80529a5:	83 c4 14             	add    $0x14,%esp
 80529a8:	68 50 ae 8f 14       	push   $0x148fae50
 80529ad:	68 18 ae 8f 14       	push   $0x148fae18
 80529b2:	68 9d 1b 06 08       	push   $0x8061b9d
 80529b7:	6a 50                	push   $0x50
 80529b9:	68 00 89 0c 08       	push   $0x80c8900
 80529be:	e8 3d 61 ff ff       	call   8048b00 <snprintf@plt>
 80529c3:	83 c4 20             	add    $0x20,%esp
 80529c6:	83 f8 4f             	cmp    $0x4f,%eax
 80529c9:	0f 8e 7a ff ff ff    	jle    8052949 <cmovbe_rm2r_w+0x49>
 80529cf:	68 bc 2a 06 08       	push   $0x8062abc
 80529d4:	6a 06                	push   $0x6
 80529d6:	68 50 1c 06 08       	push   $0x8061c50
 80529db:	68 34 24 06 08       	push   $0x8062434
 80529e0:	e8 cb 61 ff ff       	call   8048bb0 <__assert_fail@plt>
 80529e5:	8d 76 00             	lea    0x0(%esi),%esi
 80529e8:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80529ef:	83 ec 08             	sub    $0x8,%esp
 80529f2:	50                   	push   %eax
 80529f3:	68 40 ae 8f 14       	push   $0x148fae40
 80529f8:	e8 d3 a5 00 00       	call   805cfd0 <write_operand_w>
 80529fd:	83 c4 10             	add    $0x10,%esp
 8052a00:	e9 1e ff ff ff       	jmp    8052923 <cmovbe_rm2r_w+0x23>
 8052a05:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8052a09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052a10 <cmovp_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052a10:	53                   	push   %ebx
 8052a11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052a14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052a18:	83 c0 01             	add    $0x1,%eax
 8052a1b:	50                   	push   %eax
 8052a1c:	e8 4f a3 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052a21:	83 c4 10             	add    $0x10,%esp
 8052a24:	f6 05 e4 ae 8f 14 04 	testb  $0x4,0x148faee4
 8052a2b:	89 c3                	mov    %eax,%ebx
 8052a2d:	0f 85 c5 00 00 00    	jne    8052af8 <cmovp_rm2r_w+0xe8>
	print_asm_template2();
 8052a33:	83 ec 0c             	sub    $0xc,%esp
 8052a36:	68 50 ae 8f 14       	push   $0x148fae50
 8052a3b:	68 18 ae 8f 14       	push   $0x148fae18
 8052a40:	68 ab 1b 06 08       	push   $0x8061bab
 8052a45:	6a 50                	push   $0x50
 8052a47:	68 00 89 0c 08       	push   $0x80c8900
 8052a4c:	e8 af 60 ff ff       	call   8048b00 <snprintf@plt>
 8052a51:	83 c4 20             	add    $0x20,%esp
 8052a54:	83 f8 4f             	cmp    $0x4f,%eax
 8052a57:	7f 0f                	jg     8052a68 <cmovp_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052a59:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8052a5c:	8d 43 01             	lea    0x1(%ebx),%eax
 8052a5f:	5b                   	pop    %ebx
 8052a60:	c3                   	ret    
 8052a61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052a68:	83 ec 0c             	sub    $0xc,%esp
 8052a6b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8052a71:	e8 ea 5e ff ff       	call   8048960 <fflush@plt>
 8052a76:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052a7c:	6a 07                	push   $0x7
 8052a7e:	6a 01                	push   $0x1
 8052a80:	68 92 ed 05 08       	push   $0x805ed92
 8052a85:	e8 86 5f ff ff       	call   8048a10 <fwrite@plt>
 8052a8a:	83 c4 20             	add    $0x20,%esp
 8052a8d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052a93:	6a 10                	push   $0x10
 8052a95:	6a 01                	push   $0x1
 8052a97:	68 84 f8 05 08       	push   $0x805f884
 8052a9c:	e8 6f 5f ff ff       	call   8048a10 <fwrite@plt>
 8052aa1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052aa7:	6a 05                	push   $0x5
 8052aa9:	6a 01                	push   $0x1
 8052aab:	68 b1 ed 05 08       	push   $0x805edb1
 8052ab0:	e8 5b 5f ff ff       	call   8048a10 <fwrite@plt>
 8052ab5:	83 c4 14             	add    $0x14,%esp
 8052ab8:	68 50 ae 8f 14       	push   $0x148fae50
 8052abd:	68 18 ae 8f 14       	push   $0x148fae18
 8052ac2:	68 ab 1b 06 08       	push   $0x8061bab
 8052ac7:	6a 50                	push   $0x50
 8052ac9:	68 00 89 0c 08       	push   $0x80c8900
 8052ace:	e8 2d 60 ff ff       	call   8048b00 <snprintf@plt>
 8052ad3:	83 c4 20             	add    $0x20,%esp
 8052ad6:	83 f8 4f             	cmp    $0x4f,%eax
 8052ad9:	0f 8e 7a ff ff ff    	jle    8052a59 <cmovp_rm2r_w+0x49>
 8052adf:	68 3d 2a 06 08       	push   $0x8062a3d
 8052ae4:	6a 06                	push   $0x6
 8052ae6:	68 50 1c 06 08       	push   $0x8061c50
 8052aeb:	68 9c 24 06 08       	push   $0x806249c
 8052af0:	e8 bb 60 ff ff       	call   8048bb0 <__assert_fail@plt>
 8052af5:	8d 76 00             	lea    0x0(%esi),%esi
 8052af8:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052aff:	83 ec 08             	sub    $0x8,%esp
 8052b02:	50                   	push   %eax
 8052b03:	68 40 ae 8f 14       	push   $0x148fae40
 8052b08:	e8 c3 a4 00 00       	call   805cfd0 <write_operand_w>
 8052b0d:	83 c4 10             	add    $0x10,%esp
 8052b10:	e9 1e ff ff ff       	jmp    8052a33 <cmovp_rm2r_w+0x23>
 8052b15:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8052b19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052b20 <cmovno_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052b20:	53                   	push   %ebx
 8052b21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052b24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052b28:	83 c0 01             	add    $0x1,%eax
 8052b2b:	50                   	push   %eax
 8052b2c:	e8 3f a2 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052b31:	83 c4 10             	add    $0x10,%esp
 8052b34:	f6 05 e5 ae 8f 14 08 	testb  $0x8,0x148faee5
 8052b3b:	89 c3                	mov    %eax,%ebx
 8052b3d:	0f 84 c5 00 00 00    	je     8052c08 <cmovno_rm2r_w+0xe8>
	print_asm_template2();
 8052b43:	83 ec 0c             	sub    $0xc,%esp
 8052b46:	68 50 ae 8f 14       	push   $0x148fae50
 8052b4b:	68 18 ae 8f 14       	push   $0x148fae18
 8052b50:	68 b8 1b 06 08       	push   $0x8061bb8
 8052b55:	6a 50                	push   $0x50
 8052b57:	68 00 89 0c 08       	push   $0x80c8900
 8052b5c:	e8 9f 5f ff ff       	call   8048b00 <snprintf@plt>
 8052b61:	83 c4 20             	add    $0x20,%esp
 8052b64:	83 f8 4f             	cmp    $0x4f,%eax
 8052b67:	7f 0f                	jg     8052b78 <cmovno_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052b69:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8052b6c:	8d 43 01             	lea    0x1(%ebx),%eax
 8052b6f:	5b                   	pop    %ebx
 8052b70:	c3                   	ret    
 8052b71:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052b78:	83 ec 0c             	sub    $0xc,%esp
 8052b7b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8052b81:	e8 da 5d ff ff       	call   8048960 <fflush@plt>
 8052b86:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052b8c:	6a 07                	push   $0x7
 8052b8e:	6a 01                	push   $0x1
 8052b90:	68 92 ed 05 08       	push   $0x805ed92
 8052b95:	e8 76 5e ff ff       	call   8048a10 <fwrite@plt>
 8052b9a:	83 c4 20             	add    $0x20,%esp
 8052b9d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052ba3:	6a 10                	push   $0x10
 8052ba5:	6a 01                	push   $0x1
 8052ba7:	68 84 f8 05 08       	push   $0x805f884
 8052bac:	e8 5f 5e ff ff       	call   8048a10 <fwrite@plt>
 8052bb1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052bb7:	6a 05                	push   $0x5
 8052bb9:	6a 01                	push   $0x1
 8052bbb:	68 b1 ed 05 08       	push   $0x805edb1
 8052bc0:	e8 4b 5e ff ff       	call   8048a10 <fwrite@plt>
 8052bc5:	83 c4 14             	add    $0x14,%esp
 8052bc8:	68 50 ae 8f 14       	push   $0x148fae50
 8052bcd:	68 18 ae 8f 14       	push   $0x148fae18
 8052bd2:	68 b8 1b 06 08       	push   $0x8061bb8
 8052bd7:	6a 50                	push   $0x50
 8052bd9:	68 00 89 0c 08       	push   $0x80c8900
 8052bde:	e8 1d 5f ff ff       	call   8048b00 <snprintf@plt>
 8052be3:	83 c4 20             	add    $0x20,%esp
 8052be6:	83 f8 4f             	cmp    $0x4f,%eax
 8052be9:	0f 8e 7a ff ff ff    	jle    8052b69 <cmovno_rm2r_w+0x49>
 8052bef:	68 6b 2a 06 08       	push   $0x8062a6b
 8052bf4:	6a 06                	push   $0x6
 8052bf6:	68 50 1c 06 08       	push   $0x8061c50
 8052bfb:	68 04 25 06 08       	push   $0x8062504
 8052c00:	e8 ab 5f ff ff       	call   8048bb0 <__assert_fail@plt>
 8052c05:	8d 76 00             	lea    0x0(%esi),%esi
 8052c08:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052c0f:	83 ec 08             	sub    $0x8,%esp
 8052c12:	50                   	push   %eax
 8052c13:	68 40 ae 8f 14       	push   $0x148fae40
 8052c18:	e8 b3 a3 00 00       	call   805cfd0 <write_operand_w>
 8052c1d:	83 c4 10             	add    $0x10,%esp
 8052c20:	e9 1e ff ff ff       	jmp    8052b43 <cmovno_rm2r_w+0x23>
 8052c25:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8052c29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052c30 <cmovs_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052c30:	53                   	push   %ebx
 8052c31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052c34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052c38:	83 c0 01             	add    $0x1,%eax
 8052c3b:	50                   	push   %eax
 8052c3c:	e8 2f a1 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052c41:	83 c4 10             	add    $0x10,%esp
 8052c44:	80 3d e4 ae 8f 14 00 	cmpb   $0x0,0x148faee4
 8052c4b:	89 c3                	mov    %eax,%ebx
 8052c4d:	0f 88 c5 00 00 00    	js     8052d18 <cmovs_rm2r_w+0xe8>
	print_asm_template2();
 8052c53:	83 ec 0c             	sub    $0xc,%esp
 8052c56:	68 50 ae 8f 14       	push   $0x148fae50
 8052c5b:	68 18 ae 8f 14       	push   $0x148fae18
 8052c60:	68 c6 1b 06 08       	push   $0x8061bc6
 8052c65:	6a 50                	push   $0x50
 8052c67:	68 00 89 0c 08       	push   $0x80c8900
 8052c6c:	e8 8f 5e ff ff       	call   8048b00 <snprintf@plt>
 8052c71:	83 c4 20             	add    $0x20,%esp
 8052c74:	83 f8 4f             	cmp    $0x4f,%eax
 8052c77:	7f 0f                	jg     8052c88 <cmovs_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052c79:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8052c7c:	8d 43 01             	lea    0x1(%ebx),%eax
 8052c7f:	5b                   	pop    %ebx
 8052c80:	c3                   	ret    
 8052c81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052c88:	83 ec 0c             	sub    $0xc,%esp
 8052c8b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8052c91:	e8 ca 5c ff ff       	call   8048960 <fflush@plt>
 8052c96:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052c9c:	6a 07                	push   $0x7
 8052c9e:	6a 01                	push   $0x1
 8052ca0:	68 92 ed 05 08       	push   $0x805ed92
 8052ca5:	e8 66 5d ff ff       	call   8048a10 <fwrite@plt>
 8052caa:	83 c4 20             	add    $0x20,%esp
 8052cad:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052cb3:	6a 10                	push   $0x10
 8052cb5:	6a 01                	push   $0x1
 8052cb7:	68 84 f8 05 08       	push   $0x805f884
 8052cbc:	e8 4f 5d ff ff       	call   8048a10 <fwrite@plt>
 8052cc1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052cc7:	6a 05                	push   $0x5
 8052cc9:	6a 01                	push   $0x1
 8052ccb:	68 b1 ed 05 08       	push   $0x805edb1
 8052cd0:	e8 3b 5d ff ff       	call   8048a10 <fwrite@plt>
 8052cd5:	83 c4 14             	add    $0x14,%esp
 8052cd8:	68 50 ae 8f 14       	push   $0x148fae50
 8052cdd:	68 18 ae 8f 14       	push   $0x148fae18
 8052ce2:	68 c6 1b 06 08       	push   $0x8061bc6
 8052ce7:	6a 50                	push   $0x50
 8052ce9:	68 00 89 0c 08       	push   $0x80c8900
 8052cee:	e8 0d 5e ff ff       	call   8048b00 <snprintf@plt>
 8052cf3:	83 c4 20             	add    $0x20,%esp
 8052cf6:	83 f8 4f             	cmp    $0x4f,%eax
 8052cf9:	0f 8e 7a ff ff ff    	jle    8052c79 <cmovs_rm2r_w+0x49>
 8052cff:	68 32 2a 06 08       	push   $0x8062a32
 8052d04:	6a 06                	push   $0x6
 8052d06:	68 50 1c 06 08       	push   $0x8061c50
 8052d0b:	68 6c 25 06 08       	push   $0x806256c
 8052d10:	e8 9b 5e ff ff       	call   8048bb0 <__assert_fail@plt>
 8052d15:	8d 76 00             	lea    0x0(%esi),%esi
 8052d18:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052d1f:	83 ec 08             	sub    $0x8,%esp
 8052d22:	50                   	push   %eax
 8052d23:	68 40 ae 8f 14       	push   $0x148fae40
 8052d28:	e8 a3 a2 00 00       	call   805cfd0 <write_operand_w>
 8052d2d:	83 c4 10             	add    $0x10,%esp
 8052d30:	e9 1e ff ff ff       	jmp    8052c53 <cmovs_rm2r_w+0x23>
 8052d35:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8052d39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052d40 <cmovne_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052d40:	53                   	push   %ebx
 8052d41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052d44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052d48:	83 c0 01             	add    $0x1,%eax
 8052d4b:	50                   	push   %eax
 8052d4c:	e8 1f a0 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052d51:	83 c4 10             	add    $0x10,%esp
 8052d54:	f6 05 e4 ae 8f 14 40 	testb  $0x40,0x148faee4
 8052d5b:	89 c3                	mov    %eax,%ebx
 8052d5d:	0f 84 c5 00 00 00    	je     8052e28 <cmovne_rm2r_w+0xe8>
	print_asm_template2();
 8052d63:	83 ec 0c             	sub    $0xc,%esp
 8052d66:	68 50 ae 8f 14       	push   $0x148fae50
 8052d6b:	68 18 ae 8f 14       	push   $0x148fae18
 8052d70:	68 d3 1b 06 08       	push   $0x8061bd3
 8052d75:	6a 50                	push   $0x50
 8052d77:	68 00 89 0c 08       	push   $0x80c8900
 8052d7c:	e8 7f 5d ff ff       	call   8048b00 <snprintf@plt>
 8052d81:	83 c4 20             	add    $0x20,%esp
 8052d84:	83 f8 4f             	cmp    $0x4f,%eax
 8052d87:	7f 0f                	jg     8052d98 <cmovne_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052d89:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8052d8c:	8d 43 01             	lea    0x1(%ebx),%eax
 8052d8f:	5b                   	pop    %ebx
 8052d90:	c3                   	ret    
 8052d91:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052d98:	83 ec 0c             	sub    $0xc,%esp
 8052d9b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8052da1:	e8 ba 5b ff ff       	call   8048960 <fflush@plt>
 8052da6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052dac:	6a 07                	push   $0x7
 8052dae:	6a 01                	push   $0x1
 8052db0:	68 92 ed 05 08       	push   $0x805ed92
 8052db5:	e8 56 5c ff ff       	call   8048a10 <fwrite@plt>
 8052dba:	83 c4 20             	add    $0x20,%esp
 8052dbd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052dc3:	6a 10                	push   $0x10
 8052dc5:	6a 01                	push   $0x1
 8052dc7:	68 84 f8 05 08       	push   $0x805f884
 8052dcc:	e8 3f 5c ff ff       	call   8048a10 <fwrite@plt>
 8052dd1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052dd7:	6a 05                	push   $0x5
 8052dd9:	6a 01                	push   $0x1
 8052ddb:	68 b1 ed 05 08       	push   $0x805edb1
 8052de0:	e8 2b 5c ff ff       	call   8048a10 <fwrite@plt>
 8052de5:	83 c4 14             	add    $0x14,%esp
 8052de8:	68 50 ae 8f 14       	push   $0x148fae50
 8052ded:	68 18 ae 8f 14       	push   $0x148fae18
 8052df2:	68 d3 1b 06 08       	push   $0x8061bd3
 8052df7:	6a 50                	push   $0x50
 8052df9:	68 00 89 0c 08       	push   $0x80c8900
 8052dfe:	e8 fd 5c ff ff       	call   8048b00 <snprintf@plt>
 8052e03:	83 c4 20             	add    $0x20,%esp
 8052e06:	83 f8 4f             	cmp    $0x4f,%eax
 8052e09:	0f 8e 7a ff ff ff    	jle    8052d89 <cmovne_rm2r_w+0x49>
 8052e0f:	68 77 2a 06 08       	push   $0x8062a77
 8052e14:	6a 06                	push   $0x6
 8052e16:	68 50 1c 06 08       	push   $0x8061c50
 8052e1b:	68 d4 25 06 08       	push   $0x80625d4
 8052e20:	e8 8b 5d ff ff       	call   8048bb0 <__assert_fail@plt>
 8052e25:	8d 76 00             	lea    0x0(%esi),%esi
 8052e28:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052e2f:	83 ec 08             	sub    $0x8,%esp
 8052e32:	50                   	push   %eax
 8052e33:	68 40 ae 8f 14       	push   $0x148fae40
 8052e38:	e8 93 a1 00 00       	call   805cfd0 <write_operand_w>
 8052e3d:	83 c4 10             	add    $0x10,%esp
 8052e40:	e9 1e ff ff ff       	jmp    8052d63 <cmovne_rm2r_w+0x23>
 8052e45:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8052e49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052e50 <cmovns_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052e50:	53                   	push   %ebx
 8052e51:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052e54:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052e58:	83 c0 01             	add    $0x1,%eax
 8052e5b:	50                   	push   %eax
 8052e5c:	e8 0f 9f 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052e61:	83 c4 10             	add    $0x10,%esp
 8052e64:	80 3d e4 ae 8f 14 00 	cmpb   $0x0,0x148faee4
 8052e6b:	89 c3                	mov    %eax,%ebx
 8052e6d:	0f 89 c5 00 00 00    	jns    8052f38 <cmovns_rm2r_w+0xe8>
	print_asm_template2();
 8052e73:	83 ec 0c             	sub    $0xc,%esp
 8052e76:	68 50 ae 8f 14       	push   $0x148fae50
 8052e7b:	68 18 ae 8f 14       	push   $0x148fae18
 8052e80:	68 e1 1b 06 08       	push   $0x8061be1
 8052e85:	6a 50                	push   $0x50
 8052e87:	68 00 89 0c 08       	push   $0x80c8900
 8052e8c:	e8 6f 5c ff ff       	call   8048b00 <snprintf@plt>
 8052e91:	83 c4 20             	add    $0x20,%esp
 8052e94:	83 f8 4f             	cmp    $0x4f,%eax
 8052e97:	7f 0f                	jg     8052ea8 <cmovns_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052e99:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8052e9c:	8d 43 01             	lea    0x1(%ebx),%eax
 8052e9f:	5b                   	pop    %ebx
 8052ea0:	c3                   	ret    
 8052ea1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052ea8:	83 ec 0c             	sub    $0xc,%esp
 8052eab:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8052eb1:	e8 aa 5a ff ff       	call   8048960 <fflush@plt>
 8052eb6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052ebc:	6a 07                	push   $0x7
 8052ebe:	6a 01                	push   $0x1
 8052ec0:	68 92 ed 05 08       	push   $0x805ed92
 8052ec5:	e8 46 5b ff ff       	call   8048a10 <fwrite@plt>
 8052eca:	83 c4 20             	add    $0x20,%esp
 8052ecd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052ed3:	6a 10                	push   $0x10
 8052ed5:	6a 01                	push   $0x1
 8052ed7:	68 84 f8 05 08       	push   $0x805f884
 8052edc:	e8 2f 5b ff ff       	call   8048a10 <fwrite@plt>
 8052ee1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052ee7:	6a 05                	push   $0x5
 8052ee9:	6a 01                	push   $0x1
 8052eeb:	68 b1 ed 05 08       	push   $0x805edb1
 8052ef0:	e8 1b 5b ff ff       	call   8048a10 <fwrite@plt>
 8052ef5:	83 c4 14             	add    $0x14,%esp
 8052ef8:	68 50 ae 8f 14       	push   $0x148fae50
 8052efd:	68 18 ae 8f 14       	push   $0x148fae18
 8052f02:	68 e1 1b 06 08       	push   $0x8061be1
 8052f07:	6a 50                	push   $0x50
 8052f09:	68 00 89 0c 08       	push   $0x80c8900
 8052f0e:	e8 ed 5b ff ff       	call   8048b00 <snprintf@plt>
 8052f13:	83 c4 20             	add    $0x20,%esp
 8052f16:	83 f8 4f             	cmp    $0x4f,%eax
 8052f19:	0f 8e 7a ff ff ff    	jle    8052e99 <cmovns_rm2r_w+0x49>
 8052f1f:	68 53 2a 06 08       	push   $0x8062a53
 8052f24:	6a 06                	push   $0x6
 8052f26:	68 50 1c 06 08       	push   $0x8061c50
 8052f2b:	68 3c 26 06 08       	push   $0x806263c
 8052f30:	e8 7b 5c ff ff       	call   8048bb0 <__assert_fail@plt>
 8052f35:	8d 76 00             	lea    0x0(%esi),%esi
 8052f38:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052f3f:	83 ec 08             	sub    $0x8,%esp
 8052f42:	50                   	push   %eax
 8052f43:	68 40 ae 8f 14       	push   $0x148fae40
 8052f48:	e8 83 a0 00 00       	call   805cfd0 <write_operand_w>
 8052f4d:	83 c4 10             	add    $0x10,%esp
 8052f50:	e9 1e ff ff ff       	jmp    8052e73 <cmovns_rm2r_w+0x23>
 8052f55:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8052f59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052f60 <cmovnp_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052f60:	53                   	push   %ebx
 8052f61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052f64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052f68:	83 c0 01             	add    $0x1,%eax
 8052f6b:	50                   	push   %eax
 8052f6c:	e8 ff 9d 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052f71:	83 c4 10             	add    $0x10,%esp
 8052f74:	f6 05 e4 ae 8f 14 04 	testb  $0x4,0x148faee4
 8052f7b:	89 c3                	mov    %eax,%ebx
 8052f7d:	0f 84 c5 00 00 00    	je     8053048 <cmovnp_rm2r_w+0xe8>
	print_asm_template2();
 8052f83:	83 ec 0c             	sub    $0xc,%esp
 8052f86:	68 50 ae 8f 14       	push   $0x148fae50
 8052f8b:	68 18 ae 8f 14       	push   $0x148fae18
 8052f90:	68 ef 1b 06 08       	push   $0x8061bef
 8052f95:	6a 50                	push   $0x50
 8052f97:	68 00 89 0c 08       	push   $0x80c8900
 8052f9c:	e8 5f 5b ff ff       	call   8048b00 <snprintf@plt>
 8052fa1:	83 c4 20             	add    $0x20,%esp
 8052fa4:	83 f8 4f             	cmp    $0x4f,%eax
 8052fa7:	7f 0f                	jg     8052fb8 <cmovnp_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052fa9:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8052fac:	8d 43 01             	lea    0x1(%ebx),%eax
 8052faf:	5b                   	pop    %ebx
 8052fb0:	c3                   	ret    
 8052fb1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052fb8:	83 ec 0c             	sub    $0xc,%esp
 8052fbb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8052fc1:	e8 9a 59 ff ff       	call   8048960 <fflush@plt>
 8052fc6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052fcc:	6a 07                	push   $0x7
 8052fce:	6a 01                	push   $0x1
 8052fd0:	68 92 ed 05 08       	push   $0x805ed92
 8052fd5:	e8 36 5a ff ff       	call   8048a10 <fwrite@plt>
 8052fda:	83 c4 20             	add    $0x20,%esp
 8052fdd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052fe3:	6a 10                	push   $0x10
 8052fe5:	6a 01                	push   $0x1
 8052fe7:	68 84 f8 05 08       	push   $0x805f884
 8052fec:	e8 1f 5a ff ff       	call   8048a10 <fwrite@plt>
 8052ff1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8052ff7:	6a 05                	push   $0x5
 8052ff9:	6a 01                	push   $0x1
 8052ffb:	68 b1 ed 05 08       	push   $0x805edb1
 8053000:	e8 0b 5a ff ff       	call   8048a10 <fwrite@plt>
 8053005:	83 c4 14             	add    $0x14,%esp
 8053008:	68 50 ae 8f 14       	push   $0x148fae50
 805300d:	68 18 ae 8f 14       	push   $0x148fae18
 8053012:	68 ef 1b 06 08       	push   $0x8061bef
 8053017:	6a 50                	push   $0x50
 8053019:	68 00 89 0c 08       	push   $0x80c8900
 805301e:	e8 dd 5a ff ff       	call   8048b00 <snprintf@plt>
 8053023:	83 c4 20             	add    $0x20,%esp
 8053026:	83 f8 4f             	cmp    $0x4f,%eax
 8053029:	0f 8e 7a ff ff ff    	jle    8052fa9 <cmovnp_rm2r_w+0x49>
 805302f:	68 5f 2a 06 08       	push   $0x8062a5f
 8053034:	6a 06                	push   $0x6
 8053036:	68 50 1c 06 08       	push   $0x8061c50
 805303b:	68 a4 26 06 08       	push   $0x80626a4
 8053040:	e8 6b 5b ff ff       	call   8048bb0 <__assert_fail@plt>
 8053045:	8d 76 00             	lea    0x0(%esi),%esi
 8053048:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 805304f:	83 ec 08             	sub    $0x8,%esp
 8053052:	50                   	push   %eax
 8053053:	68 40 ae 8f 14       	push   $0x148fae40
 8053058:	e8 73 9f 00 00       	call   805cfd0 <write_operand_w>
 805305d:	83 c4 10             	add    $0x10,%esp
 8053060:	e9 1e ff ff ff       	jmp    8052f83 <cmovnp_rm2r_w+0x23>
 8053065:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8053069:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08053070 <cmovo_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8053070:	53                   	push   %ebx
 8053071:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053074:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053078:	83 c0 01             	add    $0x1,%eax
 805307b:	50                   	push   %eax
 805307c:	e8 ef 9c 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8053081:	83 c4 10             	add    $0x10,%esp
 8053084:	f6 05 e5 ae 8f 14 08 	testb  $0x8,0x148faee5
 805308b:	89 c3                	mov    %eax,%ebx
 805308d:	0f 85 c5 00 00 00    	jne    8053158 <cmovo_rm2r_w+0xe8>
	print_asm_template2();
 8053093:	83 ec 0c             	sub    $0xc,%esp
 8053096:	68 50 ae 8f 14       	push   $0x148fae50
 805309b:	68 18 ae 8f 14       	push   $0x148fae18
 80530a0:	68 fd 1b 06 08       	push   $0x8061bfd
 80530a5:	6a 50                	push   $0x50
 80530a7:	68 00 89 0c 08       	push   $0x80c8900
 80530ac:	e8 4f 5a ff ff       	call   8048b00 <snprintf@plt>
 80530b1:	83 c4 20             	add    $0x20,%esp
 80530b4:	83 f8 4f             	cmp    $0x4f,%eax
 80530b7:	7f 0f                	jg     80530c8 <cmovo_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 80530b9:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80530bc:	8d 43 01             	lea    0x1(%ebx),%eax
 80530bf:	5b                   	pop    %ebx
 80530c0:	c3                   	ret    
 80530c1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 80530c8:	83 ec 0c             	sub    $0xc,%esp
 80530cb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80530d1:	e8 8a 58 ff ff       	call   8048960 <fflush@plt>
 80530d6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80530dc:	6a 07                	push   $0x7
 80530de:	6a 01                	push   $0x1
 80530e0:	68 92 ed 05 08       	push   $0x805ed92
 80530e5:	e8 26 59 ff ff       	call   8048a10 <fwrite@plt>
 80530ea:	83 c4 20             	add    $0x20,%esp
 80530ed:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80530f3:	6a 10                	push   $0x10
 80530f5:	6a 01                	push   $0x1
 80530f7:	68 84 f8 05 08       	push   $0x805f884
 80530fc:	e8 0f 59 ff ff       	call   8048a10 <fwrite@plt>
 8053101:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053107:	6a 05                	push   $0x5
 8053109:	6a 01                	push   $0x1
 805310b:	68 b1 ed 05 08       	push   $0x805edb1
 8053110:	e8 fb 58 ff ff       	call   8048a10 <fwrite@plt>
 8053115:	83 c4 14             	add    $0x14,%esp
 8053118:	68 50 ae 8f 14       	push   $0x148fae50
 805311d:	68 18 ae 8f 14       	push   $0x148fae18
 8053122:	68 fd 1b 06 08       	push   $0x8061bfd
 8053127:	6a 50                	push   $0x50
 8053129:	68 00 89 0c 08       	push   $0x80c8900
 805312e:	e8 cd 59 ff ff       	call   8048b00 <snprintf@plt>
 8053133:	83 c4 20             	add    $0x20,%esp
 8053136:	83 f8 4f             	cmp    $0x4f,%eax
 8053139:	0f 8e 7a ff ff ff    	jle    80530b9 <cmovo_rm2r_w+0x49>
 805313f:	68 48 2a 06 08       	push   $0x8062a48
 8053144:	6a 06                	push   $0x6
 8053146:	68 50 1c 06 08       	push   $0x8061c50
 805314b:	68 0c 27 06 08       	push   $0x806270c
 8053150:	e8 5b 5a ff ff       	call   8048bb0 <__assert_fail@plt>
 8053155:	8d 76 00             	lea    0x0(%esi),%esi
 8053158:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 805315f:	83 ec 08             	sub    $0x8,%esp
 8053162:	50                   	push   %eax
 8053163:	68 40 ae 8f 14       	push   $0x148fae40
 8053168:	e8 63 9e 00 00       	call   805cfd0 <write_operand_w>
 805316d:	83 c4 10             	add    $0x10,%esp
 8053170:	e9 1e ff ff ff       	jmp    8053093 <cmovo_rm2r_w+0x23>
 8053175:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8053179:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08053180 <cmovl_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8053180:	53                   	push   %ebx
 8053181:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053184:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053188:	83 c0 01             	add    $0x1,%eax
 805318b:	50                   	push   %eax
 805318c:	e8 df 9b 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8053191:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 8053198:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 805319f:	83 c4 10             	add    $0x10,%esp
 80531a2:	89 c3                	mov    %eax,%ebx
 80531a4:	c0 ea 03             	shr    $0x3,%dl
 80531a7:	c0 e9 07             	shr    $0x7,%cl
 80531aa:	83 e2 01             	and    $0x1,%edx
 80531ad:	38 d1                	cmp    %dl,%cl
 80531af:	74 18                	je     80531c9 <cmovl_rm2r_w+0x49>
 80531b1:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
 80531b8:	83 ec 08             	sub    $0x8,%esp
 80531bb:	50                   	push   %eax
 80531bc:	68 40 ae 8f 14       	push   $0x148fae40
 80531c1:	e8 0a 9e 00 00       	call   805cfd0 <write_operand_w>
 80531c6:	83 c4 10             	add    $0x10,%esp
	print_asm_template2();
 80531c9:	83 ec 0c             	sub    $0xc,%esp
 80531cc:	68 50 ae 8f 14       	push   $0x148fae50
 80531d1:	68 18 ae 8f 14       	push   $0x148fae18
 80531d6:	68 0a 1c 06 08       	push   $0x8061c0a
 80531db:	6a 50                	push   $0x50
 80531dd:	68 00 89 0c 08       	push   $0x80c8900
 80531e2:	e8 19 59 ff ff       	call   8048b00 <snprintf@plt>
 80531e7:	83 c4 20             	add    $0x20,%esp
 80531ea:	83 f8 4f             	cmp    $0x4f,%eax
 80531ed:	7f 11                	jg     8053200 <cmovl_rm2r_w+0x80>
}

make_instr_helper(rm2r)
 80531ef:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80531f2:	8d 43 01             	lea    0x1(%ebx),%eax
 80531f5:	5b                   	pop    %ebx
 80531f6:	c3                   	ret    
 80531f7:	89 f6                	mov    %esi,%esi
 80531f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8053200:	83 ec 0c             	sub    $0xc,%esp
 8053203:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8053209:	e8 52 57 ff ff       	call   8048960 <fflush@plt>
 805320e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053214:	6a 07                	push   $0x7
 8053216:	6a 01                	push   $0x1
 8053218:	68 92 ed 05 08       	push   $0x805ed92
 805321d:	e8 ee 57 ff ff       	call   8048a10 <fwrite@plt>
 8053222:	83 c4 20             	add    $0x20,%esp
 8053225:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805322b:	6a 10                	push   $0x10
 805322d:	6a 01                	push   $0x1
 805322f:	68 84 f8 05 08       	push   $0x805f884
 8053234:	e8 d7 57 ff ff       	call   8048a10 <fwrite@plt>
 8053239:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805323f:	6a 05                	push   $0x5
 8053241:	6a 01                	push   $0x1
 8053243:	68 b1 ed 05 08       	push   $0x805edb1
 8053248:	e8 c3 57 ff ff       	call   8048a10 <fwrite@plt>
 805324d:	83 c4 14             	add    $0x14,%esp
 8053250:	68 50 ae 8f 14       	push   $0x148fae50
 8053255:	68 18 ae 8f 14       	push   $0x148fae18
 805325a:	68 0a 1c 06 08       	push   $0x8061c0a
 805325f:	6a 50                	push   $0x50
 8053261:	68 00 89 0c 08       	push   $0x80c8900
 8053266:	e8 95 58 ff ff       	call   8048b00 <snprintf@plt>
 805326b:	83 c4 20             	add    $0x20,%esp
 805326e:	83 f8 4f             	cmp    $0x4f,%eax
 8053271:	0f 8e 78 ff ff ff    	jle    80531ef <cmovl_rm2r_w+0x6f>
 8053277:	68 8f 2a 06 08       	push   $0x8062a8f
 805327c:	6a 06                	push   $0x6
 805327e:	68 50 1c 06 08       	push   $0x8061c50
 8053283:	68 74 27 06 08       	push   $0x8062774
 8053288:	e8 23 59 ff ff       	call   8048bb0 <__assert_fail@plt>
 805328d:	8d 76 00             	lea    0x0(%esi),%esi

08053290 <cmovg_rm2r_l>:
}

make_instr_helper(rm2r)
 8053290:	53                   	push   %ebx
 8053291:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053294:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053298:	83 c0 01             	add    $0x1,%eax
 805329b:	50                   	push   %eax
 805329c:	e8 9f 9e 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80532a1:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 80532a8:	89 c3                	mov    %eax,%ebx
 80532aa:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 80532b1:	83 c4 10             	add    $0x10,%esp
 80532b4:	c0 ea 03             	shr    $0x3,%dl
 80532b7:	89 c1                	mov    %eax,%ecx
 80532b9:	c0 e9 07             	shr    $0x7,%cl
 80532bc:	83 e2 01             	and    $0x1,%edx
 80532bf:	38 d1                	cmp    %dl,%cl
 80532c1:	0f 84 c1 00 00 00    	je     8053388 <cmovg_rm2r_l+0xf8>
	print_asm_template2();
 80532c7:	83 ec 0c             	sub    $0xc,%esp
 80532ca:	68 50 ae 8f 14       	push   $0x148fae50
 80532cf:	68 18 ae 8f 14       	push   $0x148fae18
 80532d4:	68 17 1c 06 08       	push   $0x8061c17
 80532d9:	6a 50                	push   $0x50
 80532db:	68 00 89 0c 08       	push   $0x80c8900
 80532e0:	e8 1b 58 ff ff       	call   8048b00 <snprintf@plt>
 80532e5:	83 c4 20             	add    $0x20,%esp
 80532e8:	83 f8 4f             	cmp    $0x4f,%eax
 80532eb:	7f 0b                	jg     80532f8 <cmovg_rm2r_l+0x68>
}

make_instr_helper(rm2r)
 80532ed:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80532f0:	8d 43 01             	lea    0x1(%ebx),%eax
 80532f3:	5b                   	pop    %ebx
 80532f4:	c3                   	ret    
 80532f5:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 80532f8:	83 ec 0c             	sub    $0xc,%esp
 80532fb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8053301:	e8 5a 56 ff ff       	call   8048960 <fflush@plt>
 8053306:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805330c:	6a 07                	push   $0x7
 805330e:	6a 01                	push   $0x1
 8053310:	68 92 ed 05 08       	push   $0x805ed92
 8053315:	e8 f6 56 ff ff       	call   8048a10 <fwrite@plt>
 805331a:	83 c4 20             	add    $0x20,%esp
 805331d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053323:	6a 10                	push   $0x10
 8053325:	6a 01                	push   $0x1
 8053327:	68 84 f8 05 08       	push   $0x805f884
 805332c:	e8 df 56 ff ff       	call   8048a10 <fwrite@plt>
 8053331:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053337:	6a 05                	push   $0x5
 8053339:	6a 01                	push   $0x1
 805333b:	68 b1 ed 05 08       	push   $0x805edb1
 8053340:	e8 cb 56 ff ff       	call   8048a10 <fwrite@plt>
 8053345:	83 c4 14             	add    $0x14,%esp
 8053348:	68 50 ae 8f 14       	push   $0x148fae50
 805334d:	68 18 ae 8f 14       	push   $0x148fae18
 8053352:	68 17 1c 06 08       	push   $0x8061c17
 8053357:	6a 50                	push   $0x50
 8053359:	68 00 89 0c 08       	push   $0x80c8900
 805335e:	e8 9d 57 ff ff       	call   8048b00 <snprintf@plt>
 8053363:	83 c4 20             	add    $0x20,%esp
 8053366:	83 f8 4f             	cmp    $0x4f,%eax
 8053369:	0f 8e 7e ff ff ff    	jle    80532ed <cmovg_rm2r_l+0x5d>
 805336f:	68 ee 29 06 08       	push   $0x80629ee
 8053374:	6a 06                	push   $0x6
 8053376:	68 50 1c 06 08       	push   $0x8061c50
 805337b:	68 dc 27 06 08       	push   $0x80627dc
 8053380:	e8 2b 58 ff ff       	call   8048bb0 <__assert_fail@plt>
 8053385:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8053388:	a8 40                	test   $0x40,%al
 805338a:	0f 85 37 ff ff ff    	jne    80532c7 <cmovg_rm2r_l+0x37>
 8053390:	83 ec 08             	sub    $0x8,%esp
 8053393:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 8053399:	68 40 ae 8f 14       	push   $0x148fae40
 805339e:	e8 fd 9f 00 00       	call   805d3a0 <write_operand_l>
 80533a3:	83 c4 10             	add    $0x10,%esp
 80533a6:	e9 1c ff ff ff       	jmp    80532c7 <cmovg_rm2r_l+0x37>
 80533ab:	90                   	nop
 80533ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080533b0 <cmovg_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80533b0:	53                   	push   %ebx
 80533b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80533b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80533b8:	83 c0 01             	add    $0x1,%eax
 80533bb:	50                   	push   %eax
 80533bc:	e8 af 99 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80533c1:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 80533c8:	89 c3                	mov    %eax,%ebx
 80533ca:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 80533d1:	83 c4 10             	add    $0x10,%esp
 80533d4:	c0 ea 03             	shr    $0x3,%dl
 80533d7:	89 c1                	mov    %eax,%ecx
 80533d9:	c0 e9 07             	shr    $0x7,%cl
 80533dc:	83 e2 01             	and    $0x1,%edx
 80533df:	38 d1                	cmp    %dl,%cl
 80533e1:	0f 84 c1 00 00 00    	je     80534a8 <cmovg_rm2r_w+0xf8>
	print_asm_template2();
 80533e7:	83 ec 0c             	sub    $0xc,%esp
 80533ea:	68 50 ae 8f 14       	push   $0x148fae50
 80533ef:	68 18 ae 8f 14       	push   $0x148fae18
 80533f4:	68 24 1c 06 08       	push   $0x8061c24
 80533f9:	6a 50                	push   $0x50
 80533fb:	68 00 89 0c 08       	push   $0x80c8900
 8053400:	e8 fb 56 ff ff       	call   8048b00 <snprintf@plt>
 8053405:	83 c4 20             	add    $0x20,%esp
 8053408:	83 f8 4f             	cmp    $0x4f,%eax
 805340b:	7f 0b                	jg     8053418 <cmovg_rm2r_w+0x68>
}

make_instr_helper(rm2r)
 805340d:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8053410:	8d 43 01             	lea    0x1(%ebx),%eax
 8053413:	5b                   	pop    %ebx
 8053414:	c3                   	ret    
 8053415:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8053418:	83 ec 0c             	sub    $0xc,%esp
 805341b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8053421:	e8 3a 55 ff ff       	call   8048960 <fflush@plt>
 8053426:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805342c:	6a 07                	push   $0x7
 805342e:	6a 01                	push   $0x1
 8053430:	68 92 ed 05 08       	push   $0x805ed92
 8053435:	e8 d6 55 ff ff       	call   8048a10 <fwrite@plt>
 805343a:	83 c4 20             	add    $0x20,%esp
 805343d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053443:	6a 10                	push   $0x10
 8053445:	6a 01                	push   $0x1
 8053447:	68 84 f8 05 08       	push   $0x805f884
 805344c:	e8 bf 55 ff ff       	call   8048a10 <fwrite@plt>
 8053451:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053457:	6a 05                	push   $0x5
 8053459:	6a 01                	push   $0x1
 805345b:	68 b1 ed 05 08       	push   $0x805edb1
 8053460:	e8 ab 55 ff ff       	call   8048a10 <fwrite@plt>
 8053465:	83 c4 14             	add    $0x14,%esp
 8053468:	68 50 ae 8f 14       	push   $0x148fae50
 805346d:	68 18 ae 8f 14       	push   $0x148fae18
 8053472:	68 24 1c 06 08       	push   $0x8061c24
 8053477:	6a 50                	push   $0x50
 8053479:	68 00 89 0c 08       	push   $0x80c8900
 805347e:	e8 7d 56 ff ff       	call   8048b00 <snprintf@plt>
 8053483:	83 c4 20             	add    $0x20,%esp
 8053486:	83 f8 4f             	cmp    $0x4f,%eax
 8053489:	0f 8e 7e ff ff ff    	jle    805340d <cmovg_rm2r_w+0x5d>
 805348f:	68 a6 2a 06 08       	push   $0x8062aa6
 8053494:	6a 06                	push   $0x6
 8053496:	68 50 1c 06 08       	push   $0x8061c50
 805349b:	68 44 28 06 08       	push   $0x8062844
 80534a0:	e8 0b 57 ff ff       	call   8048bb0 <__assert_fail@plt>
 80534a5:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80534a8:	a8 40                	test   $0x40,%al
 80534aa:	0f 85 37 ff ff ff    	jne    80533e7 <cmovg_rm2r_w+0x37>
 80534b0:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
 80534b7:	83 ec 08             	sub    $0x8,%esp
 80534ba:	50                   	push   %eax
 80534bb:	68 40 ae 8f 14       	push   $0x148fae40
 80534c0:	e8 0b 9b 00 00       	call   805cfd0 <write_operand_w>
 80534c5:	83 c4 10             	add    $0x10,%esp
 80534c8:	e9 1a ff ff ff       	jmp    80533e7 <cmovg_rm2r_w+0x37>
 80534cd:	8d 76 00             	lea    0x0(%esi),%esi

080534d0 <cmovle_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80534d0:	53                   	push   %ebx
 80534d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80534d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80534d8:	83 c0 01             	add    $0x1,%eax
 80534db:	50                   	push   %eax
 80534dc:	e8 5f 9c 00 00       	call   805d140 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80534e1:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 80534e8:	89 c3                	mov    %eax,%ebx
 80534ea:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 80534f1:	83 c4 10             	add    $0x10,%esp
 80534f4:	c0 ea 03             	shr    $0x3,%dl
 80534f7:	89 c1                	mov    %eax,%ecx
 80534f9:	c0 e9 07             	shr    $0x7,%cl
 80534fc:	83 e2 01             	and    $0x1,%edx
 80534ff:	38 d1                	cmp    %dl,%cl
 8053501:	74 08                	je     805350b <cmovle_rm2r_l+0x3b>
 8053503:	a8 40                	test   $0x40,%al
 8053505:	0f 85 c5 00 00 00    	jne    80535d0 <cmovle_rm2r_l+0x100>
	print_asm_template2();
 805350b:	83 ec 0c             	sub    $0xc,%esp
 805350e:	68 50 ae 8f 14       	push   $0x148fae50
 8053513:	68 18 ae 8f 14       	push   $0x148fae18
 8053518:	68 31 1c 06 08       	push   $0x8061c31
 805351d:	6a 50                	push   $0x50
 805351f:	68 00 89 0c 08       	push   $0x80c8900
 8053524:	e8 d7 55 ff ff       	call   8048b00 <snprintf@plt>
 8053529:	83 c4 20             	add    $0x20,%esp
 805352c:	83 f8 4f             	cmp    $0x4f,%eax
 805352f:	7f 0f                	jg     8053540 <cmovle_rm2r_l+0x70>
}

make_instr_helper(rm2r)
 8053531:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8053534:	8d 43 01             	lea    0x1(%ebx),%eax
 8053537:	5b                   	pop    %ebx
 8053538:	c3                   	ret    
 8053539:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8053540:	83 ec 0c             	sub    $0xc,%esp
 8053543:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8053549:	e8 12 54 ff ff       	call   8048960 <fflush@plt>
 805354e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053554:	6a 07                	push   $0x7
 8053556:	6a 01                	push   $0x1
 8053558:	68 92 ed 05 08       	push   $0x805ed92
 805355d:	e8 ae 54 ff ff       	call   8048a10 <fwrite@plt>
 8053562:	83 c4 20             	add    $0x20,%esp
 8053565:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805356b:	6a 10                	push   $0x10
 805356d:	6a 01                	push   $0x1
 805356f:	68 84 f8 05 08       	push   $0x805f884
 8053574:	e8 97 54 ff ff       	call   8048a10 <fwrite@plt>
 8053579:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805357f:	6a 05                	push   $0x5
 8053581:	6a 01                	push   $0x1
 8053583:	68 b1 ed 05 08       	push   $0x805edb1
 8053588:	e8 83 54 ff ff       	call   8048a10 <fwrite@plt>
 805358d:	83 c4 14             	add    $0x14,%esp
 8053590:	68 50 ae 8f 14       	push   $0x148fae50
 8053595:	68 18 ae 8f 14       	push   $0x148fae18
 805359a:	68 31 1c 06 08       	push   $0x8061c31
 805359f:	6a 50                	push   $0x50
 80535a1:	68 00 89 0c 08       	push   $0x80c8900
 80535a6:	e8 55 55 ff ff       	call   8048b00 <snprintf@plt>
 80535ab:	83 c4 20             	add    $0x20,%esp
 80535ae:	83 f8 4f             	cmp    $0x4f,%eax
 80535b1:	0f 8e 7a ff ff ff    	jle    8053531 <cmovle_rm2r_l+0x61>
 80535b7:	68 cb 29 06 08       	push   $0x80629cb
 80535bc:	6a 06                	push   $0x6
 80535be:	68 50 1c 06 08       	push   $0x8061c50
 80535c3:	68 ac 28 06 08       	push   $0x80628ac
 80535c8:	e8 e3 55 ff ff       	call   8048bb0 <__assert_fail@plt>
 80535cd:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80535d0:	83 ec 08             	sub    $0x8,%esp
 80535d3:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 80535d9:	68 40 ae 8f 14       	push   $0x148fae40
 80535de:	e8 bd 9d 00 00       	call   805d3a0 <write_operand_l>
 80535e3:	83 c4 10             	add    $0x10,%esp
 80535e6:	e9 20 ff ff ff       	jmp    805350b <cmovle_rm2r_l+0x3b>
 80535eb:	90                   	nop
 80535ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080535f0 <cmovle_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80535f0:	53                   	push   %ebx
 80535f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80535f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80535f8:	83 c0 01             	add    $0x1,%eax
 80535fb:	50                   	push   %eax
 80535fc:	e8 6f 97 00 00       	call   805cd70 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8053601:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 8053608:	89 c3                	mov    %eax,%ebx
 805360a:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 8053611:	83 c4 10             	add    $0x10,%esp
 8053614:	c0 ea 03             	shr    $0x3,%dl
 8053617:	89 c1                	mov    %eax,%ecx
 8053619:	c0 e9 07             	shr    $0x7,%cl
 805361c:	83 e2 01             	and    $0x1,%edx
 805361f:	38 d1                	cmp    %dl,%cl
 8053621:	74 08                	je     805362b <cmovle_rm2r_w+0x3b>
 8053623:	a8 40                	test   $0x40,%al
 8053625:	0f 85 c5 00 00 00    	jne    80536f0 <cmovle_rm2r_w+0x100>
	print_asm_template2();
 805362b:	83 ec 0c             	sub    $0xc,%esp
 805362e:	68 50 ae 8f 14       	push   $0x148fae50
 8053633:	68 18 ae 8f 14       	push   $0x148fae18
 8053638:	68 3f 1c 06 08       	push   $0x8061c3f
 805363d:	6a 50                	push   $0x50
 805363f:	68 00 89 0c 08       	push   $0x80c8900
 8053644:	e8 b7 54 ff ff       	call   8048b00 <snprintf@plt>
 8053649:	83 c4 20             	add    $0x20,%esp
 805364c:	83 f8 4f             	cmp    $0x4f,%eax
 805364f:	7f 0f                	jg     8053660 <cmovle_rm2r_w+0x70>
}

make_instr_helper(rm2r)
 8053651:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8053654:	8d 43 01             	lea    0x1(%ebx),%eax
 8053657:	5b                   	pop    %ebx
 8053658:	c3                   	ret    
 8053659:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8053660:	83 ec 0c             	sub    $0xc,%esp
 8053663:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8053669:	e8 f2 52 ff ff       	call   8048960 <fflush@plt>
 805366e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053674:	6a 07                	push   $0x7
 8053676:	6a 01                	push   $0x1
 8053678:	68 92 ed 05 08       	push   $0x805ed92
 805367d:	e8 8e 53 ff ff       	call   8048a10 <fwrite@plt>
 8053682:	83 c4 20             	add    $0x20,%esp
 8053685:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805368b:	6a 10                	push   $0x10
 805368d:	6a 01                	push   $0x1
 805368f:	68 84 f8 05 08       	push   $0x805f884
 8053694:	e8 77 53 ff ff       	call   8048a10 <fwrite@plt>
 8053699:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805369f:	6a 05                	push   $0x5
 80536a1:	6a 01                	push   $0x1
 80536a3:	68 b1 ed 05 08       	push   $0x805edb1
 80536a8:	e8 63 53 ff ff       	call   8048a10 <fwrite@plt>
 80536ad:	83 c4 14             	add    $0x14,%esp
 80536b0:	68 50 ae 8f 14       	push   $0x148fae50
 80536b5:	68 18 ae 8f 14       	push   $0x148fae18
 80536ba:	68 3f 1c 06 08       	push   $0x8061c3f
 80536bf:	6a 50                	push   $0x50
 80536c1:	68 00 89 0c 08       	push   $0x80c8900
 80536c6:	e8 35 54 ff ff       	call   8048b00 <snprintf@plt>
 80536cb:	83 c4 20             	add    $0x20,%esp
 80536ce:	83 f8 4f             	cmp    $0x4f,%eax
 80536d1:	0f 8e 7a ff ff ff    	jle    8053651 <cmovle_rm2r_w+0x61>
 80536d7:	68 83 2a 06 08       	push   $0x8062a83
 80536dc:	6a 06                	push   $0x6
 80536de:	68 50 1c 06 08       	push   $0x8061c50
 80536e3:	68 14 29 06 08       	push   $0x8062914
 80536e8:	e8 c3 54 ff ff       	call   8048bb0 <__assert_fail@plt>
 80536ed:	8d 76 00             	lea    0x0(%esi),%esi
 80536f0:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80536f7:	83 ec 08             	sub    $0x8,%esp
 80536fa:	50                   	push   %eax
 80536fb:	68 40 ae 8f 14       	push   $0x148fae40
 8053700:	e8 cb 98 00 00       	call   805cfd0 <write_operand_w>
 8053705:	83 c4 10             	add    $0x10,%esp
 8053708:	e9 1e ff ff ff       	jmp    805362b <cmovle_rm2r_w+0x3b>
 805370d:	8d 76 00             	lea    0x0(%esi),%esi

08053710 <cmovo_rm2r_v>:

#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(cmovo_rm2r)
 8053710:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8053717:	8b 54 24 04          	mov    0x4(%esp),%edx
 805371b:	b8 70 30 05 08       	mov    $0x8053070,%eax
 8053720:	75 05                	jne    8053727 <cmovo_rm2r_v+0x17>
 8053722:	b8 10 1a 05 08       	mov    $0x8051a10,%eax
 8053727:	89 54 24 04          	mov    %edx,0x4(%esp)
 805372b:	ff e0                	jmp    *%eax
 805372d:	8d 76 00             	lea    0x0(%esi),%esi

08053730 <cmovno_rm2r_v>:
make_helper_v(cmovno_rm2r)
 8053730:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8053737:	8b 54 24 04          	mov    0x4(%esp),%edx
 805373b:	b8 20 2b 05 08       	mov    $0x8052b20,%eax
 8053740:	75 05                	jne    8053747 <cmovno_rm2r_v+0x17>
 8053742:	b8 e0 16 05 08       	mov    $0x80516e0,%eax
 8053747:	89 54 24 04          	mov    %edx,0x4(%esp)
 805374b:	ff e0                	jmp    *%eax
 805374d:	8d 76 00             	lea    0x0(%esi),%esi

08053750 <cmovb_rm2r_v>:
make_helper_v(cmovb_rm2r)
 8053750:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8053757:	8b 54 24 04          	mov    0x4(%esp),%edx
 805375b:	b8 c0 24 05 08       	mov    $0x80524c0,%eax
 8053760:	75 05                	jne    8053767 <cmovb_rm2r_v+0x17>
 8053762:	b8 50 1e 05 08       	mov    $0x8051e50,%eax
 8053767:	89 54 24 04          	mov    %edx,0x4(%esp)
 805376b:	ff e0                	jmp    *%eax
 805376d:	8d 76 00             	lea    0x0(%esi),%esi

08053770 <cmovae_rm2r_v>:
make_helper_v(cmovae_rm2r)
 8053770:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8053777:	8b 54 24 04          	mov    0x4(%esp),%edx
 805377b:	b8 f0 27 05 08       	mov    $0x80527f0,%eax
 8053780:	75 05                	jne    8053787 <cmovae_rm2r_v+0x17>
 8053782:	b8 60 1f 05 08       	mov    $0x8051f60,%eax
 8053787:	89 54 24 04          	mov    %edx,0x4(%esp)
 805378b:	ff e0                	jmp    *%eax
 805378d:	8d 76 00             	lea    0x0(%esi),%esi

08053790 <cmove_rm2r_v>:
make_helper_v(cmove_rm2r)
 8053790:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8053797:	8b 54 24 04          	mov    0x4(%esp),%edx
 805379b:	b8 e0 26 05 08       	mov    $0x80526e0,%eax
 80537a0:	75 05                	jne    80537a7 <cmove_rm2r_v+0x17>
 80537a2:	b8 70 20 05 08       	mov    $0x8052070,%eax
 80537a7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80537ab:	ff e0                	jmp    *%eax
 80537ad:	8d 76 00             	lea    0x0(%esi),%esi

080537b0 <cmovne_rm2r_v>:
make_helper_v(cmovne_rm2r)
 80537b0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80537b7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80537bb:	b8 40 2d 05 08       	mov    $0x8052d40,%eax
 80537c0:	75 05                	jne    80537c7 <cmovne_rm2r_v+0x17>
 80537c2:	b8 d0 15 05 08       	mov    $0x80515d0,%eax
 80537c7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80537cb:	ff e0                	jmp    *%eax
 80537cd:	8d 76 00             	lea    0x0(%esi),%esi

080537d0 <cmovbe_rm2r_v>:
make_helper_v(cmovbe_rm2r)
 80537d0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80537d7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80537db:	b8 00 29 05 08       	mov    $0x8052900,%eax
 80537e0:	75 05                	jne    80537e7 <cmovbe_rm2r_v+0x17>
 80537e2:	b8 80 21 05 08       	mov    $0x8052180,%eax
 80537e7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80537eb:	ff e0                	jmp    *%eax
 80537ed:	8d 76 00             	lea    0x0(%esi),%esi

080537f0 <cmova_rm2r_v>:
make_helper_v(cmova_rm2r)
 80537f0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80537f7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80537fb:	b8 d0 25 05 08       	mov    $0x80525d0,%eax
 8053800:	75 05                	jne    8053807 <cmova_rm2r_v+0x17>
 8053802:	b8 40 1d 05 08       	mov    $0x8051d40,%eax
 8053807:	89 54 24 04          	mov    %edx,0x4(%esp)
 805380b:	ff e0                	jmp    *%eax
 805380d:	8d 76 00             	lea    0x0(%esi),%esi

08053810 <cmovs_rm2r_v>:
make_helper_v(cmovs_rm2r)
 8053810:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8053817:	8b 54 24 04          	mov    0x4(%esp),%edx
 805381b:	b8 30 2c 05 08       	mov    $0x8052c30,%eax
 8053820:	75 05                	jne    8053827 <cmovs_rm2r_v+0x17>
 8053822:	b8 30 1c 05 08       	mov    $0x8051c30,%eax
 8053827:	89 54 24 04          	mov    %edx,0x4(%esp)
 805382b:	ff e0                	jmp    *%eax
 805382d:	8d 76 00             	lea    0x0(%esi),%esi

08053830 <cmovns_rm2r_v>:
make_helper_v(cmovns_rm2r)
 8053830:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8053837:	8b 54 24 04          	mov    0x4(%esp),%edx
 805383b:	b8 50 2e 05 08       	mov    $0x8052e50,%eax
 8053840:	75 05                	jne    8053847 <cmovns_rm2r_v+0x17>
 8053842:	b8 f0 17 05 08       	mov    $0x80517f0,%eax
 8053847:	89 54 24 04          	mov    %edx,0x4(%esp)
 805384b:	ff e0                	jmp    *%eax
 805384d:	8d 76 00             	lea    0x0(%esi),%esi

08053850 <cmovp_rm2r_v>:
make_helper_v(cmovp_rm2r)
 8053850:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8053857:	8b 54 24 04          	mov    0x4(%esp),%edx
 805385b:	b8 10 2a 05 08       	mov    $0x8052a10,%eax
 8053860:	75 05                	jne    8053867 <cmovp_rm2r_v+0x17>
 8053862:	b8 20 1b 05 08       	mov    $0x8051b20,%eax
 8053867:	89 54 24 04          	mov    %edx,0x4(%esp)
 805386b:	ff e0                	jmp    *%eax
 805386d:	8d 76 00             	lea    0x0(%esi),%esi

08053870 <cmovnp_rm2r_v>:
make_helper_v(cmovnp_rm2r)
 8053870:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8053877:	8b 54 24 04          	mov    0x4(%esp),%edx
 805387b:	b8 60 2f 05 08       	mov    $0x8052f60,%eax
 8053880:	75 05                	jne    8053887 <cmovnp_rm2r_v+0x17>
 8053882:	b8 00 19 05 08       	mov    $0x8051900,%eax
 8053887:	89 54 24 04          	mov    %edx,0x4(%esp)
 805388b:	ff e0                	jmp    *%eax
 805388d:	8d 76 00             	lea    0x0(%esi),%esi

08053890 <cmovl_rm2r_v>:
make_helper_v(cmovl_rm2r)
 8053890:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8053897:	8b 54 24 04          	mov    0x4(%esp),%edx
 805389b:	b8 80 31 05 08       	mov    $0x8053180,%eax
 80538a0:	75 05                	jne    80538a7 <cmovl_rm2r_v+0x17>
 80538a2:	b8 b0 23 05 08       	mov    $0x80523b0,%eax
 80538a7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80538ab:	ff e0                	jmp    *%eax
 80538ad:	8d 76 00             	lea    0x0(%esi),%esi

080538b0 <cmovge_rm2r_v>:
make_helper_v(cmovge_rm2r)
 80538b0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80538b7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80538bb:	b8 90 22 05 08       	mov    $0x8052290,%eax
 80538c0:	75 05                	jne    80538c7 <cmovge_rm2r_v+0x17>
 80538c2:	b8 b0 14 05 08       	mov    $0x80514b0,%eax
 80538c7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80538cb:	ff e0                	jmp    *%eax
 80538cd:	8d 76 00             	lea    0x0(%esi),%esi

080538d0 <cmovle_rm2r_v>:
make_helper_v(cmovle_rm2r)
 80538d0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80538d7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80538db:	b8 f0 35 05 08       	mov    $0x80535f0,%eax
 80538e0:	75 05                	jne    80538e7 <cmovle_rm2r_v+0x17>
 80538e2:	b8 d0 34 05 08       	mov    $0x80534d0,%eax
 80538e7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80538eb:	ff e0                	jmp    *%eax
 80538ed:	8d 76 00             	lea    0x0(%esi),%esi

080538f0 <cmovg_rm2r_v>:
make_helper_v(cmovg_rm2r)
 80538f0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80538f7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80538fb:	b8 b0 33 05 08       	mov    $0x80533b0,%eax
 8053900:	75 05                	jne    8053907 <cmovg_rm2r_v+0x17>
 8053902:	b8 90 32 05 08       	mov    $0x8053290,%eax
 8053907:	89 54 24 04          	mov    %edx,0x4(%esp)
 805390b:	ff e0                	jmp    *%eax
 805390d:	66 90                	xchg   %ax,%ax
 805390f:	90                   	nop

08053910 <do_test_b>:
#include "cpu/exec/template-start.h"

#define instr test

static void do_execute() {
 8053910:	53                   	push   %ebx
 8053911:	83 ec 14             	sub    $0x14,%esp
	uint32_t res = op_src->val & op_dest->val;
 8053914:	a1 4c ae 8f 14       	mov    0x148fae4c,%eax
 8053919:	23 05 14 ae 8f 14    	and    0x148fae14,%eax
	cpu.CF = cpu.OF = 0;
 805391f:	80 25 e5 ae 8f 14 f7 	andb   $0xf7,0x148faee5
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	print_asm_template2();
 8053926:	68 50 ae 8f 14       	push   $0x148fae50
 805392b:	68 18 ae 8f 14       	push   $0x148fae18
 8053930:	68 ea 2a 06 08       	push   $0x8062aea
 8053935:	6a 50                	push   $0x50
 8053937:	68 00 89 0c 08       	push   $0x80c8900
#define instr test

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
 805393c:	89 c1                	mov    %eax,%ecx
 805393e:	c1 e9 1f             	shr    $0x1f,%ecx
 8053941:	89 ca                	mov    %ecx,%edx
 8053943:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 805394a:	c1 e2 07             	shl    $0x7,%edx
 805394d:	83 e1 3e             	and    $0x3e,%ecx
	cpu.ZF = (res == 0);
 8053950:	85 c0                	test   %eax,%eax
	uint32_t pf = (res & 255);
 8053952:	0f b6 c0             	movzbl %al,%eax

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 8053955:	0f 94 c3             	sete   %bl
 8053958:	09 d1                	or     %edx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 805395a:	89 c2                	mov    %eax,%edx
 805395c:	c1 ea 04             	shr    $0x4,%edx

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 805395f:	c1 e3 06             	shl    $0x6,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 8053962:	31 d0                	xor    %edx,%eax

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 8053964:	09 d9                	or     %ebx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 8053966:	89 c2                	mov    %eax,%edx
 8053968:	c1 ea 02             	shr    $0x2,%edx
 805396b:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 805396d:	89 c2                	mov    %eax,%edx
 805396f:	d1 ea                	shr    %edx
 8053971:	31 d0                	xor    %edx,%eax
	cpu.PF = pf & 1;
 8053973:	83 e0 01             	and    $0x1,%eax
 8053976:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805397d:	89 c8                	mov    %ecx,%eax
 805397f:	83 e0 fb             	and    $0xfffffffb,%eax
 8053982:	09 d0                	or     %edx,%eax
 8053984:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	print_asm_template2();
 8053989:	e8 72 51 ff ff       	call   8048b00 <snprintf@plt>
 805398e:	83 c4 20             	add    $0x20,%esp
 8053991:	83 f8 4f             	cmp    $0x4f,%eax
 8053994:	7f 0a                	jg     80539a0 <do_test_b+0x90>
}
 8053996:	83 c4 08             	add    $0x8,%esp
 8053999:	5b                   	pop    %ebx
 805399a:	c3                   	ret    
 805399b:	90                   	nop
 805399c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	print_asm_template2();
 80539a0:	83 ec 0c             	sub    $0xc,%esp
 80539a3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80539a9:	e8 b2 4f ff ff       	call   8048960 <fflush@plt>
 80539ae:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80539b4:	6a 07                	push   $0x7
 80539b6:	6a 01                	push   $0x1
 80539b8:	68 92 ed 05 08       	push   $0x805ed92
 80539bd:	e8 4e 50 ff ff       	call   8048a10 <fwrite@plt>
 80539c2:	83 c4 20             	add    $0x20,%esp
 80539c5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80539cb:	6a 10                	push   $0x10
 80539cd:	6a 01                	push   $0x1
 80539cf:	68 84 f8 05 08       	push   $0x805f884
 80539d4:	e8 37 50 ff ff       	call   8048a10 <fwrite@plt>
 80539d9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80539df:	6a 05                	push   $0x5
 80539e1:	6a 01                	push   $0x1
 80539e3:	68 b1 ed 05 08       	push   $0x805edb1
 80539e8:	e8 23 50 ff ff       	call   8048a10 <fwrite@plt>
 80539ed:	83 c4 14             	add    $0x14,%esp
 80539f0:	68 50 ae 8f 14       	push   $0x148fae50
 80539f5:	68 18 ae 8f 14       	push   $0x148fae18
 80539fa:	68 ea 2a 06 08       	push   $0x8062aea
 80539ff:	6a 50                	push   $0x50
 8053a01:	68 00 89 0c 08       	push   $0x80c8900
 8053a06:	e8 f5 50 ff ff       	call   8048b00 <snprintf@plt>
 8053a0b:	83 c4 20             	add    $0x20,%esp
 8053a0e:	83 f8 4f             	cmp    $0x4f,%eax
 8053a11:	7e 83                	jle    8053996 <do_test_b+0x86>
 8053a13:	68 78 2c 06 08       	push   $0x8062c78
 8053a18:	6a 0f                	push   $0xf
 8053a1a:	68 10 2b 06 08       	push   $0x8062b10
 8053a1f:	68 38 2b 06 08       	push   $0x8062b38
 8053a24:	e8 87 51 ff ff       	call   8048bb0 <__assert_fail@plt>
 8053a29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08053a30 <do_test_w>:
#include "cpu/exec/template-start.h"

#define instr test

static void do_execute() {
 8053a30:	53                   	push   %ebx
 8053a31:	83 ec 14             	sub    $0x14,%esp
	uint32_t res = op_src->val & op_dest->val;
 8053a34:	a1 4c ae 8f 14       	mov    0x148fae4c,%eax
 8053a39:	23 05 14 ae 8f 14    	and    0x148fae14,%eax
	cpu.CF = cpu.OF = 0;
 8053a3f:	80 25 e5 ae 8f 14 f7 	andb   $0xf7,0x148faee5
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	print_asm_template2();
 8053a46:	68 50 ae 8f 14       	push   $0x148fae50
 8053a4b:	68 18 ae 8f 14       	push   $0x148fae18
 8053a50:	68 f6 2a 06 08       	push   $0x8062af6
 8053a55:	6a 50                	push   $0x50
 8053a57:	68 00 89 0c 08       	push   $0x80c8900
#define instr test

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
 8053a5c:	89 c1                	mov    %eax,%ecx
 8053a5e:	c1 e9 1f             	shr    $0x1f,%ecx
 8053a61:	89 ca                	mov    %ecx,%edx
 8053a63:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 8053a6a:	c1 e2 07             	shl    $0x7,%edx
 8053a6d:	83 e1 3e             	and    $0x3e,%ecx
	cpu.ZF = (res == 0);
 8053a70:	85 c0                	test   %eax,%eax
	uint32_t pf = (res & 255);
 8053a72:	0f b6 c0             	movzbl %al,%eax

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 8053a75:	0f 94 c3             	sete   %bl
 8053a78:	09 d1                	or     %edx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 8053a7a:	89 c2                	mov    %eax,%edx
 8053a7c:	c1 ea 04             	shr    $0x4,%edx

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 8053a7f:	c1 e3 06             	shl    $0x6,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 8053a82:	31 d0                	xor    %edx,%eax

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 8053a84:	09 d9                	or     %ebx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 8053a86:	89 c2                	mov    %eax,%edx
 8053a88:	c1 ea 02             	shr    $0x2,%edx
 8053a8b:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 8053a8d:	89 c2                	mov    %eax,%edx
 8053a8f:	d1 ea                	shr    %edx
 8053a91:	31 d0                	xor    %edx,%eax
	cpu.PF = pf & 1;
 8053a93:	83 e0 01             	and    $0x1,%eax
 8053a96:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8053a9d:	89 c8                	mov    %ecx,%eax
 8053a9f:	83 e0 fb             	and    $0xfffffffb,%eax
 8053aa2:	09 d0                	or     %edx,%eax
 8053aa4:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	print_asm_template2();
 8053aa9:	e8 52 50 ff ff       	call   8048b00 <snprintf@plt>
 8053aae:	83 c4 20             	add    $0x20,%esp
 8053ab1:	83 f8 4f             	cmp    $0x4f,%eax
 8053ab4:	7f 0a                	jg     8053ac0 <do_test_w+0x90>
}
 8053ab6:	83 c4 08             	add    $0x8,%esp
 8053ab9:	5b                   	pop    %ebx
 8053aba:	c3                   	ret    
 8053abb:	90                   	nop
 8053abc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	print_asm_template2();
 8053ac0:	83 ec 0c             	sub    $0xc,%esp
 8053ac3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8053ac9:	e8 92 4e ff ff       	call   8048960 <fflush@plt>
 8053ace:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053ad4:	6a 07                	push   $0x7
 8053ad6:	6a 01                	push   $0x1
 8053ad8:	68 92 ed 05 08       	push   $0x805ed92
 8053add:	e8 2e 4f ff ff       	call   8048a10 <fwrite@plt>
 8053ae2:	83 c4 20             	add    $0x20,%esp
 8053ae5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053aeb:	6a 10                	push   $0x10
 8053aed:	6a 01                	push   $0x1
 8053aef:	68 84 f8 05 08       	push   $0x805f884
 8053af4:	e8 17 4f ff ff       	call   8048a10 <fwrite@plt>
 8053af9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053aff:	6a 05                	push   $0x5
 8053b01:	6a 01                	push   $0x1
 8053b03:	68 b1 ed 05 08       	push   $0x805edb1
 8053b08:	e8 03 4f ff ff       	call   8048a10 <fwrite@plt>
 8053b0d:	83 c4 14             	add    $0x14,%esp
 8053b10:	68 50 ae 8f 14       	push   $0x148fae50
 8053b15:	68 18 ae 8f 14       	push   $0x148fae18
 8053b1a:	68 f6 2a 06 08       	push   $0x8062af6
 8053b1f:	6a 50                	push   $0x50
 8053b21:	68 00 89 0c 08       	push   $0x80c8900
 8053b26:	e8 d5 4f ff ff       	call   8048b00 <snprintf@plt>
 8053b2b:	83 c4 20             	add    $0x20,%esp
 8053b2e:	83 f8 4f             	cmp    $0x4f,%eax
 8053b31:	7e 83                	jle    8053ab6 <do_test_w+0x86>
 8053b33:	68 6e 2c 06 08       	push   $0x8062c6e
 8053b38:	6a 0f                	push   $0xf
 8053b3a:	68 10 2b 06 08       	push   $0x8062b10
 8053b3f:	68 9c 2b 06 08       	push   $0x8062b9c
 8053b44:	e8 67 50 ff ff       	call   8048bb0 <__assert_fail@plt>
 8053b49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08053b50 <test_r2rm_w>:
}

make_instr_helper(r2rm)
 8053b50:	53                   	push   %ebx
 8053b51:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053b54:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053b58:	83 c0 01             	add    $0x1,%eax
 8053b5b:	50                   	push   %eax
 8053b5c:	e8 ef 91 00 00       	call   805cd50 <decode_r2rm_w>
 8053b61:	89 c3                	mov    %eax,%ebx
	execute();
 8053b63:	e8 c8 fe ff ff       	call   8053a30 <do_test_w>
 8053b68:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053b6b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053b6e:	5b                   	pop    %ebx
 8053b6f:	c3                   	ret    

08053b70 <test_i2rm_w>:
make_instr_helper(i2rm)
 8053b70:	53                   	push   %ebx
 8053b71:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053b74:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053b78:	83 c0 01             	add    $0x1,%eax
 8053b7b:	50                   	push   %eax
 8053b7c:	e8 8f 92 00 00       	call   805ce10 <decode_i2rm_w>
 8053b81:	89 c3                	mov    %eax,%ebx
	execute();
 8053b83:	e8 a8 fe ff ff       	call   8053a30 <do_test_w>
 8053b88:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053b8b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053b8e:	5b                   	pop    %ebx
 8053b8f:	c3                   	ret    

08053b90 <test_i2a_w>:
make_instr_helper(i2a)
 8053b90:	53                   	push   %ebx
 8053b91:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053b94:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053b98:	83 c0 01             	add    $0x1,%eax
 8053b9b:	50                   	push   %eax
 8053b9c:	e8 ef 91 00 00       	call   805cd90 <decode_i2a_w>
 8053ba1:	89 c3                	mov    %eax,%ebx
	execute();
 8053ba3:	e8 88 fe ff ff       	call   8053a30 <do_test_w>
 8053ba8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053bab:	8d 43 01             	lea    0x1(%ebx),%eax
 8053bae:	5b                   	pop    %ebx
 8053baf:	c3                   	ret    

08053bb0 <do_test_l>:
#include "cpu/exec/template-start.h"

#define instr test

static void do_execute() {
 8053bb0:	53                   	push   %ebx
 8053bb1:	83 ec 14             	sub    $0x14,%esp
	uint32_t res = op_src->val & op_dest->val;
 8053bb4:	a1 4c ae 8f 14       	mov    0x148fae4c,%eax
 8053bb9:	23 05 14 ae 8f 14    	and    0x148fae14,%eax
	cpu.CF = cpu.OF = 0;
 8053bbf:	80 25 e5 ae 8f 14 f7 	andb   $0xf7,0x148faee5
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	print_asm_template2();
 8053bc6:	68 50 ae 8f 14       	push   $0x148fae50
 8053bcb:	68 18 ae 8f 14       	push   $0x148fae18
 8053bd0:	68 02 2b 06 08       	push   $0x8062b02
 8053bd5:	6a 50                	push   $0x50
 8053bd7:	68 00 89 0c 08       	push   $0x80c8900
#define instr test

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
 8053bdc:	89 c1                	mov    %eax,%ecx
 8053bde:	c1 e9 1f             	shr    $0x1f,%ecx
 8053be1:	89 ca                	mov    %ecx,%edx
 8053be3:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 8053bea:	c1 e2 07             	shl    $0x7,%edx
 8053bed:	83 e1 3e             	and    $0x3e,%ecx
	cpu.ZF = (res == 0);
 8053bf0:	85 c0                	test   %eax,%eax
	uint32_t pf = (res & 255);
 8053bf2:	0f b6 c0             	movzbl %al,%eax

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 8053bf5:	0f 94 c3             	sete   %bl
 8053bf8:	09 d1                	or     %edx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 8053bfa:	89 c2                	mov    %eax,%edx
 8053bfc:	c1 ea 04             	shr    $0x4,%edx

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 8053bff:	c1 e3 06             	shl    $0x6,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 8053c02:	31 d0                	xor    %edx,%eax

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 8053c04:	09 d9                	or     %ebx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 8053c06:	89 c2                	mov    %eax,%edx
 8053c08:	c1 ea 02             	shr    $0x2,%edx
 8053c0b:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 8053c0d:	89 c2                	mov    %eax,%edx
 8053c0f:	d1 ea                	shr    %edx
 8053c11:	31 d0                	xor    %edx,%eax
	cpu.PF = pf & 1;
 8053c13:	83 e0 01             	and    $0x1,%eax
 8053c16:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8053c1d:	89 c8                	mov    %ecx,%eax
 8053c1f:	83 e0 fb             	and    $0xfffffffb,%eax
 8053c22:	09 d0                	or     %edx,%eax
 8053c24:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	print_asm_template2();
 8053c29:	e8 d2 4e ff ff       	call   8048b00 <snprintf@plt>
 8053c2e:	83 c4 20             	add    $0x20,%esp
 8053c31:	83 f8 4f             	cmp    $0x4f,%eax
 8053c34:	7f 0a                	jg     8053c40 <do_test_l+0x90>
}
 8053c36:	83 c4 08             	add    $0x8,%esp
 8053c39:	5b                   	pop    %ebx
 8053c3a:	c3                   	ret    
 8053c3b:	90                   	nop
 8053c3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	print_asm_template2();
 8053c40:	83 ec 0c             	sub    $0xc,%esp
 8053c43:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8053c49:	e8 12 4d ff ff       	call   8048960 <fflush@plt>
 8053c4e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053c54:	6a 07                	push   $0x7
 8053c56:	6a 01                	push   $0x1
 8053c58:	68 92 ed 05 08       	push   $0x805ed92
 8053c5d:	e8 ae 4d ff ff       	call   8048a10 <fwrite@plt>
 8053c62:	83 c4 20             	add    $0x20,%esp
 8053c65:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053c6b:	6a 10                	push   $0x10
 8053c6d:	6a 01                	push   $0x1
 8053c6f:	68 84 f8 05 08       	push   $0x805f884
 8053c74:	e8 97 4d ff ff       	call   8048a10 <fwrite@plt>
 8053c79:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053c7f:	6a 05                	push   $0x5
 8053c81:	6a 01                	push   $0x1
 8053c83:	68 b1 ed 05 08       	push   $0x805edb1
 8053c88:	e8 83 4d ff ff       	call   8048a10 <fwrite@plt>
 8053c8d:	83 c4 14             	add    $0x14,%esp
 8053c90:	68 50 ae 8f 14       	push   $0x148fae50
 8053c95:	68 18 ae 8f 14       	push   $0x148fae18
 8053c9a:	68 02 2b 06 08       	push   $0x8062b02
 8053c9f:	6a 50                	push   $0x50
 8053ca1:	68 00 89 0c 08       	push   $0x80c8900
 8053ca6:	e8 55 4e ff ff       	call   8048b00 <snprintf@plt>
 8053cab:	83 c4 20             	add    $0x20,%esp
 8053cae:	83 f8 4f             	cmp    $0x4f,%eax
 8053cb1:	7e 83                	jle    8053c36 <do_test_l+0x86>
 8053cb3:	68 64 2c 06 08       	push   $0x8062c64
 8053cb8:	6a 0f                	push   $0xf
 8053cba:	68 10 2b 06 08       	push   $0x8062b10
 8053cbf:	68 00 2c 06 08       	push   $0x8062c00
 8053cc4:	e8 e7 4e ff ff       	call   8048bb0 <__assert_fail@plt>
 8053cc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08053cd0 <test_r2rm_l>:
}

make_instr_helper(r2rm)
 8053cd0:	53                   	push   %ebx
 8053cd1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053cd4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053cd8:	83 c0 01             	add    $0x1,%eax
 8053cdb:	50                   	push   %eax
 8053cdc:	e8 3f 94 00 00       	call   805d120 <decode_r2rm_l>
 8053ce1:	89 c3                	mov    %eax,%ebx
	execute();
 8053ce3:	e8 c8 fe ff ff       	call   8053bb0 <do_test_l>
 8053ce8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053ceb:	8d 43 01             	lea    0x1(%ebx),%eax
 8053cee:	5b                   	pop    %ebx
 8053cef:	c3                   	ret    

08053cf0 <test_i2rm_l>:
make_instr_helper(i2rm)
 8053cf0:	53                   	push   %ebx
 8053cf1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053cf4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053cf8:	83 c0 01             	add    $0x1,%eax
 8053cfb:	50                   	push   %eax
 8053cfc:	e8 df 94 00 00       	call   805d1e0 <decode_i2rm_l>
 8053d01:	89 c3                	mov    %eax,%ebx
	execute();
 8053d03:	e8 a8 fe ff ff       	call   8053bb0 <do_test_l>
 8053d08:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053d0b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053d0e:	5b                   	pop    %ebx
 8053d0f:	c3                   	ret    

08053d10 <test_i2a_l>:
make_instr_helper(i2a)
 8053d10:	53                   	push   %ebx
 8053d11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053d14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053d18:	83 c0 01             	add    $0x1,%eax
 8053d1b:	50                   	push   %eax
 8053d1c:	e8 3f 94 00 00       	call   805d160 <decode_i2a_l>
 8053d21:	89 c3                	mov    %eax,%ebx
	execute();
 8053d23:	e8 88 fe ff ff       	call   8053bb0 <do_test_l>
 8053d28:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053d2b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053d2e:	5b                   	pop    %ebx
 8053d2f:	c3                   	ret    

08053d30 <test_r2rm_b>:
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	print_asm_template2();
}

make_instr_helper(r2rm)
 8053d30:	53                   	push   %ebx
 8053d31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053d34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053d38:	83 c0 01             	add    $0x1,%eax
 8053d3b:	50                   	push   %eax
 8053d3c:	e8 df 8c 00 00       	call   805ca20 <decode_r2rm_b>
 8053d41:	89 c3                	mov    %eax,%ebx
	execute();
 8053d43:	e8 c8 fb ff ff       	call   8053910 <do_test_b>
 8053d48:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053d4b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053d4e:	5b                   	pop    %ebx
 8053d4f:	c3                   	ret    

08053d50 <test_i2rm_b>:
make_instr_helper(i2rm)
 8053d50:	53                   	push   %ebx
 8053d51:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053d54:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053d58:	83 c0 01             	add    $0x1,%eax
 8053d5b:	50                   	push   %eax
 8053d5c:	e8 7f 8d 00 00       	call   805cae0 <decode_i2rm_b>
 8053d61:	89 c3                	mov    %eax,%ebx
	execute();
 8053d63:	e8 a8 fb ff ff       	call   8053910 <do_test_b>
 8053d68:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053d6b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053d6e:	5b                   	pop    %ebx
 8053d6f:	c3                   	ret    

08053d70 <test_i2a_b>:
make_instr_helper(i2a)
 8053d70:	53                   	push   %ebx
 8053d71:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053d74:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053d78:	83 c0 01             	add    $0x1,%eax
 8053d7b:	50                   	push   %eax
 8053d7c:	e8 df 8c 00 00       	call   805ca60 <decode_i2a_b>
 8053d81:	89 c3                	mov    %eax,%ebx
	execute();
 8053d83:	e8 88 fb ff ff       	call   8053910 <do_test_b>
 8053d88:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053d8b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053d8e:	5b                   	pop    %ebx
 8053d8f:	c3                   	ret    

08053d90 <test_r2rm_v>:
#include "test-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(test_r2rm)
 8053d90:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8053d97:	8b 54 24 04          	mov    0x4(%esp),%edx
 8053d9b:	b8 50 3b 05 08       	mov    $0x8053b50,%eax
 8053da0:	75 05                	jne    8053da7 <test_r2rm_v+0x17>
 8053da2:	b8 d0 3c 05 08       	mov    $0x8053cd0,%eax
 8053da7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8053dab:	ff e0                	jmp    *%eax
 8053dad:	8d 76 00             	lea    0x0(%esi),%esi

08053db0 <test_i2rm_v>:
make_helper_v(test_i2rm)
 8053db0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8053db7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8053dbb:	b8 70 3b 05 08       	mov    $0x8053b70,%eax
 8053dc0:	75 05                	jne    8053dc7 <test_i2rm_v+0x17>
 8053dc2:	b8 f0 3c 05 08       	mov    $0x8053cf0,%eax
 8053dc7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8053dcb:	ff e0                	jmp    *%eax
 8053dcd:	8d 76 00             	lea    0x0(%esi),%esi

08053dd0 <test_i2a_v>:
make_helper_v(test_i2a)
 8053dd0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8053dd7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8053ddb:	b8 90 3b 05 08       	mov    $0x8053b90,%eax
 8053de0:	75 05                	jne    8053de7 <test_i2a_v+0x17>
 8053de2:	b8 10 3d 05 08       	mov    $0x8053d10,%eax
 8053de7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8053deb:	ff e0                	jmp    *%eax
 8053ded:	66 90                	xchg   %ax,%ax
 8053def:	90                   	nop

08053df0 <do_sbb_b>:
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
 8053df0:	55                   	push   %ebp
 8053df1:	57                   	push   %edi
 8053df2:	56                   	push   %esi
 8053df3:	53                   	push   %ebx
 8053df4:	83 ec 24             	sub    $0x24,%esp
	op_src->val = op_src->val + cpu.CF;
 8053df7:	0f b6 3d e4 ae 8f 14 	movzbl 0x148faee4,%edi
	uint32_t res = op_dest->val - op_src->val;
 8053dfe:	8b 0d 4c ae 8f 14    	mov    0x148fae4c,%ecx
 8053e04:	89 cb                	mov    %ecx,%ebx
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
	op_src->val = op_src->val + cpu.CF;
 8053e06:	89 fe                	mov    %edi,%esi
 8053e08:	83 e6 01             	and    $0x1,%esi
 8053e0b:	03 35 14 ae 8f 14    	add    0x148fae14,%esi
	uint32_t res = op_dest->val - op_src->val;
 8053e11:	29 f3                	sub    %esi,%ebx
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
	op_src->val = op_src->val + cpu.CF;
 8053e13:	89 35 14 ae 8f 14    	mov    %esi,0x148fae14
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
 8053e19:	0f b6 c3             	movzbl %bl,%eax
	pf = (pf >> 4) ^ pf;
 8053e1c:	89 c2                	mov    %eax,%edx
 8053e1e:	c1 ea 04             	shr    $0x4,%edx
 8053e21:	31 d0                	xor    %edx,%eax
	pf = (pf >> 2) ^ pf;
 8053e23:	89 c2                	mov    %eax,%edx
 8053e25:	c1 ea 02             	shr    $0x2,%edx
 8053e28:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 8053e2a:	89 c2                	mov    %eax,%edx
 8053e2c:	d1 ea                	shr    %edx
	cpu.CF = op_dest->val < op_src->val;
 8053e2e:	39 ce                	cmp    %ecx,%esi
	op_src->val = op_src->val + cpu.CF;
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 8053e30:	89 54 24 14          	mov    %edx,0x14(%esp)
	cpu.CF = op_dest->val < op_src->val;
 8053e34:	0f 97 c2             	seta   %dl
	op_src->val = op_src->val + cpu.CF;
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 8053e37:	33 44 24 14          	xor    0x14(%esp),%eax
	cpu.CF = op_dest->val < op_src->val;
 8053e3b:	83 e7 fa             	and    $0xfffffffa,%edi
 8053e3e:	89 d5                	mov    %edx,%ebp
	cpu.PF = (pf & 1);
 8053e40:	83 e0 01             	and    $0x1,%eax
 8053e43:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8053e4a:	89 f8                	mov    %edi,%eax
 8053e4c:	09 e8                	or     %ebp,%eax
 8053e4e:	09 d0                	or     %edx,%eax
	cpu.ZF = (res == 0);
 8053e50:	85 db                	test   %ebx,%ebx
 8053e52:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 8053e55:	c1 eb 1f             	shr    $0x1f,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 8053e58:	83 e0 3f             	and    $0x3f,%eax
 8053e5b:	c1 e2 06             	shl    $0x6,%edx
	cpu.SF = (res >> 31) & 1;
 8053e5e:	89 df                	mov    %ebx,%edi
 8053e60:	09 d0                	or     %edx,%eax
 8053e62:	c1 e7 07             	shl    $0x7,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053e65:	89 ca                	mov    %ecx,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 8053e67:	09 f8                	or     %edi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053e69:	c1 ea 1f             	shr    $0x1f,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 8053e6c:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053e71:	89 f0                	mov    %esi,%eax
 8053e73:	31 d3                	xor    %edx,%ebx
 8053e75:	c1 e8 1f             	shr    $0x1f,%eax
 8053e78:	31 d0                	xor    %edx,%eax
 8053e7a:	21 c3                	and    %eax,%ebx
 8053e7c:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
 8053e83:	c1 e3 03             	shl    $0x3,%ebx
 8053e86:	83 e0 f7             	and    $0xfffffff7,%eax
 8053e89:	09 c3                	or     %eax,%ebx
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8053e8b:	89 f0                	mov    %esi,%eax
 8053e8d:	29 c1                	sub    %eax,%ecx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053e8f:	88 1d e5 ae 8f 14    	mov    %bl,0x148faee5
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8053e95:	0f b6 c9             	movzbl %cl,%ecx
 8053e98:	51                   	push   %ecx
 8053e99:	68 40 ae 8f 14       	push   $0x148fae40
 8053e9e:	e8 9d 8d 00 00       	call   805cc40 <write_operand_b>
	print_asm_template2();
 8053ea3:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8053eaa:	68 18 ae 8f 14       	push   $0x148fae18
 8053eaf:	68 82 2c 06 08       	push   $0x8062c82
 8053eb4:	6a 50                	push   $0x50
 8053eb6:	68 00 89 0c 08       	push   $0x80c8900
 8053ebb:	e8 40 4c ff ff       	call   8048b00 <snprintf@plt>
 8053ec0:	83 c4 20             	add    $0x20,%esp
 8053ec3:	83 f8 4f             	cmp    $0x4f,%eax
 8053ec6:	7f 08                	jg     8053ed0 <do_sbb_b+0xe0>
}
 8053ec8:	83 c4 1c             	add    $0x1c,%esp
 8053ecb:	5b                   	pop    %ebx
 8053ecc:	5e                   	pop    %esi
 8053ecd:	5f                   	pop    %edi
 8053ece:	5d                   	pop    %ebp
 8053ecf:	c3                   	ret    
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
 8053ed0:	83 ec 0c             	sub    $0xc,%esp
 8053ed3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8053ed9:	e8 82 4a ff ff       	call   8048960 <fflush@plt>
 8053ede:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053ee4:	6a 07                	push   $0x7
 8053ee6:	6a 01                	push   $0x1
 8053ee8:	68 92 ed 05 08       	push   $0x805ed92
 8053eed:	e8 1e 4b ff ff       	call   8048a10 <fwrite@plt>
 8053ef2:	83 c4 20             	add    $0x20,%esp
 8053ef5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053efb:	6a 10                	push   $0x10
 8053efd:	6a 01                	push   $0x1
 8053eff:	68 84 f8 05 08       	push   $0x805f884
 8053f04:	e8 07 4b ff ff       	call   8048a10 <fwrite@plt>
 8053f09:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8053f0f:	6a 05                	push   $0x5
 8053f11:	6a 01                	push   $0x1
 8053f13:	68 b1 ed 05 08       	push   $0x805edb1
 8053f18:	e8 f3 4a ff ff       	call   8048a10 <fwrite@plt>
 8053f1d:	83 c4 14             	add    $0x14,%esp
 8053f20:	68 50 ae 8f 14       	push   $0x148fae50
 8053f25:	68 18 ae 8f 14       	push   $0x148fae18
 8053f2a:	68 82 2c 06 08       	push   $0x8062c82
 8053f2f:	6a 50                	push   $0x50
 8053f31:	68 00 89 0c 08       	push   $0x80c8900
 8053f36:	e8 c5 4b ff ff       	call   8048b00 <snprintf@plt>
 8053f3b:	83 c4 20             	add    $0x20,%esp
 8053f3e:	83 f8 4f             	cmp    $0x4f,%eax
 8053f41:	7e 85                	jle    8053ec8 <do_sbb_b+0xd8>
 8053f43:	68 09 2e 06 08       	push   $0x8062e09
 8053f48:	6a 12                	push   $0x12
 8053f4a:	68 a4 2c 06 08       	push   $0x8062ca4
 8053f4f:	68 cc 2c 06 08       	push   $0x8062ccc
 8053f54:	e8 57 4c ff ff       	call   8048bb0 <__assert_fail@plt>
 8053f59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08053f60 <do_sbb_w>:
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
 8053f60:	55                   	push   %ebp
 8053f61:	57                   	push   %edi
 8053f62:	56                   	push   %esi
 8053f63:	53                   	push   %ebx
 8053f64:	83 ec 24             	sub    $0x24,%esp
	op_src->val = op_src->val + cpu.CF;
 8053f67:	0f b6 3d e4 ae 8f 14 	movzbl 0x148faee4,%edi
	uint32_t res = op_dest->val - op_src->val;
 8053f6e:	8b 0d 4c ae 8f 14    	mov    0x148fae4c,%ecx
 8053f74:	89 cb                	mov    %ecx,%ebx
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
	op_src->val = op_src->val + cpu.CF;
 8053f76:	89 fe                	mov    %edi,%esi
 8053f78:	83 e6 01             	and    $0x1,%esi
 8053f7b:	03 35 14 ae 8f 14    	add    0x148fae14,%esi
	uint32_t res = op_dest->val - op_src->val;
 8053f81:	29 f3                	sub    %esi,%ebx
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
	op_src->val = op_src->val + cpu.CF;
 8053f83:	89 35 14 ae 8f 14    	mov    %esi,0x148fae14
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
 8053f89:	0f b6 c3             	movzbl %bl,%eax
	pf = (pf >> 4) ^ pf;
 8053f8c:	89 c2                	mov    %eax,%edx
 8053f8e:	c1 ea 04             	shr    $0x4,%edx
 8053f91:	31 d0                	xor    %edx,%eax
	pf = (pf >> 2) ^ pf;
 8053f93:	89 c2                	mov    %eax,%edx
 8053f95:	c1 ea 02             	shr    $0x2,%edx
 8053f98:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 8053f9a:	89 c2                	mov    %eax,%edx
 8053f9c:	d1 ea                	shr    %edx
	cpu.CF = op_dest->val < op_src->val;
 8053f9e:	39 ce                	cmp    %ecx,%esi
	op_src->val = op_src->val + cpu.CF;
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 8053fa0:	89 54 24 14          	mov    %edx,0x14(%esp)
	cpu.CF = op_dest->val < op_src->val;
 8053fa4:	0f 97 c2             	seta   %dl
	op_src->val = op_src->val + cpu.CF;
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 8053fa7:	33 44 24 14          	xor    0x14(%esp),%eax
	cpu.CF = op_dest->val < op_src->val;
 8053fab:	83 e7 fa             	and    $0xfffffffa,%edi
 8053fae:	89 d5                	mov    %edx,%ebp
	cpu.PF = (pf & 1);
 8053fb0:	83 e0 01             	and    $0x1,%eax
 8053fb3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8053fba:	89 f8                	mov    %edi,%eax
 8053fbc:	09 e8                	or     %ebp,%eax
 8053fbe:	09 d0                	or     %edx,%eax
	cpu.ZF = (res == 0);
 8053fc0:	85 db                	test   %ebx,%ebx
 8053fc2:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 8053fc5:	c1 eb 1f             	shr    $0x1f,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 8053fc8:	83 e0 3f             	and    $0x3f,%eax
 8053fcb:	c1 e2 06             	shl    $0x6,%edx
	cpu.SF = (res >> 31) & 1;
 8053fce:	89 df                	mov    %ebx,%edi
 8053fd0:	09 d0                	or     %edx,%eax
 8053fd2:	c1 e7 07             	shl    $0x7,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053fd5:	89 ca                	mov    %ecx,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 8053fd7:	09 f8                	or     %edi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053fd9:	c1 ea 1f             	shr    $0x1f,%edx
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8053fdc:	29 f1                	sub    %esi,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 8053fde:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053fe3:	89 f0                	mov    %esi,%eax
 8053fe5:	31 d3                	xor    %edx,%ebx
 8053fe7:	c1 e8 1f             	shr    $0x1f,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8053fea:	0f b7 c9             	movzwl %cx,%ecx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053fed:	31 d0                	xor    %edx,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8053fef:	51                   	push   %ecx
 8053ff0:	68 40 ae 8f 14       	push   $0x148fae40
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053ff5:	21 c3                	and    %eax,%ebx
 8053ff7:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
 8053ffe:	c1 e3 03             	shl    $0x3,%ebx
 8054001:	83 e0 f7             	and    $0xfffffff7,%eax
 8054004:	09 c3                	or     %eax,%ebx
 8054006:	88 1d e5 ae 8f 14    	mov    %bl,0x148faee5
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 805400c:	e8 bf 8f 00 00       	call   805cfd0 <write_operand_w>
	print_asm_template2();
 8054011:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8054018:	68 18 ae 8f 14       	push   $0x148fae18
 805401d:	68 8d 2c 06 08       	push   $0x8062c8d
 8054022:	6a 50                	push   $0x50
 8054024:	68 00 89 0c 08       	push   $0x80c8900
 8054029:	e8 d2 4a ff ff       	call   8048b00 <snprintf@plt>
 805402e:	83 c4 20             	add    $0x20,%esp
 8054031:	83 f8 4f             	cmp    $0x4f,%eax
 8054034:	7f 0a                	jg     8054040 <do_sbb_w+0xe0>
}
 8054036:	83 c4 1c             	add    $0x1c,%esp
 8054039:	5b                   	pop    %ebx
 805403a:	5e                   	pop    %esi
 805403b:	5f                   	pop    %edi
 805403c:	5d                   	pop    %ebp
 805403d:	c3                   	ret    
 805403e:	66 90                	xchg   %ax,%ax
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
 8054040:	83 ec 0c             	sub    $0xc,%esp
 8054043:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8054049:	e8 12 49 ff ff       	call   8048960 <fflush@plt>
 805404e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054054:	6a 07                	push   $0x7
 8054056:	6a 01                	push   $0x1
 8054058:	68 92 ed 05 08       	push   $0x805ed92
 805405d:	e8 ae 49 ff ff       	call   8048a10 <fwrite@plt>
 8054062:	83 c4 20             	add    $0x20,%esp
 8054065:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805406b:	6a 10                	push   $0x10
 805406d:	6a 01                	push   $0x1
 805406f:	68 84 f8 05 08       	push   $0x805f884
 8054074:	e8 97 49 ff ff       	call   8048a10 <fwrite@plt>
 8054079:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805407f:	6a 05                	push   $0x5
 8054081:	6a 01                	push   $0x1
 8054083:	68 b1 ed 05 08       	push   $0x805edb1
 8054088:	e8 83 49 ff ff       	call   8048a10 <fwrite@plt>
 805408d:	83 c4 14             	add    $0x14,%esp
 8054090:	68 50 ae 8f 14       	push   $0x148fae50
 8054095:	68 18 ae 8f 14       	push   $0x148fae18
 805409a:	68 8d 2c 06 08       	push   $0x8062c8d
 805409f:	6a 50                	push   $0x50
 80540a1:	68 00 89 0c 08       	push   $0x80c8900
 80540a6:	e8 55 4a ff ff       	call   8048b00 <snprintf@plt>
 80540ab:	83 c4 20             	add    $0x20,%esp
 80540ae:	83 f8 4f             	cmp    $0x4f,%eax
 80540b1:	7e 83                	jle    8054036 <do_sbb_w+0xd6>
 80540b3:	68 00 2e 06 08       	push   $0x8062e00
 80540b8:	6a 12                	push   $0x12
 80540ba:	68 a4 2c 06 08       	push   $0x8062ca4
 80540bf:	68 30 2d 06 08       	push   $0x8062d30
 80540c4:	e8 e7 4a ff ff       	call   8048bb0 <__assert_fail@plt>
 80540c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

080540d0 <sbb_i2a_w>:
}

make_instr_helper(i2a)
 80540d0:	53                   	push   %ebx
 80540d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80540d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80540d8:	83 c0 01             	add    $0x1,%eax
 80540db:	50                   	push   %eax
 80540dc:	e8 af 8c 00 00       	call   805cd90 <decode_i2a_w>
 80540e1:	89 c3                	mov    %eax,%ebx
	execute();
 80540e3:	e8 78 fe ff ff       	call   8053f60 <do_sbb_w>
 80540e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80540eb:	8d 43 01             	lea    0x1(%ebx),%eax
 80540ee:	5b                   	pop    %ebx
 80540ef:	c3                   	ret    

080540f0 <sbb_i2rm_w>:
make_instr_helper(i2rm)
 80540f0:	53                   	push   %ebx
 80540f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80540f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80540f8:	83 c0 01             	add    $0x1,%eax
 80540fb:	50                   	push   %eax
 80540fc:	e8 0f 8d 00 00       	call   805ce10 <decode_i2rm_w>
 8054101:	89 c3                	mov    %eax,%ebx
	execute();
 8054103:	e8 58 fe ff ff       	call   8053f60 <do_sbb_w>
 8054108:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805410b:	8d 43 01             	lea    0x1(%ebx),%eax
 805410e:	5b                   	pop    %ebx
 805410f:	c3                   	ret    

08054110 <sbb_r2rm_w>:
make_instr_helper(r2rm)
 8054110:	53                   	push   %ebx
 8054111:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054114:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054118:	83 c0 01             	add    $0x1,%eax
 805411b:	50                   	push   %eax
 805411c:	e8 2f 8c 00 00       	call   805cd50 <decode_r2rm_w>
 8054121:	89 c3                	mov    %eax,%ebx
	execute();
 8054123:	e8 38 fe ff ff       	call   8053f60 <do_sbb_w>
 8054128:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805412b:	8d 43 01             	lea    0x1(%ebx),%eax
 805412e:	5b                   	pop    %ebx
 805412f:	c3                   	ret    

08054130 <sbb_rm2r_w>:
make_instr_helper(rm2r)
 8054130:	53                   	push   %ebx
 8054131:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054134:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054138:	83 c0 01             	add    $0x1,%eax
 805413b:	50                   	push   %eax
 805413c:	e8 2f 8c 00 00       	call   805cd70 <decode_rm2r_w>
 8054141:	89 c3                	mov    %eax,%ebx
	execute();
 8054143:	e8 18 fe ff ff       	call   8053f60 <do_sbb_w>
 8054148:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805414b:	8d 43 01             	lea    0x1(%ebx),%eax
 805414e:	5b                   	pop    %ebx
 805414f:	c3                   	ret    

08054150 <sbb_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8054150:	53                   	push   %ebx
 8054151:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054154:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054158:	83 c0 01             	add    $0x1,%eax
 805415b:	50                   	push   %eax
 805415c:	e8 2f 8d 00 00       	call   805ce90 <decode_si2rm_w>
 8054161:	89 c3                	mov    %eax,%ebx
	execute();
 8054163:	e8 f8 fd ff ff       	call   8053f60 <do_sbb_w>
 8054168:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805416b:	8d 43 01             	lea    0x1(%ebx),%eax
 805416e:	5b                   	pop    %ebx
 805416f:	c3                   	ret    

08054170 <do_sbb_l>:
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
 8054170:	55                   	push   %ebp
 8054171:	57                   	push   %edi
 8054172:	56                   	push   %esi
 8054173:	53                   	push   %ebx
 8054174:	83 ec 14             	sub    $0x14,%esp
	op_src->val = op_src->val + cpu.CF;
 8054177:	0f b6 2d e4 ae 8f 14 	movzbl 0x148faee4,%ebp
	uint32_t res = op_dest->val - op_src->val;
 805417e:	8b 3d 4c ae 8f 14    	mov    0x148fae4c,%edi
 8054184:	89 f9                	mov    %edi,%ecx
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
	op_src->val = op_src->val + cpu.CF;
 8054186:	89 ea                	mov    %ebp,%edx
 8054188:	83 e2 01             	and    $0x1,%edx
 805418b:	03 15 14 ae 8f 14    	add    0x148fae14,%edx
	uint32_t res = op_dest->val - op_src->val;
 8054191:	29 d1                	sub    %edx,%ecx
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
	op_src->val = op_src->val + cpu.CF;
 8054193:	89 15 14 ae 8f 14    	mov    %edx,0x148fae14
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
 8054199:	0f b6 c1             	movzbl %cl,%eax
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 805419c:	51                   	push   %ecx
 805419d:	68 40 ae 8f 14       	push   $0x148fae40

static void do_execute() {
	op_src->val = op_src->val + cpu.CF;
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 80541a2:	89 c3                	mov    %eax,%ebx
 80541a4:	c1 eb 04             	shr    $0x4,%ebx
 80541a7:	31 d8                	xor    %ebx,%eax
	pf = (pf >> 2) ^ pf;
 80541a9:	89 c3                	mov    %eax,%ebx
 80541ab:	c1 eb 02             	shr    $0x2,%ebx
 80541ae:	31 d8                	xor    %ebx,%eax
	pf = (pf >> 1) ^ pf;
 80541b0:	89 c6                	mov    %eax,%esi
 80541b2:	d1 ee                	shr    %esi
	cpu.CF = op_dest->val < op_src->val;
 80541b4:	39 fa                	cmp    %edi,%edx
 80541b6:	0f 97 c3             	seta   %bl
	op_src->val = op_src->val + cpu.CF;
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 80541b9:	31 f0                	xor    %esi,%eax
	cpu.CF = op_dest->val < op_src->val;
 80541bb:	83 e5 fa             	and    $0xfffffffa,%ebp
	cpu.PF = (pf & 1);
 80541be:	83 e0 01             	and    $0x1,%eax
 80541c1:	09 eb                	or     %ebp,%ebx
 80541c3:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 80541ca:	09 f3                	or     %esi,%ebx
	cpu.ZF = (res == 0);
 80541cc:	85 c9                	test   %ecx,%ecx
 80541ce:	0f 94 c0             	sete   %al
 80541d1:	83 e3 3f             	and    $0x3f,%ebx
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 80541d4:	c1 ef 1f             	shr    $0x1f,%edi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 80541d7:	c1 e0 06             	shl    $0x6,%eax
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 80541da:	c1 ea 1f             	shr    $0x1f,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 80541dd:	89 c6                	mov    %eax,%esi
	cpu.SF = (res >> 31) & 1;
 80541df:	89 c8                	mov    %ecx,%eax
 80541e1:	c1 e8 1f             	shr    $0x1f,%eax
 80541e4:	09 f3                	or     %esi,%ebx
 80541e6:	89 c5                	mov    %eax,%ebp
 80541e8:	c1 e5 07             	shl    $0x7,%ebp
 80541eb:	09 eb                	or     %ebp,%ebx
 80541ed:	88 1d e4 ae 8f 14    	mov    %bl,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 80541f3:	89 c3                	mov    %eax,%ebx
 80541f5:	89 f8                	mov    %edi,%eax
 80541f7:	31 d0                	xor    %edx,%eax
 80541f9:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 8054200:	31 fb                	xor    %edi,%ebx
 8054202:	21 d8                	and    %ebx,%eax
 8054204:	c1 e0 03             	shl    $0x3,%eax
 8054207:	83 e2 f7             	and    $0xfffffff7,%edx
 805420a:	09 d0                	or     %edx,%eax
 805420c:	a2 e5 ae 8f 14       	mov    %al,0x148faee5
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8054211:	e8 8a 91 00 00       	call   805d3a0 <write_operand_l>
	print_asm_template2();
 8054216:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 805421d:	68 18 ae 8f 14       	push   $0x148fae18
 8054222:	68 98 2c 06 08       	push   $0x8062c98
 8054227:	6a 50                	push   $0x50
 8054229:	68 00 89 0c 08       	push   $0x80c8900
 805422e:	e8 cd 48 ff ff       	call   8048b00 <snprintf@plt>
 8054233:	83 c4 20             	add    $0x20,%esp
 8054236:	83 f8 4f             	cmp    $0x4f,%eax
 8054239:	7f 0d                	jg     8054248 <do_sbb_l+0xd8>
}
 805423b:	83 c4 0c             	add    $0xc,%esp
 805423e:	5b                   	pop    %ebx
 805423f:	5e                   	pop    %esi
 8054240:	5f                   	pop    %edi
 8054241:	5d                   	pop    %ebp
 8054242:	c3                   	ret    
 8054243:	90                   	nop
 8054244:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
 8054248:	83 ec 0c             	sub    $0xc,%esp
 805424b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8054251:	e8 0a 47 ff ff       	call   8048960 <fflush@plt>
 8054256:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805425c:	6a 07                	push   $0x7
 805425e:	6a 01                	push   $0x1
 8054260:	68 92 ed 05 08       	push   $0x805ed92
 8054265:	e8 a6 47 ff ff       	call   8048a10 <fwrite@plt>
 805426a:	83 c4 20             	add    $0x20,%esp
 805426d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054273:	6a 10                	push   $0x10
 8054275:	6a 01                	push   $0x1
 8054277:	68 84 f8 05 08       	push   $0x805f884
 805427c:	e8 8f 47 ff ff       	call   8048a10 <fwrite@plt>
 8054281:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054287:	6a 05                	push   $0x5
 8054289:	6a 01                	push   $0x1
 805428b:	68 b1 ed 05 08       	push   $0x805edb1
 8054290:	e8 7b 47 ff ff       	call   8048a10 <fwrite@plt>
 8054295:	83 c4 14             	add    $0x14,%esp
 8054298:	68 50 ae 8f 14       	push   $0x148fae50
 805429d:	68 18 ae 8f 14       	push   $0x148fae18
 80542a2:	68 98 2c 06 08       	push   $0x8062c98
 80542a7:	6a 50                	push   $0x50
 80542a9:	68 00 89 0c 08       	push   $0x80c8900
 80542ae:	e8 4d 48 ff ff       	call   8048b00 <snprintf@plt>
 80542b3:	83 c4 20             	add    $0x20,%esp
 80542b6:	83 f8 4f             	cmp    $0x4f,%eax
 80542b9:	7e 80                	jle    805423b <do_sbb_l+0xcb>
 80542bb:	68 f7 2d 06 08       	push   $0x8062df7
 80542c0:	6a 12                	push   $0x12
 80542c2:	68 a4 2c 06 08       	push   $0x8062ca4
 80542c7:	68 94 2d 06 08       	push   $0x8062d94
 80542cc:	e8 df 48 ff ff       	call   8048bb0 <__assert_fail@plt>
 80542d1:	eb 0d                	jmp    80542e0 <sbb_i2a_l>
 80542d3:	90                   	nop
 80542d4:	90                   	nop
 80542d5:	90                   	nop
 80542d6:	90                   	nop
 80542d7:	90                   	nop
 80542d8:	90                   	nop
 80542d9:	90                   	nop
 80542da:	90                   	nop
 80542db:	90                   	nop
 80542dc:	90                   	nop
 80542dd:	90                   	nop
 80542de:	90                   	nop
 80542df:	90                   	nop

080542e0 <sbb_i2a_l>:
}

make_instr_helper(i2a)
 80542e0:	53                   	push   %ebx
 80542e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80542e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80542e8:	83 c0 01             	add    $0x1,%eax
 80542eb:	50                   	push   %eax
 80542ec:	e8 6f 8e 00 00       	call   805d160 <decode_i2a_l>
 80542f1:	89 c3                	mov    %eax,%ebx
	execute();
 80542f3:	e8 78 fe ff ff       	call   8054170 <do_sbb_l>
 80542f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80542fb:	8d 43 01             	lea    0x1(%ebx),%eax
 80542fe:	5b                   	pop    %ebx
 80542ff:	c3                   	ret    

08054300 <sbb_i2rm_l>:
make_instr_helper(i2rm)
 8054300:	53                   	push   %ebx
 8054301:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054304:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054308:	83 c0 01             	add    $0x1,%eax
 805430b:	50                   	push   %eax
 805430c:	e8 cf 8e 00 00       	call   805d1e0 <decode_i2rm_l>
 8054311:	89 c3                	mov    %eax,%ebx
	execute();
 8054313:	e8 58 fe ff ff       	call   8054170 <do_sbb_l>
 8054318:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805431b:	8d 43 01             	lea    0x1(%ebx),%eax
 805431e:	5b                   	pop    %ebx
 805431f:	c3                   	ret    

08054320 <sbb_r2rm_l>:
make_instr_helper(r2rm)
 8054320:	53                   	push   %ebx
 8054321:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054324:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054328:	83 c0 01             	add    $0x1,%eax
 805432b:	50                   	push   %eax
 805432c:	e8 ef 8d 00 00       	call   805d120 <decode_r2rm_l>
 8054331:	89 c3                	mov    %eax,%ebx
	execute();
 8054333:	e8 38 fe ff ff       	call   8054170 <do_sbb_l>
 8054338:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805433b:	8d 43 01             	lea    0x1(%ebx),%eax
 805433e:	5b                   	pop    %ebx
 805433f:	c3                   	ret    

08054340 <sbb_rm2r_l>:
make_instr_helper(rm2r)
 8054340:	53                   	push   %ebx
 8054341:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054344:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054348:	83 c0 01             	add    $0x1,%eax
 805434b:	50                   	push   %eax
 805434c:	e8 ef 8d 00 00       	call   805d140 <decode_rm2r_l>
 8054351:	89 c3                	mov    %eax,%ebx
	execute();
 8054353:	e8 18 fe ff ff       	call   8054170 <do_sbb_l>
 8054358:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805435b:	8d 43 01             	lea    0x1(%ebx),%eax
 805435e:	5b                   	pop    %ebx
 805435f:	c3                   	ret    

08054360 <sbb_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8054360:	53                   	push   %ebx
 8054361:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054364:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054368:	83 c0 01             	add    $0x1,%eax
 805436b:	50                   	push   %eax
 805436c:	e8 ef 8e 00 00       	call   805d260 <decode_si2rm_l>
 8054371:	89 c3                	mov    %eax,%ebx
	execute();
 8054373:	e8 f8 fd ff ff       	call   8054170 <do_sbb_l>
 8054378:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805437b:	8d 43 01             	lea    0x1(%ebx),%eax
 805437e:	5b                   	pop    %ebx
 805437f:	c3                   	ret    

08054380 <sbb_i2a_b>:
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
}

make_instr_helper(i2a)
 8054380:	53                   	push   %ebx
 8054381:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054384:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054388:	83 c0 01             	add    $0x1,%eax
 805438b:	50                   	push   %eax
 805438c:	e8 cf 86 00 00       	call   805ca60 <decode_i2a_b>
 8054391:	89 c3                	mov    %eax,%ebx
	execute();
 8054393:	e8 58 fa ff ff       	call   8053df0 <do_sbb_b>
 8054398:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805439b:	8d 43 01             	lea    0x1(%ebx),%eax
 805439e:	5b                   	pop    %ebx
 805439f:	c3                   	ret    

080543a0 <sbb_i2rm_b>:
make_instr_helper(i2rm)
 80543a0:	53                   	push   %ebx
 80543a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80543a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80543a8:	83 c0 01             	add    $0x1,%eax
 80543ab:	50                   	push   %eax
 80543ac:	e8 2f 87 00 00       	call   805cae0 <decode_i2rm_b>
 80543b1:	89 c3                	mov    %eax,%ebx
	execute();
 80543b3:	e8 38 fa ff ff       	call   8053df0 <do_sbb_b>
 80543b8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80543bb:	8d 43 01             	lea    0x1(%ebx),%eax
 80543be:	5b                   	pop    %ebx
 80543bf:	c3                   	ret    

080543c0 <sbb_r2rm_b>:
make_instr_helper(r2rm)
 80543c0:	53                   	push   %ebx
 80543c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80543c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80543c8:	83 c0 01             	add    $0x1,%eax
 80543cb:	50                   	push   %eax
 80543cc:	e8 4f 86 00 00       	call   805ca20 <decode_r2rm_b>
 80543d1:	89 c3                	mov    %eax,%ebx
	execute();
 80543d3:	e8 18 fa ff ff       	call   8053df0 <do_sbb_b>
 80543d8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80543db:	8d 43 01             	lea    0x1(%ebx),%eax
 80543de:	5b                   	pop    %ebx
 80543df:	c3                   	ret    

080543e0 <sbb_rm2r_b>:
make_instr_helper(rm2r)
 80543e0:	53                   	push   %ebx
 80543e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80543e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80543e8:	83 c0 01             	add    $0x1,%eax
 80543eb:	50                   	push   %eax
 80543ec:	e8 4f 86 00 00       	call   805ca40 <decode_rm2r_b>
 80543f1:	89 c3                	mov    %eax,%ebx
	execute();
 80543f3:	e8 f8 f9 ff ff       	call   8053df0 <do_sbb_b>
 80543f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80543fb:	8d 43 01             	lea    0x1(%ebx),%eax
 80543fe:	5b                   	pop    %ebx
 80543ff:	c3                   	ret    

08054400 <sbb_si2rm_v>:
#include "sbb-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(sbb_si2rm)
 8054400:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8054407:	8b 54 24 04          	mov    0x4(%esp),%edx
 805440b:	b8 50 41 05 08       	mov    $0x8054150,%eax
 8054410:	75 05                	jne    8054417 <sbb_si2rm_v+0x17>
 8054412:	b8 60 43 05 08       	mov    $0x8054360,%eax
 8054417:	89 54 24 04          	mov    %edx,0x4(%esp)
 805441b:	ff e0                	jmp    *%eax
 805441d:	8d 76 00             	lea    0x0(%esi),%esi

08054420 <sbb_i2rm_v>:
make_helper_v(sbb_i2rm)
 8054420:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8054427:	8b 54 24 04          	mov    0x4(%esp),%edx
 805442b:	b8 f0 40 05 08       	mov    $0x80540f0,%eax
 8054430:	75 05                	jne    8054437 <sbb_i2rm_v+0x17>
 8054432:	b8 00 43 05 08       	mov    $0x8054300,%eax
 8054437:	89 54 24 04          	mov    %edx,0x4(%esp)
 805443b:	ff e0                	jmp    *%eax
 805443d:	8d 76 00             	lea    0x0(%esi),%esi

08054440 <sbb_i2a_v>:
make_helper_v(sbb_i2a)
 8054440:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8054447:	8b 54 24 04          	mov    0x4(%esp),%edx
 805444b:	b8 d0 40 05 08       	mov    $0x80540d0,%eax
 8054450:	75 05                	jne    8054457 <sbb_i2a_v+0x17>
 8054452:	b8 e0 42 05 08       	mov    $0x80542e0,%eax
 8054457:	89 54 24 04          	mov    %edx,0x4(%esp)
 805445b:	ff e0                	jmp    *%eax
 805445d:	8d 76 00             	lea    0x0(%esi),%esi

08054460 <sbb_r2rm_v>:
make_helper_v(sbb_r2rm)
 8054460:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8054467:	8b 54 24 04          	mov    0x4(%esp),%edx
 805446b:	b8 10 41 05 08       	mov    $0x8054110,%eax
 8054470:	75 05                	jne    8054477 <sbb_r2rm_v+0x17>
 8054472:	b8 20 43 05 08       	mov    $0x8054320,%eax
 8054477:	89 54 24 04          	mov    %edx,0x4(%esp)
 805447b:	ff e0                	jmp    *%eax
 805447d:	8d 76 00             	lea    0x0(%esi),%esi

08054480 <sbb_rm2r_v>:
make_helper_v(sbb_rm2r)
 8054480:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8054487:	8b 54 24 04          	mov    0x4(%esp),%edx
 805448b:	b8 30 41 05 08       	mov    $0x8054130,%eax
 8054490:	75 05                	jne    8054497 <sbb_rm2r_v+0x17>
 8054492:	b8 40 43 05 08       	mov    $0x8054340,%eax
 8054497:	89 54 24 04          	mov    %edx,0x4(%esp)
 805449b:	ff e0                	jmp    *%eax
 805449d:	66 90                	xchg   %ax,%ax
 805449f:	90                   	nop

080544a0 <nop>:
#include "cpu/exec/helper.h"
#include "cpu/decode/modrm.h"

make_helper(nop) {
	print_asm("nop");
 80544a0:	c7 05 00 89 0c 08 6e 	movl   $0x706f6e,0x80c8900
 80544a7:	6f 70 00 
	return 1;
}
 80544aa:	b8 01 00 00 00       	mov    $0x1,%eax
 80544af:	c3                   	ret    

080544b0 <int3>:

make_helper(int3) {
 80544b0:	83 ec 0c             	sub    $0xc,%esp
	void do_int3();
	do_int3();
 80544b3:	e8 68 68 ff ff       	call   804ad20 <do_int3>
	print_asm("int3");
 80544b8:	c7 05 00 89 0c 08 69 	movl   $0x33746e69,0x80c8900
 80544bf:	6e 74 33 
 80544c2:	c6 05 04 89 0c 08 00 	movb   $0x0,0x80c8904

	return 1;
}
 80544c9:	b8 01 00 00 00       	mov    $0x1,%eax
 80544ce:	83 c4 0c             	add    $0xc,%esp
 80544d1:	c3                   	ret    
 80544d2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80544d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080544e0 <lea>:

make_helper(lea) {
 80544e0:	53                   	push   %ebx
 80544e1:	83 ec 20             	sub    $0x20,%esp
	ModR_M m;
	m.val = instr_fetch(eip + 1, 1);
 80544e4:	8b 44 24 28          	mov    0x28(%esp),%eax

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 80544e8:	6a 01                	push   $0x1
 80544ea:	8d 58 01             	lea    0x1(%eax),%ebx
 80544ed:	53                   	push   %ebx
 80544ee:	e8 6d 6a ff ff       	call   804af60 <swaddr_read>
 80544f3:	88 44 24 1f          	mov    %al,0x1f(%esp)
	int len = load_addr(eip + 1, &m, op_src);
 80544f7:	83 c4 0c             	add    $0xc,%esp
 80544fa:	68 08 ae 8f 14       	push   $0x148fae08
 80544ff:	8d 44 24 17          	lea    0x17(%esp),%eax
 8054503:	50                   	push   %eax
 8054504:	53                   	push   %ebx
 8054505:	e8 06 8f 00 00       	call   805d410 <load_addr>
	reg_l(m.reg) = op_src->addr;
 805450a:	0f b6 54 24 1f       	movzbl 0x1f(%esp),%edx
}

make_helper(lea) {
	ModR_M m;
	m.val = instr_fetch(eip + 1, 1);
	int len = load_addr(eip + 1, &m, op_src);
 805450f:	89 c3                	mov    %eax,%ebx
	reg_l(m.reg) = op_src->addr;
 8054511:	a1 10 ae 8f 14       	mov    0x148fae10,%eax
 8054516:	c0 ea 03             	shr    $0x3,%dl
 8054519:	83 e2 07             	and    $0x7,%edx
 805451c:	89 04 95 c0 ae 8f 14 	mov    %eax,0x148faec0(,%edx,4)

	print_asm("leal %s,%%%s", op_src->str, regsl[m.reg]);
 8054523:	58                   	pop    %eax
 8054524:	ff 34 95 c0 5b 07 08 	pushl  0x8075bc0(,%edx,4)
 805452b:	68 18 ae 8f 14       	push   $0x148fae18
 8054530:	68 12 2e 06 08       	push   $0x8062e12
 8054535:	6a 50                	push   $0x50
 8054537:	68 00 89 0c 08       	push   $0x80c8900
 805453c:	e8 bf 45 ff ff       	call   8048b00 <snprintf@plt>
 8054541:	83 c4 20             	add    $0x20,%esp
 8054544:	83 f8 4f             	cmp    $0x4f,%eax
 8054547:	7f 0f                	jg     8054558 <lea+0x78>
	return 1 + len;
}
 8054549:	83 c4 18             	add    $0x18,%esp
	m.val = instr_fetch(eip + 1, 1);
	int len = load_addr(eip + 1, &m, op_src);
	reg_l(m.reg) = op_src->addr;

	print_asm("leal %s,%%%s", op_src->str, regsl[m.reg]);
	return 1 + len;
 805454c:	8d 43 01             	lea    0x1(%ebx),%eax
}
 805454f:	5b                   	pop    %ebx
 8054550:	c3                   	ret    
 8054551:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	ModR_M m;
	m.val = instr_fetch(eip + 1, 1);
	int len = load_addr(eip + 1, &m, op_src);
	reg_l(m.reg) = op_src->addr;

	print_asm("leal %s,%%%s", op_src->str, regsl[m.reg]);
 8054558:	83 ec 0c             	sub    $0xc,%esp
 805455b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8054561:	e8 fa 43 ff ff       	call   8048960 <fflush@plt>
 8054566:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805456c:	6a 07                	push   $0x7
 805456e:	6a 01                	push   $0x1
 8054570:	68 92 ed 05 08       	push   $0x805ed92
 8054575:	e8 96 44 ff ff       	call   8048a10 <fwrite@plt>
 805457a:	83 c4 20             	add    $0x20,%esp
 805457d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054583:	6a 10                	push   $0x10
 8054585:	6a 01                	push   $0x1
 8054587:	68 84 f8 05 08       	push   $0x805f884
 805458c:	e8 7f 44 ff ff       	call   8048a10 <fwrite@plt>
 8054591:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054597:	6a 05                	push   $0x5
 8054599:	6a 01                	push   $0x1
 805459b:	68 b1 ed 05 08       	push   $0x805edb1
 80545a0:	e8 6b 44 ff ff       	call   8048a10 <fwrite@plt>
 80545a5:	83 c4 14             	add    $0x14,%esp
 80545a8:	0f b6 44 24 1b       	movzbl 0x1b(%esp),%eax
 80545ad:	c0 e8 03             	shr    $0x3,%al
 80545b0:	83 e0 07             	and    $0x7,%eax
 80545b3:	ff 34 85 c0 5b 07 08 	pushl  0x8075bc0(,%eax,4)
 80545ba:	68 18 ae 8f 14       	push   $0x148fae18
 80545bf:	68 12 2e 06 08       	push   $0x8062e12
 80545c4:	6a 50                	push   $0x50
 80545c6:	68 00 89 0c 08       	push   $0x80c8900
 80545cb:	e8 30 45 ff ff       	call   8048b00 <snprintf@plt>
 80545d0:	83 c4 20             	add    $0x20,%esp
 80545d3:	83 f8 4f             	cmp    $0x4f,%eax
 80545d6:	0f 8e 6d ff ff ff    	jle    8054549 <lea+0x69>
 80545dc:	68 93 2e 06 08       	push   $0x8062e93
 80545e1:	6a 17                	push   $0x17
 80545e3:	68 1f 2e 06 08       	push   $0x8062e1f
 80545e8:	68 40 2e 06 08       	push   $0x8062e40
 80545ed:	e8 be 45 ff ff       	call   8048bb0 <__assert_fail@plt>
 80545f2:	66 90                	xchg   %ax,%ax
 80545f4:	66 90                	xchg   %ax,%ax
 80545f6:	66 90                	xchg   %ax,%ax
 80545f8:	66 90                	xchg   %ax,%ax
 80545fa:	66 90                	xchg   %ax,%ax
 80545fc:	66 90                	xchg   %ax,%ax
 80545fe:	66 90                	xchg   %ax,%ax

08054600 <jbe_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8054600:	53                   	push   %ebx
 8054601:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054604:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054608:	83 c0 01             	add    $0x1,%eax
 805460b:	50                   	push   %eax
 805460c:	e8 2f 8a 00 00       	call   805d040 <decode_i_l>
#define instr jbe

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF || cpu.ZF) {
 8054611:	83 c4 10             	add    $0x10,%esp
 8054614:	f6 05 e4 ae 8f 14 41 	testb  $0x41,0x148faee4
 805461b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jbe

static void do_execute() {
	int res = op_src->val;
 805461d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF || cpu.ZF) {
 8054622:	74 06                	je     805462a <jbe_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8054624:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805462a:	68 18 ae 8f 14       	push   $0x148fae18
 805462f:	68 97 2e 06 08       	push   $0x8062e97
 8054634:	6a 50                	push   $0x50
 8054636:	68 00 89 0c 08       	push   $0x80c8900
 805463b:	e8 c0 44 ff ff       	call   8048b00 <snprintf@plt>
 8054640:	83 c4 10             	add    $0x10,%esp
 8054643:	83 f8 4f             	cmp    $0x4f,%eax
 8054646:	7f 08                	jg     8054650 <jbe_i_l+0x50>
}

make_instr_helper(i)
 8054648:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805464b:	8d 43 01             	lea    0x1(%ebx),%eax
 805464e:	5b                   	pop    %ebx
 805464f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054650:	83 ec 0c             	sub    $0xc,%esp
 8054653:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8054659:	e8 02 43 ff ff       	call   8048960 <fflush@plt>
 805465e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054664:	6a 07                	push   $0x7
 8054666:	6a 01                	push   $0x1
 8054668:	68 92 ed 05 08       	push   $0x805ed92
 805466d:	e8 9e 43 ff ff       	call   8048a10 <fwrite@plt>
 8054672:	83 c4 20             	add    $0x20,%esp
 8054675:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805467b:	6a 10                	push   $0x10
 805467d:	6a 01                	push   $0x1
 805467f:	68 84 f8 05 08       	push   $0x805f884
 8054684:	e8 87 43 ff ff       	call   8048a10 <fwrite@plt>
 8054689:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805468f:	6a 05                	push   $0x5
 8054691:	6a 01                	push   $0x1
 8054693:	68 b1 ed 05 08       	push   $0x805edb1
 8054698:	e8 73 43 ff ff       	call   8048a10 <fwrite@plt>
 805469d:	83 c4 20             	add    $0x20,%esp
 80546a0:	68 18 ae 8f 14       	push   $0x148fae18
 80546a5:	68 97 2e 06 08       	push   $0x8062e97
 80546aa:	6a 50                	push   $0x50
 80546ac:	68 00 89 0c 08       	push   $0x80c8900
 80546b1:	e8 4a 44 ff ff       	call   8048b00 <snprintf@plt>
 80546b6:	83 c4 10             	add    $0x10,%esp
 80546b9:	83 f8 4f             	cmp    $0x4f,%eax
 80546bc:	7e 8a                	jle    8054648 <jbe_i_l+0x48>
 80546be:	68 ae 2f 06 08       	push   $0x8062fae
 80546c3:	6a 0e                	push   $0xe
 80546c5:	68 b0 2e 06 08       	push   $0x8062eb0
 80546ca:	68 d8 2e 06 08       	push   $0x8062ed8
 80546cf:	e8 dc 44 ff ff       	call   8048bb0 <__assert_fail@plt>
 80546d4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80546da:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080546e0 <jbe_i_w>:
}

make_instr_helper(i)
 80546e0:	53                   	push   %ebx
 80546e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80546e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80546e8:	83 c0 01             	add    $0x1,%eax
 80546eb:	50                   	push   %eax
 80546ec:	e8 bf 85 00 00       	call   805ccb0 <decode_i_w>
#define instr jbe

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF || cpu.ZF) {
 80546f1:	83 c4 10             	add    $0x10,%esp
 80546f4:	f6 05 e4 ae 8f 14 41 	testb  $0x41,0x148faee4
 80546fb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jbe

static void do_execute() {
	int res = op_src->val;
 80546fd:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF || cpu.ZF) {
 8054702:	74 0f                	je     8054713 <jbe_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8054704:	66 03 05 e0 ae 8f 14 	add    0x148faee0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 805470b:	0f b7 c0             	movzwl %ax,%eax
 805470e:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
#endif
	}
	print_asm_template1();
 8054713:	68 18 ae 8f 14       	push   $0x148fae18
 8054718:	68 9f 2e 06 08       	push   $0x8062e9f
 805471d:	6a 50                	push   $0x50
 805471f:	68 00 89 0c 08       	push   $0x80c8900
 8054724:	e8 d7 43 ff ff       	call   8048b00 <snprintf@plt>
 8054729:	83 c4 10             	add    $0x10,%esp
 805472c:	83 f8 4f             	cmp    $0x4f,%eax
 805472f:	7f 0f                	jg     8054740 <jbe_i_w+0x60>
}

make_instr_helper(i)
 8054731:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054734:	8d 43 01             	lea    0x1(%ebx),%eax
 8054737:	5b                   	pop    %ebx
 8054738:	c3                   	ret    
 8054739:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054740:	83 ec 0c             	sub    $0xc,%esp
 8054743:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8054749:	e8 12 42 ff ff       	call   8048960 <fflush@plt>
 805474e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054754:	6a 07                	push   $0x7
 8054756:	6a 01                	push   $0x1
 8054758:	68 92 ed 05 08       	push   $0x805ed92
 805475d:	e8 ae 42 ff ff       	call   8048a10 <fwrite@plt>
 8054762:	83 c4 20             	add    $0x20,%esp
 8054765:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805476b:	6a 10                	push   $0x10
 805476d:	6a 01                	push   $0x1
 805476f:	68 84 f8 05 08       	push   $0x805f884
 8054774:	e8 97 42 ff ff       	call   8048a10 <fwrite@plt>
 8054779:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805477f:	6a 05                	push   $0x5
 8054781:	6a 01                	push   $0x1
 8054783:	68 b1 ed 05 08       	push   $0x805edb1
 8054788:	e8 83 42 ff ff       	call   8048a10 <fwrite@plt>
 805478d:	83 c4 20             	add    $0x20,%esp
 8054790:	68 18 ae 8f 14       	push   $0x148fae18
 8054795:	68 9f 2e 06 08       	push   $0x8062e9f
 805479a:	6a 50                	push   $0x50
 805479c:	68 00 89 0c 08       	push   $0x80c8900
 80547a1:	e8 5a 43 ff ff       	call   8048b00 <snprintf@plt>
 80547a6:	83 c4 10             	add    $0x10,%esp
 80547a9:	83 f8 4f             	cmp    $0x4f,%eax
 80547ac:	7e 83                	jle    8054731 <jbe_i_w+0x51>
 80547ae:	68 b7 2f 06 08       	push   $0x8062fb7
 80547b3:	6a 0e                	push   $0xe
 80547b5:	68 b0 2e 06 08       	push   $0x8062eb0
 80547ba:	68 20 2f 06 08       	push   $0x8062f20
 80547bf:	e8 ec 43 ff ff       	call   8048bb0 <__assert_fail@plt>
 80547c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80547ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080547d0 <jbe_i_b>:
}

make_instr_helper(i)
 80547d0:	53                   	push   %ebx
 80547d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80547d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80547d8:	83 c0 01             	add    $0x1,%eax
 80547db:	50                   	push   %eax
 80547dc:	e8 5f 81 00 00       	call   805c940 <decode_i_b>
#define instr jbe

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF || cpu.ZF) {
 80547e1:	83 c4 10             	add    $0x10,%esp
 80547e4:	f6 05 e4 ae 8f 14 41 	testb  $0x41,0x148faee4
 80547eb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jbe

static void do_execute() {
	int res = op_src->val;
 80547ed:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF || cpu.ZF) {
 80547f2:	74 09                	je     80547fd <jbe_i_b+0x2d>

#define instr jbe

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 80547f4:	0f be c0             	movsbl %al,%eax
	if(cpu.CF || cpu.ZF) {
		cpu.eip = cpu.eip + res;
 80547f7:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80547fd:	68 18 ae 8f 14       	push   $0x148fae18
 8054802:	68 a7 2e 06 08       	push   $0x8062ea7
 8054807:	6a 50                	push   $0x50
 8054809:	68 00 89 0c 08       	push   $0x80c8900
 805480e:	e8 ed 42 ff ff       	call   8048b00 <snprintf@plt>
 8054813:	83 c4 10             	add    $0x10,%esp
 8054816:	83 f8 4f             	cmp    $0x4f,%eax
 8054819:	7f 0d                	jg     8054828 <jbe_i_b+0x58>
}

make_instr_helper(i)
 805481b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805481e:	8d 43 01             	lea    0x1(%ebx),%eax
 8054821:	5b                   	pop    %ebx
 8054822:	c3                   	ret    
 8054823:	90                   	nop
 8054824:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054828:	83 ec 0c             	sub    $0xc,%esp
 805482b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8054831:	e8 2a 41 ff ff       	call   8048960 <fflush@plt>
 8054836:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805483c:	6a 07                	push   $0x7
 805483e:	6a 01                	push   $0x1
 8054840:	68 92 ed 05 08       	push   $0x805ed92
 8054845:	e8 c6 41 ff ff       	call   8048a10 <fwrite@plt>
 805484a:	83 c4 20             	add    $0x20,%esp
 805484d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054853:	6a 10                	push   $0x10
 8054855:	6a 01                	push   $0x1
 8054857:	68 84 f8 05 08       	push   $0x805f884
 805485c:	e8 af 41 ff ff       	call   8048a10 <fwrite@plt>
 8054861:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054867:	6a 05                	push   $0x5
 8054869:	6a 01                	push   $0x1
 805486b:	68 b1 ed 05 08       	push   $0x805edb1
 8054870:	e8 9b 41 ff ff       	call   8048a10 <fwrite@plt>
 8054875:	83 c4 20             	add    $0x20,%esp
 8054878:	68 18 ae 8f 14       	push   $0x148fae18
 805487d:	68 a7 2e 06 08       	push   $0x8062ea7
 8054882:	6a 50                	push   $0x50
 8054884:	68 00 89 0c 08       	push   $0x80c8900
 8054889:	e8 72 42 ff ff       	call   8048b00 <snprintf@plt>
 805488e:	83 c4 10             	add    $0x10,%esp
 8054891:	83 f8 4f             	cmp    $0x4f,%eax
 8054894:	7e 85                	jle    805481b <jbe_i_b+0x4b>
 8054896:	68 c0 2f 06 08       	push   $0x8062fc0
 805489b:	6a 0e                	push   $0xe
 805489d:	68 b0 2e 06 08       	push   $0x8062eb0
 80548a2:	68 68 2f 06 08       	push   $0x8062f68
 80548a7:	e8 04 43 ff ff       	call   8048bb0 <__assert_fail@plt>
 80548ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080548b0 <jbe_i_v>:
#include "jbe-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jbe_i)
 80548b0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80548b7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80548bb:	b8 e0 46 05 08       	mov    $0x80546e0,%eax
 80548c0:	75 05                	jne    80548c7 <jbe_i_v+0x17>
 80548c2:	b8 00 46 05 08       	mov    $0x8054600,%eax
 80548c7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80548cb:	ff e0                	jmp    *%eax
 80548cd:	66 90                	xchg   %ax,%ax
 80548cf:	90                   	nop

080548d0 <jg_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 80548d0:	56                   	push   %esi
 80548d1:	53                   	push   %ebx
 80548d2:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80548d5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80548d9:	83 c0 01             	add    $0x1,%eax
 80548dc:	50                   	push   %eax
 80548dd:	e8 5e 87 00 00       	call   805d040 <decode_i_l>
#define instr jg

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 80548e2:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 80548e9:	89 c3                	mov    %eax,%ebx
 80548eb:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 80548f2:	83 c4 10             	add    $0x10,%esp
#include "cpu/exec/template-start.h"

#define instr jg

static void do_execute() {
	int res = op_src->val;
 80548f5:	8b 35 14 ae 8f 14    	mov    0x148fae14,%esi
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 80548fb:	c0 ea 03             	shr    $0x3,%dl
 80548fe:	89 c1                	mov    %eax,%ecx
 8054900:	83 e2 01             	and    $0x1,%edx
 8054903:	c0 e9 07             	shr    $0x7,%cl
 8054906:	38 ca                	cmp    %cl,%dl
 8054908:	0f 84 b2 00 00 00    	je     80549c0 <jg_i_l+0xf0>
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805490e:	68 18 ae 8f 14       	push   $0x148fae18
 8054913:	68 c9 2f 06 08       	push   $0x8062fc9
 8054918:	6a 50                	push   $0x50
 805491a:	68 00 89 0c 08       	push   $0x80c8900
 805491f:	e8 dc 41 ff ff       	call   8048b00 <snprintf@plt>
 8054924:	83 c4 10             	add    $0x10,%esp
 8054927:	83 f8 4f             	cmp    $0x4f,%eax
 805492a:	7f 0c                	jg     8054938 <jg_i_l+0x68>
}

make_instr_helper(i)
 805492c:	83 c4 04             	add    $0x4,%esp
	execute();
	return len + 1;	// "1" for opcode
 805492f:	8d 43 01             	lea    0x1(%ebx),%eax
 8054932:	5b                   	pop    %ebx
 8054933:	5e                   	pop    %esi
 8054934:	c3                   	ret    
 8054935:	8d 76 00             	lea    0x0(%esi),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054938:	83 ec 0c             	sub    $0xc,%esp
 805493b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8054941:	e8 1a 40 ff ff       	call   8048960 <fflush@plt>
 8054946:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805494c:	6a 07                	push   $0x7
 805494e:	6a 01                	push   $0x1
 8054950:	68 92 ed 05 08       	push   $0x805ed92
 8054955:	e8 b6 40 ff ff       	call   8048a10 <fwrite@plt>
 805495a:	83 c4 20             	add    $0x20,%esp
 805495d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054963:	6a 10                	push   $0x10
 8054965:	6a 01                	push   $0x1
 8054967:	68 84 f8 05 08       	push   $0x805f884
 805496c:	e8 9f 40 ff ff       	call   8048a10 <fwrite@plt>
 8054971:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054977:	6a 05                	push   $0x5
 8054979:	6a 01                	push   $0x1
 805497b:	68 b1 ed 05 08       	push   $0x805edb1
 8054980:	e8 8b 40 ff ff       	call   8048a10 <fwrite@plt>
 8054985:	83 c4 20             	add    $0x20,%esp
 8054988:	68 18 ae 8f 14       	push   $0x148fae18
 805498d:	68 c9 2f 06 08       	push   $0x8062fc9
 8054992:	6a 50                	push   $0x50
 8054994:	68 00 89 0c 08       	push   $0x80c8900
 8054999:	e8 62 41 ff ff       	call   8048b00 <snprintf@plt>
 805499e:	83 c4 10             	add    $0x10,%esp
 80549a1:	83 f8 4f             	cmp    $0x4f,%eax
 80549a4:	7e 86                	jle    805492c <jg_i_l+0x5c>
 80549a6:	68 d9 30 06 08       	push   $0x80630d9
 80549ab:	6a 0e                	push   $0xe
 80549ad:	68 e0 2f 06 08       	push   $0x8062fe0
 80549b2:	68 04 30 06 08       	push   $0x8063004
 80549b7:	e8 f4 41 ff ff       	call   8048bb0 <__assert_fail@plt>
 80549bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr jg

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 80549c0:	a8 40                	test   $0x40,%al
 80549c2:	0f 85 46 ff ff ff    	jne    805490e <jg_i_l+0x3e>
		cpu.eip = cpu.eip + res;
 80549c8:	01 35 e0 ae 8f 14    	add    %esi,0x148faee0
 80549ce:	e9 3b ff ff ff       	jmp    805490e <jg_i_l+0x3e>
 80549d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80549d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080549e0 <jg_i_w>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 80549e0:	56                   	push   %esi
 80549e1:	53                   	push   %ebx
 80549e2:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80549e5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80549e9:	83 c0 01             	add    $0x1,%eax
 80549ec:	50                   	push   %eax
 80549ed:	e8 be 82 00 00       	call   805ccb0 <decode_i_w>
#define instr jg

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 80549f2:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 80549f9:	89 c3                	mov    %eax,%ebx
 80549fb:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 8054a02:	83 c4 10             	add    $0x10,%esp
#include "cpu/exec/template-start.h"

#define instr jg

static void do_execute() {
	int res = op_src->val;
 8054a05:	8b 35 14 ae 8f 14    	mov    0x148fae14,%esi
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 8054a0b:	c0 ea 03             	shr    $0x3,%dl
 8054a0e:	89 c1                	mov    %eax,%ecx
 8054a10:	83 e2 01             	and    $0x1,%edx
 8054a13:	c0 e9 07             	shr    $0x7,%cl
 8054a16:	38 ca                	cmp    %cl,%dl
 8054a18:	0f 84 b2 00 00 00    	je     8054ad0 <jg_i_w+0xf0>
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054a1e:	68 18 ae 8f 14       	push   $0x148fae18
 8054a23:	68 d0 2f 06 08       	push   $0x8062fd0
 8054a28:	6a 50                	push   $0x50
 8054a2a:	68 00 89 0c 08       	push   $0x80c8900
 8054a2f:	e8 cc 40 ff ff       	call   8048b00 <snprintf@plt>
 8054a34:	83 c4 10             	add    $0x10,%esp
 8054a37:	83 f8 4f             	cmp    $0x4f,%eax
 8054a3a:	7f 0c                	jg     8054a48 <jg_i_w+0x68>
}

make_instr_helper(i)
 8054a3c:	83 c4 04             	add    $0x4,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054a3f:	8d 43 01             	lea    0x1(%ebx),%eax
 8054a42:	5b                   	pop    %ebx
 8054a43:	5e                   	pop    %esi
 8054a44:	c3                   	ret    
 8054a45:	8d 76 00             	lea    0x0(%esi),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054a48:	83 ec 0c             	sub    $0xc,%esp
 8054a4b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8054a51:	e8 0a 3f ff ff       	call   8048960 <fflush@plt>
 8054a56:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054a5c:	6a 07                	push   $0x7
 8054a5e:	6a 01                	push   $0x1
 8054a60:	68 92 ed 05 08       	push   $0x805ed92
 8054a65:	e8 a6 3f ff ff       	call   8048a10 <fwrite@plt>
 8054a6a:	83 c4 20             	add    $0x20,%esp
 8054a6d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054a73:	6a 10                	push   $0x10
 8054a75:	6a 01                	push   $0x1
 8054a77:	68 84 f8 05 08       	push   $0x805f884
 8054a7c:	e8 8f 3f ff ff       	call   8048a10 <fwrite@plt>
 8054a81:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054a87:	6a 05                	push   $0x5
 8054a89:	6a 01                	push   $0x1
 8054a8b:	68 b1 ed 05 08       	push   $0x805edb1
 8054a90:	e8 7b 3f ff ff       	call   8048a10 <fwrite@plt>
 8054a95:	83 c4 20             	add    $0x20,%esp
 8054a98:	68 18 ae 8f 14       	push   $0x148fae18
 8054a9d:	68 d0 2f 06 08       	push   $0x8062fd0
 8054aa2:	6a 50                	push   $0x50
 8054aa4:	68 00 89 0c 08       	push   $0x80c8900
 8054aa9:	e8 52 40 ff ff       	call   8048b00 <snprintf@plt>
 8054aae:	83 c4 10             	add    $0x10,%esp
 8054ab1:	83 f8 4f             	cmp    $0x4f,%eax
 8054ab4:	7e 86                	jle    8054a3c <jg_i_w+0x5c>
 8054ab6:	68 e1 30 06 08       	push   $0x80630e1
 8054abb:	6a 0e                	push   $0xe
 8054abd:	68 e0 2f 06 08       	push   $0x8062fe0
 8054ac2:	68 4c 30 06 08       	push   $0x806304c
 8054ac7:	e8 e4 40 ff ff       	call   8048bb0 <__assert_fail@plt>
 8054acc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr jg

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 8054ad0:	a8 40                	test   $0x40,%al
 8054ad2:	0f 85 46 ff ff ff    	jne    8054a1e <jg_i_w+0x3e>
		cpu.eip = cpu.eip + res;
 8054ad8:	66 03 35 e0 ae 8f 14 	add    0x148faee0,%si
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 8054adf:	0f b7 f6             	movzwl %si,%esi
 8054ae2:	89 35 e0 ae 8f 14    	mov    %esi,0x148faee0
 8054ae8:	e9 31 ff ff ff       	jmp    8054a1e <jg_i_w+0x3e>
 8054aed:	8d 76 00             	lea    0x0(%esi),%esi

08054af0 <jg_i_b>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8054af0:	56                   	push   %esi
 8054af1:	53                   	push   %ebx
 8054af2:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054af5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054af9:	83 c0 01             	add    $0x1,%eax
 8054afc:	50                   	push   %eax
 8054afd:	e8 3e 7e 00 00       	call   805c940 <decode_i_b>
#define instr jg

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 8054b02:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 8054b09:	89 c3                	mov    %eax,%ebx
 8054b0b:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 8054b12:	83 c4 10             	add    $0x10,%esp
#include "cpu/exec/template-start.h"

#define instr jg

static void do_execute() {
	int res = op_src->val;
 8054b15:	8b 35 14 ae 8f 14    	mov    0x148fae14,%esi
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 8054b1b:	c0 ea 03             	shr    $0x3,%dl
 8054b1e:	89 c1                	mov    %eax,%ecx
 8054b20:	83 e2 01             	and    $0x1,%edx
 8054b23:	c0 e9 07             	shr    $0x7,%cl
 8054b26:	38 ca                	cmp    %cl,%dl
 8054b28:	0f 84 b2 00 00 00    	je     8054be0 <jg_i_b+0xf0>
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054b2e:	68 18 ae 8f 14       	push   $0x148fae18
 8054b33:	68 d7 2f 06 08       	push   $0x8062fd7
 8054b38:	6a 50                	push   $0x50
 8054b3a:	68 00 89 0c 08       	push   $0x80c8900
 8054b3f:	e8 bc 3f ff ff       	call   8048b00 <snprintf@plt>
 8054b44:	83 c4 10             	add    $0x10,%esp
 8054b47:	83 f8 4f             	cmp    $0x4f,%eax
 8054b4a:	7f 0c                	jg     8054b58 <jg_i_b+0x68>
}

make_instr_helper(i)
 8054b4c:	83 c4 04             	add    $0x4,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054b4f:	8d 43 01             	lea    0x1(%ebx),%eax
 8054b52:	5b                   	pop    %ebx
 8054b53:	5e                   	pop    %esi
 8054b54:	c3                   	ret    
 8054b55:	8d 76 00             	lea    0x0(%esi),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054b58:	83 ec 0c             	sub    $0xc,%esp
 8054b5b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8054b61:	e8 fa 3d ff ff       	call   8048960 <fflush@plt>
 8054b66:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054b6c:	6a 07                	push   $0x7
 8054b6e:	6a 01                	push   $0x1
 8054b70:	68 92 ed 05 08       	push   $0x805ed92
 8054b75:	e8 96 3e ff ff       	call   8048a10 <fwrite@plt>
 8054b7a:	83 c4 20             	add    $0x20,%esp
 8054b7d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054b83:	6a 10                	push   $0x10
 8054b85:	6a 01                	push   $0x1
 8054b87:	68 84 f8 05 08       	push   $0x805f884
 8054b8c:	e8 7f 3e ff ff       	call   8048a10 <fwrite@plt>
 8054b91:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054b97:	6a 05                	push   $0x5
 8054b99:	6a 01                	push   $0x1
 8054b9b:	68 b1 ed 05 08       	push   $0x805edb1
 8054ba0:	e8 6b 3e ff ff       	call   8048a10 <fwrite@plt>
 8054ba5:	83 c4 20             	add    $0x20,%esp
 8054ba8:	68 18 ae 8f 14       	push   $0x148fae18
 8054bad:	68 d7 2f 06 08       	push   $0x8062fd7
 8054bb2:	6a 50                	push   $0x50
 8054bb4:	68 00 89 0c 08       	push   $0x80c8900
 8054bb9:	e8 42 3f ff ff       	call   8048b00 <snprintf@plt>
 8054bbe:	83 c4 10             	add    $0x10,%esp
 8054bc1:	83 f8 4f             	cmp    $0x4f,%eax
 8054bc4:	7e 86                	jle    8054b4c <jg_i_b+0x5c>
 8054bc6:	68 e9 30 06 08       	push   $0x80630e9
 8054bcb:	6a 0e                	push   $0xe
 8054bcd:	68 e0 2f 06 08       	push   $0x8062fe0
 8054bd2:	68 94 30 06 08       	push   $0x8063094
 8054bd7:	e8 d4 3f ff ff       	call   8048bb0 <__assert_fail@plt>
 8054bdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr jg

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 8054be0:	a8 40                	test   $0x40,%al
 8054be2:	0f 85 46 ff ff ff    	jne    8054b2e <jg_i_b+0x3e>

#define instr jg

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8054be8:	89 f0                	mov    %esi,%eax
 8054bea:	0f be f0             	movsbl %al,%esi
	if(cpu.OF == cpu.SF && !cpu.ZF) {
		cpu.eip = cpu.eip + res;
 8054bed:	01 35 e0 ae 8f 14    	add    %esi,0x148faee0
 8054bf3:	e9 36 ff ff ff       	jmp    8054b2e <jg_i_b+0x3e>
 8054bf8:	90                   	nop
 8054bf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08054c00 <jg_i_v>:
#include "jg-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jg_i)
 8054c00:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8054c07:	8b 54 24 04          	mov    0x4(%esp),%edx
 8054c0b:	b8 e0 49 05 08       	mov    $0x80549e0,%eax
 8054c10:	75 05                	jne    8054c17 <jg_i_v+0x17>
 8054c12:	b8 d0 48 05 08       	mov    $0x80548d0,%eax
 8054c17:	89 54 24 04          	mov    %edx,0x4(%esp)
 8054c1b:	ff e0                	jmp    *%eax
 8054c1d:	66 90                	xchg   %ax,%ax
 8054c1f:	90                   	nop

08054c20 <jne_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8054c20:	53                   	push   %ebx
 8054c21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054c24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054c28:	83 c0 01             	add    $0x1,%eax
 8054c2b:	50                   	push   %eax
 8054c2c:	e8 0f 84 00 00       	call   805d040 <decode_i_l>
#define instr jne

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.ZF) {
 8054c31:	83 c4 10             	add    $0x10,%esp
 8054c34:	f6 05 e4 ae 8f 14 40 	testb  $0x40,0x148faee4
 8054c3b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jne

static void do_execute() {
	int res = op_src->val;
 8054c3d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.ZF) {
 8054c42:	75 06                	jne    8054c4a <jne_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8054c44:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054c4a:	68 18 ae 8f 14       	push   $0x148fae18
 8054c4f:	68 f1 30 06 08       	push   $0x80630f1
 8054c54:	6a 50                	push   $0x50
 8054c56:	68 00 89 0c 08       	push   $0x80c8900
 8054c5b:	e8 a0 3e ff ff       	call   8048b00 <snprintf@plt>
 8054c60:	83 c4 10             	add    $0x10,%esp
 8054c63:	83 f8 4f             	cmp    $0x4f,%eax
 8054c66:	7f 08                	jg     8054c70 <jne_i_l+0x50>
}

make_instr_helper(i)
 8054c68:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054c6b:	8d 43 01             	lea    0x1(%ebx),%eax
 8054c6e:	5b                   	pop    %ebx
 8054c6f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054c70:	83 ec 0c             	sub    $0xc,%esp
 8054c73:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8054c79:	e8 e2 3c ff ff       	call   8048960 <fflush@plt>
 8054c7e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054c84:	6a 07                	push   $0x7
 8054c86:	6a 01                	push   $0x1
 8054c88:	68 92 ed 05 08       	push   $0x805ed92
 8054c8d:	e8 7e 3d ff ff       	call   8048a10 <fwrite@plt>
 8054c92:	83 c4 20             	add    $0x20,%esp
 8054c95:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054c9b:	6a 10                	push   $0x10
 8054c9d:	6a 01                	push   $0x1
 8054c9f:	68 84 f8 05 08       	push   $0x805f884
 8054ca4:	e8 67 3d ff ff       	call   8048a10 <fwrite@plt>
 8054ca9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054caf:	6a 05                	push   $0x5
 8054cb1:	6a 01                	push   $0x1
 8054cb3:	68 b1 ed 05 08       	push   $0x805edb1
 8054cb8:	e8 53 3d ff ff       	call   8048a10 <fwrite@plt>
 8054cbd:	83 c4 20             	add    $0x20,%esp
 8054cc0:	68 18 ae 8f 14       	push   $0x148fae18
 8054cc5:	68 f1 30 06 08       	push   $0x80630f1
 8054cca:	6a 50                	push   $0x50
 8054ccc:	68 00 89 0c 08       	push   $0x80c8900
 8054cd1:	e8 2a 3e ff ff       	call   8048b00 <snprintf@plt>
 8054cd6:	83 c4 10             	add    $0x10,%esp
 8054cd9:	83 f8 4f             	cmp    $0x4f,%eax
 8054cdc:	7e 8a                	jle    8054c68 <jne_i_l+0x48>
 8054cde:	68 0a 32 06 08       	push   $0x806320a
 8054ce3:	6a 0e                	push   $0xe
 8054ce5:	68 0c 31 06 08       	push   $0x806310c
 8054cea:	68 34 31 06 08       	push   $0x8063134
 8054cef:	e8 bc 3e ff ff       	call   8048bb0 <__assert_fail@plt>
 8054cf4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8054cfa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08054d00 <jne_i_w>:
}

make_instr_helper(i)
 8054d00:	53                   	push   %ebx
 8054d01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054d04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054d08:	83 c0 01             	add    $0x1,%eax
 8054d0b:	50                   	push   %eax
 8054d0c:	e8 9f 7f 00 00       	call   805ccb0 <decode_i_w>
#define instr jne

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.ZF) {
 8054d11:	83 c4 10             	add    $0x10,%esp
 8054d14:	f6 05 e4 ae 8f 14 40 	testb  $0x40,0x148faee4
 8054d1b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jne

static void do_execute() {
	int res = op_src->val;
 8054d1d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.ZF) {
 8054d22:	75 0f                	jne    8054d33 <jne_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8054d24:	66 03 05 e0 ae 8f 14 	add    0x148faee0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 8054d2b:	0f b7 c0             	movzwl %ax,%eax
 8054d2e:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
#endif
	}
	print_asm_template1();
 8054d33:	68 18 ae 8f 14       	push   $0x148fae18
 8054d38:	68 f9 30 06 08       	push   $0x80630f9
 8054d3d:	6a 50                	push   $0x50
 8054d3f:	68 00 89 0c 08       	push   $0x80c8900
 8054d44:	e8 b7 3d ff ff       	call   8048b00 <snprintf@plt>
 8054d49:	83 c4 10             	add    $0x10,%esp
 8054d4c:	83 f8 4f             	cmp    $0x4f,%eax
 8054d4f:	7f 0f                	jg     8054d60 <jne_i_w+0x60>
}

make_instr_helper(i)
 8054d51:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054d54:	8d 43 01             	lea    0x1(%ebx),%eax
 8054d57:	5b                   	pop    %ebx
 8054d58:	c3                   	ret    
 8054d59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054d60:	83 ec 0c             	sub    $0xc,%esp
 8054d63:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8054d69:	e8 f2 3b ff ff       	call   8048960 <fflush@plt>
 8054d6e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054d74:	6a 07                	push   $0x7
 8054d76:	6a 01                	push   $0x1
 8054d78:	68 92 ed 05 08       	push   $0x805ed92
 8054d7d:	e8 8e 3c ff ff       	call   8048a10 <fwrite@plt>
 8054d82:	83 c4 20             	add    $0x20,%esp
 8054d85:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054d8b:	6a 10                	push   $0x10
 8054d8d:	6a 01                	push   $0x1
 8054d8f:	68 84 f8 05 08       	push   $0x805f884
 8054d94:	e8 77 3c ff ff       	call   8048a10 <fwrite@plt>
 8054d99:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054d9f:	6a 05                	push   $0x5
 8054da1:	6a 01                	push   $0x1
 8054da3:	68 b1 ed 05 08       	push   $0x805edb1
 8054da8:	e8 63 3c ff ff       	call   8048a10 <fwrite@plt>
 8054dad:	83 c4 20             	add    $0x20,%esp
 8054db0:	68 18 ae 8f 14       	push   $0x148fae18
 8054db5:	68 f9 30 06 08       	push   $0x80630f9
 8054dba:	6a 50                	push   $0x50
 8054dbc:	68 00 89 0c 08       	push   $0x80c8900
 8054dc1:	e8 3a 3d ff ff       	call   8048b00 <snprintf@plt>
 8054dc6:	83 c4 10             	add    $0x10,%esp
 8054dc9:	83 f8 4f             	cmp    $0x4f,%eax
 8054dcc:	7e 83                	jle    8054d51 <jne_i_w+0x51>
 8054dce:	68 13 32 06 08       	push   $0x8063213
 8054dd3:	6a 0e                	push   $0xe
 8054dd5:	68 0c 31 06 08       	push   $0x806310c
 8054dda:	68 7c 31 06 08       	push   $0x806317c
 8054ddf:	e8 cc 3d ff ff       	call   8048bb0 <__assert_fail@plt>
 8054de4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8054dea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08054df0 <jne_i_b>:
}

make_instr_helper(i)
 8054df0:	53                   	push   %ebx
 8054df1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054df4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054df8:	83 c0 01             	add    $0x1,%eax
 8054dfb:	50                   	push   %eax
 8054dfc:	e8 3f 7b 00 00       	call   805c940 <decode_i_b>
#define instr jne

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.ZF) {
 8054e01:	83 c4 10             	add    $0x10,%esp
 8054e04:	f6 05 e4 ae 8f 14 40 	testb  $0x40,0x148faee4
 8054e0b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jne

static void do_execute() {
	int res = op_src->val;
 8054e0d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.ZF) {
 8054e12:	75 09                	jne    8054e1d <jne_i_b+0x2d>

#define instr jne

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8054e14:	0f be c0             	movsbl %al,%eax
	if(!cpu.ZF) {
		cpu.eip = cpu.eip + res;
 8054e17:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054e1d:	68 18 ae 8f 14       	push   $0x148fae18
 8054e22:	68 01 31 06 08       	push   $0x8063101
 8054e27:	6a 50                	push   $0x50
 8054e29:	68 00 89 0c 08       	push   $0x80c8900
 8054e2e:	e8 cd 3c ff ff       	call   8048b00 <snprintf@plt>
 8054e33:	83 c4 10             	add    $0x10,%esp
 8054e36:	83 f8 4f             	cmp    $0x4f,%eax
 8054e39:	7f 0d                	jg     8054e48 <jne_i_b+0x58>
}

make_instr_helper(i)
 8054e3b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054e3e:	8d 43 01             	lea    0x1(%ebx),%eax
 8054e41:	5b                   	pop    %ebx
 8054e42:	c3                   	ret    
 8054e43:	90                   	nop
 8054e44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054e48:	83 ec 0c             	sub    $0xc,%esp
 8054e4b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8054e51:	e8 0a 3b ff ff       	call   8048960 <fflush@plt>
 8054e56:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054e5c:	6a 07                	push   $0x7
 8054e5e:	6a 01                	push   $0x1
 8054e60:	68 92 ed 05 08       	push   $0x805ed92
 8054e65:	e8 a6 3b ff ff       	call   8048a10 <fwrite@plt>
 8054e6a:	83 c4 20             	add    $0x20,%esp
 8054e6d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054e73:	6a 10                	push   $0x10
 8054e75:	6a 01                	push   $0x1
 8054e77:	68 84 f8 05 08       	push   $0x805f884
 8054e7c:	e8 8f 3b ff ff       	call   8048a10 <fwrite@plt>
 8054e81:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054e87:	6a 05                	push   $0x5
 8054e89:	6a 01                	push   $0x1
 8054e8b:	68 b1 ed 05 08       	push   $0x805edb1
 8054e90:	e8 7b 3b ff ff       	call   8048a10 <fwrite@plt>
 8054e95:	83 c4 20             	add    $0x20,%esp
 8054e98:	68 18 ae 8f 14       	push   $0x148fae18
 8054e9d:	68 01 31 06 08       	push   $0x8063101
 8054ea2:	6a 50                	push   $0x50
 8054ea4:	68 00 89 0c 08       	push   $0x80c8900
 8054ea9:	e8 52 3c ff ff       	call   8048b00 <snprintf@plt>
 8054eae:	83 c4 10             	add    $0x10,%esp
 8054eb1:	83 f8 4f             	cmp    $0x4f,%eax
 8054eb4:	7e 85                	jle    8054e3b <jne_i_b+0x4b>
 8054eb6:	68 1c 32 06 08       	push   $0x806321c
 8054ebb:	6a 0e                	push   $0xe
 8054ebd:	68 0c 31 06 08       	push   $0x806310c
 8054ec2:	68 c4 31 06 08       	push   $0x80631c4
 8054ec7:	e8 e4 3c ff ff       	call   8048bb0 <__assert_fail@plt>
 8054ecc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08054ed0 <jne_i_v>:
#include "jne-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jne_i)
 8054ed0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8054ed7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8054edb:	b8 00 4d 05 08       	mov    $0x8054d00,%eax
 8054ee0:	75 05                	jne    8054ee7 <jne_i_v+0x17>
 8054ee2:	b8 20 4c 05 08       	mov    $0x8054c20,%eax
 8054ee7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8054eeb:	ff e0                	jmp    *%eax
 8054eed:	66 90                	xchg   %ax,%ax
 8054eef:	90                   	nop

08054ef0 <jae_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8054ef0:	53                   	push   %ebx
 8054ef1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054ef4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054ef8:	83 c0 01             	add    $0x1,%eax
 8054efb:	50                   	push   %eax
 8054efc:	e8 3f 81 00 00       	call   805d040 <decode_i_l>
#define instr jae

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF) {
 8054f01:	83 c4 10             	add    $0x10,%esp
 8054f04:	f6 05 e4 ae 8f 14 01 	testb  $0x1,0x148faee4
 8054f0b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jae

static void do_execute() {
	int res = op_src->val;
 8054f0d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF) {
 8054f12:	75 06                	jne    8054f1a <jae_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8054f14:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054f1a:	68 18 ae 8f 14       	push   $0x148fae18
 8054f1f:	68 25 32 06 08       	push   $0x8063225
 8054f24:	6a 50                	push   $0x50
 8054f26:	68 00 89 0c 08       	push   $0x80c8900
 8054f2b:	e8 d0 3b ff ff       	call   8048b00 <snprintf@plt>
 8054f30:	83 c4 10             	add    $0x10,%esp
 8054f33:	83 f8 4f             	cmp    $0x4f,%eax
 8054f36:	7f 08                	jg     8054f40 <jae_i_l+0x50>
}

make_instr_helper(i)
 8054f38:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054f3b:	8d 43 01             	lea    0x1(%ebx),%eax
 8054f3e:	5b                   	pop    %ebx
 8054f3f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054f40:	83 ec 0c             	sub    $0xc,%esp
 8054f43:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8054f49:	e8 12 3a ff ff       	call   8048960 <fflush@plt>
 8054f4e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054f54:	6a 07                	push   $0x7
 8054f56:	6a 01                	push   $0x1
 8054f58:	68 92 ed 05 08       	push   $0x805ed92
 8054f5d:	e8 ae 3a ff ff       	call   8048a10 <fwrite@plt>
 8054f62:	83 c4 20             	add    $0x20,%esp
 8054f65:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054f6b:	6a 10                	push   $0x10
 8054f6d:	6a 01                	push   $0x1
 8054f6f:	68 84 f8 05 08       	push   $0x805f884
 8054f74:	e8 97 3a ff ff       	call   8048a10 <fwrite@plt>
 8054f79:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8054f7f:	6a 05                	push   $0x5
 8054f81:	6a 01                	push   $0x1
 8054f83:	68 b1 ed 05 08       	push   $0x805edb1
 8054f88:	e8 83 3a ff ff       	call   8048a10 <fwrite@plt>
 8054f8d:	83 c4 20             	add    $0x20,%esp
 8054f90:	68 18 ae 8f 14       	push   $0x148fae18
 8054f95:	68 25 32 06 08       	push   $0x8063225
 8054f9a:	6a 50                	push   $0x50
 8054f9c:	68 00 89 0c 08       	push   $0x80c8900
 8054fa1:	e8 5a 3b ff ff       	call   8048b00 <snprintf@plt>
 8054fa6:	83 c4 10             	add    $0x10,%esp
 8054fa9:	83 f8 4f             	cmp    $0x4f,%eax
 8054fac:	7e 8a                	jle    8054f38 <jae_i_l+0x48>
 8054fae:	68 3e 33 06 08       	push   $0x806333e
 8054fb3:	6a 0e                	push   $0xe
 8054fb5:	68 40 32 06 08       	push   $0x8063240
 8054fba:	68 68 32 06 08       	push   $0x8063268
 8054fbf:	e8 ec 3b ff ff       	call   8048bb0 <__assert_fail@plt>
 8054fc4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8054fca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08054fd0 <jae_i_w>:
}

make_instr_helper(i)
 8054fd0:	53                   	push   %ebx
 8054fd1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054fd4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054fd8:	83 c0 01             	add    $0x1,%eax
 8054fdb:	50                   	push   %eax
 8054fdc:	e8 cf 7c 00 00       	call   805ccb0 <decode_i_w>
#define instr jae

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF) {
 8054fe1:	83 c4 10             	add    $0x10,%esp
 8054fe4:	f6 05 e4 ae 8f 14 01 	testb  $0x1,0x148faee4
 8054feb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jae

static void do_execute() {
	int res = op_src->val;
 8054fed:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF) {
 8054ff2:	75 0f                	jne    8055003 <jae_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8054ff4:	66 03 05 e0 ae 8f 14 	add    0x148faee0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 8054ffb:	0f b7 c0             	movzwl %ax,%eax
 8054ffe:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
#endif
	}
	print_asm_template1();
 8055003:	68 18 ae 8f 14       	push   $0x148fae18
 8055008:	68 2d 32 06 08       	push   $0x806322d
 805500d:	6a 50                	push   $0x50
 805500f:	68 00 89 0c 08       	push   $0x80c8900
 8055014:	e8 e7 3a ff ff       	call   8048b00 <snprintf@plt>
 8055019:	83 c4 10             	add    $0x10,%esp
 805501c:	83 f8 4f             	cmp    $0x4f,%eax
 805501f:	7f 0f                	jg     8055030 <jae_i_w+0x60>
}

make_instr_helper(i)
 8055021:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055024:	8d 43 01             	lea    0x1(%ebx),%eax
 8055027:	5b                   	pop    %ebx
 8055028:	c3                   	ret    
 8055029:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055030:	83 ec 0c             	sub    $0xc,%esp
 8055033:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8055039:	e8 22 39 ff ff       	call   8048960 <fflush@plt>
 805503e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055044:	6a 07                	push   $0x7
 8055046:	6a 01                	push   $0x1
 8055048:	68 92 ed 05 08       	push   $0x805ed92
 805504d:	e8 be 39 ff ff       	call   8048a10 <fwrite@plt>
 8055052:	83 c4 20             	add    $0x20,%esp
 8055055:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805505b:	6a 10                	push   $0x10
 805505d:	6a 01                	push   $0x1
 805505f:	68 84 f8 05 08       	push   $0x805f884
 8055064:	e8 a7 39 ff ff       	call   8048a10 <fwrite@plt>
 8055069:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805506f:	6a 05                	push   $0x5
 8055071:	6a 01                	push   $0x1
 8055073:	68 b1 ed 05 08       	push   $0x805edb1
 8055078:	e8 93 39 ff ff       	call   8048a10 <fwrite@plt>
 805507d:	83 c4 20             	add    $0x20,%esp
 8055080:	68 18 ae 8f 14       	push   $0x148fae18
 8055085:	68 2d 32 06 08       	push   $0x806322d
 805508a:	6a 50                	push   $0x50
 805508c:	68 00 89 0c 08       	push   $0x80c8900
 8055091:	e8 6a 3a ff ff       	call   8048b00 <snprintf@plt>
 8055096:	83 c4 10             	add    $0x10,%esp
 8055099:	83 f8 4f             	cmp    $0x4f,%eax
 805509c:	7e 83                	jle    8055021 <jae_i_w+0x51>
 805509e:	68 47 33 06 08       	push   $0x8063347
 80550a3:	6a 0e                	push   $0xe
 80550a5:	68 40 32 06 08       	push   $0x8063240
 80550aa:	68 b0 32 06 08       	push   $0x80632b0
 80550af:	e8 fc 3a ff ff       	call   8048bb0 <__assert_fail@plt>
 80550b4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80550ba:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080550c0 <jae_i_b>:
}

make_instr_helper(i)
 80550c0:	53                   	push   %ebx
 80550c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80550c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80550c8:	83 c0 01             	add    $0x1,%eax
 80550cb:	50                   	push   %eax
 80550cc:	e8 6f 78 00 00       	call   805c940 <decode_i_b>
#define instr jae

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF) {
 80550d1:	83 c4 10             	add    $0x10,%esp
 80550d4:	f6 05 e4 ae 8f 14 01 	testb  $0x1,0x148faee4
 80550db:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jae

static void do_execute() {
	int res = op_src->val;
 80550dd:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF) {
 80550e2:	75 09                	jne    80550ed <jae_i_b+0x2d>

#define instr jae

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 80550e4:	0f be c0             	movsbl %al,%eax
	if(!cpu.CF) {
		cpu.eip = cpu.eip + res;
 80550e7:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80550ed:	68 18 ae 8f 14       	push   $0x148fae18
 80550f2:	68 35 32 06 08       	push   $0x8063235
 80550f7:	6a 50                	push   $0x50
 80550f9:	68 00 89 0c 08       	push   $0x80c8900
 80550fe:	e8 fd 39 ff ff       	call   8048b00 <snprintf@plt>
 8055103:	83 c4 10             	add    $0x10,%esp
 8055106:	83 f8 4f             	cmp    $0x4f,%eax
 8055109:	7f 0d                	jg     8055118 <jae_i_b+0x58>
}

make_instr_helper(i)
 805510b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805510e:	8d 43 01             	lea    0x1(%ebx),%eax
 8055111:	5b                   	pop    %ebx
 8055112:	c3                   	ret    
 8055113:	90                   	nop
 8055114:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055118:	83 ec 0c             	sub    $0xc,%esp
 805511b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8055121:	e8 3a 38 ff ff       	call   8048960 <fflush@plt>
 8055126:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805512c:	6a 07                	push   $0x7
 805512e:	6a 01                	push   $0x1
 8055130:	68 92 ed 05 08       	push   $0x805ed92
 8055135:	e8 d6 38 ff ff       	call   8048a10 <fwrite@plt>
 805513a:	83 c4 20             	add    $0x20,%esp
 805513d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055143:	6a 10                	push   $0x10
 8055145:	6a 01                	push   $0x1
 8055147:	68 84 f8 05 08       	push   $0x805f884
 805514c:	e8 bf 38 ff ff       	call   8048a10 <fwrite@plt>
 8055151:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055157:	6a 05                	push   $0x5
 8055159:	6a 01                	push   $0x1
 805515b:	68 b1 ed 05 08       	push   $0x805edb1
 8055160:	e8 ab 38 ff ff       	call   8048a10 <fwrite@plt>
 8055165:	83 c4 20             	add    $0x20,%esp
 8055168:	68 18 ae 8f 14       	push   $0x148fae18
 805516d:	68 35 32 06 08       	push   $0x8063235
 8055172:	6a 50                	push   $0x50
 8055174:	68 00 89 0c 08       	push   $0x80c8900
 8055179:	e8 82 39 ff ff       	call   8048b00 <snprintf@plt>
 805517e:	83 c4 10             	add    $0x10,%esp
 8055181:	83 f8 4f             	cmp    $0x4f,%eax
 8055184:	7e 85                	jle    805510b <jae_i_b+0x4b>
 8055186:	68 50 33 06 08       	push   $0x8063350
 805518b:	6a 0e                	push   $0xe
 805518d:	68 40 32 06 08       	push   $0x8063240
 8055192:	68 f8 32 06 08       	push   $0x80632f8
 8055197:	e8 14 3a ff ff       	call   8048bb0 <__assert_fail@plt>
 805519c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080551a0 <jae_i_v>:
#include "jae-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jae_i)
 80551a0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80551a7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80551ab:	b8 d0 4f 05 08       	mov    $0x8054fd0,%eax
 80551b0:	75 05                	jne    80551b7 <jae_i_v+0x17>
 80551b2:	b8 f0 4e 05 08       	mov    $0x8054ef0,%eax
 80551b7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80551bb:	ff e0                	jmp    *%eax
 80551bd:	66 90                	xchg   %ax,%ax
 80551bf:	90                   	nop

080551c0 <jo_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 80551c0:	53                   	push   %ebx
 80551c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80551c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80551c8:	83 c0 01             	add    $0x1,%eax
 80551cb:	50                   	push   %eax
 80551cc:	e8 6f 7e 00 00       	call   805d040 <decode_i_l>
#define instr jo

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF) {
 80551d1:	83 c4 10             	add    $0x10,%esp
 80551d4:	f6 05 e5 ae 8f 14 08 	testb  $0x8,0x148faee5
 80551db:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jo

static void do_execute() {
	int res = op_src->val;
 80551dd:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF) {
 80551e2:	74 06                	je     80551ea <jo_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 80551e4:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80551ea:	68 18 ae 8f 14       	push   $0x148fae18
 80551ef:	68 59 33 06 08       	push   $0x8063359
 80551f4:	6a 50                	push   $0x50
 80551f6:	68 00 89 0c 08       	push   $0x80c8900
 80551fb:	e8 00 39 ff ff       	call   8048b00 <snprintf@plt>
 8055200:	83 c4 10             	add    $0x10,%esp
 8055203:	83 f8 4f             	cmp    $0x4f,%eax
 8055206:	7f 08                	jg     8055210 <jo_i_l+0x50>
}

make_instr_helper(i)
 8055208:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805520b:	8d 43 01             	lea    0x1(%ebx),%eax
 805520e:	5b                   	pop    %ebx
 805520f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055210:	83 ec 0c             	sub    $0xc,%esp
 8055213:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8055219:	e8 42 37 ff ff       	call   8048960 <fflush@plt>
 805521e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055224:	6a 07                	push   $0x7
 8055226:	6a 01                	push   $0x1
 8055228:	68 92 ed 05 08       	push   $0x805ed92
 805522d:	e8 de 37 ff ff       	call   8048a10 <fwrite@plt>
 8055232:	83 c4 20             	add    $0x20,%esp
 8055235:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805523b:	6a 10                	push   $0x10
 805523d:	6a 01                	push   $0x1
 805523f:	68 84 f8 05 08       	push   $0x805f884
 8055244:	e8 c7 37 ff ff       	call   8048a10 <fwrite@plt>
 8055249:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805524f:	6a 05                	push   $0x5
 8055251:	6a 01                	push   $0x1
 8055253:	68 b1 ed 05 08       	push   $0x805edb1
 8055258:	e8 b3 37 ff ff       	call   8048a10 <fwrite@plt>
 805525d:	83 c4 20             	add    $0x20,%esp
 8055260:	68 18 ae 8f 14       	push   $0x148fae18
 8055265:	68 59 33 06 08       	push   $0x8063359
 805526a:	6a 50                	push   $0x50
 805526c:	68 00 89 0c 08       	push   $0x80c8900
 8055271:	e8 8a 38 ff ff       	call   8048b00 <snprintf@plt>
 8055276:	83 c4 10             	add    $0x10,%esp
 8055279:	83 f8 4f             	cmp    $0x4f,%eax
 805527c:	7e 8a                	jle    8055208 <jo_i_l+0x48>
 805527e:	68 69 34 06 08       	push   $0x8063469
 8055283:	6a 0e                	push   $0xe
 8055285:	68 70 33 06 08       	push   $0x8063370
 805528a:	68 94 33 06 08       	push   $0x8063394
 805528f:	e8 1c 39 ff ff       	call   8048bb0 <__assert_fail@plt>
 8055294:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805529a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080552a0 <jo_i_w>:
}

make_instr_helper(i)
 80552a0:	53                   	push   %ebx
 80552a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80552a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80552a8:	83 c0 01             	add    $0x1,%eax
 80552ab:	50                   	push   %eax
 80552ac:	e8 ff 79 00 00       	call   805ccb0 <decode_i_w>
#define instr jo

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF) {
 80552b1:	83 c4 10             	add    $0x10,%esp
 80552b4:	f6 05 e5 ae 8f 14 08 	testb  $0x8,0x148faee5
 80552bb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jo

static void do_execute() {
	int res = op_src->val;
 80552bd:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF) {
 80552c2:	74 0f                	je     80552d3 <jo_i_w+0x33>
		cpu.eip = cpu.eip + res;
 80552c4:	66 03 05 e0 ae 8f 14 	add    0x148faee0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 80552cb:	0f b7 c0             	movzwl %ax,%eax
 80552ce:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
#endif
	}
	print_asm_template1();
 80552d3:	68 18 ae 8f 14       	push   $0x148fae18
 80552d8:	68 60 33 06 08       	push   $0x8063360
 80552dd:	6a 50                	push   $0x50
 80552df:	68 00 89 0c 08       	push   $0x80c8900
 80552e4:	e8 17 38 ff ff       	call   8048b00 <snprintf@plt>
 80552e9:	83 c4 10             	add    $0x10,%esp
 80552ec:	83 f8 4f             	cmp    $0x4f,%eax
 80552ef:	7f 0f                	jg     8055300 <jo_i_w+0x60>
}

make_instr_helper(i)
 80552f1:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80552f4:	8d 43 01             	lea    0x1(%ebx),%eax
 80552f7:	5b                   	pop    %ebx
 80552f8:	c3                   	ret    
 80552f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055300:	83 ec 0c             	sub    $0xc,%esp
 8055303:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8055309:	e8 52 36 ff ff       	call   8048960 <fflush@plt>
 805530e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055314:	6a 07                	push   $0x7
 8055316:	6a 01                	push   $0x1
 8055318:	68 92 ed 05 08       	push   $0x805ed92
 805531d:	e8 ee 36 ff ff       	call   8048a10 <fwrite@plt>
 8055322:	83 c4 20             	add    $0x20,%esp
 8055325:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805532b:	6a 10                	push   $0x10
 805532d:	6a 01                	push   $0x1
 805532f:	68 84 f8 05 08       	push   $0x805f884
 8055334:	e8 d7 36 ff ff       	call   8048a10 <fwrite@plt>
 8055339:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805533f:	6a 05                	push   $0x5
 8055341:	6a 01                	push   $0x1
 8055343:	68 b1 ed 05 08       	push   $0x805edb1
 8055348:	e8 c3 36 ff ff       	call   8048a10 <fwrite@plt>
 805534d:	83 c4 20             	add    $0x20,%esp
 8055350:	68 18 ae 8f 14       	push   $0x148fae18
 8055355:	68 60 33 06 08       	push   $0x8063360
 805535a:	6a 50                	push   $0x50
 805535c:	68 00 89 0c 08       	push   $0x80c8900
 8055361:	e8 9a 37 ff ff       	call   8048b00 <snprintf@plt>
 8055366:	83 c4 10             	add    $0x10,%esp
 8055369:	83 f8 4f             	cmp    $0x4f,%eax
 805536c:	7e 83                	jle    80552f1 <jo_i_w+0x51>
 805536e:	68 71 34 06 08       	push   $0x8063471
 8055373:	6a 0e                	push   $0xe
 8055375:	68 70 33 06 08       	push   $0x8063370
 805537a:	68 dc 33 06 08       	push   $0x80633dc
 805537f:	e8 2c 38 ff ff       	call   8048bb0 <__assert_fail@plt>
 8055384:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805538a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08055390 <jo_i_b>:
}

make_instr_helper(i)
 8055390:	53                   	push   %ebx
 8055391:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055394:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055398:	83 c0 01             	add    $0x1,%eax
 805539b:	50                   	push   %eax
 805539c:	e8 9f 75 00 00       	call   805c940 <decode_i_b>
#define instr jo

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF) {
 80553a1:	83 c4 10             	add    $0x10,%esp
 80553a4:	f6 05 e5 ae 8f 14 08 	testb  $0x8,0x148faee5
 80553ab:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jo

static void do_execute() {
	int res = op_src->val;
 80553ad:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF) {
 80553b2:	74 09                	je     80553bd <jo_i_b+0x2d>

#define instr jo

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 80553b4:	0f be c0             	movsbl %al,%eax
	if(cpu.OF) {
		cpu.eip = cpu.eip + res;
 80553b7:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80553bd:	68 18 ae 8f 14       	push   $0x148fae18
 80553c2:	68 67 33 06 08       	push   $0x8063367
 80553c7:	6a 50                	push   $0x50
 80553c9:	68 00 89 0c 08       	push   $0x80c8900
 80553ce:	e8 2d 37 ff ff       	call   8048b00 <snprintf@plt>
 80553d3:	83 c4 10             	add    $0x10,%esp
 80553d6:	83 f8 4f             	cmp    $0x4f,%eax
 80553d9:	7f 0d                	jg     80553e8 <jo_i_b+0x58>
}

make_instr_helper(i)
 80553db:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80553de:	8d 43 01             	lea    0x1(%ebx),%eax
 80553e1:	5b                   	pop    %ebx
 80553e2:	c3                   	ret    
 80553e3:	90                   	nop
 80553e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80553e8:	83 ec 0c             	sub    $0xc,%esp
 80553eb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80553f1:	e8 6a 35 ff ff       	call   8048960 <fflush@plt>
 80553f6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80553fc:	6a 07                	push   $0x7
 80553fe:	6a 01                	push   $0x1
 8055400:	68 92 ed 05 08       	push   $0x805ed92
 8055405:	e8 06 36 ff ff       	call   8048a10 <fwrite@plt>
 805540a:	83 c4 20             	add    $0x20,%esp
 805540d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055413:	6a 10                	push   $0x10
 8055415:	6a 01                	push   $0x1
 8055417:	68 84 f8 05 08       	push   $0x805f884
 805541c:	e8 ef 35 ff ff       	call   8048a10 <fwrite@plt>
 8055421:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055427:	6a 05                	push   $0x5
 8055429:	6a 01                	push   $0x1
 805542b:	68 b1 ed 05 08       	push   $0x805edb1
 8055430:	e8 db 35 ff ff       	call   8048a10 <fwrite@plt>
 8055435:	83 c4 20             	add    $0x20,%esp
 8055438:	68 18 ae 8f 14       	push   $0x148fae18
 805543d:	68 67 33 06 08       	push   $0x8063367
 8055442:	6a 50                	push   $0x50
 8055444:	68 00 89 0c 08       	push   $0x80c8900
 8055449:	e8 b2 36 ff ff       	call   8048b00 <snprintf@plt>
 805544e:	83 c4 10             	add    $0x10,%esp
 8055451:	83 f8 4f             	cmp    $0x4f,%eax
 8055454:	7e 85                	jle    80553db <jo_i_b+0x4b>
 8055456:	68 79 34 06 08       	push   $0x8063479
 805545b:	6a 0e                	push   $0xe
 805545d:	68 70 33 06 08       	push   $0x8063370
 8055462:	68 24 34 06 08       	push   $0x8063424
 8055467:	e8 44 37 ff ff       	call   8048bb0 <__assert_fail@plt>
 805546c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08055470 <jo_i_v>:
#include "jo-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jo_i)
 8055470:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8055477:	8b 54 24 04          	mov    0x4(%esp),%edx
 805547b:	b8 a0 52 05 08       	mov    $0x80552a0,%eax
 8055480:	75 05                	jne    8055487 <jo_i_v+0x17>
 8055482:	b8 c0 51 05 08       	mov    $0x80551c0,%eax
 8055487:	89 54 24 04          	mov    %edx,0x4(%esp)
 805548b:	ff e0                	jmp    *%eax
 805548d:	66 90                	xchg   %ax,%ax
 805548f:	90                   	nop

08055490 <jge_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8055490:	53                   	push   %ebx
 8055491:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055494:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055498:	83 c0 01             	add    $0x1,%eax
 805549b:	50                   	push   %eax
 805549c:	e8 9f 7b 00 00       	call   805d040 <decode_i_l>
#define instr jge

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
 80554a1:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 80554a8:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 80554af:	83 c4 10             	add    $0x10,%esp
 80554b2:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jge

static void do_execute() {
	int res = op_src->val;
 80554b4:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
 80554b9:	c0 ea 03             	shr    $0x3,%dl
 80554bc:	c0 e9 07             	shr    $0x7,%cl
 80554bf:	83 e2 01             	and    $0x1,%edx
 80554c2:	38 ca                	cmp    %cl,%dl
 80554c4:	0f 84 ae 00 00 00    	je     8055578 <jge_i_l+0xe8>
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80554ca:	68 18 ae 8f 14       	push   $0x148fae18
 80554cf:	68 81 34 06 08       	push   $0x8063481
 80554d4:	6a 50                	push   $0x50
 80554d6:	68 00 89 0c 08       	push   $0x80c8900
 80554db:	e8 20 36 ff ff       	call   8048b00 <snprintf@plt>
 80554e0:	83 c4 10             	add    $0x10,%esp
 80554e3:	83 f8 4f             	cmp    $0x4f,%eax
 80554e6:	7f 08                	jg     80554f0 <jge_i_l+0x60>
}

make_instr_helper(i)
 80554e8:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80554eb:	8d 43 01             	lea    0x1(%ebx),%eax
 80554ee:	5b                   	pop    %ebx
 80554ef:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80554f0:	83 ec 0c             	sub    $0xc,%esp
 80554f3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80554f9:	e8 62 34 ff ff       	call   8048960 <fflush@plt>
 80554fe:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055504:	6a 07                	push   $0x7
 8055506:	6a 01                	push   $0x1
 8055508:	68 92 ed 05 08       	push   $0x805ed92
 805550d:	e8 fe 34 ff ff       	call   8048a10 <fwrite@plt>
 8055512:	83 c4 20             	add    $0x20,%esp
 8055515:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805551b:	6a 10                	push   $0x10
 805551d:	6a 01                	push   $0x1
 805551f:	68 84 f8 05 08       	push   $0x805f884
 8055524:	e8 e7 34 ff ff       	call   8048a10 <fwrite@plt>
 8055529:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805552f:	6a 05                	push   $0x5
 8055531:	6a 01                	push   $0x1
 8055533:	68 b1 ed 05 08       	push   $0x805edb1
 8055538:	e8 d3 34 ff ff       	call   8048a10 <fwrite@plt>
 805553d:	83 c4 20             	add    $0x20,%esp
 8055540:	68 18 ae 8f 14       	push   $0x148fae18
 8055545:	68 81 34 06 08       	push   $0x8063481
 805554a:	6a 50                	push   $0x50
 805554c:	68 00 89 0c 08       	push   $0x80c8900
 8055551:	e8 aa 35 ff ff       	call   8048b00 <snprintf@plt>
 8055556:	83 c4 10             	add    $0x10,%esp
 8055559:	83 f8 4f             	cmp    $0x4f,%eax
 805555c:	7e 8a                	jle    80554e8 <jge_i_l+0x58>
 805555e:	68 9a 35 06 08       	push   $0x806359a
 8055563:	6a 0e                	push   $0xe
 8055565:	68 9c 34 06 08       	push   $0x806349c
 805556a:	68 c4 34 06 08       	push   $0x80634c4
 805556f:	e8 3c 36 ff ff       	call   8048bb0 <__assert_fail@plt>
 8055574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
		cpu.eip = cpu.eip + res;
 8055578:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
 805557e:	e9 47 ff ff ff       	jmp    80554ca <jge_i_l+0x3a>
 8055583:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8055589:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08055590 <jge_i_w>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8055590:	53                   	push   %ebx
 8055591:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055594:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055598:	83 c0 01             	add    $0x1,%eax
 805559b:	50                   	push   %eax
 805559c:	e8 0f 77 00 00       	call   805ccb0 <decode_i_w>
#define instr jge

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
 80555a1:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 80555a8:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 80555af:	83 c4 10             	add    $0x10,%esp
 80555b2:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jge

static void do_execute() {
	int res = op_src->val;
 80555b4:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
 80555b9:	c0 ea 03             	shr    $0x3,%dl
 80555bc:	c0 e9 07             	shr    $0x7,%cl
 80555bf:	83 e2 01             	and    $0x1,%edx
 80555c2:	38 ca                	cmp    %cl,%dl
 80555c4:	0f 84 ae 00 00 00    	je     8055678 <jge_i_w+0xe8>
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80555ca:	68 18 ae 8f 14       	push   $0x148fae18
 80555cf:	68 89 34 06 08       	push   $0x8063489
 80555d4:	6a 50                	push   $0x50
 80555d6:	68 00 89 0c 08       	push   $0x80c8900
 80555db:	e8 20 35 ff ff       	call   8048b00 <snprintf@plt>
 80555e0:	83 c4 10             	add    $0x10,%esp
 80555e3:	83 f8 4f             	cmp    $0x4f,%eax
 80555e6:	7f 08                	jg     80555f0 <jge_i_w+0x60>
}

make_instr_helper(i)
 80555e8:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80555eb:	8d 43 01             	lea    0x1(%ebx),%eax
 80555ee:	5b                   	pop    %ebx
 80555ef:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80555f0:	83 ec 0c             	sub    $0xc,%esp
 80555f3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80555f9:	e8 62 33 ff ff       	call   8048960 <fflush@plt>
 80555fe:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055604:	6a 07                	push   $0x7
 8055606:	6a 01                	push   $0x1
 8055608:	68 92 ed 05 08       	push   $0x805ed92
 805560d:	e8 fe 33 ff ff       	call   8048a10 <fwrite@plt>
 8055612:	83 c4 20             	add    $0x20,%esp
 8055615:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805561b:	6a 10                	push   $0x10
 805561d:	6a 01                	push   $0x1
 805561f:	68 84 f8 05 08       	push   $0x805f884
 8055624:	e8 e7 33 ff ff       	call   8048a10 <fwrite@plt>
 8055629:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805562f:	6a 05                	push   $0x5
 8055631:	6a 01                	push   $0x1
 8055633:	68 b1 ed 05 08       	push   $0x805edb1
 8055638:	e8 d3 33 ff ff       	call   8048a10 <fwrite@plt>
 805563d:	83 c4 20             	add    $0x20,%esp
 8055640:	68 18 ae 8f 14       	push   $0x148fae18
 8055645:	68 89 34 06 08       	push   $0x8063489
 805564a:	6a 50                	push   $0x50
 805564c:	68 00 89 0c 08       	push   $0x80c8900
 8055651:	e8 aa 34 ff ff       	call   8048b00 <snprintf@plt>
 8055656:	83 c4 10             	add    $0x10,%esp
 8055659:	83 f8 4f             	cmp    $0x4f,%eax
 805565c:	7e 8a                	jle    80555e8 <jge_i_w+0x58>
 805565e:	68 a3 35 06 08       	push   $0x80635a3
 8055663:	6a 0e                	push   $0xe
 8055665:	68 9c 34 06 08       	push   $0x806349c
 805566a:	68 0c 35 06 08       	push   $0x806350c
 805566f:	e8 3c 35 ff ff       	call   8048bb0 <__assert_fail@plt>
 8055674:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
		cpu.eip = cpu.eip + res;
 8055678:	66 03 05 e0 ae 8f 14 	add    0x148faee0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 805567f:	0f b7 c0             	movzwl %ax,%eax
 8055682:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
 8055687:	e9 3e ff ff ff       	jmp    80555ca <jge_i_w+0x3a>
 805568c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08055690 <jge_i_b>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8055690:	53                   	push   %ebx
 8055691:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055694:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055698:	83 c0 01             	add    $0x1,%eax
 805569b:	50                   	push   %eax
 805569c:	e8 9f 72 00 00       	call   805c940 <decode_i_b>
#define instr jge

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
 80556a1:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 80556a8:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 80556af:	83 c4 10             	add    $0x10,%esp
 80556b2:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jge

static void do_execute() {
	int res = op_src->val;
 80556b4:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
 80556b9:	c0 ea 03             	shr    $0x3,%dl
 80556bc:	c0 e9 07             	shr    $0x7,%cl
 80556bf:	83 e2 01             	and    $0x1,%edx
 80556c2:	38 ca                	cmp    %cl,%dl
 80556c4:	0f 84 ae 00 00 00    	je     8055778 <jge_i_b+0xe8>
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80556ca:	68 18 ae 8f 14       	push   $0x148fae18
 80556cf:	68 91 34 06 08       	push   $0x8063491
 80556d4:	6a 50                	push   $0x50
 80556d6:	68 00 89 0c 08       	push   $0x80c8900
 80556db:	e8 20 34 ff ff       	call   8048b00 <snprintf@plt>
 80556e0:	83 c4 10             	add    $0x10,%esp
 80556e3:	83 f8 4f             	cmp    $0x4f,%eax
 80556e6:	7f 08                	jg     80556f0 <jge_i_b+0x60>
}

make_instr_helper(i)
 80556e8:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80556eb:	8d 43 01             	lea    0x1(%ebx),%eax
 80556ee:	5b                   	pop    %ebx
 80556ef:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80556f0:	83 ec 0c             	sub    $0xc,%esp
 80556f3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80556f9:	e8 62 32 ff ff       	call   8048960 <fflush@plt>
 80556fe:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055704:	6a 07                	push   $0x7
 8055706:	6a 01                	push   $0x1
 8055708:	68 92 ed 05 08       	push   $0x805ed92
 805570d:	e8 fe 32 ff ff       	call   8048a10 <fwrite@plt>
 8055712:	83 c4 20             	add    $0x20,%esp
 8055715:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805571b:	6a 10                	push   $0x10
 805571d:	6a 01                	push   $0x1
 805571f:	68 84 f8 05 08       	push   $0x805f884
 8055724:	e8 e7 32 ff ff       	call   8048a10 <fwrite@plt>
 8055729:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805572f:	6a 05                	push   $0x5
 8055731:	6a 01                	push   $0x1
 8055733:	68 b1 ed 05 08       	push   $0x805edb1
 8055738:	e8 d3 32 ff ff       	call   8048a10 <fwrite@plt>
 805573d:	83 c4 20             	add    $0x20,%esp
 8055740:	68 18 ae 8f 14       	push   $0x148fae18
 8055745:	68 91 34 06 08       	push   $0x8063491
 805574a:	6a 50                	push   $0x50
 805574c:	68 00 89 0c 08       	push   $0x80c8900
 8055751:	e8 aa 33 ff ff       	call   8048b00 <snprintf@plt>
 8055756:	83 c4 10             	add    $0x10,%esp
 8055759:	83 f8 4f             	cmp    $0x4f,%eax
 805575c:	7e 8a                	jle    80556e8 <jge_i_b+0x58>
 805575e:	68 ac 35 06 08       	push   $0x80635ac
 8055763:	6a 0e                	push   $0xe
 8055765:	68 9c 34 06 08       	push   $0x806349c
 805576a:	68 54 35 06 08       	push   $0x8063554
 805576f:	e8 3c 34 ff ff       	call   8048bb0 <__assert_fail@plt>
 8055774:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

#define instr jge

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8055778:	0f be c0             	movsbl %al,%eax
	if(cpu.OF == cpu.SF) {
		cpu.eip = cpu.eip + res;
 805577b:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
 8055781:	e9 44 ff ff ff       	jmp    80556ca <jge_i_b+0x3a>
 8055786:	8d 76 00             	lea    0x0(%esi),%esi
 8055789:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08055790 <jge_i_v>:
#include "jge-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jge_i)
 8055790:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8055797:	8b 54 24 04          	mov    0x4(%esp),%edx
 805579b:	b8 90 55 05 08       	mov    $0x8055590,%eax
 80557a0:	75 05                	jne    80557a7 <jge_i_v+0x17>
 80557a2:	b8 90 54 05 08       	mov    $0x8055490,%eax
 80557a7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80557ab:	ff e0                	jmp    *%eax
 80557ad:	66 90                	xchg   %ax,%ax
 80557af:	90                   	nop

080557b0 <do_jcxz_b>:
#include "cpu/exec/template-start.h"

#define instr jcxz

static void do_execute() {
 80557b0:	83 ec 0c             	sub    $0xc,%esp
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	bool flag = !(reg_l(R_ECX) << (32 - (op_src2->val << 3)) >> (32 - (op_src2->val << 3)));
 80557b3:	a1 84 ae 8f 14       	mov    0x148fae84,%eax
 80557b8:	b9 20 00 00 00       	mov    $0x20,%ecx
#include "cpu/exec/template-start.h"

#define instr jcxz

static void do_execute() {
	int res = op_src->val;
 80557bd:	8b 15 14 ae 8f 14    	mov    0x148fae14,%edx
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	bool flag = !(reg_l(R_ECX) << (32 - (op_src2->val << 3)) >> (32 - (op_src2->val << 3)));
 80557c3:	c1 e0 03             	shl    $0x3,%eax
 80557c6:	29 c1                	sub    %eax,%ecx
 80557c8:	a1 c4 ae 8f 14       	mov    0x148faec4,%eax
 80557cd:	d3 e0                	shl    %cl,%eax
 80557cf:	d3 e8                	shr    %cl,%eax
	if(flag) {
 80557d1:	85 c0                	test   %eax,%eax
 80557d3:	75 09                	jne    80557de <do_jcxz_b+0x2e>

#define instr jcxz

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 80557d5:	0f be d2             	movsbl %dl,%edx
	bool flag = !(reg_l(R_ECX) << (32 - (op_src2->val << 3)) >> (32 - (op_src2->val << 3)));
	if(flag) {
		cpu.eip = cpu.eip + res;
 80557d8:	01 15 e0 ae 8f 14    	add    %edx,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80557de:	68 18 ae 8f 14       	push   $0x148fae18
 80557e3:	68 b5 35 06 08       	push   $0x80635b5
 80557e8:	6a 50                	push   $0x50
 80557ea:	68 00 89 0c 08       	push   $0x80c8900
 80557ef:	e8 0c 33 ff ff       	call   8048b00 <snprintf@plt>
 80557f4:	83 c4 10             	add    $0x10,%esp
 80557f7:	83 f8 4f             	cmp    $0x4f,%eax
 80557fa:	7f 04                	jg     8055800 <do_jcxz_b+0x50>
}
 80557fc:	83 c4 0c             	add    $0xc,%esp
 80557ff:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055800:	83 ec 0c             	sub    $0xc,%esp
 8055803:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8055809:	e8 52 31 ff ff       	call   8048960 <fflush@plt>
 805580e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055814:	6a 07                	push   $0x7
 8055816:	6a 01                	push   $0x1
 8055818:	68 92 ed 05 08       	push   $0x805ed92
 805581d:	e8 ee 31 ff ff       	call   8048a10 <fwrite@plt>
 8055822:	83 c4 20             	add    $0x20,%esp
 8055825:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805582b:	6a 10                	push   $0x10
 805582d:	6a 01                	push   $0x1
 805582f:	68 84 f8 05 08       	push   $0x805f884
 8055834:	e8 d7 31 ff ff       	call   8048a10 <fwrite@plt>
 8055839:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805583f:	6a 05                	push   $0x5
 8055841:	6a 01                	push   $0x1
 8055843:	68 b1 ed 05 08       	push   $0x805edb1
 8055848:	e8 c3 31 ff ff       	call   8048a10 <fwrite@plt>
 805584d:	83 c4 20             	add    $0x20,%esp
 8055850:	68 18 ae 8f 14       	push   $0x148fae18
 8055855:	68 b5 35 06 08       	push   $0x80635b5
 805585a:	6a 50                	push   $0x50
 805585c:	68 00 89 0c 08       	push   $0x80c8900
 8055861:	e8 9a 32 ff ff       	call   8048b00 <snprintf@plt>
 8055866:	83 c4 10             	add    $0x10,%esp
 8055869:	83 f8 4f             	cmp    $0x4f,%eax
 805586c:	7e 8e                	jle    80557fc <do_jcxz_b+0x4c>
 805586e:	68 2f 36 06 08       	push   $0x806362f
 8055873:	6a 0f                	push   $0xf
 8055875:	68 c0 35 06 08       	push   $0x80635c0
 805587a:	68 e8 35 06 08       	push   $0x80635e8
 805587f:	e8 2c 33 ff ff       	call   8048bb0 <__assert_fail@plt>
 8055884:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805588a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08055890 <jcxz_i_b>:
}

make_instr_helper(i)
 8055890:	53                   	push   %ebx
 8055891:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055894:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055898:	83 c0 01             	add    $0x1,%eax
 805589b:	50                   	push   %eax
 805589c:	e8 9f 70 00 00       	call   805c940 <decode_i_b>
 80558a1:	89 c3                	mov    %eax,%ebx
	execute();
 80558a3:	e8 08 ff ff ff       	call   80557b0 <do_jcxz_b>
 80558a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80558ab:	8d 43 01             	lea    0x1(%ebx),%eax
 80558ae:	5b                   	pop    %ebx
 80558af:	c3                   	ret    

080558b0 <jcxz_i_v>:
#define DATA_BYTE 1
#include "jcxz-template.h"
#undef DATA_BYTE
/* for instruction encoding overloading */

make_helper(jcxz_i_v) {
 80558b0:	53                   	push   %ebx
 80558b1:	83 ec 14             	sub    $0x14,%esp
	if(ops_decoded.is_data_size_16) {
		op_src2->val = 2;
 80558b4:	80 3d 04 ae 8f 14 01 	cmpb   $0x1,0x148fae04
 80558bb:	19 c0                	sbb    %eax,%eax
 80558bd:	83 e0 02             	and    $0x2,%eax
 80558c0:	83 c0 02             	add    $0x2,%eax
 80558c3:	a3 84 ae 8f 14       	mov    %eax,0x148fae84
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80558c8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80558cc:	83 c0 01             	add    $0x1,%eax
 80558cf:	50                   	push   %eax
 80558d0:	e8 6b 70 00 00       	call   805c940 <decode_i_b>
 80558d5:	89 c3                	mov    %eax,%ebx
	execute();
 80558d7:	e8 d4 fe ff ff       	call   80557b0 <do_jcxz_b>
	}
	else {
		op_src2->val = 4;
	}
	return jcxz_i_b(eip);
}
 80558dc:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80558df:	8d 43 01             	lea    0x1(%ebx),%eax
 80558e2:	5b                   	pop    %ebx
 80558e3:	c3                   	ret    
 80558e4:	66 90                	xchg   %ax,%ax
 80558e6:	66 90                	xchg   %ax,%ax
 80558e8:	66 90                	xchg   %ax,%ax
 80558ea:	66 90                	xchg   %ax,%ax
 80558ec:	66 90                	xchg   %ax,%ax
 80558ee:	66 90                	xchg   %ax,%ax

080558f0 <js_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 80558f0:	53                   	push   %ebx
 80558f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80558f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80558f8:	83 c0 01             	add    $0x1,%eax
 80558fb:	50                   	push   %eax
 80558fc:	e8 3f 77 00 00       	call   805d040 <decode_i_l>
#define instr js

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.SF) {
 8055901:	83 c4 10             	add    $0x10,%esp
 8055904:	80 3d e4 ae 8f 14 00 	cmpb   $0x0,0x148faee4
 805590b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr js

static void do_execute() {
	int res = op_src->val;
 805590d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.SF) {
 8055912:	79 06                	jns    805591a <js_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8055914:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805591a:	68 18 ae 8f 14       	push   $0x148fae18
 805591f:	68 39 36 06 08       	push   $0x8063639
 8055924:	6a 50                	push   $0x50
 8055926:	68 00 89 0c 08       	push   $0x80c8900
 805592b:	e8 d0 31 ff ff       	call   8048b00 <snprintf@plt>
 8055930:	83 c4 10             	add    $0x10,%esp
 8055933:	83 f8 4f             	cmp    $0x4f,%eax
 8055936:	7f 08                	jg     8055940 <js_i_l+0x50>
}

make_instr_helper(i)
 8055938:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805593b:	8d 43 01             	lea    0x1(%ebx),%eax
 805593e:	5b                   	pop    %ebx
 805593f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055940:	83 ec 0c             	sub    $0xc,%esp
 8055943:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8055949:	e8 12 30 ff ff       	call   8048960 <fflush@plt>
 805594e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055954:	6a 07                	push   $0x7
 8055956:	6a 01                	push   $0x1
 8055958:	68 92 ed 05 08       	push   $0x805ed92
 805595d:	e8 ae 30 ff ff       	call   8048a10 <fwrite@plt>
 8055962:	83 c4 20             	add    $0x20,%esp
 8055965:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805596b:	6a 10                	push   $0x10
 805596d:	6a 01                	push   $0x1
 805596f:	68 84 f8 05 08       	push   $0x805f884
 8055974:	e8 97 30 ff ff       	call   8048a10 <fwrite@plt>
 8055979:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805597f:	6a 05                	push   $0x5
 8055981:	6a 01                	push   $0x1
 8055983:	68 b1 ed 05 08       	push   $0x805edb1
 8055988:	e8 83 30 ff ff       	call   8048a10 <fwrite@plt>
 805598d:	83 c4 20             	add    $0x20,%esp
 8055990:	68 18 ae 8f 14       	push   $0x148fae18
 8055995:	68 39 36 06 08       	push   $0x8063639
 805599a:	6a 50                	push   $0x50
 805599c:	68 00 89 0c 08       	push   $0x80c8900
 80559a1:	e8 5a 31 ff ff       	call   8048b00 <snprintf@plt>
 80559a6:	83 c4 10             	add    $0x10,%esp
 80559a9:	83 f8 4f             	cmp    $0x4f,%eax
 80559ac:	7e 8a                	jle    8055938 <js_i_l+0x48>
 80559ae:	68 49 37 06 08       	push   $0x8063749
 80559b3:	6a 0e                	push   $0xe
 80559b5:	68 50 36 06 08       	push   $0x8063650
 80559ba:	68 74 36 06 08       	push   $0x8063674
 80559bf:	e8 ec 31 ff ff       	call   8048bb0 <__assert_fail@plt>
 80559c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80559ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080559d0 <js_i_w>:
}

make_instr_helper(i)
 80559d0:	53                   	push   %ebx
 80559d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80559d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80559d8:	83 c0 01             	add    $0x1,%eax
 80559db:	50                   	push   %eax
 80559dc:	e8 cf 72 00 00       	call   805ccb0 <decode_i_w>
#define instr js

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.SF) {
 80559e1:	83 c4 10             	add    $0x10,%esp
 80559e4:	80 3d e4 ae 8f 14 00 	cmpb   $0x0,0x148faee4
 80559eb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr js

static void do_execute() {
	int res = op_src->val;
 80559ed:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.SF) {
 80559f2:	79 0f                	jns    8055a03 <js_i_w+0x33>
		cpu.eip = cpu.eip + res;
 80559f4:	66 03 05 e0 ae 8f 14 	add    0x148faee0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 80559fb:	0f b7 c0             	movzwl %ax,%eax
 80559fe:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
#endif
	}
	print_asm_template1();
 8055a03:	68 18 ae 8f 14       	push   $0x148fae18
 8055a08:	68 40 36 06 08       	push   $0x8063640
 8055a0d:	6a 50                	push   $0x50
 8055a0f:	68 00 89 0c 08       	push   $0x80c8900
 8055a14:	e8 e7 30 ff ff       	call   8048b00 <snprintf@plt>
 8055a19:	83 c4 10             	add    $0x10,%esp
 8055a1c:	83 f8 4f             	cmp    $0x4f,%eax
 8055a1f:	7f 0f                	jg     8055a30 <js_i_w+0x60>
}

make_instr_helper(i)
 8055a21:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055a24:	8d 43 01             	lea    0x1(%ebx),%eax
 8055a27:	5b                   	pop    %ebx
 8055a28:	c3                   	ret    
 8055a29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055a30:	83 ec 0c             	sub    $0xc,%esp
 8055a33:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8055a39:	e8 22 2f ff ff       	call   8048960 <fflush@plt>
 8055a3e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055a44:	6a 07                	push   $0x7
 8055a46:	6a 01                	push   $0x1
 8055a48:	68 92 ed 05 08       	push   $0x805ed92
 8055a4d:	e8 be 2f ff ff       	call   8048a10 <fwrite@plt>
 8055a52:	83 c4 20             	add    $0x20,%esp
 8055a55:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055a5b:	6a 10                	push   $0x10
 8055a5d:	6a 01                	push   $0x1
 8055a5f:	68 84 f8 05 08       	push   $0x805f884
 8055a64:	e8 a7 2f ff ff       	call   8048a10 <fwrite@plt>
 8055a69:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055a6f:	6a 05                	push   $0x5
 8055a71:	6a 01                	push   $0x1
 8055a73:	68 b1 ed 05 08       	push   $0x805edb1
 8055a78:	e8 93 2f ff ff       	call   8048a10 <fwrite@plt>
 8055a7d:	83 c4 20             	add    $0x20,%esp
 8055a80:	68 18 ae 8f 14       	push   $0x148fae18
 8055a85:	68 40 36 06 08       	push   $0x8063640
 8055a8a:	6a 50                	push   $0x50
 8055a8c:	68 00 89 0c 08       	push   $0x80c8900
 8055a91:	e8 6a 30 ff ff       	call   8048b00 <snprintf@plt>
 8055a96:	83 c4 10             	add    $0x10,%esp
 8055a99:	83 f8 4f             	cmp    $0x4f,%eax
 8055a9c:	7e 83                	jle    8055a21 <js_i_w+0x51>
 8055a9e:	68 51 37 06 08       	push   $0x8063751
 8055aa3:	6a 0e                	push   $0xe
 8055aa5:	68 50 36 06 08       	push   $0x8063650
 8055aaa:	68 bc 36 06 08       	push   $0x80636bc
 8055aaf:	e8 fc 30 ff ff       	call   8048bb0 <__assert_fail@plt>
 8055ab4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8055aba:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08055ac0 <js_i_b>:
}

make_instr_helper(i)
 8055ac0:	53                   	push   %ebx
 8055ac1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055ac4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055ac8:	83 c0 01             	add    $0x1,%eax
 8055acb:	50                   	push   %eax
 8055acc:	e8 6f 6e 00 00       	call   805c940 <decode_i_b>
#define instr js

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.SF) {
 8055ad1:	83 c4 10             	add    $0x10,%esp
 8055ad4:	80 3d e4 ae 8f 14 00 	cmpb   $0x0,0x148faee4
 8055adb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr js

static void do_execute() {
	int res = op_src->val;
 8055add:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.SF) {
 8055ae2:	79 09                	jns    8055aed <js_i_b+0x2d>

#define instr js

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8055ae4:	0f be c0             	movsbl %al,%eax
	if(cpu.SF) {
		cpu.eip = cpu.eip + res;
 8055ae7:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055aed:	68 18 ae 8f 14       	push   $0x148fae18
 8055af2:	68 47 36 06 08       	push   $0x8063647
 8055af7:	6a 50                	push   $0x50
 8055af9:	68 00 89 0c 08       	push   $0x80c8900
 8055afe:	e8 fd 2f ff ff       	call   8048b00 <snprintf@plt>
 8055b03:	83 c4 10             	add    $0x10,%esp
 8055b06:	83 f8 4f             	cmp    $0x4f,%eax
 8055b09:	7f 0d                	jg     8055b18 <js_i_b+0x58>
}

make_instr_helper(i)
 8055b0b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055b0e:	8d 43 01             	lea    0x1(%ebx),%eax
 8055b11:	5b                   	pop    %ebx
 8055b12:	c3                   	ret    
 8055b13:	90                   	nop
 8055b14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055b18:	83 ec 0c             	sub    $0xc,%esp
 8055b1b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8055b21:	e8 3a 2e ff ff       	call   8048960 <fflush@plt>
 8055b26:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055b2c:	6a 07                	push   $0x7
 8055b2e:	6a 01                	push   $0x1
 8055b30:	68 92 ed 05 08       	push   $0x805ed92
 8055b35:	e8 d6 2e ff ff       	call   8048a10 <fwrite@plt>
 8055b3a:	83 c4 20             	add    $0x20,%esp
 8055b3d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055b43:	6a 10                	push   $0x10
 8055b45:	6a 01                	push   $0x1
 8055b47:	68 84 f8 05 08       	push   $0x805f884
 8055b4c:	e8 bf 2e ff ff       	call   8048a10 <fwrite@plt>
 8055b51:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055b57:	6a 05                	push   $0x5
 8055b59:	6a 01                	push   $0x1
 8055b5b:	68 b1 ed 05 08       	push   $0x805edb1
 8055b60:	e8 ab 2e ff ff       	call   8048a10 <fwrite@plt>
 8055b65:	83 c4 20             	add    $0x20,%esp
 8055b68:	68 18 ae 8f 14       	push   $0x148fae18
 8055b6d:	68 47 36 06 08       	push   $0x8063647
 8055b72:	6a 50                	push   $0x50
 8055b74:	68 00 89 0c 08       	push   $0x80c8900
 8055b79:	e8 82 2f ff ff       	call   8048b00 <snprintf@plt>
 8055b7e:	83 c4 10             	add    $0x10,%esp
 8055b81:	83 f8 4f             	cmp    $0x4f,%eax
 8055b84:	7e 85                	jle    8055b0b <js_i_b+0x4b>
 8055b86:	68 59 37 06 08       	push   $0x8063759
 8055b8b:	6a 0e                	push   $0xe
 8055b8d:	68 50 36 06 08       	push   $0x8063650
 8055b92:	68 04 37 06 08       	push   $0x8063704
 8055b97:	e8 14 30 ff ff       	call   8048bb0 <__assert_fail@plt>
 8055b9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08055ba0 <js_i_v>:
#include "js-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(js_i)
 8055ba0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8055ba7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8055bab:	b8 d0 59 05 08       	mov    $0x80559d0,%eax
 8055bb0:	75 05                	jne    8055bb7 <js_i_v+0x17>
 8055bb2:	b8 f0 58 05 08       	mov    $0x80558f0,%eax
 8055bb7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8055bbb:	ff e0                	jmp    *%eax
 8055bbd:	66 90                	xchg   %ax,%ax
 8055bbf:	90                   	nop

08055bc0 <jb_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8055bc0:	53                   	push   %ebx
 8055bc1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055bc4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055bc8:	83 c0 01             	add    $0x1,%eax
 8055bcb:	50                   	push   %eax
 8055bcc:	e8 6f 74 00 00       	call   805d040 <decode_i_l>
#define instr jb

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF) {
 8055bd1:	83 c4 10             	add    $0x10,%esp
 8055bd4:	f6 05 e4 ae 8f 14 01 	testb  $0x1,0x148faee4
 8055bdb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jb

static void do_execute() {
	int res = op_src->val;
 8055bdd:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF) {
 8055be2:	74 06                	je     8055bea <jb_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8055be4:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055bea:	68 18 ae 8f 14       	push   $0x148fae18
 8055bef:	68 61 37 06 08       	push   $0x8063761
 8055bf4:	6a 50                	push   $0x50
 8055bf6:	68 00 89 0c 08       	push   $0x80c8900
 8055bfb:	e8 00 2f ff ff       	call   8048b00 <snprintf@plt>
 8055c00:	83 c4 10             	add    $0x10,%esp
 8055c03:	83 f8 4f             	cmp    $0x4f,%eax
 8055c06:	7f 08                	jg     8055c10 <jb_i_l+0x50>
}

make_instr_helper(i)
 8055c08:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055c0b:	8d 43 01             	lea    0x1(%ebx),%eax
 8055c0e:	5b                   	pop    %ebx
 8055c0f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055c10:	83 ec 0c             	sub    $0xc,%esp
 8055c13:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8055c19:	e8 42 2d ff ff       	call   8048960 <fflush@plt>
 8055c1e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055c24:	6a 07                	push   $0x7
 8055c26:	6a 01                	push   $0x1
 8055c28:	68 92 ed 05 08       	push   $0x805ed92
 8055c2d:	e8 de 2d ff ff       	call   8048a10 <fwrite@plt>
 8055c32:	83 c4 20             	add    $0x20,%esp
 8055c35:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055c3b:	6a 10                	push   $0x10
 8055c3d:	6a 01                	push   $0x1
 8055c3f:	68 84 f8 05 08       	push   $0x805f884
 8055c44:	e8 c7 2d ff ff       	call   8048a10 <fwrite@plt>
 8055c49:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055c4f:	6a 05                	push   $0x5
 8055c51:	6a 01                	push   $0x1
 8055c53:	68 b1 ed 05 08       	push   $0x805edb1
 8055c58:	e8 b3 2d ff ff       	call   8048a10 <fwrite@plt>
 8055c5d:	83 c4 20             	add    $0x20,%esp
 8055c60:	68 18 ae 8f 14       	push   $0x148fae18
 8055c65:	68 61 37 06 08       	push   $0x8063761
 8055c6a:	6a 50                	push   $0x50
 8055c6c:	68 00 89 0c 08       	push   $0x80c8900
 8055c71:	e8 8a 2e ff ff       	call   8048b00 <snprintf@plt>
 8055c76:	83 c4 10             	add    $0x10,%esp
 8055c79:	83 f8 4f             	cmp    $0x4f,%eax
 8055c7c:	7e 8a                	jle    8055c08 <jb_i_l+0x48>
 8055c7e:	68 71 38 06 08       	push   $0x8063871
 8055c83:	6a 0e                	push   $0xe
 8055c85:	68 78 37 06 08       	push   $0x8063778
 8055c8a:	68 9c 37 06 08       	push   $0x806379c
 8055c8f:	e8 1c 2f ff ff       	call   8048bb0 <__assert_fail@plt>
 8055c94:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8055c9a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08055ca0 <jb_i_w>:
}

make_instr_helper(i)
 8055ca0:	53                   	push   %ebx
 8055ca1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055ca4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055ca8:	83 c0 01             	add    $0x1,%eax
 8055cab:	50                   	push   %eax
 8055cac:	e8 ff 6f 00 00       	call   805ccb0 <decode_i_w>
#define instr jb

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF) {
 8055cb1:	83 c4 10             	add    $0x10,%esp
 8055cb4:	f6 05 e4 ae 8f 14 01 	testb  $0x1,0x148faee4
 8055cbb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jb

static void do_execute() {
	int res = op_src->val;
 8055cbd:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF) {
 8055cc2:	74 0f                	je     8055cd3 <jb_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8055cc4:	66 03 05 e0 ae 8f 14 	add    0x148faee0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 8055ccb:	0f b7 c0             	movzwl %ax,%eax
 8055cce:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
#endif
	}
	print_asm_template1();
 8055cd3:	68 18 ae 8f 14       	push   $0x148fae18
 8055cd8:	68 68 37 06 08       	push   $0x8063768
 8055cdd:	6a 50                	push   $0x50
 8055cdf:	68 00 89 0c 08       	push   $0x80c8900
 8055ce4:	e8 17 2e ff ff       	call   8048b00 <snprintf@plt>
 8055ce9:	83 c4 10             	add    $0x10,%esp
 8055cec:	83 f8 4f             	cmp    $0x4f,%eax
 8055cef:	7f 0f                	jg     8055d00 <jb_i_w+0x60>
}

make_instr_helper(i)
 8055cf1:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055cf4:	8d 43 01             	lea    0x1(%ebx),%eax
 8055cf7:	5b                   	pop    %ebx
 8055cf8:	c3                   	ret    
 8055cf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055d00:	83 ec 0c             	sub    $0xc,%esp
 8055d03:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8055d09:	e8 52 2c ff ff       	call   8048960 <fflush@plt>
 8055d0e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055d14:	6a 07                	push   $0x7
 8055d16:	6a 01                	push   $0x1
 8055d18:	68 92 ed 05 08       	push   $0x805ed92
 8055d1d:	e8 ee 2c ff ff       	call   8048a10 <fwrite@plt>
 8055d22:	83 c4 20             	add    $0x20,%esp
 8055d25:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055d2b:	6a 10                	push   $0x10
 8055d2d:	6a 01                	push   $0x1
 8055d2f:	68 84 f8 05 08       	push   $0x805f884
 8055d34:	e8 d7 2c ff ff       	call   8048a10 <fwrite@plt>
 8055d39:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055d3f:	6a 05                	push   $0x5
 8055d41:	6a 01                	push   $0x1
 8055d43:	68 b1 ed 05 08       	push   $0x805edb1
 8055d48:	e8 c3 2c ff ff       	call   8048a10 <fwrite@plt>
 8055d4d:	83 c4 20             	add    $0x20,%esp
 8055d50:	68 18 ae 8f 14       	push   $0x148fae18
 8055d55:	68 68 37 06 08       	push   $0x8063768
 8055d5a:	6a 50                	push   $0x50
 8055d5c:	68 00 89 0c 08       	push   $0x80c8900
 8055d61:	e8 9a 2d ff ff       	call   8048b00 <snprintf@plt>
 8055d66:	83 c4 10             	add    $0x10,%esp
 8055d69:	83 f8 4f             	cmp    $0x4f,%eax
 8055d6c:	7e 83                	jle    8055cf1 <jb_i_w+0x51>
 8055d6e:	68 79 38 06 08       	push   $0x8063879
 8055d73:	6a 0e                	push   $0xe
 8055d75:	68 78 37 06 08       	push   $0x8063778
 8055d7a:	68 e4 37 06 08       	push   $0x80637e4
 8055d7f:	e8 2c 2e ff ff       	call   8048bb0 <__assert_fail@plt>
 8055d84:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8055d8a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08055d90 <jb_i_b>:
}

make_instr_helper(i)
 8055d90:	53                   	push   %ebx
 8055d91:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055d94:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055d98:	83 c0 01             	add    $0x1,%eax
 8055d9b:	50                   	push   %eax
 8055d9c:	e8 9f 6b 00 00       	call   805c940 <decode_i_b>
#define instr jb

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF) {
 8055da1:	83 c4 10             	add    $0x10,%esp
 8055da4:	f6 05 e4 ae 8f 14 01 	testb  $0x1,0x148faee4
 8055dab:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jb

static void do_execute() {
	int res = op_src->val;
 8055dad:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF) {
 8055db2:	74 09                	je     8055dbd <jb_i_b+0x2d>

#define instr jb

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8055db4:	0f be c0             	movsbl %al,%eax
	if(cpu.CF) {
		cpu.eip = cpu.eip + res;
 8055db7:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055dbd:	68 18 ae 8f 14       	push   $0x148fae18
 8055dc2:	68 6f 37 06 08       	push   $0x806376f
 8055dc7:	6a 50                	push   $0x50
 8055dc9:	68 00 89 0c 08       	push   $0x80c8900
 8055dce:	e8 2d 2d ff ff       	call   8048b00 <snprintf@plt>
 8055dd3:	83 c4 10             	add    $0x10,%esp
 8055dd6:	83 f8 4f             	cmp    $0x4f,%eax
 8055dd9:	7f 0d                	jg     8055de8 <jb_i_b+0x58>
}

make_instr_helper(i)
 8055ddb:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055dde:	8d 43 01             	lea    0x1(%ebx),%eax
 8055de1:	5b                   	pop    %ebx
 8055de2:	c3                   	ret    
 8055de3:	90                   	nop
 8055de4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055de8:	83 ec 0c             	sub    $0xc,%esp
 8055deb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8055df1:	e8 6a 2b ff ff       	call   8048960 <fflush@plt>
 8055df6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055dfc:	6a 07                	push   $0x7
 8055dfe:	6a 01                	push   $0x1
 8055e00:	68 92 ed 05 08       	push   $0x805ed92
 8055e05:	e8 06 2c ff ff       	call   8048a10 <fwrite@plt>
 8055e0a:	83 c4 20             	add    $0x20,%esp
 8055e0d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055e13:	6a 10                	push   $0x10
 8055e15:	6a 01                	push   $0x1
 8055e17:	68 84 f8 05 08       	push   $0x805f884
 8055e1c:	e8 ef 2b ff ff       	call   8048a10 <fwrite@plt>
 8055e21:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055e27:	6a 05                	push   $0x5
 8055e29:	6a 01                	push   $0x1
 8055e2b:	68 b1 ed 05 08       	push   $0x805edb1
 8055e30:	e8 db 2b ff ff       	call   8048a10 <fwrite@plt>
 8055e35:	83 c4 20             	add    $0x20,%esp
 8055e38:	68 18 ae 8f 14       	push   $0x148fae18
 8055e3d:	68 6f 37 06 08       	push   $0x806376f
 8055e42:	6a 50                	push   $0x50
 8055e44:	68 00 89 0c 08       	push   $0x80c8900
 8055e49:	e8 b2 2c ff ff       	call   8048b00 <snprintf@plt>
 8055e4e:	83 c4 10             	add    $0x10,%esp
 8055e51:	83 f8 4f             	cmp    $0x4f,%eax
 8055e54:	7e 85                	jle    8055ddb <jb_i_b+0x4b>
 8055e56:	68 81 38 06 08       	push   $0x8063881
 8055e5b:	6a 0e                	push   $0xe
 8055e5d:	68 78 37 06 08       	push   $0x8063778
 8055e62:	68 2c 38 06 08       	push   $0x806382c
 8055e67:	e8 44 2d ff ff       	call   8048bb0 <__assert_fail@plt>
 8055e6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08055e70 <jb_i_v>:
#include "jb-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jb_i)
 8055e70:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8055e77:	8b 54 24 04          	mov    0x4(%esp),%edx
 8055e7b:	b8 a0 5c 05 08       	mov    $0x8055ca0,%eax
 8055e80:	75 05                	jne    8055e87 <jb_i_v+0x17>
 8055e82:	b8 c0 5b 05 08       	mov    $0x8055bc0,%eax
 8055e87:	89 54 24 04          	mov    %edx,0x4(%esp)
 8055e8b:	ff e0                	jmp    *%eax
 8055e8d:	66 90                	xchg   %ax,%ax
 8055e8f:	90                   	nop

08055e90 <je_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8055e90:	53                   	push   %ebx
 8055e91:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055e94:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055e98:	83 c0 01             	add    $0x1,%eax
 8055e9b:	50                   	push   %eax
 8055e9c:	e8 9f 71 00 00       	call   805d040 <decode_i_l>
#define instr je

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.ZF) {
 8055ea1:	83 c4 10             	add    $0x10,%esp
 8055ea4:	f6 05 e4 ae 8f 14 40 	testb  $0x40,0x148faee4
 8055eab:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr je

static void do_execute() {
	int res = op_src->val;
 8055ead:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.ZF) {
 8055eb2:	74 06                	je     8055eba <je_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8055eb4:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055eba:	68 18 ae 8f 14       	push   $0x148fae18
 8055ebf:	68 89 38 06 08       	push   $0x8063889
 8055ec4:	6a 50                	push   $0x50
 8055ec6:	68 00 89 0c 08       	push   $0x80c8900
 8055ecb:	e8 30 2c ff ff       	call   8048b00 <snprintf@plt>
 8055ed0:	83 c4 10             	add    $0x10,%esp
 8055ed3:	83 f8 4f             	cmp    $0x4f,%eax
 8055ed6:	7f 08                	jg     8055ee0 <je_i_l+0x50>
}

make_instr_helper(i)
 8055ed8:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055edb:	8d 43 01             	lea    0x1(%ebx),%eax
 8055ede:	5b                   	pop    %ebx
 8055edf:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055ee0:	83 ec 0c             	sub    $0xc,%esp
 8055ee3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8055ee9:	e8 72 2a ff ff       	call   8048960 <fflush@plt>
 8055eee:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055ef4:	6a 07                	push   $0x7
 8055ef6:	6a 01                	push   $0x1
 8055ef8:	68 92 ed 05 08       	push   $0x805ed92
 8055efd:	e8 0e 2b ff ff       	call   8048a10 <fwrite@plt>
 8055f02:	83 c4 20             	add    $0x20,%esp
 8055f05:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055f0b:	6a 10                	push   $0x10
 8055f0d:	6a 01                	push   $0x1
 8055f0f:	68 84 f8 05 08       	push   $0x805f884
 8055f14:	e8 f7 2a ff ff       	call   8048a10 <fwrite@plt>
 8055f19:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055f1f:	6a 05                	push   $0x5
 8055f21:	6a 01                	push   $0x1
 8055f23:	68 b1 ed 05 08       	push   $0x805edb1
 8055f28:	e8 e3 2a ff ff       	call   8048a10 <fwrite@plt>
 8055f2d:	83 c4 20             	add    $0x20,%esp
 8055f30:	68 18 ae 8f 14       	push   $0x148fae18
 8055f35:	68 89 38 06 08       	push   $0x8063889
 8055f3a:	6a 50                	push   $0x50
 8055f3c:	68 00 89 0c 08       	push   $0x80c8900
 8055f41:	e8 ba 2b ff ff       	call   8048b00 <snprintf@plt>
 8055f46:	83 c4 10             	add    $0x10,%esp
 8055f49:	83 f8 4f             	cmp    $0x4f,%eax
 8055f4c:	7e 8a                	jle    8055ed8 <je_i_l+0x48>
 8055f4e:	68 99 39 06 08       	push   $0x8063999
 8055f53:	6a 0e                	push   $0xe
 8055f55:	68 a0 38 06 08       	push   $0x80638a0
 8055f5a:	68 c4 38 06 08       	push   $0x80638c4
 8055f5f:	e8 4c 2c ff ff       	call   8048bb0 <__assert_fail@plt>
 8055f64:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8055f6a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08055f70 <je_i_w>:
}

make_instr_helper(i)
 8055f70:	53                   	push   %ebx
 8055f71:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055f74:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055f78:	83 c0 01             	add    $0x1,%eax
 8055f7b:	50                   	push   %eax
 8055f7c:	e8 2f 6d 00 00       	call   805ccb0 <decode_i_w>
#define instr je

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.ZF) {
 8055f81:	83 c4 10             	add    $0x10,%esp
 8055f84:	f6 05 e4 ae 8f 14 40 	testb  $0x40,0x148faee4
 8055f8b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr je

static void do_execute() {
	int res = op_src->val;
 8055f8d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.ZF) {
 8055f92:	74 0f                	je     8055fa3 <je_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8055f94:	66 03 05 e0 ae 8f 14 	add    0x148faee0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 8055f9b:	0f b7 c0             	movzwl %ax,%eax
 8055f9e:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
#endif
	}
	print_asm_template1();
 8055fa3:	68 18 ae 8f 14       	push   $0x148fae18
 8055fa8:	68 90 38 06 08       	push   $0x8063890
 8055fad:	6a 50                	push   $0x50
 8055faf:	68 00 89 0c 08       	push   $0x80c8900
 8055fb4:	e8 47 2b ff ff       	call   8048b00 <snprintf@plt>
 8055fb9:	83 c4 10             	add    $0x10,%esp
 8055fbc:	83 f8 4f             	cmp    $0x4f,%eax
 8055fbf:	7f 0f                	jg     8055fd0 <je_i_w+0x60>
}

make_instr_helper(i)
 8055fc1:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055fc4:	8d 43 01             	lea    0x1(%ebx),%eax
 8055fc7:	5b                   	pop    %ebx
 8055fc8:	c3                   	ret    
 8055fc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055fd0:	83 ec 0c             	sub    $0xc,%esp
 8055fd3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8055fd9:	e8 82 29 ff ff       	call   8048960 <fflush@plt>
 8055fde:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055fe4:	6a 07                	push   $0x7
 8055fe6:	6a 01                	push   $0x1
 8055fe8:	68 92 ed 05 08       	push   $0x805ed92
 8055fed:	e8 1e 2a ff ff       	call   8048a10 <fwrite@plt>
 8055ff2:	83 c4 20             	add    $0x20,%esp
 8055ff5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8055ffb:	6a 10                	push   $0x10
 8055ffd:	6a 01                	push   $0x1
 8055fff:	68 84 f8 05 08       	push   $0x805f884
 8056004:	e8 07 2a ff ff       	call   8048a10 <fwrite@plt>
 8056009:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805600f:	6a 05                	push   $0x5
 8056011:	6a 01                	push   $0x1
 8056013:	68 b1 ed 05 08       	push   $0x805edb1
 8056018:	e8 f3 29 ff ff       	call   8048a10 <fwrite@plt>
 805601d:	83 c4 20             	add    $0x20,%esp
 8056020:	68 18 ae 8f 14       	push   $0x148fae18
 8056025:	68 90 38 06 08       	push   $0x8063890
 805602a:	6a 50                	push   $0x50
 805602c:	68 00 89 0c 08       	push   $0x80c8900
 8056031:	e8 ca 2a ff ff       	call   8048b00 <snprintf@plt>
 8056036:	83 c4 10             	add    $0x10,%esp
 8056039:	83 f8 4f             	cmp    $0x4f,%eax
 805603c:	7e 83                	jle    8055fc1 <je_i_w+0x51>
 805603e:	68 a1 39 06 08       	push   $0x80639a1
 8056043:	6a 0e                	push   $0xe
 8056045:	68 a0 38 06 08       	push   $0x80638a0
 805604a:	68 0c 39 06 08       	push   $0x806390c
 805604f:	e8 5c 2b ff ff       	call   8048bb0 <__assert_fail@plt>
 8056054:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805605a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08056060 <je_i_b>:
}

make_instr_helper(i)
 8056060:	53                   	push   %ebx
 8056061:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056064:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056068:	83 c0 01             	add    $0x1,%eax
 805606b:	50                   	push   %eax
 805606c:	e8 cf 68 00 00       	call   805c940 <decode_i_b>
#define instr je

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.ZF) {
 8056071:	83 c4 10             	add    $0x10,%esp
 8056074:	f6 05 e4 ae 8f 14 40 	testb  $0x40,0x148faee4
 805607b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr je

static void do_execute() {
	int res = op_src->val;
 805607d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.ZF) {
 8056082:	74 09                	je     805608d <je_i_b+0x2d>

#define instr je

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8056084:	0f be c0             	movsbl %al,%eax
	if(cpu.ZF) {
		cpu.eip = cpu.eip + res;
 8056087:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805608d:	68 18 ae 8f 14       	push   $0x148fae18
 8056092:	68 97 38 06 08       	push   $0x8063897
 8056097:	6a 50                	push   $0x50
 8056099:	68 00 89 0c 08       	push   $0x80c8900
 805609e:	e8 5d 2a ff ff       	call   8048b00 <snprintf@plt>
 80560a3:	83 c4 10             	add    $0x10,%esp
 80560a6:	83 f8 4f             	cmp    $0x4f,%eax
 80560a9:	7f 0d                	jg     80560b8 <je_i_b+0x58>
}

make_instr_helper(i)
 80560ab:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80560ae:	8d 43 01             	lea    0x1(%ebx),%eax
 80560b1:	5b                   	pop    %ebx
 80560b2:	c3                   	ret    
 80560b3:	90                   	nop
 80560b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80560b8:	83 ec 0c             	sub    $0xc,%esp
 80560bb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80560c1:	e8 9a 28 ff ff       	call   8048960 <fflush@plt>
 80560c6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80560cc:	6a 07                	push   $0x7
 80560ce:	6a 01                	push   $0x1
 80560d0:	68 92 ed 05 08       	push   $0x805ed92
 80560d5:	e8 36 29 ff ff       	call   8048a10 <fwrite@plt>
 80560da:	83 c4 20             	add    $0x20,%esp
 80560dd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80560e3:	6a 10                	push   $0x10
 80560e5:	6a 01                	push   $0x1
 80560e7:	68 84 f8 05 08       	push   $0x805f884
 80560ec:	e8 1f 29 ff ff       	call   8048a10 <fwrite@plt>
 80560f1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80560f7:	6a 05                	push   $0x5
 80560f9:	6a 01                	push   $0x1
 80560fb:	68 b1 ed 05 08       	push   $0x805edb1
 8056100:	e8 0b 29 ff ff       	call   8048a10 <fwrite@plt>
 8056105:	83 c4 20             	add    $0x20,%esp
 8056108:	68 18 ae 8f 14       	push   $0x148fae18
 805610d:	68 97 38 06 08       	push   $0x8063897
 8056112:	6a 50                	push   $0x50
 8056114:	68 00 89 0c 08       	push   $0x80c8900
 8056119:	e8 e2 29 ff ff       	call   8048b00 <snprintf@plt>
 805611e:	83 c4 10             	add    $0x10,%esp
 8056121:	83 f8 4f             	cmp    $0x4f,%eax
 8056124:	7e 85                	jle    80560ab <je_i_b+0x4b>
 8056126:	68 a9 39 06 08       	push   $0x80639a9
 805612b:	6a 0e                	push   $0xe
 805612d:	68 a0 38 06 08       	push   $0x80638a0
 8056132:	68 54 39 06 08       	push   $0x8063954
 8056137:	e8 74 2a ff ff       	call   8048bb0 <__assert_fail@plt>
 805613c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08056140 <je_i_v>:
#include "je-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(je_i)
 8056140:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8056147:	8b 54 24 04          	mov    0x4(%esp),%edx
 805614b:	b8 70 5f 05 08       	mov    $0x8055f70,%eax
 8056150:	75 05                	jne    8056157 <je_i_v+0x17>
 8056152:	b8 90 5e 05 08       	mov    $0x8055e90,%eax
 8056157:	89 54 24 04          	mov    %edx,0x4(%esp)
 805615b:	ff e0                	jmp    *%eax
 805615d:	66 90                	xchg   %ax,%ax
 805615f:	90                   	nop

08056160 <jns_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8056160:	53                   	push   %ebx
 8056161:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056164:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056168:	83 c0 01             	add    $0x1,%eax
 805616b:	50                   	push   %eax
 805616c:	e8 cf 6e 00 00       	call   805d040 <decode_i_l>
#define instr jns

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.SF) {
 8056171:	83 c4 10             	add    $0x10,%esp
 8056174:	80 3d e4 ae 8f 14 00 	cmpb   $0x0,0x148faee4
 805617b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jns

static void do_execute() {
	int res = op_src->val;
 805617d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.SF) {
 8056182:	78 06                	js     805618a <jns_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8056184:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805618a:	68 18 ae 8f 14       	push   $0x148fae18
 805618f:	68 b1 39 06 08       	push   $0x80639b1
 8056194:	6a 50                	push   $0x50
 8056196:	68 00 89 0c 08       	push   $0x80c8900
 805619b:	e8 60 29 ff ff       	call   8048b00 <snprintf@plt>
 80561a0:	83 c4 10             	add    $0x10,%esp
 80561a3:	83 f8 4f             	cmp    $0x4f,%eax
 80561a6:	7f 08                	jg     80561b0 <jns_i_l+0x50>
}

make_instr_helper(i)
 80561a8:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80561ab:	8d 43 01             	lea    0x1(%ebx),%eax
 80561ae:	5b                   	pop    %ebx
 80561af:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80561b0:	83 ec 0c             	sub    $0xc,%esp
 80561b3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80561b9:	e8 a2 27 ff ff       	call   8048960 <fflush@plt>
 80561be:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80561c4:	6a 07                	push   $0x7
 80561c6:	6a 01                	push   $0x1
 80561c8:	68 92 ed 05 08       	push   $0x805ed92
 80561cd:	e8 3e 28 ff ff       	call   8048a10 <fwrite@plt>
 80561d2:	83 c4 20             	add    $0x20,%esp
 80561d5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80561db:	6a 10                	push   $0x10
 80561dd:	6a 01                	push   $0x1
 80561df:	68 84 f8 05 08       	push   $0x805f884
 80561e4:	e8 27 28 ff ff       	call   8048a10 <fwrite@plt>
 80561e9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80561ef:	6a 05                	push   $0x5
 80561f1:	6a 01                	push   $0x1
 80561f3:	68 b1 ed 05 08       	push   $0x805edb1
 80561f8:	e8 13 28 ff ff       	call   8048a10 <fwrite@plt>
 80561fd:	83 c4 20             	add    $0x20,%esp
 8056200:	68 18 ae 8f 14       	push   $0x148fae18
 8056205:	68 b1 39 06 08       	push   $0x80639b1
 805620a:	6a 50                	push   $0x50
 805620c:	68 00 89 0c 08       	push   $0x80c8900
 8056211:	e8 ea 28 ff ff       	call   8048b00 <snprintf@plt>
 8056216:	83 c4 10             	add    $0x10,%esp
 8056219:	83 f8 4f             	cmp    $0x4f,%eax
 805621c:	7e 8a                	jle    80561a8 <jns_i_l+0x48>
 805621e:	68 ca 3a 06 08       	push   $0x8063aca
 8056223:	6a 0e                	push   $0xe
 8056225:	68 cc 39 06 08       	push   $0x80639cc
 805622a:	68 f4 39 06 08       	push   $0x80639f4
 805622f:	e8 7c 29 ff ff       	call   8048bb0 <__assert_fail@plt>
 8056234:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805623a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08056240 <jns_i_w>:
}

make_instr_helper(i)
 8056240:	53                   	push   %ebx
 8056241:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056244:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056248:	83 c0 01             	add    $0x1,%eax
 805624b:	50                   	push   %eax
 805624c:	e8 5f 6a 00 00       	call   805ccb0 <decode_i_w>
#define instr jns

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.SF) {
 8056251:	83 c4 10             	add    $0x10,%esp
 8056254:	80 3d e4 ae 8f 14 00 	cmpb   $0x0,0x148faee4
 805625b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jns

static void do_execute() {
	int res = op_src->val;
 805625d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.SF) {
 8056262:	78 0f                	js     8056273 <jns_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8056264:	66 03 05 e0 ae 8f 14 	add    0x148faee0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 805626b:	0f b7 c0             	movzwl %ax,%eax
 805626e:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
#endif
	}
	print_asm_template1();
 8056273:	68 18 ae 8f 14       	push   $0x148fae18
 8056278:	68 b9 39 06 08       	push   $0x80639b9
 805627d:	6a 50                	push   $0x50
 805627f:	68 00 89 0c 08       	push   $0x80c8900
 8056284:	e8 77 28 ff ff       	call   8048b00 <snprintf@plt>
 8056289:	83 c4 10             	add    $0x10,%esp
 805628c:	83 f8 4f             	cmp    $0x4f,%eax
 805628f:	7f 0f                	jg     80562a0 <jns_i_w+0x60>
}

make_instr_helper(i)
 8056291:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056294:	8d 43 01             	lea    0x1(%ebx),%eax
 8056297:	5b                   	pop    %ebx
 8056298:	c3                   	ret    
 8056299:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80562a0:	83 ec 0c             	sub    $0xc,%esp
 80562a3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80562a9:	e8 b2 26 ff ff       	call   8048960 <fflush@plt>
 80562ae:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80562b4:	6a 07                	push   $0x7
 80562b6:	6a 01                	push   $0x1
 80562b8:	68 92 ed 05 08       	push   $0x805ed92
 80562bd:	e8 4e 27 ff ff       	call   8048a10 <fwrite@plt>
 80562c2:	83 c4 20             	add    $0x20,%esp
 80562c5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80562cb:	6a 10                	push   $0x10
 80562cd:	6a 01                	push   $0x1
 80562cf:	68 84 f8 05 08       	push   $0x805f884
 80562d4:	e8 37 27 ff ff       	call   8048a10 <fwrite@plt>
 80562d9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80562df:	6a 05                	push   $0x5
 80562e1:	6a 01                	push   $0x1
 80562e3:	68 b1 ed 05 08       	push   $0x805edb1
 80562e8:	e8 23 27 ff ff       	call   8048a10 <fwrite@plt>
 80562ed:	83 c4 20             	add    $0x20,%esp
 80562f0:	68 18 ae 8f 14       	push   $0x148fae18
 80562f5:	68 b9 39 06 08       	push   $0x80639b9
 80562fa:	6a 50                	push   $0x50
 80562fc:	68 00 89 0c 08       	push   $0x80c8900
 8056301:	e8 fa 27 ff ff       	call   8048b00 <snprintf@plt>
 8056306:	83 c4 10             	add    $0x10,%esp
 8056309:	83 f8 4f             	cmp    $0x4f,%eax
 805630c:	7e 83                	jle    8056291 <jns_i_w+0x51>
 805630e:	68 d3 3a 06 08       	push   $0x8063ad3
 8056313:	6a 0e                	push   $0xe
 8056315:	68 cc 39 06 08       	push   $0x80639cc
 805631a:	68 3c 3a 06 08       	push   $0x8063a3c
 805631f:	e8 8c 28 ff ff       	call   8048bb0 <__assert_fail@plt>
 8056324:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805632a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08056330 <jns_i_b>:
}

make_instr_helper(i)
 8056330:	53                   	push   %ebx
 8056331:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056334:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056338:	83 c0 01             	add    $0x1,%eax
 805633b:	50                   	push   %eax
 805633c:	e8 ff 65 00 00       	call   805c940 <decode_i_b>
#define instr jns

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.SF) {
 8056341:	83 c4 10             	add    $0x10,%esp
 8056344:	80 3d e4 ae 8f 14 00 	cmpb   $0x0,0x148faee4
 805634b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jns

static void do_execute() {
	int res = op_src->val;
 805634d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.SF) {
 8056352:	78 09                	js     805635d <jns_i_b+0x2d>

#define instr jns

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8056354:	0f be c0             	movsbl %al,%eax
	if(!cpu.SF) {
		cpu.eip = cpu.eip + res;
 8056357:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805635d:	68 18 ae 8f 14       	push   $0x148fae18
 8056362:	68 c1 39 06 08       	push   $0x80639c1
 8056367:	6a 50                	push   $0x50
 8056369:	68 00 89 0c 08       	push   $0x80c8900
 805636e:	e8 8d 27 ff ff       	call   8048b00 <snprintf@plt>
 8056373:	83 c4 10             	add    $0x10,%esp
 8056376:	83 f8 4f             	cmp    $0x4f,%eax
 8056379:	7f 0d                	jg     8056388 <jns_i_b+0x58>
}

make_instr_helper(i)
 805637b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805637e:	8d 43 01             	lea    0x1(%ebx),%eax
 8056381:	5b                   	pop    %ebx
 8056382:	c3                   	ret    
 8056383:	90                   	nop
 8056384:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056388:	83 ec 0c             	sub    $0xc,%esp
 805638b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8056391:	e8 ca 25 ff ff       	call   8048960 <fflush@plt>
 8056396:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805639c:	6a 07                	push   $0x7
 805639e:	6a 01                	push   $0x1
 80563a0:	68 92 ed 05 08       	push   $0x805ed92
 80563a5:	e8 66 26 ff ff       	call   8048a10 <fwrite@plt>
 80563aa:	83 c4 20             	add    $0x20,%esp
 80563ad:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80563b3:	6a 10                	push   $0x10
 80563b5:	6a 01                	push   $0x1
 80563b7:	68 84 f8 05 08       	push   $0x805f884
 80563bc:	e8 4f 26 ff ff       	call   8048a10 <fwrite@plt>
 80563c1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80563c7:	6a 05                	push   $0x5
 80563c9:	6a 01                	push   $0x1
 80563cb:	68 b1 ed 05 08       	push   $0x805edb1
 80563d0:	e8 3b 26 ff ff       	call   8048a10 <fwrite@plt>
 80563d5:	83 c4 20             	add    $0x20,%esp
 80563d8:	68 18 ae 8f 14       	push   $0x148fae18
 80563dd:	68 c1 39 06 08       	push   $0x80639c1
 80563e2:	6a 50                	push   $0x50
 80563e4:	68 00 89 0c 08       	push   $0x80c8900
 80563e9:	e8 12 27 ff ff       	call   8048b00 <snprintf@plt>
 80563ee:	83 c4 10             	add    $0x10,%esp
 80563f1:	83 f8 4f             	cmp    $0x4f,%eax
 80563f4:	7e 85                	jle    805637b <jns_i_b+0x4b>
 80563f6:	68 dc 3a 06 08       	push   $0x8063adc
 80563fb:	6a 0e                	push   $0xe
 80563fd:	68 cc 39 06 08       	push   $0x80639cc
 8056402:	68 84 3a 06 08       	push   $0x8063a84
 8056407:	e8 a4 27 ff ff       	call   8048bb0 <__assert_fail@plt>
 805640c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08056410 <jns_i_v>:
#include "jns-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jns_i)
 8056410:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8056417:	8b 54 24 04          	mov    0x4(%esp),%edx
 805641b:	b8 40 62 05 08       	mov    $0x8056240,%eax
 8056420:	75 05                	jne    8056427 <jns_i_v+0x17>
 8056422:	b8 60 61 05 08       	mov    $0x8056160,%eax
 8056427:	89 54 24 04          	mov    %edx,0x4(%esp)
 805642b:	ff e0                	jmp    *%eax
 805642d:	66 90                	xchg   %ax,%ax
 805642f:	90                   	nop

08056430 <jnp_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8056430:	53                   	push   %ebx
 8056431:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056434:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056438:	83 c0 01             	add    $0x1,%eax
 805643b:	50                   	push   %eax
 805643c:	e8 ff 6b 00 00       	call   805d040 <decode_i_l>
#define instr jnp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.PF) {
 8056441:	83 c4 10             	add    $0x10,%esp
 8056444:	f6 05 e4 ae 8f 14 04 	testb  $0x4,0x148faee4
 805644b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jnp

static void do_execute() {
	int res = op_src->val;
 805644d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.PF) {
 8056452:	75 06                	jne    805645a <jnp_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8056454:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805645a:	68 18 ae 8f 14       	push   $0x148fae18
 805645f:	68 e5 3a 06 08       	push   $0x8063ae5
 8056464:	6a 50                	push   $0x50
 8056466:	68 00 89 0c 08       	push   $0x80c8900
 805646b:	e8 90 26 ff ff       	call   8048b00 <snprintf@plt>
 8056470:	83 c4 10             	add    $0x10,%esp
 8056473:	83 f8 4f             	cmp    $0x4f,%eax
 8056476:	7f 08                	jg     8056480 <jnp_i_l+0x50>
}

make_instr_helper(i)
 8056478:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805647b:	8d 43 01             	lea    0x1(%ebx),%eax
 805647e:	5b                   	pop    %ebx
 805647f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056480:	83 ec 0c             	sub    $0xc,%esp
 8056483:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8056489:	e8 d2 24 ff ff       	call   8048960 <fflush@plt>
 805648e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056494:	6a 07                	push   $0x7
 8056496:	6a 01                	push   $0x1
 8056498:	68 92 ed 05 08       	push   $0x805ed92
 805649d:	e8 6e 25 ff ff       	call   8048a10 <fwrite@plt>
 80564a2:	83 c4 20             	add    $0x20,%esp
 80564a5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80564ab:	6a 10                	push   $0x10
 80564ad:	6a 01                	push   $0x1
 80564af:	68 84 f8 05 08       	push   $0x805f884
 80564b4:	e8 57 25 ff ff       	call   8048a10 <fwrite@plt>
 80564b9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80564bf:	6a 05                	push   $0x5
 80564c1:	6a 01                	push   $0x1
 80564c3:	68 b1 ed 05 08       	push   $0x805edb1
 80564c8:	e8 43 25 ff ff       	call   8048a10 <fwrite@plt>
 80564cd:	83 c4 20             	add    $0x20,%esp
 80564d0:	68 18 ae 8f 14       	push   $0x148fae18
 80564d5:	68 e5 3a 06 08       	push   $0x8063ae5
 80564da:	6a 50                	push   $0x50
 80564dc:	68 00 89 0c 08       	push   $0x80c8900
 80564e1:	e8 1a 26 ff ff       	call   8048b00 <snprintf@plt>
 80564e6:	83 c4 10             	add    $0x10,%esp
 80564e9:	83 f8 4f             	cmp    $0x4f,%eax
 80564ec:	7e 8a                	jle    8056478 <jnp_i_l+0x48>
 80564ee:	68 fe 3b 06 08       	push   $0x8063bfe
 80564f3:	6a 0e                	push   $0xe
 80564f5:	68 00 3b 06 08       	push   $0x8063b00
 80564fa:	68 28 3b 06 08       	push   $0x8063b28
 80564ff:	e8 ac 26 ff ff       	call   8048bb0 <__assert_fail@plt>
 8056504:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805650a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08056510 <jnp_i_w>:
}

make_instr_helper(i)
 8056510:	53                   	push   %ebx
 8056511:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056514:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056518:	83 c0 01             	add    $0x1,%eax
 805651b:	50                   	push   %eax
 805651c:	e8 8f 67 00 00       	call   805ccb0 <decode_i_w>
#define instr jnp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.PF) {
 8056521:	83 c4 10             	add    $0x10,%esp
 8056524:	f6 05 e4 ae 8f 14 04 	testb  $0x4,0x148faee4
 805652b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jnp

static void do_execute() {
	int res = op_src->val;
 805652d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.PF) {
 8056532:	75 0f                	jne    8056543 <jnp_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8056534:	66 03 05 e0 ae 8f 14 	add    0x148faee0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 805653b:	0f b7 c0             	movzwl %ax,%eax
 805653e:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
#endif
	}
	print_asm_template1();
 8056543:	68 18 ae 8f 14       	push   $0x148fae18
 8056548:	68 ed 3a 06 08       	push   $0x8063aed
 805654d:	6a 50                	push   $0x50
 805654f:	68 00 89 0c 08       	push   $0x80c8900
 8056554:	e8 a7 25 ff ff       	call   8048b00 <snprintf@plt>
 8056559:	83 c4 10             	add    $0x10,%esp
 805655c:	83 f8 4f             	cmp    $0x4f,%eax
 805655f:	7f 0f                	jg     8056570 <jnp_i_w+0x60>
}

make_instr_helper(i)
 8056561:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056564:	8d 43 01             	lea    0x1(%ebx),%eax
 8056567:	5b                   	pop    %ebx
 8056568:	c3                   	ret    
 8056569:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056570:	83 ec 0c             	sub    $0xc,%esp
 8056573:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8056579:	e8 e2 23 ff ff       	call   8048960 <fflush@plt>
 805657e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056584:	6a 07                	push   $0x7
 8056586:	6a 01                	push   $0x1
 8056588:	68 92 ed 05 08       	push   $0x805ed92
 805658d:	e8 7e 24 ff ff       	call   8048a10 <fwrite@plt>
 8056592:	83 c4 20             	add    $0x20,%esp
 8056595:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805659b:	6a 10                	push   $0x10
 805659d:	6a 01                	push   $0x1
 805659f:	68 84 f8 05 08       	push   $0x805f884
 80565a4:	e8 67 24 ff ff       	call   8048a10 <fwrite@plt>
 80565a9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80565af:	6a 05                	push   $0x5
 80565b1:	6a 01                	push   $0x1
 80565b3:	68 b1 ed 05 08       	push   $0x805edb1
 80565b8:	e8 53 24 ff ff       	call   8048a10 <fwrite@plt>
 80565bd:	83 c4 20             	add    $0x20,%esp
 80565c0:	68 18 ae 8f 14       	push   $0x148fae18
 80565c5:	68 ed 3a 06 08       	push   $0x8063aed
 80565ca:	6a 50                	push   $0x50
 80565cc:	68 00 89 0c 08       	push   $0x80c8900
 80565d1:	e8 2a 25 ff ff       	call   8048b00 <snprintf@plt>
 80565d6:	83 c4 10             	add    $0x10,%esp
 80565d9:	83 f8 4f             	cmp    $0x4f,%eax
 80565dc:	7e 83                	jle    8056561 <jnp_i_w+0x51>
 80565de:	68 07 3c 06 08       	push   $0x8063c07
 80565e3:	6a 0e                	push   $0xe
 80565e5:	68 00 3b 06 08       	push   $0x8063b00
 80565ea:	68 70 3b 06 08       	push   $0x8063b70
 80565ef:	e8 bc 25 ff ff       	call   8048bb0 <__assert_fail@plt>
 80565f4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80565fa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08056600 <jnp_i_b>:
}

make_instr_helper(i)
 8056600:	53                   	push   %ebx
 8056601:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056604:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056608:	83 c0 01             	add    $0x1,%eax
 805660b:	50                   	push   %eax
 805660c:	e8 2f 63 00 00       	call   805c940 <decode_i_b>
#define instr jnp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.PF) {
 8056611:	83 c4 10             	add    $0x10,%esp
 8056614:	f6 05 e4 ae 8f 14 04 	testb  $0x4,0x148faee4
 805661b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jnp

static void do_execute() {
	int res = op_src->val;
 805661d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.PF) {
 8056622:	75 09                	jne    805662d <jnp_i_b+0x2d>

#define instr jnp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8056624:	0f be c0             	movsbl %al,%eax
	if(!cpu.PF) {
		cpu.eip = cpu.eip + res;
 8056627:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805662d:	68 18 ae 8f 14       	push   $0x148fae18
 8056632:	68 f5 3a 06 08       	push   $0x8063af5
 8056637:	6a 50                	push   $0x50
 8056639:	68 00 89 0c 08       	push   $0x80c8900
 805663e:	e8 bd 24 ff ff       	call   8048b00 <snprintf@plt>
 8056643:	83 c4 10             	add    $0x10,%esp
 8056646:	83 f8 4f             	cmp    $0x4f,%eax
 8056649:	7f 0d                	jg     8056658 <jnp_i_b+0x58>
}

make_instr_helper(i)
 805664b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805664e:	8d 43 01             	lea    0x1(%ebx),%eax
 8056651:	5b                   	pop    %ebx
 8056652:	c3                   	ret    
 8056653:	90                   	nop
 8056654:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056658:	83 ec 0c             	sub    $0xc,%esp
 805665b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8056661:	e8 fa 22 ff ff       	call   8048960 <fflush@plt>
 8056666:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805666c:	6a 07                	push   $0x7
 805666e:	6a 01                	push   $0x1
 8056670:	68 92 ed 05 08       	push   $0x805ed92
 8056675:	e8 96 23 ff ff       	call   8048a10 <fwrite@plt>
 805667a:	83 c4 20             	add    $0x20,%esp
 805667d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056683:	6a 10                	push   $0x10
 8056685:	6a 01                	push   $0x1
 8056687:	68 84 f8 05 08       	push   $0x805f884
 805668c:	e8 7f 23 ff ff       	call   8048a10 <fwrite@plt>
 8056691:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056697:	6a 05                	push   $0x5
 8056699:	6a 01                	push   $0x1
 805669b:	68 b1 ed 05 08       	push   $0x805edb1
 80566a0:	e8 6b 23 ff ff       	call   8048a10 <fwrite@plt>
 80566a5:	83 c4 20             	add    $0x20,%esp
 80566a8:	68 18 ae 8f 14       	push   $0x148fae18
 80566ad:	68 f5 3a 06 08       	push   $0x8063af5
 80566b2:	6a 50                	push   $0x50
 80566b4:	68 00 89 0c 08       	push   $0x80c8900
 80566b9:	e8 42 24 ff ff       	call   8048b00 <snprintf@plt>
 80566be:	83 c4 10             	add    $0x10,%esp
 80566c1:	83 f8 4f             	cmp    $0x4f,%eax
 80566c4:	7e 85                	jle    805664b <jnp_i_b+0x4b>
 80566c6:	68 10 3c 06 08       	push   $0x8063c10
 80566cb:	6a 0e                	push   $0xe
 80566cd:	68 00 3b 06 08       	push   $0x8063b00
 80566d2:	68 b8 3b 06 08       	push   $0x8063bb8
 80566d7:	e8 d4 24 ff ff       	call   8048bb0 <__assert_fail@plt>
 80566dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080566e0 <jnp_i_v>:
#include "jnp-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jnp_i)
 80566e0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80566e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80566eb:	b8 10 65 05 08       	mov    $0x8056510,%eax
 80566f0:	75 05                	jne    80566f7 <jnp_i_v+0x17>
 80566f2:	b8 30 64 05 08       	mov    $0x8056430,%eax
 80566f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80566fb:	ff e0                	jmp    *%eax
 80566fd:	66 90                	xchg   %ax,%ax
 80566ff:	90                   	nop

08056700 <jl_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8056700:	53                   	push   %ebx
 8056701:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056704:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056708:	83 c0 01             	add    $0x1,%eax
 805670b:	50                   	push   %eax
 805670c:	e8 2f 69 00 00       	call   805d040 <decode_i_l>
#define instr jl

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF) {
 8056711:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 8056718:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 805671f:	83 c4 10             	add    $0x10,%esp
 8056722:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jl

static void do_execute() {
	int res = op_src->val;
 8056724:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF) {
 8056729:	c0 ea 03             	shr    $0x3,%dl
 805672c:	c0 e9 07             	shr    $0x7,%cl
 805672f:	83 e2 01             	and    $0x1,%edx
 8056732:	38 ca                	cmp    %cl,%dl
 8056734:	74 06                	je     805673c <jl_i_l+0x3c>
		cpu.eip = cpu.eip + res;
 8056736:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805673c:	68 18 ae 8f 14       	push   $0x148fae18
 8056741:	68 19 3c 06 08       	push   $0x8063c19
 8056746:	6a 50                	push   $0x50
 8056748:	68 00 89 0c 08       	push   $0x80c8900
 805674d:	e8 ae 23 ff ff       	call   8048b00 <snprintf@plt>
 8056752:	83 c4 10             	add    $0x10,%esp
 8056755:	83 f8 4f             	cmp    $0x4f,%eax
 8056758:	7f 0e                	jg     8056768 <jl_i_l+0x68>
}

make_instr_helper(i)
 805675a:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805675d:	8d 43 01             	lea    0x1(%ebx),%eax
 8056760:	5b                   	pop    %ebx
 8056761:	c3                   	ret    
 8056762:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056768:	83 ec 0c             	sub    $0xc,%esp
 805676b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8056771:	e8 ea 21 ff ff       	call   8048960 <fflush@plt>
 8056776:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805677c:	6a 07                	push   $0x7
 805677e:	6a 01                	push   $0x1
 8056780:	68 92 ed 05 08       	push   $0x805ed92
 8056785:	e8 86 22 ff ff       	call   8048a10 <fwrite@plt>
 805678a:	83 c4 20             	add    $0x20,%esp
 805678d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056793:	6a 10                	push   $0x10
 8056795:	6a 01                	push   $0x1
 8056797:	68 84 f8 05 08       	push   $0x805f884
 805679c:	e8 6f 22 ff ff       	call   8048a10 <fwrite@plt>
 80567a1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80567a7:	6a 05                	push   $0x5
 80567a9:	6a 01                	push   $0x1
 80567ab:	68 b1 ed 05 08       	push   $0x805edb1
 80567b0:	e8 5b 22 ff ff       	call   8048a10 <fwrite@plt>
 80567b5:	83 c4 20             	add    $0x20,%esp
 80567b8:	68 18 ae 8f 14       	push   $0x148fae18
 80567bd:	68 19 3c 06 08       	push   $0x8063c19
 80567c2:	6a 50                	push   $0x50
 80567c4:	68 00 89 0c 08       	push   $0x80c8900
 80567c9:	e8 32 23 ff ff       	call   8048b00 <snprintf@plt>
 80567ce:	83 c4 10             	add    $0x10,%esp
 80567d1:	83 f8 4f             	cmp    $0x4f,%eax
 80567d4:	7e 84                	jle    805675a <jl_i_l+0x5a>
 80567d6:	68 29 3d 06 08       	push   $0x8063d29
 80567db:	6a 0e                	push   $0xe
 80567dd:	68 30 3c 06 08       	push   $0x8063c30
 80567e2:	68 54 3c 06 08       	push   $0x8063c54
 80567e7:	e8 c4 23 ff ff       	call   8048bb0 <__assert_fail@plt>
 80567ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080567f0 <jl_i_w>:
}

make_instr_helper(i)
 80567f0:	53                   	push   %ebx
 80567f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80567f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80567f8:	83 c0 01             	add    $0x1,%eax
 80567fb:	50                   	push   %eax
 80567fc:	e8 af 64 00 00       	call   805ccb0 <decode_i_w>
#define instr jl

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF) {
 8056801:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 8056808:	89 c3                	mov    %eax,%ebx
 805680a:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 8056811:	83 c4 10             	add    $0x10,%esp
#include "cpu/exec/template-start.h"

#define instr jl

static void do_execute() {
	int res = op_src->val;
 8056814:	8b 0d 14 ae 8f 14    	mov    0x148fae14,%ecx
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF) {
 805681a:	c0 ea 03             	shr    $0x3,%dl
 805681d:	c0 e8 07             	shr    $0x7,%al
 8056820:	83 e2 01             	and    $0x1,%edx
 8056823:	38 c2                	cmp    %al,%dl
 8056825:	74 10                	je     8056837 <jl_i_w+0x47>
		cpu.eip = cpu.eip + res;
 8056827:	66 03 0d e0 ae 8f 14 	add    0x148faee0,%cx
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 805682e:	0f b7 c9             	movzwl %cx,%ecx
 8056831:	89 0d e0 ae 8f 14    	mov    %ecx,0x148faee0
#endif
	}
	print_asm_template1();
 8056837:	68 18 ae 8f 14       	push   $0x148fae18
 805683c:	68 20 3c 06 08       	push   $0x8063c20
 8056841:	6a 50                	push   $0x50
 8056843:	68 00 89 0c 08       	push   $0x80c8900
 8056848:	e8 b3 22 ff ff       	call   8048b00 <snprintf@plt>
 805684d:	83 c4 10             	add    $0x10,%esp
 8056850:	83 f8 4f             	cmp    $0x4f,%eax
 8056853:	7f 0b                	jg     8056860 <jl_i_w+0x70>
}

make_instr_helper(i)
 8056855:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056858:	8d 43 01             	lea    0x1(%ebx),%eax
 805685b:	5b                   	pop    %ebx
 805685c:	c3                   	ret    
 805685d:	8d 76 00             	lea    0x0(%esi),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056860:	83 ec 0c             	sub    $0xc,%esp
 8056863:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8056869:	e8 f2 20 ff ff       	call   8048960 <fflush@plt>
 805686e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056874:	6a 07                	push   $0x7
 8056876:	6a 01                	push   $0x1
 8056878:	68 92 ed 05 08       	push   $0x805ed92
 805687d:	e8 8e 21 ff ff       	call   8048a10 <fwrite@plt>
 8056882:	83 c4 20             	add    $0x20,%esp
 8056885:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805688b:	6a 10                	push   $0x10
 805688d:	6a 01                	push   $0x1
 805688f:	68 84 f8 05 08       	push   $0x805f884
 8056894:	e8 77 21 ff ff       	call   8048a10 <fwrite@plt>
 8056899:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805689f:	6a 05                	push   $0x5
 80568a1:	6a 01                	push   $0x1
 80568a3:	68 b1 ed 05 08       	push   $0x805edb1
 80568a8:	e8 63 21 ff ff       	call   8048a10 <fwrite@plt>
 80568ad:	83 c4 20             	add    $0x20,%esp
 80568b0:	68 18 ae 8f 14       	push   $0x148fae18
 80568b5:	68 20 3c 06 08       	push   $0x8063c20
 80568ba:	6a 50                	push   $0x50
 80568bc:	68 00 89 0c 08       	push   $0x80c8900
 80568c1:	e8 3a 22 ff ff       	call   8048b00 <snprintf@plt>
 80568c6:	83 c4 10             	add    $0x10,%esp
 80568c9:	83 f8 4f             	cmp    $0x4f,%eax
 80568cc:	7e 87                	jle    8056855 <jl_i_w+0x65>
 80568ce:	68 31 3d 06 08       	push   $0x8063d31
 80568d3:	6a 0e                	push   $0xe
 80568d5:	68 30 3c 06 08       	push   $0x8063c30
 80568da:	68 9c 3c 06 08       	push   $0x8063c9c
 80568df:	e8 cc 22 ff ff       	call   8048bb0 <__assert_fail@plt>
 80568e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80568ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080568f0 <jl_i_b>:
}

make_instr_helper(i)
 80568f0:	53                   	push   %ebx
 80568f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80568f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80568f8:	83 c0 01             	add    $0x1,%eax
 80568fb:	50                   	push   %eax
 80568fc:	e8 3f 60 00 00       	call   805c940 <decode_i_b>
#define instr jl

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF) {
 8056901:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 8056908:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 805690f:	83 c4 10             	add    $0x10,%esp
 8056912:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jl

static void do_execute() {
	int res = op_src->val;
 8056914:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF) {
 8056919:	c0 ea 03             	shr    $0x3,%dl
 805691c:	c0 e9 07             	shr    $0x7,%cl
 805691f:	83 e2 01             	and    $0x1,%edx
 8056922:	38 ca                	cmp    %cl,%dl
 8056924:	74 09                	je     805692f <jl_i_b+0x3f>

#define instr jl

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8056926:	0f be c0             	movsbl %al,%eax
	if(cpu.OF != cpu.SF) {
		cpu.eip = cpu.eip + res;
 8056929:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805692f:	68 18 ae 8f 14       	push   $0x148fae18
 8056934:	68 27 3c 06 08       	push   $0x8063c27
 8056939:	6a 50                	push   $0x50
 805693b:	68 00 89 0c 08       	push   $0x80c8900
 8056940:	e8 bb 21 ff ff       	call   8048b00 <snprintf@plt>
 8056945:	83 c4 10             	add    $0x10,%esp
 8056948:	83 f8 4f             	cmp    $0x4f,%eax
 805694b:	7f 0b                	jg     8056958 <jl_i_b+0x68>
}

make_instr_helper(i)
 805694d:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056950:	8d 43 01             	lea    0x1(%ebx),%eax
 8056953:	5b                   	pop    %ebx
 8056954:	c3                   	ret    
 8056955:	8d 76 00             	lea    0x0(%esi),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056958:	83 ec 0c             	sub    $0xc,%esp
 805695b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8056961:	e8 fa 1f ff ff       	call   8048960 <fflush@plt>
 8056966:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805696c:	6a 07                	push   $0x7
 805696e:	6a 01                	push   $0x1
 8056970:	68 92 ed 05 08       	push   $0x805ed92
 8056975:	e8 96 20 ff ff       	call   8048a10 <fwrite@plt>
 805697a:	83 c4 20             	add    $0x20,%esp
 805697d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056983:	6a 10                	push   $0x10
 8056985:	6a 01                	push   $0x1
 8056987:	68 84 f8 05 08       	push   $0x805f884
 805698c:	e8 7f 20 ff ff       	call   8048a10 <fwrite@plt>
 8056991:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056997:	6a 05                	push   $0x5
 8056999:	6a 01                	push   $0x1
 805699b:	68 b1 ed 05 08       	push   $0x805edb1
 80569a0:	e8 6b 20 ff ff       	call   8048a10 <fwrite@plt>
 80569a5:	83 c4 20             	add    $0x20,%esp
 80569a8:	68 18 ae 8f 14       	push   $0x148fae18
 80569ad:	68 27 3c 06 08       	push   $0x8063c27
 80569b2:	6a 50                	push   $0x50
 80569b4:	68 00 89 0c 08       	push   $0x80c8900
 80569b9:	e8 42 21 ff ff       	call   8048b00 <snprintf@plt>
 80569be:	83 c4 10             	add    $0x10,%esp
 80569c1:	83 f8 4f             	cmp    $0x4f,%eax
 80569c4:	7e 87                	jle    805694d <jl_i_b+0x5d>
 80569c6:	68 39 3d 06 08       	push   $0x8063d39
 80569cb:	6a 0e                	push   $0xe
 80569cd:	68 30 3c 06 08       	push   $0x8063c30
 80569d2:	68 e4 3c 06 08       	push   $0x8063ce4
 80569d7:	e8 d4 21 ff ff       	call   8048bb0 <__assert_fail@plt>
 80569dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080569e0 <jl_i_v>:
#include "jl-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jl_i)
 80569e0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80569e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80569eb:	b8 f0 67 05 08       	mov    $0x80567f0,%eax
 80569f0:	75 05                	jne    80569f7 <jl_i_v+0x17>
 80569f2:	b8 00 67 05 08       	mov    $0x8056700,%eax
 80569f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80569fb:	ff e0                	jmp    *%eax
 80569fd:	66 90                	xchg   %ax,%ax
 80569ff:	90                   	nop

08056a00 <ja_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8056a00:	53                   	push   %ebx
 8056a01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056a04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056a08:	83 c0 01             	add    $0x1,%eax
 8056a0b:	50                   	push   %eax
 8056a0c:	e8 2f 66 00 00       	call   805d040 <decode_i_l>
#define instr ja

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF && !cpu.ZF) {
 8056a11:	83 c4 10             	add    $0x10,%esp
 8056a14:	f6 05 e4 ae 8f 14 41 	testb  $0x41,0x148faee4
 8056a1b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr ja

static void do_execute() {
	int res = op_src->val;
 8056a1d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF && !cpu.ZF) {
 8056a22:	75 06                	jne    8056a2a <ja_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8056a24:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056a2a:	68 18 ae 8f 14       	push   $0x148fae18
 8056a2f:	68 41 3d 06 08       	push   $0x8063d41
 8056a34:	6a 50                	push   $0x50
 8056a36:	68 00 89 0c 08       	push   $0x80c8900
 8056a3b:	e8 c0 20 ff ff       	call   8048b00 <snprintf@plt>
 8056a40:	83 c4 10             	add    $0x10,%esp
 8056a43:	83 f8 4f             	cmp    $0x4f,%eax
 8056a46:	7f 08                	jg     8056a50 <ja_i_l+0x50>
}

make_instr_helper(i)
 8056a48:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056a4b:	8d 43 01             	lea    0x1(%ebx),%eax
 8056a4e:	5b                   	pop    %ebx
 8056a4f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056a50:	83 ec 0c             	sub    $0xc,%esp
 8056a53:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8056a59:	e8 02 1f ff ff       	call   8048960 <fflush@plt>
 8056a5e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056a64:	6a 07                	push   $0x7
 8056a66:	6a 01                	push   $0x1
 8056a68:	68 92 ed 05 08       	push   $0x805ed92
 8056a6d:	e8 9e 1f ff ff       	call   8048a10 <fwrite@plt>
 8056a72:	83 c4 20             	add    $0x20,%esp
 8056a75:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056a7b:	6a 10                	push   $0x10
 8056a7d:	6a 01                	push   $0x1
 8056a7f:	68 84 f8 05 08       	push   $0x805f884
 8056a84:	e8 87 1f ff ff       	call   8048a10 <fwrite@plt>
 8056a89:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056a8f:	6a 05                	push   $0x5
 8056a91:	6a 01                	push   $0x1
 8056a93:	68 b1 ed 05 08       	push   $0x805edb1
 8056a98:	e8 73 1f ff ff       	call   8048a10 <fwrite@plt>
 8056a9d:	83 c4 20             	add    $0x20,%esp
 8056aa0:	68 18 ae 8f 14       	push   $0x148fae18
 8056aa5:	68 41 3d 06 08       	push   $0x8063d41
 8056aaa:	6a 50                	push   $0x50
 8056aac:	68 00 89 0c 08       	push   $0x80c8900
 8056ab1:	e8 4a 20 ff ff       	call   8048b00 <snprintf@plt>
 8056ab6:	83 c4 10             	add    $0x10,%esp
 8056ab9:	83 f8 4f             	cmp    $0x4f,%eax
 8056abc:	7e 8a                	jle    8056a48 <ja_i_l+0x48>
 8056abe:	68 51 3e 06 08       	push   $0x8063e51
 8056ac3:	6a 0e                	push   $0xe
 8056ac5:	68 58 3d 06 08       	push   $0x8063d58
 8056aca:	68 7c 3d 06 08       	push   $0x8063d7c
 8056acf:	e8 dc 20 ff ff       	call   8048bb0 <__assert_fail@plt>
 8056ad4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8056ada:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08056ae0 <ja_i_w>:
}

make_instr_helper(i)
 8056ae0:	53                   	push   %ebx
 8056ae1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056ae4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056ae8:	83 c0 01             	add    $0x1,%eax
 8056aeb:	50                   	push   %eax
 8056aec:	e8 bf 61 00 00       	call   805ccb0 <decode_i_w>
#define instr ja

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF && !cpu.ZF) {
 8056af1:	83 c4 10             	add    $0x10,%esp
 8056af4:	f6 05 e4 ae 8f 14 41 	testb  $0x41,0x148faee4
 8056afb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr ja

static void do_execute() {
	int res = op_src->val;
 8056afd:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF && !cpu.ZF) {
 8056b02:	75 0f                	jne    8056b13 <ja_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8056b04:	66 03 05 e0 ae 8f 14 	add    0x148faee0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 8056b0b:	0f b7 c0             	movzwl %ax,%eax
 8056b0e:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
#endif
	}
	print_asm_template1();
 8056b13:	68 18 ae 8f 14       	push   $0x148fae18
 8056b18:	68 48 3d 06 08       	push   $0x8063d48
 8056b1d:	6a 50                	push   $0x50
 8056b1f:	68 00 89 0c 08       	push   $0x80c8900
 8056b24:	e8 d7 1f ff ff       	call   8048b00 <snprintf@plt>
 8056b29:	83 c4 10             	add    $0x10,%esp
 8056b2c:	83 f8 4f             	cmp    $0x4f,%eax
 8056b2f:	7f 0f                	jg     8056b40 <ja_i_w+0x60>
}

make_instr_helper(i)
 8056b31:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056b34:	8d 43 01             	lea    0x1(%ebx),%eax
 8056b37:	5b                   	pop    %ebx
 8056b38:	c3                   	ret    
 8056b39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056b40:	83 ec 0c             	sub    $0xc,%esp
 8056b43:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8056b49:	e8 12 1e ff ff       	call   8048960 <fflush@plt>
 8056b4e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056b54:	6a 07                	push   $0x7
 8056b56:	6a 01                	push   $0x1
 8056b58:	68 92 ed 05 08       	push   $0x805ed92
 8056b5d:	e8 ae 1e ff ff       	call   8048a10 <fwrite@plt>
 8056b62:	83 c4 20             	add    $0x20,%esp
 8056b65:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056b6b:	6a 10                	push   $0x10
 8056b6d:	6a 01                	push   $0x1
 8056b6f:	68 84 f8 05 08       	push   $0x805f884
 8056b74:	e8 97 1e ff ff       	call   8048a10 <fwrite@plt>
 8056b79:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056b7f:	6a 05                	push   $0x5
 8056b81:	6a 01                	push   $0x1
 8056b83:	68 b1 ed 05 08       	push   $0x805edb1
 8056b88:	e8 83 1e ff ff       	call   8048a10 <fwrite@plt>
 8056b8d:	83 c4 20             	add    $0x20,%esp
 8056b90:	68 18 ae 8f 14       	push   $0x148fae18
 8056b95:	68 48 3d 06 08       	push   $0x8063d48
 8056b9a:	6a 50                	push   $0x50
 8056b9c:	68 00 89 0c 08       	push   $0x80c8900
 8056ba1:	e8 5a 1f ff ff       	call   8048b00 <snprintf@plt>
 8056ba6:	83 c4 10             	add    $0x10,%esp
 8056ba9:	83 f8 4f             	cmp    $0x4f,%eax
 8056bac:	7e 83                	jle    8056b31 <ja_i_w+0x51>
 8056bae:	68 59 3e 06 08       	push   $0x8063e59
 8056bb3:	6a 0e                	push   $0xe
 8056bb5:	68 58 3d 06 08       	push   $0x8063d58
 8056bba:	68 c4 3d 06 08       	push   $0x8063dc4
 8056bbf:	e8 ec 1f ff ff       	call   8048bb0 <__assert_fail@plt>
 8056bc4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8056bca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08056bd0 <ja_i_b>:
}

make_instr_helper(i)
 8056bd0:	53                   	push   %ebx
 8056bd1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056bd4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056bd8:	83 c0 01             	add    $0x1,%eax
 8056bdb:	50                   	push   %eax
 8056bdc:	e8 5f 5d 00 00       	call   805c940 <decode_i_b>
#define instr ja

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF && !cpu.ZF) {
 8056be1:	83 c4 10             	add    $0x10,%esp
 8056be4:	f6 05 e4 ae 8f 14 41 	testb  $0x41,0x148faee4
 8056beb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr ja

static void do_execute() {
	int res = op_src->val;
 8056bed:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF && !cpu.ZF) {
 8056bf2:	75 09                	jne    8056bfd <ja_i_b+0x2d>

#define instr ja

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8056bf4:	0f be c0             	movsbl %al,%eax
	if(!cpu.CF && !cpu.ZF) {
		cpu.eip = cpu.eip + res;
 8056bf7:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056bfd:	68 18 ae 8f 14       	push   $0x148fae18
 8056c02:	68 4f 3d 06 08       	push   $0x8063d4f
 8056c07:	6a 50                	push   $0x50
 8056c09:	68 00 89 0c 08       	push   $0x80c8900
 8056c0e:	e8 ed 1e ff ff       	call   8048b00 <snprintf@plt>
 8056c13:	83 c4 10             	add    $0x10,%esp
 8056c16:	83 f8 4f             	cmp    $0x4f,%eax
 8056c19:	7f 0d                	jg     8056c28 <ja_i_b+0x58>
}

make_instr_helper(i)
 8056c1b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056c1e:	8d 43 01             	lea    0x1(%ebx),%eax
 8056c21:	5b                   	pop    %ebx
 8056c22:	c3                   	ret    
 8056c23:	90                   	nop
 8056c24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056c28:	83 ec 0c             	sub    $0xc,%esp
 8056c2b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8056c31:	e8 2a 1d ff ff       	call   8048960 <fflush@plt>
 8056c36:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056c3c:	6a 07                	push   $0x7
 8056c3e:	6a 01                	push   $0x1
 8056c40:	68 92 ed 05 08       	push   $0x805ed92
 8056c45:	e8 c6 1d ff ff       	call   8048a10 <fwrite@plt>
 8056c4a:	83 c4 20             	add    $0x20,%esp
 8056c4d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056c53:	6a 10                	push   $0x10
 8056c55:	6a 01                	push   $0x1
 8056c57:	68 84 f8 05 08       	push   $0x805f884
 8056c5c:	e8 af 1d ff ff       	call   8048a10 <fwrite@plt>
 8056c61:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056c67:	6a 05                	push   $0x5
 8056c69:	6a 01                	push   $0x1
 8056c6b:	68 b1 ed 05 08       	push   $0x805edb1
 8056c70:	e8 9b 1d ff ff       	call   8048a10 <fwrite@plt>
 8056c75:	83 c4 20             	add    $0x20,%esp
 8056c78:	68 18 ae 8f 14       	push   $0x148fae18
 8056c7d:	68 4f 3d 06 08       	push   $0x8063d4f
 8056c82:	6a 50                	push   $0x50
 8056c84:	68 00 89 0c 08       	push   $0x80c8900
 8056c89:	e8 72 1e ff ff       	call   8048b00 <snprintf@plt>
 8056c8e:	83 c4 10             	add    $0x10,%esp
 8056c91:	83 f8 4f             	cmp    $0x4f,%eax
 8056c94:	7e 85                	jle    8056c1b <ja_i_b+0x4b>
 8056c96:	68 61 3e 06 08       	push   $0x8063e61
 8056c9b:	6a 0e                	push   $0xe
 8056c9d:	68 58 3d 06 08       	push   $0x8063d58
 8056ca2:	68 0c 3e 06 08       	push   $0x8063e0c
 8056ca7:	e8 04 1f ff ff       	call   8048bb0 <__assert_fail@plt>
 8056cac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08056cb0 <ja_i_v>:
#include "ja-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(ja_i)
 8056cb0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8056cb7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8056cbb:	b8 e0 6a 05 08       	mov    $0x8056ae0,%eax
 8056cc0:	75 05                	jne    8056cc7 <ja_i_v+0x17>
 8056cc2:	b8 00 6a 05 08       	mov    $0x8056a00,%eax
 8056cc7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8056ccb:	ff e0                	jmp    *%eax
 8056ccd:	66 90                	xchg   %ax,%ax
 8056ccf:	90                   	nop

08056cd0 <jle_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8056cd0:	56                   	push   %esi
 8056cd1:	53                   	push   %ebx
 8056cd2:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056cd5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056cd9:	83 c0 01             	add    $0x1,%eax
 8056cdc:	50                   	push   %eax
 8056cdd:	e8 5e 63 00 00       	call   805d040 <decode_i_l>
#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF || cpu.ZF) {
 8056ce2:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 8056ce9:	89 c3                	mov    %eax,%ebx
 8056ceb:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 8056cf2:	83 c4 10             	add    $0x10,%esp
#include "cpu/exec/template-start.h"

#define instr jle

static void do_execute() {
	int res = op_src->val;
 8056cf5:	8b 35 14 ae 8f 14    	mov    0x148fae14,%esi
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF || cpu.ZF) {
 8056cfb:	c0 ea 03             	shr    $0x3,%dl
 8056cfe:	89 c1                	mov    %eax,%ecx
 8056d00:	83 e2 01             	and    $0x1,%edx
 8056d03:	c0 e9 07             	shr    $0x7,%cl
 8056d06:	38 ca                	cmp    %cl,%dl
 8056d08:	0f 84 ba 00 00 00    	je     8056dc8 <jle_i_l+0xf8>
		cpu.eip = cpu.eip + res;
 8056d0e:	01 35 e0 ae 8f 14    	add    %esi,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056d14:	68 18 ae 8f 14       	push   $0x148fae18
 8056d19:	68 69 3e 06 08       	push   $0x8063e69
 8056d1e:	6a 50                	push   $0x50
 8056d20:	68 00 89 0c 08       	push   $0x80c8900
 8056d25:	e8 d6 1d ff ff       	call   8048b00 <snprintf@plt>
 8056d2a:	83 c4 10             	add    $0x10,%esp
 8056d2d:	83 f8 4f             	cmp    $0x4f,%eax
 8056d30:	7f 0e                	jg     8056d40 <jle_i_l+0x70>
}

make_instr_helper(i)
 8056d32:	83 c4 04             	add    $0x4,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056d35:	8d 43 01             	lea    0x1(%ebx),%eax
 8056d38:	5b                   	pop    %ebx
 8056d39:	5e                   	pop    %esi
 8056d3a:	c3                   	ret    
 8056d3b:	90                   	nop
 8056d3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056d40:	83 ec 0c             	sub    $0xc,%esp
 8056d43:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8056d49:	e8 12 1c ff ff       	call   8048960 <fflush@plt>
 8056d4e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056d54:	6a 07                	push   $0x7
 8056d56:	6a 01                	push   $0x1
 8056d58:	68 92 ed 05 08       	push   $0x805ed92
 8056d5d:	e8 ae 1c ff ff       	call   8048a10 <fwrite@plt>
 8056d62:	83 c4 20             	add    $0x20,%esp
 8056d65:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056d6b:	6a 10                	push   $0x10
 8056d6d:	6a 01                	push   $0x1
 8056d6f:	68 84 f8 05 08       	push   $0x805f884
 8056d74:	e8 97 1c ff ff       	call   8048a10 <fwrite@plt>
 8056d79:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056d7f:	6a 05                	push   $0x5
 8056d81:	6a 01                	push   $0x1
 8056d83:	68 b1 ed 05 08       	push   $0x805edb1
 8056d88:	e8 83 1c ff ff       	call   8048a10 <fwrite@plt>
 8056d8d:	83 c4 20             	add    $0x20,%esp
 8056d90:	68 18 ae 8f 14       	push   $0x148fae18
 8056d95:	68 69 3e 06 08       	push   $0x8063e69
 8056d9a:	6a 50                	push   $0x50
 8056d9c:	68 00 89 0c 08       	push   $0x80c8900
 8056da1:	e8 5a 1d ff ff       	call   8048b00 <snprintf@plt>
 8056da6:	83 c4 10             	add    $0x10,%esp
 8056da9:	83 f8 4f             	cmp    $0x4f,%eax
 8056dac:	7e 84                	jle    8056d32 <jle_i_l+0x62>
 8056dae:	68 82 3f 06 08       	push   $0x8063f82
 8056db3:	6a 0e                	push   $0xe
 8056db5:	68 84 3e 06 08       	push   $0x8063e84
 8056dba:	68 ac 3e 06 08       	push   $0x8063eac
 8056dbf:	e8 ec 1d ff ff       	call   8048bb0 <__assert_fail@plt>
 8056dc4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF || cpu.ZF) {
 8056dc8:	a8 40                	test   $0x40,%al
 8056dca:	0f 84 44 ff ff ff    	je     8056d14 <jle_i_l+0x44>
 8056dd0:	e9 39 ff ff ff       	jmp    8056d0e <jle_i_l+0x3e>
 8056dd5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8056dd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08056de0 <jle_i_w>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8056de0:	57                   	push   %edi
 8056de1:	56                   	push   %esi
 8056de2:	53                   	push   %ebx
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056de3:	83 ec 0c             	sub    $0xc,%esp
 8056de6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056dea:	83 c0 01             	add    $0x1,%eax
 8056ded:	50                   	push   %eax
 8056dee:	e8 bd 5e 00 00       	call   805ccb0 <decode_i_w>
#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF || cpu.ZF) {
 8056df3:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 8056dfa:	89 c3                	mov    %eax,%ebx
 8056dfc:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 8056e03:	83 c4 10             	add    $0x10,%esp

#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8056e06:	0f bf 3d 14 ae 8f 14 	movswl 0x148fae14,%edi
	if(cpu.OF != cpu.SF || cpu.ZF) {
 8056e0d:	c0 ea 03             	shr    $0x3,%dl
 8056e10:	89 c1                	mov    %eax,%ecx
 8056e12:	83 e2 01             	and    $0x1,%edx
 8056e15:	c0 e9 07             	shr    $0x7,%cl
 8056e18:	38 ca                	cmp    %cl,%dl
 8056e1a:	0f 84 c8 00 00 00    	je     8056ee8 <jle_i_w+0x108>
		cpu.eip = cpu.eip + res;
 8056e20:	03 3d e0 ae 8f 14    	add    0x148faee0,%edi
 8056e26:	89 f9                	mov    %edi,%ecx
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 8056e28:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
 8056e2e:	89 0d e0 ae 8f 14    	mov    %ecx,0x148faee0
#endif
	}
	print_asm_template1();
 8056e34:	68 18 ae 8f 14       	push   $0x148fae18
 8056e39:	68 71 3e 06 08       	push   $0x8063e71
 8056e3e:	6a 50                	push   $0x50
 8056e40:	68 00 89 0c 08       	push   $0x80c8900
 8056e45:	e8 b6 1c ff ff       	call   8048b00 <snprintf@plt>
 8056e4a:	83 c4 10             	add    $0x10,%esp
 8056e4d:	83 f8 4f             	cmp    $0x4f,%eax
 8056e50:	7f 0e                	jg     8056e60 <jle_i_w+0x80>
	execute();
	return len + 1;	// "1" for opcode
 8056e52:	8d 43 01             	lea    0x1(%ebx),%eax
}

make_instr_helper(i)
 8056e55:	5b                   	pop    %ebx
 8056e56:	5e                   	pop    %esi
 8056e57:	5f                   	pop    %edi
 8056e58:	c3                   	ret    
 8056e59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056e60:	83 ec 0c             	sub    $0xc,%esp
 8056e63:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8056e69:	e8 f2 1a ff ff       	call   8048960 <fflush@plt>
 8056e6e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056e74:	6a 07                	push   $0x7
 8056e76:	6a 01                	push   $0x1
 8056e78:	68 92 ed 05 08       	push   $0x805ed92
 8056e7d:	e8 8e 1b ff ff       	call   8048a10 <fwrite@plt>
 8056e82:	83 c4 20             	add    $0x20,%esp
 8056e85:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056e8b:	6a 10                	push   $0x10
 8056e8d:	6a 01                	push   $0x1
 8056e8f:	68 84 f8 05 08       	push   $0x805f884
 8056e94:	e8 77 1b ff ff       	call   8048a10 <fwrite@plt>
 8056e99:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056e9f:	6a 05                	push   $0x5
 8056ea1:	6a 01                	push   $0x1
 8056ea3:	68 b1 ed 05 08       	push   $0x805edb1
 8056ea8:	e8 63 1b ff ff       	call   8048a10 <fwrite@plt>
 8056ead:	83 c4 20             	add    $0x20,%esp
 8056eb0:	68 18 ae 8f 14       	push   $0x148fae18
 8056eb5:	68 71 3e 06 08       	push   $0x8063e71
 8056eba:	6a 50                	push   $0x50
 8056ebc:	68 00 89 0c 08       	push   $0x80c8900
 8056ec1:	e8 3a 1c ff ff       	call   8048b00 <snprintf@plt>
 8056ec6:	83 c4 10             	add    $0x10,%esp
 8056ec9:	83 f8 4f             	cmp    $0x4f,%eax
 8056ecc:	7e 84                	jle    8056e52 <jle_i_w+0x72>
 8056ece:	68 8b 3f 06 08       	push   $0x8063f8b
 8056ed3:	6a 0e                	push   $0xe
 8056ed5:	68 84 3e 06 08       	push   $0x8063e84
 8056eda:	68 f4 3e 06 08       	push   $0x8063ef4
 8056edf:	e8 cc 1c ff ff       	call   8048bb0 <__assert_fail@plt>
 8056ee4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF || cpu.ZF) {
 8056ee8:	a8 40                	test   $0x40,%al
 8056eea:	0f 84 44 ff ff ff    	je     8056e34 <jle_i_w+0x54>
 8056ef0:	e9 2b ff ff ff       	jmp    8056e20 <jle_i_w+0x40>
 8056ef5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8056ef9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08056f00 <jle_i_b>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8056f00:	56                   	push   %esi
 8056f01:	53                   	push   %ebx
 8056f02:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056f05:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056f09:	83 c0 01             	add    $0x1,%eax
 8056f0c:	50                   	push   %eax
 8056f0d:	e8 2e 5a 00 00       	call   805c940 <decode_i_b>
#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF || cpu.ZF) {
 8056f12:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 8056f19:	89 c3                	mov    %eax,%ebx
 8056f1b:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 8056f22:	83 c4 10             	add    $0x10,%esp

#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8056f25:	0f be 35 14 ae 8f 14 	movsbl 0x148fae14,%esi
	if(cpu.OF != cpu.SF || cpu.ZF) {
 8056f2c:	c0 ea 03             	shr    $0x3,%dl
 8056f2f:	89 c1                	mov    %eax,%ecx
 8056f31:	83 e2 01             	and    $0x1,%edx
 8056f34:	c0 e9 07             	shr    $0x7,%cl
 8056f37:	38 ca                	cmp    %cl,%dl
 8056f39:	0f 84 b9 00 00 00    	je     8056ff8 <jle_i_b+0xf8>
		cpu.eip = cpu.eip + res;
 8056f3f:	01 35 e0 ae 8f 14    	add    %esi,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056f45:	68 18 ae 8f 14       	push   $0x148fae18
 8056f4a:	68 79 3e 06 08       	push   $0x8063e79
 8056f4f:	6a 50                	push   $0x50
 8056f51:	68 00 89 0c 08       	push   $0x80c8900
 8056f56:	e8 a5 1b ff ff       	call   8048b00 <snprintf@plt>
 8056f5b:	83 c4 10             	add    $0x10,%esp
 8056f5e:	83 f8 4f             	cmp    $0x4f,%eax
 8056f61:	7f 0d                	jg     8056f70 <jle_i_b+0x70>
}

make_instr_helper(i)
 8056f63:	83 c4 04             	add    $0x4,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056f66:	8d 43 01             	lea    0x1(%ebx),%eax
 8056f69:	5b                   	pop    %ebx
 8056f6a:	5e                   	pop    %esi
 8056f6b:	c3                   	ret    
 8056f6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056f70:	83 ec 0c             	sub    $0xc,%esp
 8056f73:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8056f79:	e8 e2 19 ff ff       	call   8048960 <fflush@plt>
 8056f7e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056f84:	6a 07                	push   $0x7
 8056f86:	6a 01                	push   $0x1
 8056f88:	68 92 ed 05 08       	push   $0x805ed92
 8056f8d:	e8 7e 1a ff ff       	call   8048a10 <fwrite@plt>
 8056f92:	83 c4 20             	add    $0x20,%esp
 8056f95:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056f9b:	6a 10                	push   $0x10
 8056f9d:	6a 01                	push   $0x1
 8056f9f:	68 84 f8 05 08       	push   $0x805f884
 8056fa4:	e8 67 1a ff ff       	call   8048a10 <fwrite@plt>
 8056fa9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8056faf:	6a 05                	push   $0x5
 8056fb1:	6a 01                	push   $0x1
 8056fb3:	68 b1 ed 05 08       	push   $0x805edb1
 8056fb8:	e8 53 1a ff ff       	call   8048a10 <fwrite@plt>
 8056fbd:	83 c4 20             	add    $0x20,%esp
 8056fc0:	68 18 ae 8f 14       	push   $0x148fae18
 8056fc5:	68 79 3e 06 08       	push   $0x8063e79
 8056fca:	6a 50                	push   $0x50
 8056fcc:	68 00 89 0c 08       	push   $0x80c8900
 8056fd1:	e8 2a 1b ff ff       	call   8048b00 <snprintf@plt>
 8056fd6:	83 c4 10             	add    $0x10,%esp
 8056fd9:	83 f8 4f             	cmp    $0x4f,%eax
 8056fdc:	7e 85                	jle    8056f63 <jle_i_b+0x63>
 8056fde:	68 94 3f 06 08       	push   $0x8063f94
 8056fe3:	6a 0e                	push   $0xe
 8056fe5:	68 84 3e 06 08       	push   $0x8063e84
 8056fea:	68 3c 3f 06 08       	push   $0x8063f3c
 8056fef:	e8 bc 1b ff ff       	call   8048bb0 <__assert_fail@plt>
 8056ff4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF || cpu.ZF) {
 8056ff8:	a8 40                	test   $0x40,%al
 8056ffa:	0f 84 45 ff ff ff    	je     8056f45 <jle_i_b+0x45>
 8057000:	e9 3a ff ff ff       	jmp    8056f3f <jle_i_b+0x3f>
 8057005:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8057009:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08057010 <jle_i_v>:
#include "jle-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jle_i)
 8057010:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8057017:	8b 54 24 04          	mov    0x4(%esp),%edx
 805701b:	b8 e0 6d 05 08       	mov    $0x8056de0,%eax
 8057020:	75 05                	jne    8057027 <jle_i_v+0x17>
 8057022:	b8 d0 6c 05 08       	mov    $0x8056cd0,%eax
 8057027:	89 54 24 04          	mov    %edx,0x4(%esp)
 805702b:	ff e0                	jmp    *%eax
 805702d:	66 90                	xchg   %ax,%ax
 805702f:	90                   	nop

08057030 <jno_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8057030:	53                   	push   %ebx
 8057031:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057034:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057038:	83 c0 01             	add    $0x1,%eax
 805703b:	50                   	push   %eax
 805703c:	e8 ff 5f 00 00       	call   805d040 <decode_i_l>
#define instr jno

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.OF) {
 8057041:	83 c4 10             	add    $0x10,%esp
 8057044:	f6 05 e5 ae 8f 14 08 	testb  $0x8,0x148faee5
 805704b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jno

static void do_execute() {
	int res = op_src->val;
 805704d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.OF) {
 8057052:	75 06                	jne    805705a <jno_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8057054:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805705a:	68 18 ae 8f 14       	push   $0x148fae18
 805705f:	68 9d 3f 06 08       	push   $0x8063f9d
 8057064:	6a 50                	push   $0x50
 8057066:	68 00 89 0c 08       	push   $0x80c8900
 805706b:	e8 90 1a ff ff       	call   8048b00 <snprintf@plt>
 8057070:	83 c4 10             	add    $0x10,%esp
 8057073:	83 f8 4f             	cmp    $0x4f,%eax
 8057076:	7f 08                	jg     8057080 <jno_i_l+0x50>
}

make_instr_helper(i)
 8057078:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805707b:	8d 43 01             	lea    0x1(%ebx),%eax
 805707e:	5b                   	pop    %ebx
 805707f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8057080:	83 ec 0c             	sub    $0xc,%esp
 8057083:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8057089:	e8 d2 18 ff ff       	call   8048960 <fflush@plt>
 805708e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057094:	6a 07                	push   $0x7
 8057096:	6a 01                	push   $0x1
 8057098:	68 92 ed 05 08       	push   $0x805ed92
 805709d:	e8 6e 19 ff ff       	call   8048a10 <fwrite@plt>
 80570a2:	83 c4 20             	add    $0x20,%esp
 80570a5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80570ab:	6a 10                	push   $0x10
 80570ad:	6a 01                	push   $0x1
 80570af:	68 84 f8 05 08       	push   $0x805f884
 80570b4:	e8 57 19 ff ff       	call   8048a10 <fwrite@plt>
 80570b9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80570bf:	6a 05                	push   $0x5
 80570c1:	6a 01                	push   $0x1
 80570c3:	68 b1 ed 05 08       	push   $0x805edb1
 80570c8:	e8 43 19 ff ff       	call   8048a10 <fwrite@plt>
 80570cd:	83 c4 20             	add    $0x20,%esp
 80570d0:	68 18 ae 8f 14       	push   $0x148fae18
 80570d5:	68 9d 3f 06 08       	push   $0x8063f9d
 80570da:	6a 50                	push   $0x50
 80570dc:	68 00 89 0c 08       	push   $0x80c8900
 80570e1:	e8 1a 1a ff ff       	call   8048b00 <snprintf@plt>
 80570e6:	83 c4 10             	add    $0x10,%esp
 80570e9:	83 f8 4f             	cmp    $0x4f,%eax
 80570ec:	7e 8a                	jle    8057078 <jno_i_l+0x48>
 80570ee:	68 b6 40 06 08       	push   $0x80640b6
 80570f3:	6a 0e                	push   $0xe
 80570f5:	68 b8 3f 06 08       	push   $0x8063fb8
 80570fa:	68 e0 3f 06 08       	push   $0x8063fe0
 80570ff:	e8 ac 1a ff ff       	call   8048bb0 <__assert_fail@plt>
 8057104:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805710a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08057110 <jno_i_w>:
}

make_instr_helper(i)
 8057110:	53                   	push   %ebx
 8057111:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057114:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057118:	83 c0 01             	add    $0x1,%eax
 805711b:	50                   	push   %eax
 805711c:	e8 8f 5b 00 00       	call   805ccb0 <decode_i_w>
#define instr jno

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.OF) {
 8057121:	83 c4 10             	add    $0x10,%esp
 8057124:	f6 05 e5 ae 8f 14 08 	testb  $0x8,0x148faee5
 805712b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jno

static void do_execute() {
	int res = op_src->val;
 805712d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.OF) {
 8057132:	75 0f                	jne    8057143 <jno_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8057134:	66 03 05 e0 ae 8f 14 	add    0x148faee0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 805713b:	0f b7 c0             	movzwl %ax,%eax
 805713e:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
#endif
	}
	print_asm_template1();
 8057143:	68 18 ae 8f 14       	push   $0x148fae18
 8057148:	68 a5 3f 06 08       	push   $0x8063fa5
 805714d:	6a 50                	push   $0x50
 805714f:	68 00 89 0c 08       	push   $0x80c8900
 8057154:	e8 a7 19 ff ff       	call   8048b00 <snprintf@plt>
 8057159:	83 c4 10             	add    $0x10,%esp
 805715c:	83 f8 4f             	cmp    $0x4f,%eax
 805715f:	7f 0f                	jg     8057170 <jno_i_w+0x60>
}

make_instr_helper(i)
 8057161:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8057164:	8d 43 01             	lea    0x1(%ebx),%eax
 8057167:	5b                   	pop    %ebx
 8057168:	c3                   	ret    
 8057169:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8057170:	83 ec 0c             	sub    $0xc,%esp
 8057173:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8057179:	e8 e2 17 ff ff       	call   8048960 <fflush@plt>
 805717e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057184:	6a 07                	push   $0x7
 8057186:	6a 01                	push   $0x1
 8057188:	68 92 ed 05 08       	push   $0x805ed92
 805718d:	e8 7e 18 ff ff       	call   8048a10 <fwrite@plt>
 8057192:	83 c4 20             	add    $0x20,%esp
 8057195:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805719b:	6a 10                	push   $0x10
 805719d:	6a 01                	push   $0x1
 805719f:	68 84 f8 05 08       	push   $0x805f884
 80571a4:	e8 67 18 ff ff       	call   8048a10 <fwrite@plt>
 80571a9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80571af:	6a 05                	push   $0x5
 80571b1:	6a 01                	push   $0x1
 80571b3:	68 b1 ed 05 08       	push   $0x805edb1
 80571b8:	e8 53 18 ff ff       	call   8048a10 <fwrite@plt>
 80571bd:	83 c4 20             	add    $0x20,%esp
 80571c0:	68 18 ae 8f 14       	push   $0x148fae18
 80571c5:	68 a5 3f 06 08       	push   $0x8063fa5
 80571ca:	6a 50                	push   $0x50
 80571cc:	68 00 89 0c 08       	push   $0x80c8900
 80571d1:	e8 2a 19 ff ff       	call   8048b00 <snprintf@plt>
 80571d6:	83 c4 10             	add    $0x10,%esp
 80571d9:	83 f8 4f             	cmp    $0x4f,%eax
 80571dc:	7e 83                	jle    8057161 <jno_i_w+0x51>
 80571de:	68 bf 40 06 08       	push   $0x80640bf
 80571e3:	6a 0e                	push   $0xe
 80571e5:	68 b8 3f 06 08       	push   $0x8063fb8
 80571ea:	68 28 40 06 08       	push   $0x8064028
 80571ef:	e8 bc 19 ff ff       	call   8048bb0 <__assert_fail@plt>
 80571f4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80571fa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08057200 <jno_i_b>:
}

make_instr_helper(i)
 8057200:	53                   	push   %ebx
 8057201:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057204:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057208:	83 c0 01             	add    $0x1,%eax
 805720b:	50                   	push   %eax
 805720c:	e8 2f 57 00 00       	call   805c940 <decode_i_b>
#define instr jno

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.OF) {
 8057211:	83 c4 10             	add    $0x10,%esp
 8057214:	f6 05 e5 ae 8f 14 08 	testb  $0x8,0x148faee5
 805721b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jno

static void do_execute() {
	int res = op_src->val;
 805721d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.OF) {
 8057222:	75 09                	jne    805722d <jno_i_b+0x2d>

#define instr jno

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8057224:	0f be c0             	movsbl %al,%eax
	if(!cpu.OF) {
		cpu.eip = cpu.eip + res;
 8057227:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805722d:	68 18 ae 8f 14       	push   $0x148fae18
 8057232:	68 ad 3f 06 08       	push   $0x8063fad
 8057237:	6a 50                	push   $0x50
 8057239:	68 00 89 0c 08       	push   $0x80c8900
 805723e:	e8 bd 18 ff ff       	call   8048b00 <snprintf@plt>
 8057243:	83 c4 10             	add    $0x10,%esp
 8057246:	83 f8 4f             	cmp    $0x4f,%eax
 8057249:	7f 0d                	jg     8057258 <jno_i_b+0x58>
}

make_instr_helper(i)
 805724b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805724e:	8d 43 01             	lea    0x1(%ebx),%eax
 8057251:	5b                   	pop    %ebx
 8057252:	c3                   	ret    
 8057253:	90                   	nop
 8057254:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8057258:	83 ec 0c             	sub    $0xc,%esp
 805725b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8057261:	e8 fa 16 ff ff       	call   8048960 <fflush@plt>
 8057266:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805726c:	6a 07                	push   $0x7
 805726e:	6a 01                	push   $0x1
 8057270:	68 92 ed 05 08       	push   $0x805ed92
 8057275:	e8 96 17 ff ff       	call   8048a10 <fwrite@plt>
 805727a:	83 c4 20             	add    $0x20,%esp
 805727d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057283:	6a 10                	push   $0x10
 8057285:	6a 01                	push   $0x1
 8057287:	68 84 f8 05 08       	push   $0x805f884
 805728c:	e8 7f 17 ff ff       	call   8048a10 <fwrite@plt>
 8057291:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057297:	6a 05                	push   $0x5
 8057299:	6a 01                	push   $0x1
 805729b:	68 b1 ed 05 08       	push   $0x805edb1
 80572a0:	e8 6b 17 ff ff       	call   8048a10 <fwrite@plt>
 80572a5:	83 c4 20             	add    $0x20,%esp
 80572a8:	68 18 ae 8f 14       	push   $0x148fae18
 80572ad:	68 ad 3f 06 08       	push   $0x8063fad
 80572b2:	6a 50                	push   $0x50
 80572b4:	68 00 89 0c 08       	push   $0x80c8900
 80572b9:	e8 42 18 ff ff       	call   8048b00 <snprintf@plt>
 80572be:	83 c4 10             	add    $0x10,%esp
 80572c1:	83 f8 4f             	cmp    $0x4f,%eax
 80572c4:	7e 85                	jle    805724b <jno_i_b+0x4b>
 80572c6:	68 c8 40 06 08       	push   $0x80640c8
 80572cb:	6a 0e                	push   $0xe
 80572cd:	68 b8 3f 06 08       	push   $0x8063fb8
 80572d2:	68 70 40 06 08       	push   $0x8064070
 80572d7:	e8 d4 18 ff ff       	call   8048bb0 <__assert_fail@plt>
 80572dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080572e0 <jno_i_v>:
#include "jno-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jno_i)
 80572e0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80572e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80572eb:	b8 10 71 05 08       	mov    $0x8057110,%eax
 80572f0:	75 05                	jne    80572f7 <jno_i_v+0x17>
 80572f2:	b8 30 70 05 08       	mov    $0x8057030,%eax
 80572f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80572fb:	ff e0                	jmp    *%eax
 80572fd:	66 90                	xchg   %ax,%ax
 80572ff:	90                   	nop

08057300 <jp_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8057300:	53                   	push   %ebx
 8057301:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057304:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057308:	83 c0 01             	add    $0x1,%eax
 805730b:	50                   	push   %eax
 805730c:	e8 2f 5d 00 00       	call   805d040 <decode_i_l>
#define instr jp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.PF) {
 8057311:	83 c4 10             	add    $0x10,%esp
 8057314:	f6 05 e4 ae 8f 14 04 	testb  $0x4,0x148faee4
 805731b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jp

static void do_execute() {
	int res = op_src->val;
 805731d:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.PF) {
 8057322:	74 06                	je     805732a <jp_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8057324:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805732a:	68 18 ae 8f 14       	push   $0x148fae18
 805732f:	68 d1 40 06 08       	push   $0x80640d1
 8057334:	6a 50                	push   $0x50
 8057336:	68 00 89 0c 08       	push   $0x80c8900
 805733b:	e8 c0 17 ff ff       	call   8048b00 <snprintf@plt>
 8057340:	83 c4 10             	add    $0x10,%esp
 8057343:	83 f8 4f             	cmp    $0x4f,%eax
 8057346:	7f 08                	jg     8057350 <jp_i_l+0x50>
}

make_instr_helper(i)
 8057348:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805734b:	8d 43 01             	lea    0x1(%ebx),%eax
 805734e:	5b                   	pop    %ebx
 805734f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8057350:	83 ec 0c             	sub    $0xc,%esp
 8057353:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8057359:	e8 02 16 ff ff       	call   8048960 <fflush@plt>
 805735e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057364:	6a 07                	push   $0x7
 8057366:	6a 01                	push   $0x1
 8057368:	68 92 ed 05 08       	push   $0x805ed92
 805736d:	e8 9e 16 ff ff       	call   8048a10 <fwrite@plt>
 8057372:	83 c4 20             	add    $0x20,%esp
 8057375:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805737b:	6a 10                	push   $0x10
 805737d:	6a 01                	push   $0x1
 805737f:	68 84 f8 05 08       	push   $0x805f884
 8057384:	e8 87 16 ff ff       	call   8048a10 <fwrite@plt>
 8057389:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805738f:	6a 05                	push   $0x5
 8057391:	6a 01                	push   $0x1
 8057393:	68 b1 ed 05 08       	push   $0x805edb1
 8057398:	e8 73 16 ff ff       	call   8048a10 <fwrite@plt>
 805739d:	83 c4 20             	add    $0x20,%esp
 80573a0:	68 18 ae 8f 14       	push   $0x148fae18
 80573a5:	68 d1 40 06 08       	push   $0x80640d1
 80573aa:	6a 50                	push   $0x50
 80573ac:	68 00 89 0c 08       	push   $0x80c8900
 80573b1:	e8 4a 17 ff ff       	call   8048b00 <snprintf@plt>
 80573b6:	83 c4 10             	add    $0x10,%esp
 80573b9:	83 f8 4f             	cmp    $0x4f,%eax
 80573bc:	7e 8a                	jle    8057348 <jp_i_l+0x48>
 80573be:	68 e1 41 06 08       	push   $0x80641e1
 80573c3:	6a 0e                	push   $0xe
 80573c5:	68 e8 40 06 08       	push   $0x80640e8
 80573ca:	68 0c 41 06 08       	push   $0x806410c
 80573cf:	e8 dc 17 ff ff       	call   8048bb0 <__assert_fail@plt>
 80573d4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80573da:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080573e0 <jp_i_w>:
}

make_instr_helper(i)
 80573e0:	53                   	push   %ebx
 80573e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80573e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80573e8:	83 c0 01             	add    $0x1,%eax
 80573eb:	50                   	push   %eax
 80573ec:	e8 bf 58 00 00       	call   805ccb0 <decode_i_w>
#define instr jp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.PF) {
 80573f1:	83 c4 10             	add    $0x10,%esp
 80573f4:	f6 05 e4 ae 8f 14 04 	testb  $0x4,0x148faee4
 80573fb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jp

static void do_execute() {
	int res = op_src->val;
 80573fd:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.PF) {
 8057402:	74 0f                	je     8057413 <jp_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8057404:	66 03 05 e0 ae 8f 14 	add    0x148faee0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 805740b:	0f b7 c0             	movzwl %ax,%eax
 805740e:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0
#endif
	}
	print_asm_template1();
 8057413:	68 18 ae 8f 14       	push   $0x148fae18
 8057418:	68 d8 40 06 08       	push   $0x80640d8
 805741d:	6a 50                	push   $0x50
 805741f:	68 00 89 0c 08       	push   $0x80c8900
 8057424:	e8 d7 16 ff ff       	call   8048b00 <snprintf@plt>
 8057429:	83 c4 10             	add    $0x10,%esp
 805742c:	83 f8 4f             	cmp    $0x4f,%eax
 805742f:	7f 0f                	jg     8057440 <jp_i_w+0x60>
}

make_instr_helper(i)
 8057431:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8057434:	8d 43 01             	lea    0x1(%ebx),%eax
 8057437:	5b                   	pop    %ebx
 8057438:	c3                   	ret    
 8057439:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8057440:	83 ec 0c             	sub    $0xc,%esp
 8057443:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8057449:	e8 12 15 ff ff       	call   8048960 <fflush@plt>
 805744e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057454:	6a 07                	push   $0x7
 8057456:	6a 01                	push   $0x1
 8057458:	68 92 ed 05 08       	push   $0x805ed92
 805745d:	e8 ae 15 ff ff       	call   8048a10 <fwrite@plt>
 8057462:	83 c4 20             	add    $0x20,%esp
 8057465:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805746b:	6a 10                	push   $0x10
 805746d:	6a 01                	push   $0x1
 805746f:	68 84 f8 05 08       	push   $0x805f884
 8057474:	e8 97 15 ff ff       	call   8048a10 <fwrite@plt>
 8057479:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805747f:	6a 05                	push   $0x5
 8057481:	6a 01                	push   $0x1
 8057483:	68 b1 ed 05 08       	push   $0x805edb1
 8057488:	e8 83 15 ff ff       	call   8048a10 <fwrite@plt>
 805748d:	83 c4 20             	add    $0x20,%esp
 8057490:	68 18 ae 8f 14       	push   $0x148fae18
 8057495:	68 d8 40 06 08       	push   $0x80640d8
 805749a:	6a 50                	push   $0x50
 805749c:	68 00 89 0c 08       	push   $0x80c8900
 80574a1:	e8 5a 16 ff ff       	call   8048b00 <snprintf@plt>
 80574a6:	83 c4 10             	add    $0x10,%esp
 80574a9:	83 f8 4f             	cmp    $0x4f,%eax
 80574ac:	7e 83                	jle    8057431 <jp_i_w+0x51>
 80574ae:	68 e9 41 06 08       	push   $0x80641e9
 80574b3:	6a 0e                	push   $0xe
 80574b5:	68 e8 40 06 08       	push   $0x80640e8
 80574ba:	68 54 41 06 08       	push   $0x8064154
 80574bf:	e8 ec 16 ff ff       	call   8048bb0 <__assert_fail@plt>
 80574c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80574ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080574d0 <jp_i_b>:
}

make_instr_helper(i)
 80574d0:	53                   	push   %ebx
 80574d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80574d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80574d8:	83 c0 01             	add    $0x1,%eax
 80574db:	50                   	push   %eax
 80574dc:	e8 5f 54 00 00       	call   805c940 <decode_i_b>
#define instr jp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.PF) {
 80574e1:	83 c4 10             	add    $0x10,%esp
 80574e4:	f6 05 e4 ae 8f 14 04 	testb  $0x4,0x148faee4
 80574eb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jp

static void do_execute() {
	int res = op_src->val;
 80574ed:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.PF) {
 80574f2:	74 09                	je     80574fd <jp_i_b+0x2d>

#define instr jp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 80574f4:	0f be c0             	movsbl %al,%eax
	if(cpu.PF) {
		cpu.eip = cpu.eip + res;
 80574f7:	01 05 e0 ae 8f 14    	add    %eax,0x148faee0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80574fd:	68 18 ae 8f 14       	push   $0x148fae18
 8057502:	68 df 40 06 08       	push   $0x80640df
 8057507:	6a 50                	push   $0x50
 8057509:	68 00 89 0c 08       	push   $0x80c8900
 805750e:	e8 ed 15 ff ff       	call   8048b00 <snprintf@plt>
 8057513:	83 c4 10             	add    $0x10,%esp
 8057516:	83 f8 4f             	cmp    $0x4f,%eax
 8057519:	7f 0d                	jg     8057528 <jp_i_b+0x58>
}

make_instr_helper(i)
 805751b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805751e:	8d 43 01             	lea    0x1(%ebx),%eax
 8057521:	5b                   	pop    %ebx
 8057522:	c3                   	ret    
 8057523:	90                   	nop
 8057524:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8057528:	83 ec 0c             	sub    $0xc,%esp
 805752b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8057531:	e8 2a 14 ff ff       	call   8048960 <fflush@plt>
 8057536:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805753c:	6a 07                	push   $0x7
 805753e:	6a 01                	push   $0x1
 8057540:	68 92 ed 05 08       	push   $0x805ed92
 8057545:	e8 c6 14 ff ff       	call   8048a10 <fwrite@plt>
 805754a:	83 c4 20             	add    $0x20,%esp
 805754d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057553:	6a 10                	push   $0x10
 8057555:	6a 01                	push   $0x1
 8057557:	68 84 f8 05 08       	push   $0x805f884
 805755c:	e8 af 14 ff ff       	call   8048a10 <fwrite@plt>
 8057561:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057567:	6a 05                	push   $0x5
 8057569:	6a 01                	push   $0x1
 805756b:	68 b1 ed 05 08       	push   $0x805edb1
 8057570:	e8 9b 14 ff ff       	call   8048a10 <fwrite@plt>
 8057575:	83 c4 20             	add    $0x20,%esp
 8057578:	68 18 ae 8f 14       	push   $0x148fae18
 805757d:	68 df 40 06 08       	push   $0x80640df
 8057582:	6a 50                	push   $0x50
 8057584:	68 00 89 0c 08       	push   $0x80c8900
 8057589:	e8 72 15 ff ff       	call   8048b00 <snprintf@plt>
 805758e:	83 c4 10             	add    $0x10,%esp
 8057591:	83 f8 4f             	cmp    $0x4f,%eax
 8057594:	7e 85                	jle    805751b <jp_i_b+0x4b>
 8057596:	68 f1 41 06 08       	push   $0x80641f1
 805759b:	6a 0e                	push   $0xe
 805759d:	68 e8 40 06 08       	push   $0x80640e8
 80575a2:	68 9c 41 06 08       	push   $0x806419c
 80575a7:	e8 04 16 ff ff       	call   8048bb0 <__assert_fail@plt>
 80575ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080575b0 <jp_i_v>:
#include "jp-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jp_i)
 80575b0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80575b7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80575bb:	b8 e0 73 05 08       	mov    $0x80573e0,%eax
 80575c0:	75 05                	jne    80575c7 <jp_i_v+0x17>
 80575c2:	b8 00 73 05 08       	mov    $0x8057300,%eax
 80575c7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80575cb:	ff e0                	jmp    *%eax
 80575cd:	66 90                	xchg   %ax,%ax
 80575cf:	90                   	nop

080575d0 <do_adc_b>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
 80575d0:	55                   	push   %ebp
 80575d1:	57                   	push   %edi
 80575d2:	56                   	push   %esi
 80575d3:	53                   	push   %ebx
 80575d4:	83 ec 0c             	sub    $0xc,%esp
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 80575d7:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 80575de:	8b 15 14 ae 8f 14    	mov    0x148fae14,%edx
 80575e4:	8b 35 4c ae 8f 14    	mov    0x148fae4c,%esi
 80575ea:	89 c1                	mov    %eax,%ecx
 80575ec:	8d 1c 16             	lea    (%esi,%edx,1),%ebx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80575ef:	89 f7                	mov    %esi,%edi
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 80575f1:	83 e1 01             	and    $0x1,%ecx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80575f4:	c1 ef 07             	shr    $0x7,%edi
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 80575f7:	00 cb                	add    %cl,%bl
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80575f9:	89 d1                	mov    %edx,%ecx
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 80575fb:	0f 88 4f 01 00 00    	js     8057750 <do_adc_b+0x180>
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
	}
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
 8057601:	c1 e9 07             	shr    $0x7,%ecx
 8057604:	83 e0 fe             	and    $0xfffffffe,%eax
 8057607:	09 f9                	or     %edi,%ecx
 8057609:	83 e1 01             	and    $0x1,%ecx
 805760c:	09 c8                	or     %ecx,%eax
 805760e:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
 8057613:	0f be fb             	movsbl %bl,%edi
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
 8057616:	31 c0                	xor    %eax,%eax
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 8057618:	31 c9                	xor    %ecx,%ecx
 805761a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
 8057620:	89 fd                	mov    %edi,%ebp
 8057622:	d3 fd                	sar    %cl,%ebp
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 8057624:	83 c1 01             	add    $0x1,%ecx
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
 8057627:	83 e5 01             	and    $0x1,%ebp
 805762a:	31 e8                	xor    %ebp,%eax
 805762c:	83 e0 01             	and    $0x1,%eax
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 805762f:	83 f9 08             	cmp    $0x8,%ecx
 8057632:	75 ec                	jne    8057620 <do_adc_b+0x50>
 8057634:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 805763b:	c1 e0 02             	shl    $0x2,%eax
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 805763e:	89 df                	mov    %ebx,%edi
 8057640:	83 e1 fb             	and    $0xfffffffb,%ecx
 8057643:	09 c8                	or     %ecx,%eax
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 8057645:	84 db                	test   %bl,%bl
 8057647:	0f 94 c1             	sete   %cl
 805764a:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 805764d:	83 e7 80             	and    $0xffffff80,%edi
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 8057650:	c1 e1 06             	shl    $0x6,%ecx
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057653:	31 da                	xor    %ebx,%edx
	OPERAND_W(op_dest, res);
 8057655:	83 ec 08             	sub    $0x8,%esp
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8057658:	09 c8                	or     %ecx,%eax
 805765a:	09 f8                	or     %edi,%eax
 805765c:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057661:	89 f0                	mov    %esi,%eax
 8057663:	31 d8                	xor    %ebx,%eax
	OPERAND_W(op_dest, res);
 8057665:	0f b6 db             	movzbl %bl,%ebx
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057668:	21 d0                	and    %edx,%eax
 805766a:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
	OPERAND_W(op_dest, res);
 8057671:	53                   	push   %ebx
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057672:	83 e0 01             	and    $0x1,%eax
	OPERAND_W(op_dest, res);
 8057675:	68 40 ae 8f 14       	push   $0x148fae40
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 805767a:	c1 e0 03             	shl    $0x3,%eax
 805767d:	83 e2 f7             	and    $0xfffffff7,%edx
 8057680:	09 d0                	or     %edx,%eax
 8057682:	a2 e5 ae 8f 14       	mov    %al,0x148faee5
	OPERAND_W(op_dest, res);
 8057687:	e8 b4 55 00 00       	call   805cc40 <write_operand_b>
	print_asm_template2();
 805768c:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8057693:	68 18 ae 8f 14       	push   $0x148fae18
 8057698:	68 f9 41 06 08       	push   $0x80641f9
 805769d:	6a 50                	push   $0x50
 805769f:	68 00 89 0c 08       	push   $0x80c8900
 80576a4:	e8 57 14 ff ff       	call   8048b00 <snprintf@plt>
 80576a9:	83 c4 20             	add    $0x20,%esp
 80576ac:	83 f8 4f             	cmp    $0x4f,%eax
 80576af:	7f 0f                	jg     80576c0 <do_adc_b+0xf0>
}
 80576b1:	83 c4 0c             	add    $0xc,%esp
 80576b4:	5b                   	pop    %ebx
 80576b5:	5e                   	pop    %esi
 80576b6:	5f                   	pop    %edi
 80576b7:	5d                   	pop    %ebp
 80576b8:	c3                   	ret    
 80576b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 80576c0:	83 ec 0c             	sub    $0xc,%esp
 80576c3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80576c9:	e8 92 12 ff ff       	call   8048960 <fflush@plt>
 80576ce:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80576d4:	6a 07                	push   $0x7
 80576d6:	6a 01                	push   $0x1
 80576d8:	68 92 ed 05 08       	push   $0x805ed92
 80576dd:	e8 2e 13 ff ff       	call   8048a10 <fwrite@plt>
 80576e2:	83 c4 20             	add    $0x20,%esp
 80576e5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80576eb:	6a 10                	push   $0x10
 80576ed:	6a 01                	push   $0x1
 80576ef:	68 84 f8 05 08       	push   $0x805f884
 80576f4:	e8 17 13 ff ff       	call   8048a10 <fwrite@plt>
 80576f9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80576ff:	6a 05                	push   $0x5
 8057701:	6a 01                	push   $0x1
 8057703:	68 b1 ed 05 08       	push   $0x805edb1
 8057708:	e8 03 13 ff ff       	call   8048a10 <fwrite@plt>
 805770d:	83 c4 14             	add    $0x14,%esp
 8057710:	68 50 ae 8f 14       	push   $0x148fae50
 8057715:	68 18 ae 8f 14       	push   $0x148fae18
 805771a:	68 f9 41 06 08       	push   $0x80641f9
 805771f:	6a 50                	push   $0x50
 8057721:	68 00 89 0c 08       	push   $0x80c8900
 8057726:	e8 d5 13 ff ff       	call   8048b00 <snprintf@plt>
 805772b:	83 c4 20             	add    $0x20,%esp
 805772e:	83 f8 4f             	cmp    $0x4f,%eax
 8057731:	0f 8e 7a ff ff ff    	jle    80576b1 <do_adc_b+0xe1>
 8057737:	68 81 43 06 08       	push   $0x8064381
 805773c:	6a 1d                	push   $0x1d
 805773e:	68 1c 42 06 08       	push   $0x806421c
 8057743:	68 44 42 06 08       	push   $0x8064244
 8057748:	e8 63 14 ff ff       	call   8048bb0 <__assert_fail@plt>
 805774d:	8d 76 00             	lea    0x0(%esi),%esi
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8057750:	c1 e9 07             	shr    $0x7,%ecx
 8057753:	83 e0 fe             	and    $0xfffffffe,%eax
 8057756:	21 f9                	and    %edi,%ecx
 8057758:	83 e1 01             	and    $0x1,%ecx
 805775b:	09 c8                	or     %ecx,%eax
 805775d:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
 8057762:	e9 ac fe ff ff       	jmp    8057613 <do_adc_b+0x43>
 8057767:	89 f6                	mov    %esi,%esi
 8057769:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08057770 <do_adc_w>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
 8057770:	55                   	push   %ebp
 8057771:	57                   	push   %edi
 8057772:	56                   	push   %esi
 8057773:	53                   	push   %ebx
 8057774:	83 ec 0c             	sub    $0xc,%esp
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 8057777:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
 805777e:	8b 15 14 ae 8f 14    	mov    0x148fae14,%edx
 8057784:	8b 35 4c ae 8f 14    	mov    0x148fae4c,%esi
 805778a:	89 c1                	mov    %eax,%ecx
 805778c:	8d 1c 16             	lea    (%esi,%edx,1),%ebx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 805778f:	89 f7                	mov    %esi,%edi
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 8057791:	83 e1 01             	and    $0x1,%ecx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8057794:	c1 ef 0f             	shr    $0xf,%edi
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 8057797:	66 01 cb             	add    %cx,%bx
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 805779a:	89 d1                	mov    %edx,%ecx
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 805779c:	0f 88 4e 01 00 00    	js     80578f0 <do_adc_w+0x180>
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
	}
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
 80577a2:	c1 e9 0f             	shr    $0xf,%ecx
 80577a5:	83 e0 fe             	and    $0xfffffffe,%eax
 80577a8:	09 f9                	or     %edi,%ecx
 80577aa:	83 e1 01             	and    $0x1,%ecx
 80577ad:	09 c8                	or     %ecx,%eax
 80577af:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
 80577b4:	0f bf fb             	movswl %bx,%edi
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
 80577b7:	31 c0                	xor    %eax,%eax
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 80577b9:	31 c9                	xor    %ecx,%ecx
 80577bb:	90                   	nop
 80577bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
 80577c0:	89 fd                	mov    %edi,%ebp
 80577c2:	d3 fd                	sar    %cl,%ebp
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 80577c4:	83 c1 01             	add    $0x1,%ecx
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
 80577c7:	83 e5 01             	and    $0x1,%ebp
 80577ca:	31 e8                	xor    %ebp,%eax
 80577cc:	83 e0 01             	and    $0x1,%eax
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 80577cf:	83 f9 10             	cmp    $0x10,%ecx
 80577d2:	75 ec                	jne    80577c0 <do_adc_w+0x50>
 80577d4:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 80577db:	c1 e0 02             	shl    $0x2,%eax
 80577de:	83 e1 fb             	and    $0xfffffffb,%ecx
 80577e1:	09 c8                	or     %ecx,%eax
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 80577e3:	66 85 db             	test   %bx,%bx
 80577e6:	0f 94 c1             	sete   %cl
 80577e9:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80577ec:	31 da                	xor    %ebx,%edx
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 80577ee:	89 cf                	mov    %ecx,%edi
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80577f0:	89 d9                	mov    %ebx,%ecx
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 80577f2:	83 ec 08             	sub    $0x8,%esp
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 80577f5:	c1 e7 06             	shl    $0x6,%edi
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80577f8:	66 c1 f9 0f          	sar    $0xf,%cx
 80577fc:	c1 e1 07             	shl    $0x7,%ecx
 80577ff:	09 f8                	or     %edi,%eax
 8057801:	09 c8                	or     %ecx,%eax
 8057803:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057808:	89 f0                	mov    %esi,%eax
 805780a:	31 d8                	xor    %ebx,%eax
	OPERAND_W(op_dest, res);
 805780c:	0f b7 db             	movzwl %bx,%ebx
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 805780f:	21 d0                	and    %edx,%eax
 8057811:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
	OPERAND_W(op_dest, res);
 8057818:	53                   	push   %ebx
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057819:	83 e0 01             	and    $0x1,%eax
	OPERAND_W(op_dest, res);
 805781c:	68 40 ae 8f 14       	push   $0x148fae40
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057821:	c1 e0 03             	shl    $0x3,%eax
 8057824:	83 e2 f7             	and    $0xfffffff7,%edx
 8057827:	09 d0                	or     %edx,%eax
 8057829:	a2 e5 ae 8f 14       	mov    %al,0x148faee5
	OPERAND_W(op_dest, res);
 805782e:	e8 9d 57 00 00       	call   805cfd0 <write_operand_w>
	print_asm_template2();
 8057833:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 805783a:	68 18 ae 8f 14       	push   $0x148fae18
 805783f:	68 04 42 06 08       	push   $0x8064204
 8057844:	6a 50                	push   $0x50
 8057846:	68 00 89 0c 08       	push   $0x80c8900
 805784b:	e8 b0 12 ff ff       	call   8048b00 <snprintf@plt>
 8057850:	83 c4 20             	add    $0x20,%esp
 8057853:	83 f8 4f             	cmp    $0x4f,%eax
 8057856:	7f 08                	jg     8057860 <do_adc_w+0xf0>
}
 8057858:	83 c4 0c             	add    $0xc,%esp
 805785b:	5b                   	pop    %ebx
 805785c:	5e                   	pop    %esi
 805785d:	5f                   	pop    %edi
 805785e:	5d                   	pop    %ebp
 805785f:	c3                   	ret    
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8057860:	83 ec 0c             	sub    $0xc,%esp
 8057863:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8057869:	e8 f2 10 ff ff       	call   8048960 <fflush@plt>
 805786e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057874:	6a 07                	push   $0x7
 8057876:	6a 01                	push   $0x1
 8057878:	68 92 ed 05 08       	push   $0x805ed92
 805787d:	e8 8e 11 ff ff       	call   8048a10 <fwrite@plt>
 8057882:	83 c4 20             	add    $0x20,%esp
 8057885:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805788b:	6a 10                	push   $0x10
 805788d:	6a 01                	push   $0x1
 805788f:	68 84 f8 05 08       	push   $0x805f884
 8057894:	e8 77 11 ff ff       	call   8048a10 <fwrite@plt>
 8057899:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805789f:	6a 05                	push   $0x5
 80578a1:	6a 01                	push   $0x1
 80578a3:	68 b1 ed 05 08       	push   $0x805edb1
 80578a8:	e8 63 11 ff ff       	call   8048a10 <fwrite@plt>
 80578ad:	83 c4 14             	add    $0x14,%esp
 80578b0:	68 50 ae 8f 14       	push   $0x148fae50
 80578b5:	68 18 ae 8f 14       	push   $0x148fae18
 80578ba:	68 04 42 06 08       	push   $0x8064204
 80578bf:	6a 50                	push   $0x50
 80578c1:	68 00 89 0c 08       	push   $0x80c8900
 80578c6:	e8 35 12 ff ff       	call   8048b00 <snprintf@plt>
 80578cb:	83 c4 20             	add    $0x20,%esp
 80578ce:	83 f8 4f             	cmp    $0x4f,%eax
 80578d1:	7e 85                	jle    8057858 <do_adc_w+0xe8>
 80578d3:	68 78 43 06 08       	push   $0x8064378
 80578d8:	6a 1d                	push   $0x1d
 80578da:	68 1c 42 06 08       	push   $0x806421c
 80578df:	68 a8 42 06 08       	push   $0x80642a8
 80578e4:	e8 c7 12 ff ff       	call   8048bb0 <__assert_fail@plt>
 80578e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80578f0:	c1 e9 0f             	shr    $0xf,%ecx
 80578f3:	83 e0 fe             	and    $0xfffffffe,%eax
 80578f6:	21 f9                	and    %edi,%ecx
 80578f8:	83 e1 01             	and    $0x1,%ecx
 80578fb:	09 c8                	or     %ecx,%eax
 80578fd:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
 8057902:	e9 ad fe ff ff       	jmp    80577b4 <do_adc_w+0x44>
 8057907:	89 f6                	mov    %esi,%esi
 8057909:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08057910 <adc_i2a_w>:
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(i2a)
 8057910:	53                   	push   %ebx
 8057911:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057914:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057918:	83 c0 01             	add    $0x1,%eax
 805791b:	50                   	push   %eax
 805791c:	e8 6f 54 00 00       	call   805cd90 <decode_i2a_w>
 8057921:	89 c3                	mov    %eax,%ebx
	execute();
 8057923:	e8 48 fe ff ff       	call   8057770 <do_adc_w>
 8057928:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805792b:	8d 43 01             	lea    0x1(%ebx),%eax
 805792e:	5b                   	pop    %ebx
 805792f:	c3                   	ret    

08057930 <adc_i2rm_w>:
make_instr_helper(i2rm)
 8057930:	53                   	push   %ebx
 8057931:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057934:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057938:	83 c0 01             	add    $0x1,%eax
 805793b:	50                   	push   %eax
 805793c:	e8 cf 54 00 00       	call   805ce10 <decode_i2rm_w>
 8057941:	89 c3                	mov    %eax,%ebx
	execute();
 8057943:	e8 28 fe ff ff       	call   8057770 <do_adc_w>
 8057948:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805794b:	8d 43 01             	lea    0x1(%ebx),%eax
 805794e:	5b                   	pop    %ebx
 805794f:	c3                   	ret    

08057950 <adc_r2rm_w>:
make_instr_helper(r2rm)
 8057950:	53                   	push   %ebx
 8057951:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057954:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057958:	83 c0 01             	add    $0x1,%eax
 805795b:	50                   	push   %eax
 805795c:	e8 ef 53 00 00       	call   805cd50 <decode_r2rm_w>
 8057961:	89 c3                	mov    %eax,%ebx
	execute();
 8057963:	e8 08 fe ff ff       	call   8057770 <do_adc_w>
 8057968:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805796b:	8d 43 01             	lea    0x1(%ebx),%eax
 805796e:	5b                   	pop    %ebx
 805796f:	c3                   	ret    

08057970 <adc_rm2r_w>:
make_instr_helper(rm2r)
 8057970:	53                   	push   %ebx
 8057971:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057974:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057978:	83 c0 01             	add    $0x1,%eax
 805797b:	50                   	push   %eax
 805797c:	e8 ef 53 00 00       	call   805cd70 <decode_rm2r_w>
 8057981:	89 c3                	mov    %eax,%ebx
	execute();
 8057983:	e8 e8 fd ff ff       	call   8057770 <do_adc_w>
 8057988:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805798b:	8d 43 01             	lea    0x1(%ebx),%eax
 805798e:	5b                   	pop    %ebx
 805798f:	c3                   	ret    

08057990 <adc_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8057990:	53                   	push   %ebx
 8057991:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057994:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057998:	83 c0 01             	add    $0x1,%eax
 805799b:	50                   	push   %eax
 805799c:	e8 ef 54 00 00       	call   805ce90 <decode_si2rm_w>
 80579a1:	89 c3                	mov    %eax,%ebx
	execute();
 80579a3:	e8 c8 fd ff ff       	call   8057770 <do_adc_w>
 80579a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80579ab:	8d 43 01             	lea    0x1(%ebx),%eax
 80579ae:	5b                   	pop    %ebx
 80579af:	c3                   	ret    

080579b0 <do_adc_l>:
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 80579b0:	0f b6 05 e4 ae 8f 14 	movzbl 0x148faee4,%eax
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
 80579b7:	57                   	push   %edi
 80579b8:	56                   	push   %esi
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 80579b9:	8b 35 4c ae 8f 14    	mov    0x148fae4c,%esi
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
 80579bf:	53                   	push   %ebx
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 80579c0:	8b 1d 14 ae 8f 14    	mov    0x148fae14,%ebx
 80579c6:	89 c2                	mov    %eax,%edx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80579c8:	89 f7                	mov    %esi,%edi
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 80579ca:	8d 0c 1e             	lea    (%esi,%ebx,1),%ecx
 80579cd:	83 e2 01             	and    $0x1,%edx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80579d0:	c1 ef 1f             	shr    $0x1f,%edi
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 80579d3:	01 ca                	add    %ecx,%edx
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80579d5:	89 d9                	mov    %ebx,%ecx
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 80579d7:	0f 88 43 01 00 00    	js     8057b20 <do_adc_l+0x170>
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
	}
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
 80579dd:	c1 e9 1f             	shr    $0x1f,%ecx
 80579e0:	83 e0 fe             	and    $0xfffffffe,%eax
 80579e3:	09 f9                	or     %edi,%ecx
 80579e5:	09 c8                	or     %ecx,%eax
 80579e7:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
 80579ec:	31 c0                	xor    %eax,%eax
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 80579ee:	31 c9                	xor    %ecx,%ecx
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
 80579f0:	89 d7                	mov    %edx,%edi
 80579f2:	d3 ff                	sar    %cl,%edi
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 80579f4:	83 c1 01             	add    $0x1,%ecx
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
 80579f7:	83 e7 01             	and    $0x1,%edi
 80579fa:	31 f8                	xor    %edi,%eax
 80579fc:	83 e0 01             	and    $0x1,%eax
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 80579ff:	83 f9 20             	cmp    $0x20,%ecx
 8057a02:	75 ec                	jne    80579f0 <do_adc_l+0x40>
 8057a04:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 8057a0b:	c1 e0 02             	shl    $0x2,%eax
 8057a0e:	83 e1 fb             	and    $0xfffffffb,%ecx
 8057a11:	09 c8                	or     %ecx,%eax
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 8057a13:	85 d2                	test   %edx,%edx
 8057a15:	0f 94 c1             	sete   %cl
 8057a18:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057a1b:	31 d3                	xor    %edx,%ebx
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 8057a1d:	c1 e1 06             	shl    $0x6,%ecx
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 8057a20:	83 ec 08             	sub    $0x8,%esp
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 8057a23:	89 cf                	mov    %ecx,%edi
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8057a25:	89 d1                	mov    %edx,%ecx
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 8057a27:	52                   	push   %edx
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8057a28:	c1 e9 1f             	shr    $0x1f,%ecx
 8057a2b:	09 f8                	or     %edi,%eax
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 8057a2d:	68 40 ae 8f 14       	push   $0x148fae40
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8057a32:	c1 e1 07             	shl    $0x7,%ecx
 8057a35:	09 c8                	or     %ecx,%eax
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057a37:	0f b6 0d e5 ae 8f 14 	movzbl 0x148faee5,%ecx
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8057a3e:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057a43:	89 f0                	mov    %esi,%eax
 8057a45:	31 d0                	xor    %edx,%eax
 8057a47:	21 d8                	and    %ebx,%eax
 8057a49:	83 e0 01             	and    $0x1,%eax
 8057a4c:	83 e1 f7             	and    $0xfffffff7,%ecx
 8057a4f:	c1 e0 03             	shl    $0x3,%eax
 8057a52:	09 c8                	or     %ecx,%eax
 8057a54:	a2 e5 ae 8f 14       	mov    %al,0x148faee5
	OPERAND_W(op_dest, res);
 8057a59:	e8 42 59 00 00       	call   805d3a0 <write_operand_l>
	print_asm_template2();
 8057a5e:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8057a65:	68 18 ae 8f 14       	push   $0x148fae18
 8057a6a:	68 0f 42 06 08       	push   $0x806420f
 8057a6f:	6a 50                	push   $0x50
 8057a71:	68 00 89 0c 08       	push   $0x80c8900
 8057a76:	e8 85 10 ff ff       	call   8048b00 <snprintf@plt>
 8057a7b:	83 c4 20             	add    $0x20,%esp
 8057a7e:	83 f8 4f             	cmp    $0x4f,%eax
 8057a81:	7f 0d                	jg     8057a90 <do_adc_l+0xe0>
}
 8057a83:	5b                   	pop    %ebx
 8057a84:	5e                   	pop    %esi
 8057a85:	5f                   	pop    %edi
 8057a86:	c3                   	ret    
 8057a87:	89 f6                	mov    %esi,%esi
 8057a89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8057a90:	83 ec 0c             	sub    $0xc,%esp
 8057a93:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8057a99:	e8 c2 0e ff ff       	call   8048960 <fflush@plt>
 8057a9e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057aa4:	6a 07                	push   $0x7
 8057aa6:	6a 01                	push   $0x1
 8057aa8:	68 92 ed 05 08       	push   $0x805ed92
 8057aad:	e8 5e 0f ff ff       	call   8048a10 <fwrite@plt>
 8057ab2:	83 c4 20             	add    $0x20,%esp
 8057ab5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057abb:	6a 10                	push   $0x10
 8057abd:	6a 01                	push   $0x1
 8057abf:	68 84 f8 05 08       	push   $0x805f884
 8057ac4:	e8 47 0f ff ff       	call   8048a10 <fwrite@plt>
 8057ac9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057acf:	6a 05                	push   $0x5
 8057ad1:	6a 01                	push   $0x1
 8057ad3:	68 b1 ed 05 08       	push   $0x805edb1
 8057ad8:	e8 33 0f ff ff       	call   8048a10 <fwrite@plt>
 8057add:	83 c4 14             	add    $0x14,%esp
 8057ae0:	68 50 ae 8f 14       	push   $0x148fae50
 8057ae5:	68 18 ae 8f 14       	push   $0x148fae18
 8057aea:	68 0f 42 06 08       	push   $0x806420f
 8057aef:	6a 50                	push   $0x50
 8057af1:	68 00 89 0c 08       	push   $0x80c8900
 8057af6:	e8 05 10 ff ff       	call   8048b00 <snprintf@plt>
 8057afb:	83 c4 20             	add    $0x20,%esp
 8057afe:	83 f8 4f             	cmp    $0x4f,%eax
 8057b01:	7e 80                	jle    8057a83 <do_adc_l+0xd3>
 8057b03:	68 6f 43 06 08       	push   $0x806436f
 8057b08:	6a 1d                	push   $0x1d
 8057b0a:	68 1c 42 06 08       	push   $0x806421c
 8057b0f:	68 0c 43 06 08       	push   $0x806430c
 8057b14:	e8 97 10 ff ff       	call   8048bb0 <__assert_fail@plt>
 8057b19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8057b20:	c1 e9 1f             	shr    $0x1f,%ecx
 8057b23:	83 e0 fe             	and    $0xfffffffe,%eax
 8057b26:	21 f9                	and    %edi,%ecx
 8057b28:	09 c8                	or     %ecx,%eax
 8057b2a:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
 8057b2f:	e9 b8 fe ff ff       	jmp    80579ec <do_adc_l+0x3c>
 8057b34:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8057b3a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08057b40 <adc_i2a_l>:
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(i2a)
 8057b40:	53                   	push   %ebx
 8057b41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057b44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057b48:	83 c0 01             	add    $0x1,%eax
 8057b4b:	50                   	push   %eax
 8057b4c:	e8 0f 56 00 00       	call   805d160 <decode_i2a_l>
 8057b51:	89 c3                	mov    %eax,%ebx
	execute();
 8057b53:	e8 58 fe ff ff       	call   80579b0 <do_adc_l>
 8057b58:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057b5b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057b5e:	5b                   	pop    %ebx
 8057b5f:	c3                   	ret    

08057b60 <adc_i2rm_l>:
make_instr_helper(i2rm)
 8057b60:	53                   	push   %ebx
 8057b61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057b64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057b68:	83 c0 01             	add    $0x1,%eax
 8057b6b:	50                   	push   %eax
 8057b6c:	e8 6f 56 00 00       	call   805d1e0 <decode_i2rm_l>
 8057b71:	89 c3                	mov    %eax,%ebx
	execute();
 8057b73:	e8 38 fe ff ff       	call   80579b0 <do_adc_l>
 8057b78:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057b7b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057b7e:	5b                   	pop    %ebx
 8057b7f:	c3                   	ret    

08057b80 <adc_r2rm_l>:
make_instr_helper(r2rm)
 8057b80:	53                   	push   %ebx
 8057b81:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057b84:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057b88:	83 c0 01             	add    $0x1,%eax
 8057b8b:	50                   	push   %eax
 8057b8c:	e8 8f 55 00 00       	call   805d120 <decode_r2rm_l>
 8057b91:	89 c3                	mov    %eax,%ebx
	execute();
 8057b93:	e8 18 fe ff ff       	call   80579b0 <do_adc_l>
 8057b98:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057b9b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057b9e:	5b                   	pop    %ebx
 8057b9f:	c3                   	ret    

08057ba0 <adc_rm2r_l>:
make_instr_helper(rm2r)
 8057ba0:	53                   	push   %ebx
 8057ba1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057ba4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057ba8:	83 c0 01             	add    $0x1,%eax
 8057bab:	50                   	push   %eax
 8057bac:	e8 8f 55 00 00       	call   805d140 <decode_rm2r_l>
 8057bb1:	89 c3                	mov    %eax,%ebx
	execute();
 8057bb3:	e8 f8 fd ff ff       	call   80579b0 <do_adc_l>
 8057bb8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057bbb:	8d 43 01             	lea    0x1(%ebx),%eax
 8057bbe:	5b                   	pop    %ebx
 8057bbf:	c3                   	ret    

08057bc0 <adc_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8057bc0:	53                   	push   %ebx
 8057bc1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057bc4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057bc8:	83 c0 01             	add    $0x1,%eax
 8057bcb:	50                   	push   %eax
 8057bcc:	e8 8f 56 00 00       	call   805d260 <decode_si2rm_l>
 8057bd1:	89 c3                	mov    %eax,%ebx
	execute();
 8057bd3:	e8 d8 fd ff ff       	call   80579b0 <do_adc_l>
 8057bd8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057bdb:	8d 43 01             	lea    0x1(%ebx),%eax
 8057bde:	5b                   	pop    %ebx
 8057bdf:	c3                   	ret    

08057be0 <adc_i2a_b>:
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(i2a)
 8057be0:	53                   	push   %ebx
 8057be1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057be4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057be8:	83 c0 01             	add    $0x1,%eax
 8057beb:	50                   	push   %eax
 8057bec:	e8 6f 4e 00 00       	call   805ca60 <decode_i2a_b>
 8057bf1:	89 c3                	mov    %eax,%ebx
	execute();
 8057bf3:	e8 d8 f9 ff ff       	call   80575d0 <do_adc_b>
 8057bf8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057bfb:	8d 43 01             	lea    0x1(%ebx),%eax
 8057bfe:	5b                   	pop    %ebx
 8057bff:	c3                   	ret    

08057c00 <adc_i2rm_b>:
make_instr_helper(i2rm)
 8057c00:	53                   	push   %ebx
 8057c01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057c04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057c08:	83 c0 01             	add    $0x1,%eax
 8057c0b:	50                   	push   %eax
 8057c0c:	e8 cf 4e 00 00       	call   805cae0 <decode_i2rm_b>
 8057c11:	89 c3                	mov    %eax,%ebx
	execute();
 8057c13:	e8 b8 f9 ff ff       	call   80575d0 <do_adc_b>
 8057c18:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057c1b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057c1e:	5b                   	pop    %ebx
 8057c1f:	c3                   	ret    

08057c20 <adc_r2rm_b>:
make_instr_helper(r2rm)
 8057c20:	53                   	push   %ebx
 8057c21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057c24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057c28:	83 c0 01             	add    $0x1,%eax
 8057c2b:	50                   	push   %eax
 8057c2c:	e8 ef 4d 00 00       	call   805ca20 <decode_r2rm_b>
 8057c31:	89 c3                	mov    %eax,%ebx
	execute();
 8057c33:	e8 98 f9 ff ff       	call   80575d0 <do_adc_b>
 8057c38:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057c3b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057c3e:	5b                   	pop    %ebx
 8057c3f:	c3                   	ret    

08057c40 <adc_rm2r_b>:
make_instr_helper(rm2r)
 8057c40:	53                   	push   %ebx
 8057c41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057c44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057c48:	83 c0 01             	add    $0x1,%eax
 8057c4b:	50                   	push   %eax
 8057c4c:	e8 ef 4d 00 00       	call   805ca40 <decode_rm2r_b>
 8057c51:	89 c3                	mov    %eax,%ebx
	execute();
 8057c53:	e8 78 f9 ff ff       	call   80575d0 <do_adc_b>
 8057c58:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057c5b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057c5e:	5b                   	pop    %ebx
 8057c5f:	c3                   	ret    

08057c60 <adc_r2rm_v>:
#include "adc-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(adc_r2rm)
 8057c60:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8057c67:	8b 54 24 04          	mov    0x4(%esp),%edx
 8057c6b:	b8 50 79 05 08       	mov    $0x8057950,%eax
 8057c70:	75 05                	jne    8057c77 <adc_r2rm_v+0x17>
 8057c72:	b8 80 7b 05 08       	mov    $0x8057b80,%eax
 8057c77:	89 54 24 04          	mov    %edx,0x4(%esp)
 8057c7b:	ff e0                	jmp    *%eax
 8057c7d:	8d 76 00             	lea    0x0(%esi),%esi

08057c80 <adc_rm2r_v>:
make_helper_v(adc_rm2r)
 8057c80:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8057c87:	8b 54 24 04          	mov    0x4(%esp),%edx
 8057c8b:	b8 70 79 05 08       	mov    $0x8057970,%eax
 8057c90:	75 05                	jne    8057c97 <adc_rm2r_v+0x17>
 8057c92:	b8 a0 7b 05 08       	mov    $0x8057ba0,%eax
 8057c97:	89 54 24 04          	mov    %edx,0x4(%esp)
 8057c9b:	ff e0                	jmp    *%eax
 8057c9d:	8d 76 00             	lea    0x0(%esi),%esi

08057ca0 <adc_i2rm_v>:
make_helper_v(adc_i2rm)
 8057ca0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8057ca7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8057cab:	b8 30 79 05 08       	mov    $0x8057930,%eax
 8057cb0:	75 05                	jne    8057cb7 <adc_i2rm_v+0x17>
 8057cb2:	b8 60 7b 05 08       	mov    $0x8057b60,%eax
 8057cb7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8057cbb:	ff e0                	jmp    *%eax
 8057cbd:	8d 76 00             	lea    0x0(%esi),%esi

08057cc0 <adc_si2rm_v>:
make_helper_v(adc_si2rm)
 8057cc0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8057cc7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8057ccb:	b8 90 79 05 08       	mov    $0x8057990,%eax
 8057cd0:	75 05                	jne    8057cd7 <adc_si2rm_v+0x17>
 8057cd2:	b8 c0 7b 05 08       	mov    $0x8057bc0,%eax
 8057cd7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8057cdb:	ff e0                	jmp    *%eax
 8057cdd:	8d 76 00             	lea    0x0(%esi),%esi

08057ce0 <adc_i2a_v>:
make_helper_v(adc_i2a)
 8057ce0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8057ce7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8057ceb:	b8 10 79 05 08       	mov    $0x8057910,%eax
 8057cf0:	75 05                	jne    8057cf7 <adc_i2a_v+0x17>
 8057cf2:	b8 40 7b 05 08       	mov    $0x8057b40,%eax
 8057cf7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8057cfb:	ff e0                	jmp    *%eax
 8057cfd:	66 90                	xchg   %ax,%ax
 8057cff:	90                   	nop

08057d00 <do_sub_b>:
#include "cpu/exec/template-start.h"

#define instr sub

static void do_execute() {
 8057d00:	55                   	push   %ebp
 8057d01:	57                   	push   %edi
 8057d02:	56                   	push   %esi
 8057d03:	53                   	push   %ebx
 8057d04:	83 ec 14             	sub    $0x14,%esp
	uint32_t res = op_dest->val - op_src->val;
 8057d07:	8b 1d 14 ae 8f 14    	mov    0x148fae14,%ebx
 8057d0d:	8b 0d 4c ae 8f 14    	mov    0x148fae4c,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 8057d13:	0f b6 2d e4 ae 8f 14 	movzbl 0x148faee4,%ebp
#include "cpu/exec/template-start.h"

#define instr sub

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
 8057d1a:	29 d9                	sub    %ebx,%ecx
	uint32_t pf = (res & 255);
 8057d1c:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
 8057d1f:	89 c6                	mov    %eax,%esi
 8057d21:	c1 ee 04             	shr    $0x4,%esi
 8057d24:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 8057d26:	89 c6                	mov    %eax,%esi
 8057d28:	c1 ee 02             	shr    $0x2,%esi
 8057d2b:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 8057d2d:	89 c6                	mov    %eax,%esi
 8057d2f:	d1 ee                	shr    %esi
	cpu.CF = op_dest->val < op_src->val;
 8057d31:	39 1d 4c ae 8f 14    	cmp    %ebx,0x148fae4c
 8057d37:	0f 92 c2             	setb   %dl
static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 8057d3a:	31 f0                	xor    %esi,%eax
	cpu.CF = op_dest->val < op_src->val;
 8057d3c:	83 e5 fa             	and    $0xfffffffa,%ebp
	cpu.PF = (pf & 1);
 8057d3f:	83 e0 01             	and    $0x1,%eax
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 8057d42:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
 8057d44:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 8057d4b:	89 e8                	mov    %ebp,%eax
 8057d4d:	09 f8                	or     %edi,%eax
 8057d4f:	09 f0                	or     %esi,%eax
	cpu.ZF = (res == 0);
 8057d51:	85 c9                	test   %ecx,%ecx
 8057d53:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 8057d56:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 8057d59:	83 e0 3f             	and    $0x3f,%eax
 8057d5c:	89 d6                	mov    %edx,%esi
	cpu.SF = (res >> 31) & 1;
 8057d5e:	89 cf                	mov    %ecx,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057d60:	0f b6 15 4c ae 8f 14 	movzbl 0x148fae4c,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 8057d67:	c1 e6 06             	shl    $0x6,%esi
	cpu.SF = (res >> 31) & 1;
 8057d6a:	c1 e7 07             	shl    $0x7,%edi
 8057d6d:	09 f0                	or     %esi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057d6f:	8b 35 4c ae 8f 14    	mov    0x148fae4c,%esi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 8057d75:	09 f8                	or     %edi,%eax
 8057d77:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057d7c:	89 d8                	mov    %ebx,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057d7e:	29 da                	sub    %ebx,%edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057d80:	c1 ee 1f             	shr    $0x1f,%esi
 8057d83:	c1 e8 1f             	shr    $0x1f,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057d86:	0f b6 d2             	movzbl %dl,%edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057d89:	31 f0                	xor    %esi,%eax
 8057d8b:	31 f1                	xor    %esi,%ecx
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057d8d:	52                   	push   %edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057d8e:	21 c1                	and    %eax,%ecx
 8057d90:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057d97:	68 40 ae 8f 14       	push   $0x148fae40
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057d9c:	c1 e1 03             	shl    $0x3,%ecx
 8057d9f:	83 e0 f7             	and    $0xfffffff7,%eax
 8057da2:	09 c1                	or     %eax,%ecx
 8057da4:	88 0d e5 ae 8f 14    	mov    %cl,0x148faee5
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057daa:	e8 91 4e 00 00       	call   805cc40 <write_operand_b>
	print_asm_template2();
 8057daf:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8057db6:	68 18 ae 8f 14       	push   $0x148fae18
 8057dbb:	68 8a 43 06 08       	push   $0x806438a
 8057dc0:	6a 50                	push   $0x50
 8057dc2:	68 00 89 0c 08       	push   $0x80c8900
 8057dc7:	e8 34 0d ff ff       	call   8048b00 <snprintf@plt>
 8057dcc:	83 c4 20             	add    $0x20,%esp
 8057dcf:	83 f8 4f             	cmp    $0x4f,%eax
 8057dd2:	7f 0c                	jg     8057de0 <do_sub_b+0xe0>
}
 8057dd4:	83 c4 0c             	add    $0xc,%esp
 8057dd7:	5b                   	pop    %ebx
 8057dd8:	5e                   	pop    %esi
 8057dd9:	5f                   	pop    %edi
 8057dda:	5d                   	pop    %ebp
 8057ddb:	c3                   	ret    
 8057ddc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
 8057de0:	83 ec 0c             	sub    $0xc,%esp
 8057de3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8057de9:	e8 72 0b ff ff       	call   8048960 <fflush@plt>
 8057dee:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057df4:	6a 07                	push   $0x7
 8057df6:	6a 01                	push   $0x1
 8057df8:	68 92 ed 05 08       	push   $0x805ed92
 8057dfd:	e8 0e 0c ff ff       	call   8048a10 <fwrite@plt>
 8057e02:	83 c4 20             	add    $0x20,%esp
 8057e05:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057e0b:	6a 10                	push   $0x10
 8057e0d:	6a 01                	push   $0x1
 8057e0f:	68 84 f8 05 08       	push   $0x805f884
 8057e14:	e8 f7 0b ff ff       	call   8048a10 <fwrite@plt>
 8057e19:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057e1f:	6a 05                	push   $0x5
 8057e21:	6a 01                	push   $0x1
 8057e23:	68 b1 ed 05 08       	push   $0x805edb1
 8057e28:	e8 e3 0b ff ff       	call   8048a10 <fwrite@plt>
 8057e2d:	83 c4 14             	add    $0x14,%esp
 8057e30:	68 50 ae 8f 14       	push   $0x148fae50
 8057e35:	68 18 ae 8f 14       	push   $0x148fae18
 8057e3a:	68 8a 43 06 08       	push   $0x806438a
 8057e3f:	6a 50                	push   $0x50
 8057e41:	68 00 89 0c 08       	push   $0x80c8900
 8057e46:	e8 b5 0c ff ff       	call   8048b00 <snprintf@plt>
 8057e4b:	83 c4 20             	add    $0x20,%esp
 8057e4e:	83 f8 4f             	cmp    $0x4f,%eax
 8057e51:	7e 81                	jle    8057dd4 <do_sub_b+0xd4>
 8057e53:	68 11 45 06 08       	push   $0x8064511
 8057e58:	6a 11                	push   $0x11
 8057e5a:	68 ac 43 06 08       	push   $0x80643ac
 8057e5f:	68 d4 43 06 08       	push   $0x80643d4
 8057e64:	e8 47 0d ff ff       	call   8048bb0 <__assert_fail@plt>
 8057e69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08057e70 <do_sub_w>:
#include "cpu/exec/template-start.h"

#define instr sub

static void do_execute() {
 8057e70:	55                   	push   %ebp
 8057e71:	57                   	push   %edi
 8057e72:	56                   	push   %esi
 8057e73:	53                   	push   %ebx
 8057e74:	83 ec 14             	sub    $0x14,%esp
	uint32_t res = op_dest->val - op_src->val;
 8057e77:	8b 1d 14 ae 8f 14    	mov    0x148fae14,%ebx
 8057e7d:	8b 0d 4c ae 8f 14    	mov    0x148fae4c,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 8057e83:	0f b6 2d e4 ae 8f 14 	movzbl 0x148faee4,%ebp
#include "cpu/exec/template-start.h"

#define instr sub

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
 8057e8a:	29 d9                	sub    %ebx,%ecx
	uint32_t pf = (res & 255);
 8057e8c:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
 8057e8f:	89 c6                	mov    %eax,%esi
 8057e91:	c1 ee 04             	shr    $0x4,%esi
 8057e94:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 8057e96:	89 c6                	mov    %eax,%esi
 8057e98:	c1 ee 02             	shr    $0x2,%esi
 8057e9b:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 8057e9d:	89 c6                	mov    %eax,%esi
 8057e9f:	d1 ee                	shr    %esi
	cpu.CF = op_dest->val < op_src->val;
 8057ea1:	39 1d 4c ae 8f 14    	cmp    %ebx,0x148fae4c
 8057ea7:	0f 92 c2             	setb   %dl
static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 8057eaa:	31 f0                	xor    %esi,%eax
	cpu.CF = op_dest->val < op_src->val;
 8057eac:	83 e5 fa             	and    $0xfffffffa,%ebp
	cpu.PF = (pf & 1);
 8057eaf:	83 e0 01             	and    $0x1,%eax
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 8057eb2:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
 8057eb4:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 8057ebb:	89 e8                	mov    %ebp,%eax
 8057ebd:	09 f8                	or     %edi,%eax
 8057ebf:	09 f0                	or     %esi,%eax
	cpu.ZF = (res == 0);
 8057ec1:	85 c9                	test   %ecx,%ecx
 8057ec3:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 8057ec6:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 8057ec9:	83 e0 3f             	and    $0x3f,%eax
 8057ecc:	89 d6                	mov    %edx,%esi
	cpu.SF = (res >> 31) & 1;
 8057ece:	89 cf                	mov    %ecx,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057ed0:	0f b7 15 4c ae 8f 14 	movzwl 0x148fae4c,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 8057ed7:	c1 e6 06             	shl    $0x6,%esi
	cpu.SF = (res >> 31) & 1;
 8057eda:	c1 e7 07             	shl    $0x7,%edi
 8057edd:	09 f0                	or     %esi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057edf:	8b 35 4c ae 8f 14    	mov    0x148fae4c,%esi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 8057ee5:	09 f8                	or     %edi,%eax
 8057ee7:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057eec:	89 d8                	mov    %ebx,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057eee:	29 da                	sub    %ebx,%edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057ef0:	c1 ee 1f             	shr    $0x1f,%esi
 8057ef3:	c1 e8 1f             	shr    $0x1f,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057ef6:	0f b7 d2             	movzwl %dx,%edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057ef9:	31 f0                	xor    %esi,%eax
 8057efb:	31 f1                	xor    %esi,%ecx
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057efd:	52                   	push   %edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057efe:	21 c1                	and    %eax,%ecx
 8057f00:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057f07:	68 40 ae 8f 14       	push   $0x148fae40
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057f0c:	c1 e1 03             	shl    $0x3,%ecx
 8057f0f:	83 e0 f7             	and    $0xfffffff7,%eax
 8057f12:	09 c1                	or     %eax,%ecx
 8057f14:	88 0d e5 ae 8f 14    	mov    %cl,0x148faee5
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057f1a:	e8 b1 50 00 00       	call   805cfd0 <write_operand_w>
	print_asm_template2();
 8057f1f:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8057f26:	68 18 ae 8f 14       	push   $0x148fae18
 8057f2b:	68 95 43 06 08       	push   $0x8064395
 8057f30:	6a 50                	push   $0x50
 8057f32:	68 00 89 0c 08       	push   $0x80c8900
 8057f37:	e8 c4 0b ff ff       	call   8048b00 <snprintf@plt>
 8057f3c:	83 c4 20             	add    $0x20,%esp
 8057f3f:	83 f8 4f             	cmp    $0x4f,%eax
 8057f42:	7f 0c                	jg     8057f50 <do_sub_w+0xe0>
}
 8057f44:	83 c4 0c             	add    $0xc,%esp
 8057f47:	5b                   	pop    %ebx
 8057f48:	5e                   	pop    %esi
 8057f49:	5f                   	pop    %edi
 8057f4a:	5d                   	pop    %ebp
 8057f4b:	c3                   	ret    
 8057f4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
 8057f50:	83 ec 0c             	sub    $0xc,%esp
 8057f53:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8057f59:	e8 02 0a ff ff       	call   8048960 <fflush@plt>
 8057f5e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057f64:	6a 07                	push   $0x7
 8057f66:	6a 01                	push   $0x1
 8057f68:	68 92 ed 05 08       	push   $0x805ed92
 8057f6d:	e8 9e 0a ff ff       	call   8048a10 <fwrite@plt>
 8057f72:	83 c4 20             	add    $0x20,%esp
 8057f75:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057f7b:	6a 10                	push   $0x10
 8057f7d:	6a 01                	push   $0x1
 8057f7f:	68 84 f8 05 08       	push   $0x805f884
 8057f84:	e8 87 0a ff ff       	call   8048a10 <fwrite@plt>
 8057f89:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8057f8f:	6a 05                	push   $0x5
 8057f91:	6a 01                	push   $0x1
 8057f93:	68 b1 ed 05 08       	push   $0x805edb1
 8057f98:	e8 73 0a ff ff       	call   8048a10 <fwrite@plt>
 8057f9d:	83 c4 14             	add    $0x14,%esp
 8057fa0:	68 50 ae 8f 14       	push   $0x148fae50
 8057fa5:	68 18 ae 8f 14       	push   $0x148fae18
 8057faa:	68 95 43 06 08       	push   $0x8064395
 8057faf:	6a 50                	push   $0x50
 8057fb1:	68 00 89 0c 08       	push   $0x80c8900
 8057fb6:	e8 45 0b ff ff       	call   8048b00 <snprintf@plt>
 8057fbb:	83 c4 20             	add    $0x20,%esp
 8057fbe:	83 f8 4f             	cmp    $0x4f,%eax
 8057fc1:	7e 81                	jle    8057f44 <do_sub_w+0xd4>
 8057fc3:	68 08 45 06 08       	push   $0x8064508
 8057fc8:	6a 11                	push   $0x11
 8057fca:	68 ac 43 06 08       	push   $0x80643ac
 8057fcf:	68 38 44 06 08       	push   $0x8064438
 8057fd4:	e8 d7 0b ff ff       	call   8048bb0 <__assert_fail@plt>
 8057fd9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08057fe0 <sub_i2a_w>:
}

make_instr_helper(i2a)
 8057fe0:	53                   	push   %ebx
 8057fe1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057fe4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057fe8:	83 c0 01             	add    $0x1,%eax
 8057feb:	50                   	push   %eax
 8057fec:	e8 9f 4d 00 00       	call   805cd90 <decode_i2a_w>
 8057ff1:	89 c3                	mov    %eax,%ebx
	execute();
 8057ff3:	e8 78 fe ff ff       	call   8057e70 <do_sub_w>
 8057ff8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057ffb:	8d 43 01             	lea    0x1(%ebx),%eax
 8057ffe:	5b                   	pop    %ebx
 8057fff:	c3                   	ret    

08058000 <sub_i2rm_w>:
make_instr_helper(i2rm)
 8058000:	53                   	push   %ebx
 8058001:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058004:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058008:	83 c0 01             	add    $0x1,%eax
 805800b:	50                   	push   %eax
 805800c:	e8 ff 4d 00 00       	call   805ce10 <decode_i2rm_w>
 8058011:	89 c3                	mov    %eax,%ebx
	execute();
 8058013:	e8 58 fe ff ff       	call   8057e70 <do_sub_w>
 8058018:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805801b:	8d 43 01             	lea    0x1(%ebx),%eax
 805801e:	5b                   	pop    %ebx
 805801f:	c3                   	ret    

08058020 <sub_r2rm_w>:
make_instr_helper(r2rm)
 8058020:	53                   	push   %ebx
 8058021:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058024:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058028:	83 c0 01             	add    $0x1,%eax
 805802b:	50                   	push   %eax
 805802c:	e8 1f 4d 00 00       	call   805cd50 <decode_r2rm_w>
 8058031:	89 c3                	mov    %eax,%ebx
	execute();
 8058033:	e8 38 fe ff ff       	call   8057e70 <do_sub_w>
 8058038:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805803b:	8d 43 01             	lea    0x1(%ebx),%eax
 805803e:	5b                   	pop    %ebx
 805803f:	c3                   	ret    

08058040 <sub_rm2r_w>:
make_instr_helper(rm2r)
 8058040:	53                   	push   %ebx
 8058041:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058044:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058048:	83 c0 01             	add    $0x1,%eax
 805804b:	50                   	push   %eax
 805804c:	e8 1f 4d 00 00       	call   805cd70 <decode_rm2r_w>
 8058051:	89 c3                	mov    %eax,%ebx
	execute();
 8058053:	e8 18 fe ff ff       	call   8057e70 <do_sub_w>
 8058058:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805805b:	8d 43 01             	lea    0x1(%ebx),%eax
 805805e:	5b                   	pop    %ebx
 805805f:	c3                   	ret    

08058060 <sub_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8058060:	53                   	push   %ebx
 8058061:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058064:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058068:	83 c0 01             	add    $0x1,%eax
 805806b:	50                   	push   %eax
 805806c:	e8 1f 4e 00 00       	call   805ce90 <decode_si2rm_w>
 8058071:	89 c3                	mov    %eax,%ebx
	execute();
 8058073:	e8 f8 fd ff ff       	call   8057e70 <do_sub_w>
 8058078:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805807b:	8d 43 01             	lea    0x1(%ebx),%eax
 805807e:	5b                   	pop    %ebx
 805807f:	c3                   	ret    

08058080 <do_sub_l>:
#include "cpu/exec/template-start.h"

#define instr sub

static void do_execute() {
 8058080:	55                   	push   %ebp
 8058081:	57                   	push   %edi
 8058082:	56                   	push   %esi
 8058083:	53                   	push   %ebx
 8058084:	83 ec 14             	sub    $0x14,%esp
	uint32_t res = op_dest->val - op_src->val;
 8058087:	8b 0d 4c ae 8f 14    	mov    0x148fae4c,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805808d:	0f b6 2d e4 ae 8f 14 	movzbl 0x148faee4,%ebp
#include "cpu/exec/template-start.h"

#define instr sub

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
 8058094:	89 cb                	mov    %ecx,%ebx
 8058096:	2b 1d 14 ae 8f 14    	sub    0x148fae14,%ebx
	uint32_t pf = (res & 255);
 805809c:	0f b6 c3             	movzbl %bl,%eax
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 805809f:	53                   	push   %ebx
 80580a0:	68 40 ae 8f 14       	push   $0x148fae40
#define instr sub

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 80580a5:	89 c6                	mov    %eax,%esi
 80580a7:	c1 ee 04             	shr    $0x4,%esi
 80580aa:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 80580ac:	89 c6                	mov    %eax,%esi
 80580ae:	c1 ee 02             	shr    $0x2,%esi
 80580b1:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 80580b3:	89 c6                	mov    %eax,%esi
 80580b5:	d1 ee                	shr    %esi
	cpu.CF = op_dest->val < op_src->val;
 80580b7:	3b 0d 14 ae 8f 14    	cmp    0x148fae14,%ecx
 80580bd:	0f 92 c2             	setb   %dl
static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 80580c0:	31 f0                	xor    %esi,%eax
	cpu.CF = op_dest->val < op_src->val;
 80580c2:	83 e5 fa             	and    $0xfffffffa,%ebp
	cpu.PF = (pf & 1);
 80580c5:	83 e0 01             	and    $0x1,%eax
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 80580c8:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
 80580ca:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 80580d1:	89 e8                	mov    %ebp,%eax
 80580d3:	09 f8                	or     %edi,%eax
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 80580d5:	89 df                	mov    %ebx,%edi
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
 80580d7:	09 f0                	or     %esi,%eax
	cpu.ZF = (res == 0);
 80580d9:	85 db                	test   %ebx,%ebx
 80580db:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 80580de:	c1 ef 1f             	shr    $0x1f,%edi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 80580e1:	83 e0 3f             	and    $0x3f,%eax
 80580e4:	89 d6                	mov    %edx,%esi
	cpu.SF = (res >> 31) & 1;
 80580e6:	89 fd                	mov    %edi,%ebp
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 80580e8:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 80580eb:	c1 e6 06             	shl    $0x6,%esi
	cpu.SF = (res >> 31) & 1;
 80580ee:	c1 e5 07             	shl    $0x7,%ebp
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 80580f1:	31 cf                	xor    %ecx,%edi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 80580f3:	09 f0                	or     %esi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 80580f5:	89 ca                	mov    %ecx,%edx
 80580f7:	0f b6 0d e5 ae 8f 14 	movzbl 0x148faee5,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 80580fe:	09 e8                	or     %ebp,%eax
 8058100:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8058105:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
 805810a:	83 e1 f7             	and    $0xfffffff7,%ecx
 805810d:	c1 e8 1f             	shr    $0x1f,%eax
 8058110:	31 c2                	xor    %eax,%edx
 8058112:	21 fa                	and    %edi,%edx
 8058114:	c1 e2 03             	shl    $0x3,%edx
 8058117:	09 ca                	or     %ecx,%edx
 8058119:	88 15 e5 ae 8f 14    	mov    %dl,0x148faee5
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 805811f:	e8 7c 52 00 00       	call   805d3a0 <write_operand_l>
	print_asm_template2();
 8058124:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 805812b:	68 18 ae 8f 14       	push   $0x148fae18
 8058130:	68 a0 43 06 08       	push   $0x80643a0
 8058135:	6a 50                	push   $0x50
 8058137:	68 00 89 0c 08       	push   $0x80c8900
 805813c:	e8 bf 09 ff ff       	call   8048b00 <snprintf@plt>
 8058141:	83 c4 20             	add    $0x20,%esp
 8058144:	83 f8 4f             	cmp    $0x4f,%eax
 8058147:	7f 0f                	jg     8058158 <do_sub_l+0xd8>
}
 8058149:	83 c4 0c             	add    $0xc,%esp
 805814c:	5b                   	pop    %ebx
 805814d:	5e                   	pop    %esi
 805814e:	5f                   	pop    %edi
 805814f:	5d                   	pop    %ebp
 8058150:	c3                   	ret    
 8058151:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
 8058158:	83 ec 0c             	sub    $0xc,%esp
 805815b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8058161:	e8 fa 07 ff ff       	call   8048960 <fflush@plt>
 8058166:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805816c:	6a 07                	push   $0x7
 805816e:	6a 01                	push   $0x1
 8058170:	68 92 ed 05 08       	push   $0x805ed92
 8058175:	e8 96 08 ff ff       	call   8048a10 <fwrite@plt>
 805817a:	83 c4 20             	add    $0x20,%esp
 805817d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058183:	6a 10                	push   $0x10
 8058185:	6a 01                	push   $0x1
 8058187:	68 84 f8 05 08       	push   $0x805f884
 805818c:	e8 7f 08 ff ff       	call   8048a10 <fwrite@plt>
 8058191:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058197:	6a 05                	push   $0x5
 8058199:	6a 01                	push   $0x1
 805819b:	68 b1 ed 05 08       	push   $0x805edb1
 80581a0:	e8 6b 08 ff ff       	call   8048a10 <fwrite@plt>
 80581a5:	83 c4 14             	add    $0x14,%esp
 80581a8:	68 50 ae 8f 14       	push   $0x148fae50
 80581ad:	68 18 ae 8f 14       	push   $0x148fae18
 80581b2:	68 a0 43 06 08       	push   $0x80643a0
 80581b7:	6a 50                	push   $0x50
 80581b9:	68 00 89 0c 08       	push   $0x80c8900
 80581be:	e8 3d 09 ff ff       	call   8048b00 <snprintf@plt>
 80581c3:	83 c4 20             	add    $0x20,%esp
 80581c6:	83 f8 4f             	cmp    $0x4f,%eax
 80581c9:	0f 8e 7a ff ff ff    	jle    8058149 <do_sub_l+0xc9>
 80581cf:	68 ff 44 06 08       	push   $0x80644ff
 80581d4:	6a 11                	push   $0x11
 80581d6:	68 ac 43 06 08       	push   $0x80643ac
 80581db:	68 9c 44 06 08       	push   $0x806449c
 80581e0:	e8 cb 09 ff ff       	call   8048bb0 <__assert_fail@plt>
 80581e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80581e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080581f0 <sub_i2a_l>:
}

make_instr_helper(i2a)
 80581f0:	53                   	push   %ebx
 80581f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80581f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80581f8:	83 c0 01             	add    $0x1,%eax
 80581fb:	50                   	push   %eax
 80581fc:	e8 5f 4f 00 00       	call   805d160 <decode_i2a_l>
 8058201:	89 c3                	mov    %eax,%ebx
	execute();
 8058203:	e8 78 fe ff ff       	call   8058080 <do_sub_l>
 8058208:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805820b:	8d 43 01             	lea    0x1(%ebx),%eax
 805820e:	5b                   	pop    %ebx
 805820f:	c3                   	ret    

08058210 <sub_i2rm_l>:
make_instr_helper(i2rm)
 8058210:	53                   	push   %ebx
 8058211:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058214:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058218:	83 c0 01             	add    $0x1,%eax
 805821b:	50                   	push   %eax
 805821c:	e8 bf 4f 00 00       	call   805d1e0 <decode_i2rm_l>
 8058221:	89 c3                	mov    %eax,%ebx
	execute();
 8058223:	e8 58 fe ff ff       	call   8058080 <do_sub_l>
 8058228:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805822b:	8d 43 01             	lea    0x1(%ebx),%eax
 805822e:	5b                   	pop    %ebx
 805822f:	c3                   	ret    

08058230 <sub_r2rm_l>:
make_instr_helper(r2rm)
 8058230:	53                   	push   %ebx
 8058231:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058234:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058238:	83 c0 01             	add    $0x1,%eax
 805823b:	50                   	push   %eax
 805823c:	e8 df 4e 00 00       	call   805d120 <decode_r2rm_l>
 8058241:	89 c3                	mov    %eax,%ebx
	execute();
 8058243:	e8 38 fe ff ff       	call   8058080 <do_sub_l>
 8058248:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805824b:	8d 43 01             	lea    0x1(%ebx),%eax
 805824e:	5b                   	pop    %ebx
 805824f:	c3                   	ret    

08058250 <sub_rm2r_l>:
make_instr_helper(rm2r)
 8058250:	53                   	push   %ebx
 8058251:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058254:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058258:	83 c0 01             	add    $0x1,%eax
 805825b:	50                   	push   %eax
 805825c:	e8 df 4e 00 00       	call   805d140 <decode_rm2r_l>
 8058261:	89 c3                	mov    %eax,%ebx
	execute();
 8058263:	e8 18 fe ff ff       	call   8058080 <do_sub_l>
 8058268:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805826b:	8d 43 01             	lea    0x1(%ebx),%eax
 805826e:	5b                   	pop    %ebx
 805826f:	c3                   	ret    

08058270 <sub_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8058270:	53                   	push   %ebx
 8058271:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058274:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058278:	83 c0 01             	add    $0x1,%eax
 805827b:	50                   	push   %eax
 805827c:	e8 df 4f 00 00       	call   805d260 <decode_si2rm_l>
 8058281:	89 c3                	mov    %eax,%ebx
	execute();
 8058283:	e8 f8 fd ff ff       	call   8058080 <do_sub_l>
 8058288:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805828b:	8d 43 01             	lea    0x1(%ebx),%eax
 805828e:	5b                   	pop    %ebx
 805828f:	c3                   	ret    

08058290 <sub_i2a_b>:
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
}

make_instr_helper(i2a)
 8058290:	53                   	push   %ebx
 8058291:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058294:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058298:	83 c0 01             	add    $0x1,%eax
 805829b:	50                   	push   %eax
 805829c:	e8 bf 47 00 00       	call   805ca60 <decode_i2a_b>
 80582a1:	89 c3                	mov    %eax,%ebx
	execute();
 80582a3:	e8 58 fa ff ff       	call   8057d00 <do_sub_b>
 80582a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80582ab:	8d 43 01             	lea    0x1(%ebx),%eax
 80582ae:	5b                   	pop    %ebx
 80582af:	c3                   	ret    

080582b0 <sub_i2rm_b>:
make_instr_helper(i2rm)
 80582b0:	53                   	push   %ebx
 80582b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80582b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80582b8:	83 c0 01             	add    $0x1,%eax
 80582bb:	50                   	push   %eax
 80582bc:	e8 1f 48 00 00       	call   805cae0 <decode_i2rm_b>
 80582c1:	89 c3                	mov    %eax,%ebx
	execute();
 80582c3:	e8 38 fa ff ff       	call   8057d00 <do_sub_b>
 80582c8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80582cb:	8d 43 01             	lea    0x1(%ebx),%eax
 80582ce:	5b                   	pop    %ebx
 80582cf:	c3                   	ret    

080582d0 <sub_r2rm_b>:
make_instr_helper(r2rm)
 80582d0:	53                   	push   %ebx
 80582d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80582d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80582d8:	83 c0 01             	add    $0x1,%eax
 80582db:	50                   	push   %eax
 80582dc:	e8 3f 47 00 00       	call   805ca20 <decode_r2rm_b>
 80582e1:	89 c3                	mov    %eax,%ebx
	execute();
 80582e3:	e8 18 fa ff ff       	call   8057d00 <do_sub_b>
 80582e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80582eb:	8d 43 01             	lea    0x1(%ebx),%eax
 80582ee:	5b                   	pop    %ebx
 80582ef:	c3                   	ret    

080582f0 <sub_rm2r_b>:
make_instr_helper(rm2r)
 80582f0:	53                   	push   %ebx
 80582f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80582f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80582f8:	83 c0 01             	add    $0x1,%eax
 80582fb:	50                   	push   %eax
 80582fc:	e8 3f 47 00 00       	call   805ca40 <decode_rm2r_b>
 8058301:	89 c3                	mov    %eax,%ebx
	execute();
 8058303:	e8 f8 f9 ff ff       	call   8057d00 <do_sub_b>
 8058308:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805830b:	8d 43 01             	lea    0x1(%ebx),%eax
 805830e:	5b                   	pop    %ebx
 805830f:	c3                   	ret    

08058310 <sub_si2rm_v>:
#include "sub-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(sub_si2rm)
 8058310:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8058317:	8b 54 24 04          	mov    0x4(%esp),%edx
 805831b:	b8 60 80 05 08       	mov    $0x8058060,%eax
 8058320:	75 05                	jne    8058327 <sub_si2rm_v+0x17>
 8058322:	b8 70 82 05 08       	mov    $0x8058270,%eax
 8058327:	89 54 24 04          	mov    %edx,0x4(%esp)
 805832b:	ff e0                	jmp    *%eax
 805832d:	8d 76 00             	lea    0x0(%esi),%esi

08058330 <sub_i2rm_v>:
make_helper_v(sub_i2rm)
 8058330:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8058337:	8b 54 24 04          	mov    0x4(%esp),%edx
 805833b:	b8 00 80 05 08       	mov    $0x8058000,%eax
 8058340:	75 05                	jne    8058347 <sub_i2rm_v+0x17>
 8058342:	b8 10 82 05 08       	mov    $0x8058210,%eax
 8058347:	89 54 24 04          	mov    %edx,0x4(%esp)
 805834b:	ff e0                	jmp    *%eax
 805834d:	8d 76 00             	lea    0x0(%esi),%esi

08058350 <sub_i2a_v>:
make_helper_v(sub_i2a)
 8058350:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8058357:	8b 54 24 04          	mov    0x4(%esp),%edx
 805835b:	b8 e0 7f 05 08       	mov    $0x8057fe0,%eax
 8058360:	75 05                	jne    8058367 <sub_i2a_v+0x17>
 8058362:	b8 f0 81 05 08       	mov    $0x80581f0,%eax
 8058367:	89 54 24 04          	mov    %edx,0x4(%esp)
 805836b:	ff e0                	jmp    *%eax
 805836d:	8d 76 00             	lea    0x0(%esi),%esi

08058370 <sub_r2rm_v>:
make_helper_v(sub_r2rm)
 8058370:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8058377:	8b 54 24 04          	mov    0x4(%esp),%edx
 805837b:	b8 20 80 05 08       	mov    $0x8058020,%eax
 8058380:	75 05                	jne    8058387 <sub_r2rm_v+0x17>
 8058382:	b8 30 82 05 08       	mov    $0x8058230,%eax
 8058387:	89 54 24 04          	mov    %edx,0x4(%esp)
 805838b:	ff e0                	jmp    *%eax
 805838d:	8d 76 00             	lea    0x0(%esi),%esi

08058390 <sub_rm2r_v>:
make_helper_v(sub_rm2r)
 8058390:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8058397:	8b 54 24 04          	mov    0x4(%esp),%edx
 805839b:	b8 40 80 05 08       	mov    $0x8058040,%eax
 80583a0:	75 05                	jne    80583a7 <sub_rm2r_v+0x17>
 80583a2:	b8 50 82 05 08       	mov    $0x8058250,%eax
 80583a7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80583ab:	ff e0                	jmp    *%eax
 80583ad:	66 90                	xchg   %ax,%ax
 80583af:	90                   	nop

080583b0 <stos_w>:
#include "cpu/exec/template-start.h"

#define instr stos

make_helper(concat(stos_, SUFFIX)) {
 80583b0:	83 ec 10             	sub    $0x10,%esp
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
 80583b3:	0f b7 05 c0 ae 8f 14 	movzwl 0x148faec0,%eax
 80583ba:	50                   	push   %eax
 80583bb:	6a 02                	push   $0x2
 80583bd:	ff 35 dc ae 8f 14    	pushl  0x148faedc
 80583c3:	e8 e8 2b ff ff       	call   804afb0 <swaddr_write>
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 80583c8:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
 80583cf:	ba 01 00 00 00       	mov    $0x1,%edx
	print_asm_template1();
 80583d4:	68 18 ae 8f 14       	push   $0x148fae18
 80583d9:	68 1a 45 06 08       	push   $0x806451a
 80583de:	6a 50                	push   $0x50
 80583e0:	68 00 89 0c 08       	push   $0x80c8900

#define instr stos

make_helper(concat(stos_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 80583e5:	c0 e8 02             	shr    $0x2,%al
 80583e8:	83 e0 01             	and    $0x1,%eax
 80583eb:	01 c0                	add    %eax,%eax
 80583ed:	29 c2                	sub    %eax,%edx
 80583ef:	89 d0                	mov    %edx,%eax
 80583f1:	01 c0                	add    %eax,%eax
 80583f3:	01 05 dc ae 8f 14    	add    %eax,0x148faedc
	print_asm_template1();
 80583f9:	e8 02 07 ff ff       	call   8048b00 <snprintf@plt>
 80583fe:	83 c4 20             	add    $0x20,%esp
 8058401:	83 f8 4f             	cmp    $0x4f,%eax
 8058404:	7f 0a                	jg     8058410 <stos_w+0x60>
	return 1;
}
 8058406:	b8 01 00 00 00       	mov    $0x1,%eax
 805840b:	83 c4 0c             	add    $0xc,%esp
 805840e:	c3                   	ret    
 805840f:	90                   	nop
#define instr stos

make_helper(concat(stos_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 8058410:	83 ec 0c             	sub    $0xc,%esp
 8058413:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8058419:	e8 42 05 ff ff       	call   8048960 <fflush@plt>
 805841e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058424:	6a 07                	push   $0x7
 8058426:	6a 01                	push   $0x1
 8058428:	68 92 ed 05 08       	push   $0x805ed92
 805842d:	e8 de 05 ff ff       	call   8048a10 <fwrite@plt>
 8058432:	83 c4 20             	add    $0x20,%esp
 8058435:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805843b:	6a 10                	push   $0x10
 805843d:	6a 01                	push   $0x1
 805843f:	68 84 f8 05 08       	push   $0x805f884
 8058444:	e8 c7 05 ff ff       	call   8048a10 <fwrite@plt>
 8058449:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805844f:	6a 05                	push   $0x5
 8058451:	6a 01                	push   $0x1
 8058453:	68 b1 ed 05 08       	push   $0x805edb1
 8058458:	e8 b3 05 ff ff       	call   8048a10 <fwrite@plt>
 805845d:	83 c4 20             	add    $0x20,%esp
 8058460:	68 18 ae 8f 14       	push   $0x148fae18
 8058465:	68 1a 45 06 08       	push   $0x806451a
 805846a:	6a 50                	push   $0x50
 805846c:	68 00 89 0c 08       	push   $0x80c8900
 8058471:	e8 8a 06 ff ff       	call   8048b00 <snprintf@plt>
 8058476:	83 c4 10             	add    $0x10,%esp
 8058479:	83 f8 4f             	cmp    $0x4f,%eax
 805847c:	7e 88                	jle    8058406 <stos_w+0x56>
 805847e:	68 3e 46 06 08       	push   $0x806463e
 8058483:	6a 08                	push   $0x8
 8058485:	68 38 45 06 08       	push   $0x8064538
 805848a:	68 60 45 06 08       	push   $0x8064560
 805848f:	e8 1c 07 ff ff       	call   8048bb0 <__assert_fail@plt>
 8058494:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805849a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080584a0 <stos_l>:
#include "cpu/exec/template-start.h"

#define instr stos

make_helper(concat(stos_, SUFFIX)) {
 80584a0:	83 ec 10             	sub    $0x10,%esp
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
 80584a3:	ff 35 c0 ae 8f 14    	pushl  0x148faec0
 80584a9:	6a 04                	push   $0x4
 80584ab:	ff 35 dc ae 8f 14    	pushl  0x148faedc
 80584b1:	e8 fa 2a ff ff       	call   804afb0 <swaddr_write>
 80584b6:	a1 dc ae 8f 14       	mov    0x148faedc,%eax
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 80584bb:	68 18 ae 8f 14       	push   $0x148fae18
 80584c0:	68 23 45 06 08       	push   $0x8064523
 80584c5:	6a 50                	push   $0x50
 80584c7:	68 00 89 0c 08       	push   $0x80c8900
 80584cc:	8d 50 04             	lea    0x4(%eax),%edx

#define instr stos

make_helper(concat(stos_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 80584cf:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
 80584d6:	c0 e8 02             	shr    $0x2,%al
 80584d9:	83 e0 01             	and    $0x1,%eax
 80584dc:	c1 e0 03             	shl    $0x3,%eax
 80584df:	29 c2                	sub    %eax,%edx
 80584e1:	89 15 dc ae 8f 14    	mov    %edx,0x148faedc
	print_asm_template1();
 80584e7:	e8 14 06 ff ff       	call   8048b00 <snprintf@plt>
 80584ec:	83 c4 20             	add    $0x20,%esp
 80584ef:	83 f8 4f             	cmp    $0x4f,%eax
 80584f2:	7f 0c                	jg     8058500 <stos_l+0x60>
	return 1;
}
 80584f4:	b8 01 00 00 00       	mov    $0x1,%eax
 80584f9:	83 c4 0c             	add    $0xc,%esp
 80584fc:	c3                   	ret    
 80584fd:	8d 76 00             	lea    0x0(%esi),%esi
#define instr stos

make_helper(concat(stos_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 8058500:	83 ec 0c             	sub    $0xc,%esp
 8058503:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8058509:	e8 52 04 ff ff       	call   8048960 <fflush@plt>
 805850e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058514:	6a 07                	push   $0x7
 8058516:	6a 01                	push   $0x1
 8058518:	68 92 ed 05 08       	push   $0x805ed92
 805851d:	e8 ee 04 ff ff       	call   8048a10 <fwrite@plt>
 8058522:	83 c4 20             	add    $0x20,%esp
 8058525:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805852b:	6a 10                	push   $0x10
 805852d:	6a 01                	push   $0x1
 805852f:	68 84 f8 05 08       	push   $0x805f884
 8058534:	e8 d7 04 ff ff       	call   8048a10 <fwrite@plt>
 8058539:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805853f:	6a 05                	push   $0x5
 8058541:	6a 01                	push   $0x1
 8058543:	68 b1 ed 05 08       	push   $0x805edb1
 8058548:	e8 c3 04 ff ff       	call   8048a10 <fwrite@plt>
 805854d:	83 c4 20             	add    $0x20,%esp
 8058550:	68 18 ae 8f 14       	push   $0x148fae18
 8058555:	68 23 45 06 08       	push   $0x8064523
 805855a:	6a 50                	push   $0x50
 805855c:	68 00 89 0c 08       	push   $0x80c8900
 8058561:	e8 9a 05 ff ff       	call   8048b00 <snprintf@plt>
 8058566:	83 c4 10             	add    $0x10,%esp
 8058569:	83 f8 4f             	cmp    $0x4f,%eax
 805856c:	7e 86                	jle    80584f4 <stos_l+0x54>
 805856e:	68 37 46 06 08       	push   $0x8064637
 8058573:	6a 08                	push   $0x8
 8058575:	68 38 45 06 08       	push   $0x8064538
 805857a:	68 a8 45 06 08       	push   $0x80645a8
 805857f:	e8 2c 06 ff ff       	call   8048bb0 <__assert_fail@plt>
 8058584:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805858a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08058590 <stos_b>:
#include "cpu/exec/template-start.h"

#define instr stos

make_helper(concat(stos_, SUFFIX)) {
 8058590:	83 ec 10             	sub    $0x10,%esp
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
 8058593:	0f b6 05 c0 ae 8f 14 	movzbl 0x148faec0,%eax
 805859a:	50                   	push   %eax
 805859b:	6a 01                	push   $0x1
 805859d:	ff 35 dc ae 8f 14    	pushl  0x148faedc
 80585a3:	e8 08 2a ff ff       	call   804afb0 <swaddr_write>
 80585a8:	a1 dc ae 8f 14       	mov    0x148faedc,%eax
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 80585ad:	68 18 ae 8f 14       	push   $0x148fae18
 80585b2:	68 2c 45 06 08       	push   $0x806452c
 80585b7:	6a 50                	push   $0x50
 80585b9:	68 00 89 0c 08       	push   $0x80c8900
 80585be:	8d 50 01             	lea    0x1(%eax),%edx

#define instr stos

make_helper(concat(stos_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 80585c1:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
 80585c8:	c0 e8 02             	shr    $0x2,%al
 80585cb:	83 e0 01             	and    $0x1,%eax
 80585ce:	01 c0                	add    %eax,%eax
 80585d0:	29 c2                	sub    %eax,%edx
 80585d2:	89 15 dc ae 8f 14    	mov    %edx,0x148faedc
	print_asm_template1();
 80585d8:	e8 23 05 ff ff       	call   8048b00 <snprintf@plt>
 80585dd:	83 c4 20             	add    $0x20,%esp
 80585e0:	83 f8 4f             	cmp    $0x4f,%eax
 80585e3:	7f 0b                	jg     80585f0 <stos_b+0x60>
	return 1;
}
 80585e5:	b8 01 00 00 00       	mov    $0x1,%eax
 80585ea:	83 c4 0c             	add    $0xc,%esp
 80585ed:	c3                   	ret    
 80585ee:	66 90                	xchg   %ax,%ax
#define instr stos

make_helper(concat(stos_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 80585f0:	83 ec 0c             	sub    $0xc,%esp
 80585f3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80585f9:	e8 62 03 ff ff       	call   8048960 <fflush@plt>
 80585fe:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058604:	6a 07                	push   $0x7
 8058606:	6a 01                	push   $0x1
 8058608:	68 92 ed 05 08       	push   $0x805ed92
 805860d:	e8 fe 03 ff ff       	call   8048a10 <fwrite@plt>
 8058612:	83 c4 20             	add    $0x20,%esp
 8058615:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805861b:	6a 10                	push   $0x10
 805861d:	6a 01                	push   $0x1
 805861f:	68 84 f8 05 08       	push   $0x805f884
 8058624:	e8 e7 03 ff ff       	call   8048a10 <fwrite@plt>
 8058629:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805862f:	6a 05                	push   $0x5
 8058631:	6a 01                	push   $0x1
 8058633:	68 b1 ed 05 08       	push   $0x805edb1
 8058638:	e8 d3 03 ff ff       	call   8048a10 <fwrite@plt>
 805863d:	83 c4 20             	add    $0x20,%esp
 8058640:	68 18 ae 8f 14       	push   $0x148fae18
 8058645:	68 2c 45 06 08       	push   $0x806452c
 805864a:	6a 50                	push   $0x50
 805864c:	68 00 89 0c 08       	push   $0x80c8900
 8058651:	e8 aa 04 ff ff       	call   8048b00 <snprintf@plt>
 8058656:	83 c4 10             	add    $0x10,%esp
 8058659:	83 f8 4f             	cmp    $0x4f,%eax
 805865c:	7e 87                	jle    80585e5 <stos_b+0x55>
 805865e:	68 45 46 06 08       	push   $0x8064645
 8058663:	6a 08                	push   $0x8
 8058665:	68 38 45 06 08       	push   $0x8064538
 805866a:	68 f0 45 06 08       	push   $0x80645f0
 805866f:	e8 3c 05 ff ff       	call   8048bb0 <__assert_fail@plt>
 8058674:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805867a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08058680 <stos_v>:

#define DATA_BYTE 4
#include "stos-template.h"
#undef DATA_BYTE

make_helper_v(stos)
 8058680:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8058687:	8b 54 24 04          	mov    0x4(%esp),%edx
 805868b:	b8 b0 83 05 08       	mov    $0x80583b0,%eax
 8058690:	75 05                	jne    8058697 <stos_v+0x17>
 8058692:	b8 a0 84 05 08       	mov    $0x80584a0,%eax
 8058697:	89 54 24 04          	mov    %edx,0x4(%esp)
 805869b:	ff e0                	jmp    *%eax
 805869d:	66 90                	xchg   %ax,%ax
 805869f:	90                   	nop

080586a0 <do_add_b>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr add

static void do_execute() {
 80586a0:	55                   	push   %ebp
 80586a1:	57                   	push   %edi
 80586a2:	56                   	push   %esi
 80586a3:	53                   	push   %ebx
 80586a4:	83 ec 1c             	sub    $0x1c,%esp
	RET_DATA_TYPE res = op_src->val + op_dest->val;
 80586a7:	8b 1d 14 ae 8f 14    	mov    0x148fae14,%ebx
 80586ad:	8b 35 4c ae 8f 14    	mov    0x148fae4c,%esi
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80586b3:	89 da                	mov    %ebx,%edx
#endif
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 80586b5:	89 f0                	mov    %esi,%eax
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80586b7:	89 f1                	mov    %esi,%ecx
 80586b9:	c1 e9 07             	shr    $0x7,%ecx
 80586bc:	c1 ea 07             	shr    $0x7,%edx
#endif
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 80586bf:	00 d8                	add    %bl,%al
 80586c1:	0f 88 59 01 00 00    	js     8058820 <do_add_b+0x180>
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
	}
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
 80586c7:	09 ca                	or     %ecx,%edx
 80586c9:	0f b6 0d e4 ae 8f 14 	movzbl 0x148faee4,%ecx
 80586d0:	83 e2 01             	and    $0x1,%edx
 80586d3:	83 e1 fe             	and    $0xfffffffe,%ecx
 80586d6:	09 ca                	or     %ecx,%edx
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
 80586d8:	0f b6 c8             	movzbl %al,%ecx
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
	}
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
 80586db:	88 15 e4 ae 8f 14    	mov    %dl,0x148faee4
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 80586e1:	89 ca                	mov    %ecx,%edx
 80586e3:	c1 ea 04             	shr    $0x4,%edx
 80586e6:	31 ca                	xor    %ecx,%edx
	pf = (pf >> 2) ^ pf;
 80586e8:	89 d7                	mov    %edx,%edi
 80586ea:	c1 ef 02             	shr    $0x2,%edi
 80586ed:	31 fa                	xor    %edi,%edx
	pf = (pf >> 1) ^ pf;
 80586ef:	89 d7                	mov    %edx,%edi
 80586f1:	d1 ef                	shr    %edi
 80586f3:	31 fa                	xor    %edi,%edx
	cpu.PF = pf & 1;
 80586f5:	83 e2 01             	and    $0x1,%edx
 80586f8:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
 80586ff:	0f b6 15 e4 ae 8f 14 	movzbl 0x148faee4,%edx
 8058706:	83 e2 bb             	and    $0xffffffbb,%edx
	cpu.ZF = (res == 0);
 8058709:	84 c0                	test   %al,%al
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 805870b:	88 54 24 0f          	mov    %dl,0xf(%esp)
	cpu.ZF = (res == 0);
 805870f:	0f 94 c2             	sete   %dl
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058712:	31 c6                	xor    %eax,%esi
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 8058714:	89 d5                	mov    %edx,%ebp
 8058716:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 805871b:	83 ec 08             	sub    $0x8,%esp
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 805871e:	c1 e5 06             	shl    $0x6,%ebp
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 8058721:	51                   	push   %ecx
 8058722:	68 40 ae 8f 14       	push   $0x148fae40
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 8058727:	09 fa                	or     %edi,%edx
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8058729:	89 c7                	mov    %eax,%edi
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 805872b:	31 d8                	xor    %ebx,%eax
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 805872d:	09 ea                	or     %ebp,%edx
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 805872f:	83 e7 80             	and    $0xffffff80,%edi
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058732:	21 f0                	and    %esi,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8058734:	83 e2 7f             	and    $0x7f,%edx
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058737:	83 e0 01             	and    $0x1,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 805873a:	09 fa                	or     %edi,%edx
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 805873c:	c1 e0 03             	shl    $0x3,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 805873f:	88 15 e4 ae 8f 14    	mov    %dl,0x148faee4
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058745:	0f b6 15 e5 ae 8f 14 	movzbl 0x148faee5,%edx
 805874c:	83 e2 f7             	and    $0xfffffff7,%edx
 805874f:	09 d0                	or     %edx,%eax
 8058751:	a2 e5 ae 8f 14       	mov    %al,0x148faee5
	OPERAND_W(op_dest, res);
 8058756:	e8 e5 44 00 00       	call   805cc40 <write_operand_b>
	print_asm_template2();
 805875b:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8058762:	68 18 ae 8f 14       	push   $0x148fae18
 8058767:	68 4c 46 06 08       	push   $0x806464c
 805876c:	6a 50                	push   $0x50
 805876e:	68 00 89 0c 08       	push   $0x80c8900
 8058773:	e8 88 03 ff ff       	call   8048b00 <snprintf@plt>
 8058778:	83 c4 20             	add    $0x20,%esp
 805877b:	83 f8 4f             	cmp    $0x4f,%eax
 805877e:	7f 10                	jg     8058790 <do_add_b+0xf0>
}
 8058780:	83 c4 1c             	add    $0x1c,%esp
 8058783:	5b                   	pop    %ebx
 8058784:	5e                   	pop    %esi
 8058785:	5f                   	pop    %edi
 8058786:	5d                   	pop    %ebp
 8058787:	c3                   	ret    
 8058788:	90                   	nop
 8058789:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8058790:	83 ec 0c             	sub    $0xc,%esp
 8058793:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8058799:	e8 c2 01 ff ff       	call   8048960 <fflush@plt>
 805879e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80587a4:	6a 07                	push   $0x7
 80587a6:	6a 01                	push   $0x1
 80587a8:	68 92 ed 05 08       	push   $0x805ed92
 80587ad:	e8 5e 02 ff ff       	call   8048a10 <fwrite@plt>
 80587b2:	83 c4 20             	add    $0x20,%esp
 80587b5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80587bb:	6a 10                	push   $0x10
 80587bd:	6a 01                	push   $0x1
 80587bf:	68 84 f8 05 08       	push   $0x805f884
 80587c4:	e8 47 02 ff ff       	call   8048a10 <fwrite@plt>
 80587c9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80587cf:	6a 05                	push   $0x5
 80587d1:	6a 01                	push   $0x1
 80587d3:	68 b1 ed 05 08       	push   $0x805edb1
 80587d8:	e8 33 02 ff ff       	call   8048a10 <fwrite@plt>
 80587dd:	83 c4 14             	add    $0x14,%esp
 80587e0:	68 50 ae 8f 14       	push   $0x148fae50
 80587e5:	68 18 ae 8f 14       	push   $0x148fae18
 80587ea:	68 4c 46 06 08       	push   $0x806464c
 80587ef:	6a 50                	push   $0x50
 80587f1:	68 00 89 0c 08       	push   $0x80c8900
 80587f6:	e8 05 03 ff ff       	call   8048b00 <snprintf@plt>
 80587fb:	83 c4 20             	add    $0x20,%esp
 80587fe:	83 f8 4f             	cmp    $0x4f,%eax
 8058801:	0f 8e 79 ff ff ff    	jle    8058780 <do_add_b+0xe0>
 8058807:	68 d5 47 06 08       	push   $0x80647d5
 805880c:	6a 1e                	push   $0x1e
 805880e:	68 70 46 06 08       	push   $0x8064670
 8058813:	68 98 46 06 08       	push   $0x8064698
 8058818:	e8 93 03 ff ff       	call   8048bb0 <__assert_fail@plt>
 805881d:	8d 76 00             	lea    0x0(%esi),%esi
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8058820:	21 ca                	and    %ecx,%edx
 8058822:	e9 a2 fe ff ff       	jmp    80586c9 <do_add_b+0x29>
 8058827:	89 f6                	mov    %esi,%esi
 8058829:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08058830 <do_add_w>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr add

static void do_execute() {
 8058830:	55                   	push   %ebp
 8058831:	57                   	push   %edi
 8058832:	56                   	push   %esi
 8058833:	53                   	push   %ebx
 8058834:	83 ec 0c             	sub    $0xc,%esp
	RET_DATA_TYPE res = op_src->val + op_dest->val;
 8058837:	8b 15 14 ae 8f 14    	mov    0x148fae14,%edx
 805883d:	8b 1d 4c ae 8f 14    	mov    0x148fae4c,%ebx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8058843:	89 d0                	mov    %edx,%eax
#endif
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 8058845:	89 d9                	mov    %ebx,%ecx
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8058847:	89 de                	mov    %ebx,%esi
 8058849:	c1 ee 0f             	shr    $0xf,%esi
 805884c:	c1 e8 0f             	shr    $0xf,%eax
#endif
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 805884f:	66 01 d1             	add    %dx,%cx
 8058852:	0f 88 58 01 00 00    	js     80589b0 <do_add_w+0x180>
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
	}
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
 8058858:	09 f0                	or     %esi,%eax
 805885a:	0f b6 35 e4 ae 8f 14 	movzbl 0x148faee4,%esi
 8058861:	83 e0 01             	and    $0x1,%eax
 8058864:	83 e6 fe             	and    $0xfffffffe,%esi
 8058867:	09 f0                	or     %esi,%eax
 8058869:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
 805886e:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 8058871:	0f b6 2d e4 ae 8f 14 	movzbl 0x148faee4,%ebp
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 8058878:	89 c6                	mov    %eax,%esi
 805887a:	c1 ee 04             	shr    $0x4,%esi
 805887d:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 805887f:	89 c6                	mov    %eax,%esi
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 8058881:	83 e5 bb             	and    $0xffffffbb,%ebp
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 8058884:	c1 ee 02             	shr    $0x2,%esi
 8058887:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 8058889:	89 c6                	mov    %eax,%esi
 805888b:	d1 ee                	shr    %esi
 805888d:	31 f0                	xor    %esi,%eax
	cpu.PF = pf & 1;
 805888f:	83 e0 01             	and    $0x1,%eax
	cpu.ZF = (res == 0);
 8058892:	66 85 c9             	test   %cx,%cx
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 8058895:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
	cpu.ZF = (res == 0);
 805889c:	0f 94 c0             	sete   %al
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 805889f:	31 cb                	xor    %ecx,%ebx
 80588a1:	31 ca                	xor    %ecx,%edx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 80588a3:	c1 e0 06             	shl    $0x6,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 80588a6:	83 ec 08             	sub    $0x8,%esp
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80588a9:	21 da                	and    %ebx,%edx
 80588ab:	0f b6 1d e5 ae 8f 14 	movzbl 0x148faee5,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 80588b2:	89 c7                	mov    %eax,%edi
 80588b4:	89 e8                	mov    %ebp,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80588b6:	83 e2 01             	and    $0x1,%edx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 80588b9:	09 f0                	or     %esi,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80588bb:	89 ce                	mov    %ecx,%esi
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 80588bd:	0f b7 c9             	movzwl %cx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 80588c0:	09 f8                	or     %edi,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80588c2:	66 c1 fe 0f          	sar    $0xf,%si
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 80588c6:	51                   	push   %ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80588c7:	c1 e6 07             	shl    $0x7,%esi
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 80588ca:	68 40 ae 8f 14       	push   $0x148fae40
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80588cf:	83 e0 7f             	and    $0x7f,%eax
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80588d2:	c1 e2 03             	shl    $0x3,%edx
 80588d5:	83 e3 f7             	and    $0xfffffff7,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80588d8:	09 f0                	or     %esi,%eax
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80588da:	09 da                	or     %ebx,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80588dc:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80588e1:	88 15 e5 ae 8f 14    	mov    %dl,0x148faee5
	OPERAND_W(op_dest, res);
 80588e7:	e8 e4 46 00 00       	call   805cfd0 <write_operand_w>
	print_asm_template2();
 80588ec:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 80588f3:	68 18 ae 8f 14       	push   $0x148fae18
 80588f8:	68 57 46 06 08       	push   $0x8064657
 80588fd:	6a 50                	push   $0x50
 80588ff:	68 00 89 0c 08       	push   $0x80c8900
 8058904:	e8 f7 01 ff ff       	call   8048b00 <snprintf@plt>
 8058909:	83 c4 20             	add    $0x20,%esp
 805890c:	83 f8 4f             	cmp    $0x4f,%eax
 805890f:	7f 0f                	jg     8058920 <do_add_w+0xf0>
}
 8058911:	83 c4 0c             	add    $0xc,%esp
 8058914:	5b                   	pop    %ebx
 8058915:	5e                   	pop    %esi
 8058916:	5f                   	pop    %edi
 8058917:	5d                   	pop    %ebp
 8058918:	c3                   	ret    
 8058919:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8058920:	83 ec 0c             	sub    $0xc,%esp
 8058923:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8058929:	e8 32 00 ff ff       	call   8048960 <fflush@plt>
 805892e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058934:	6a 07                	push   $0x7
 8058936:	6a 01                	push   $0x1
 8058938:	68 92 ed 05 08       	push   $0x805ed92
 805893d:	e8 ce 00 ff ff       	call   8048a10 <fwrite@plt>
 8058942:	83 c4 20             	add    $0x20,%esp
 8058945:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805894b:	6a 10                	push   $0x10
 805894d:	6a 01                	push   $0x1
 805894f:	68 84 f8 05 08       	push   $0x805f884
 8058954:	e8 b7 00 ff ff       	call   8048a10 <fwrite@plt>
 8058959:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805895f:	6a 05                	push   $0x5
 8058961:	6a 01                	push   $0x1
 8058963:	68 b1 ed 05 08       	push   $0x805edb1
 8058968:	e8 a3 00 ff ff       	call   8048a10 <fwrite@plt>
 805896d:	83 c4 14             	add    $0x14,%esp
 8058970:	68 50 ae 8f 14       	push   $0x148fae50
 8058975:	68 18 ae 8f 14       	push   $0x148fae18
 805897a:	68 57 46 06 08       	push   $0x8064657
 805897f:	6a 50                	push   $0x50
 8058981:	68 00 89 0c 08       	push   $0x80c8900
 8058986:	e8 75 01 ff ff       	call   8048b00 <snprintf@plt>
 805898b:	83 c4 20             	add    $0x20,%esp
 805898e:	83 f8 4f             	cmp    $0x4f,%eax
 8058991:	0f 8e 7a ff ff ff    	jle    8058911 <do_add_w+0xe1>
 8058997:	68 cc 47 06 08       	push   $0x80647cc
 805899c:	6a 1e                	push   $0x1e
 805899e:	68 70 46 06 08       	push   $0x8064670
 80589a3:	68 fc 46 06 08       	push   $0x80646fc
 80589a8:	e8 03 02 ff ff       	call   8048bb0 <__assert_fail@plt>
 80589ad:	8d 76 00             	lea    0x0(%esi),%esi
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80589b0:	21 f0                	and    %esi,%eax
 80589b2:	e9 a3 fe ff ff       	jmp    805885a <do_add_w+0x2a>
 80589b7:	89 f6                	mov    %esi,%esi
 80589b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080589c0 <add_i2a_w>:
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(i2a)
 80589c0:	53                   	push   %ebx
 80589c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80589c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80589c8:	83 c0 01             	add    $0x1,%eax
 80589cb:	50                   	push   %eax
 80589cc:	e8 bf 43 00 00       	call   805cd90 <decode_i2a_w>
 80589d1:	89 c3                	mov    %eax,%ebx
	execute();
 80589d3:	e8 58 fe ff ff       	call   8058830 <do_add_w>
 80589d8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80589db:	8d 43 01             	lea    0x1(%ebx),%eax
 80589de:	5b                   	pop    %ebx
 80589df:	c3                   	ret    

080589e0 <add_i2rm_w>:
make_instr_helper(i2rm)
 80589e0:	53                   	push   %ebx
 80589e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80589e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80589e8:	83 c0 01             	add    $0x1,%eax
 80589eb:	50                   	push   %eax
 80589ec:	e8 1f 44 00 00       	call   805ce10 <decode_i2rm_w>
 80589f1:	89 c3                	mov    %eax,%ebx
	execute();
 80589f3:	e8 38 fe ff ff       	call   8058830 <do_add_w>
 80589f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80589fb:	8d 43 01             	lea    0x1(%ebx),%eax
 80589fe:	5b                   	pop    %ebx
 80589ff:	c3                   	ret    

08058a00 <add_r2rm_w>:
make_instr_helper(r2rm)
 8058a00:	53                   	push   %ebx
 8058a01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058a04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058a08:	83 c0 01             	add    $0x1,%eax
 8058a0b:	50                   	push   %eax
 8058a0c:	e8 3f 43 00 00       	call   805cd50 <decode_r2rm_w>
 8058a11:	89 c3                	mov    %eax,%ebx
	execute();
 8058a13:	e8 18 fe ff ff       	call   8058830 <do_add_w>
 8058a18:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058a1b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058a1e:	5b                   	pop    %ebx
 8058a1f:	c3                   	ret    

08058a20 <add_rm2r_w>:
make_instr_helper(rm2r)
 8058a20:	53                   	push   %ebx
 8058a21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058a24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058a28:	83 c0 01             	add    $0x1,%eax
 8058a2b:	50                   	push   %eax
 8058a2c:	e8 3f 43 00 00       	call   805cd70 <decode_rm2r_w>
 8058a31:	89 c3                	mov    %eax,%ebx
	execute();
 8058a33:	e8 f8 fd ff ff       	call   8058830 <do_add_w>
 8058a38:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058a3b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058a3e:	5b                   	pop    %ebx
 8058a3f:	c3                   	ret    

08058a40 <add_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8058a40:	53                   	push   %ebx
 8058a41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058a44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058a48:	83 c0 01             	add    $0x1,%eax
 8058a4b:	50                   	push   %eax
 8058a4c:	e8 3f 44 00 00       	call   805ce90 <decode_si2rm_w>
 8058a51:	89 c3                	mov    %eax,%ebx
	execute();
 8058a53:	e8 d8 fd ff ff       	call   8058830 <do_add_w>
 8058a58:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058a5b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058a5e:	5b                   	pop    %ebx
 8058a5f:	c3                   	ret    

08058a60 <do_add_l>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr add

static void do_execute() {
 8058a60:	55                   	push   %ebp
 8058a61:	57                   	push   %edi
 8058a62:	56                   	push   %esi
 8058a63:	53                   	push   %ebx
 8058a64:	83 ec 0c             	sub    $0xc,%esp
	RET_DATA_TYPE res = op_src->val + op_dest->val;
 8058a67:	8b 15 14 ae 8f 14    	mov    0x148fae14,%edx
 8058a6d:	8b 1d 4c ae 8f 14    	mov    0x148fae4c,%ebx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8058a73:	89 d0                	mov    %edx,%eax
#endif
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 8058a75:	89 d9                	mov    %ebx,%ecx
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8058a77:	89 de                	mov    %ebx,%esi
 8058a79:	c1 ee 1f             	shr    $0x1f,%esi
 8058a7c:	c1 e8 1f             	shr    $0x1f,%eax
#endif
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 8058a7f:	01 d1                	add    %edx,%ecx
 8058a81:	0f 88 49 01 00 00    	js     8058bd0 <do_add_l+0x170>
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
	}
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
 8058a87:	09 f0                	or     %esi,%eax
 8058a89:	0f b6 35 e4 ae 8f 14 	movzbl 0x148faee4,%esi
 8058a90:	83 e6 fe             	and    $0xfffffffe,%esi
 8058a93:	09 f0                	or     %esi,%eax
 8058a95:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
 8058a9a:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 8058a9d:	0f b6 2d e4 ae 8f 14 	movzbl 0x148faee4,%ebp
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 8058aa4:	89 c6                	mov    %eax,%esi
 8058aa6:	c1 ee 04             	shr    $0x4,%esi
 8058aa9:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 8058aab:	89 c6                	mov    %eax,%esi
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 8058aad:	83 e5 bb             	and    $0xffffffbb,%ebp
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 8058ab0:	c1 ee 02             	shr    $0x2,%esi
 8058ab3:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 8058ab5:	89 c6                	mov    %eax,%esi
 8058ab7:	d1 ee                	shr    %esi
 8058ab9:	31 f0                	xor    %esi,%eax
	cpu.PF = pf & 1;
 8058abb:	83 e0 01             	and    $0x1,%eax
	cpu.ZF = (res == 0);
 8058abe:	85 c9                	test   %ecx,%ecx
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 8058ac0:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
	cpu.ZF = (res == 0);
 8058ac7:	0f 94 c0             	sete   %al
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058aca:	31 cb                	xor    %ecx,%ebx
 8058acc:	31 ca                	xor    %ecx,%edx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 8058ace:	c1 e0 06             	shl    $0x6,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 8058ad1:	83 ec 08             	sub    $0x8,%esp
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058ad4:	21 da                	and    %ebx,%edx
 8058ad6:	0f b6 1d e5 ae 8f 14 	movzbl 0x148faee5,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 8058add:	89 c7                	mov    %eax,%edi
 8058adf:	89 e8                	mov    %ebp,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058ae1:	83 e2 01             	and    $0x1,%edx
	OPERAND_W(op_dest, res);
 8058ae4:	51                   	push   %ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 8058ae5:	09 f0                	or     %esi,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8058ae7:	89 ce                	mov    %ecx,%esi
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 8058ae9:	68 40 ae 8f 14       	push   $0x148fae40
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 8058aee:	09 f8                	or     %edi,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8058af0:	c1 ee 1f             	shr    $0x1f,%esi
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058af3:	c1 e2 03             	shl    $0x3,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8058af6:	c1 e6 07             	shl    $0x7,%esi
 8058af9:	83 e0 7f             	and    $0x7f,%eax
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058afc:	83 e3 f7             	and    $0xfffffff7,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8058aff:	09 f0                	or     %esi,%eax
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058b01:	09 da                	or     %ebx,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8058b03:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058b08:	88 15 e5 ae 8f 14    	mov    %dl,0x148faee5
	OPERAND_W(op_dest, res);
 8058b0e:	e8 8d 48 00 00       	call   805d3a0 <write_operand_l>
	print_asm_template2();
 8058b13:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8058b1a:	68 18 ae 8f 14       	push   $0x148fae18
 8058b1f:	68 62 46 06 08       	push   $0x8064662
 8058b24:	6a 50                	push   $0x50
 8058b26:	68 00 89 0c 08       	push   $0x80c8900
 8058b2b:	e8 d0 ff fe ff       	call   8048b00 <snprintf@plt>
 8058b30:	83 c4 20             	add    $0x20,%esp
 8058b33:	83 f8 4f             	cmp    $0x4f,%eax
 8058b36:	7f 08                	jg     8058b40 <do_add_l+0xe0>
}
 8058b38:	83 c4 0c             	add    $0xc,%esp
 8058b3b:	5b                   	pop    %ebx
 8058b3c:	5e                   	pop    %esi
 8058b3d:	5f                   	pop    %edi
 8058b3e:	5d                   	pop    %ebp
 8058b3f:	c3                   	ret    
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8058b40:	83 ec 0c             	sub    $0xc,%esp
 8058b43:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8058b49:	e8 12 fe fe ff       	call   8048960 <fflush@plt>
 8058b4e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058b54:	6a 07                	push   $0x7
 8058b56:	6a 01                	push   $0x1
 8058b58:	68 92 ed 05 08       	push   $0x805ed92
 8058b5d:	e8 ae fe fe ff       	call   8048a10 <fwrite@plt>
 8058b62:	83 c4 20             	add    $0x20,%esp
 8058b65:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058b6b:	6a 10                	push   $0x10
 8058b6d:	6a 01                	push   $0x1
 8058b6f:	68 84 f8 05 08       	push   $0x805f884
 8058b74:	e8 97 fe fe ff       	call   8048a10 <fwrite@plt>
 8058b79:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058b7f:	6a 05                	push   $0x5
 8058b81:	6a 01                	push   $0x1
 8058b83:	68 b1 ed 05 08       	push   $0x805edb1
 8058b88:	e8 83 fe fe ff       	call   8048a10 <fwrite@plt>
 8058b8d:	83 c4 14             	add    $0x14,%esp
 8058b90:	68 50 ae 8f 14       	push   $0x148fae50
 8058b95:	68 18 ae 8f 14       	push   $0x148fae18
 8058b9a:	68 62 46 06 08       	push   $0x8064662
 8058b9f:	6a 50                	push   $0x50
 8058ba1:	68 00 89 0c 08       	push   $0x80c8900
 8058ba6:	e8 55 ff fe ff       	call   8048b00 <snprintf@plt>
 8058bab:	83 c4 20             	add    $0x20,%esp
 8058bae:	83 f8 4f             	cmp    $0x4f,%eax
 8058bb1:	7e 85                	jle    8058b38 <do_add_l+0xd8>
 8058bb3:	68 c3 47 06 08       	push   $0x80647c3
 8058bb8:	6a 1e                	push   $0x1e
 8058bba:	68 70 46 06 08       	push   $0x8064670
 8058bbf:	68 60 47 06 08       	push   $0x8064760
 8058bc4:	e8 e7 ff fe ff       	call   8048bb0 <__assert_fail@plt>
 8058bc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8058bd0:	21 f0                	and    %esi,%eax
 8058bd2:	0f b6 35 e4 ae 8f 14 	movzbl 0x148faee4,%esi
 8058bd9:	83 e6 fe             	and    $0xfffffffe,%esi
 8058bdc:	09 f0                	or     %esi,%eax
 8058bde:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
 8058be3:	e9 b2 fe ff ff       	jmp    8058a9a <do_add_l+0x3a>
 8058be8:	90                   	nop
 8058be9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08058bf0 <add_i2a_l>:
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(i2a)
 8058bf0:	53                   	push   %ebx
 8058bf1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058bf4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058bf8:	83 c0 01             	add    $0x1,%eax
 8058bfb:	50                   	push   %eax
 8058bfc:	e8 5f 45 00 00       	call   805d160 <decode_i2a_l>
 8058c01:	89 c3                	mov    %eax,%ebx
	execute();
 8058c03:	e8 58 fe ff ff       	call   8058a60 <do_add_l>
 8058c08:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058c0b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058c0e:	5b                   	pop    %ebx
 8058c0f:	c3                   	ret    

08058c10 <add_i2rm_l>:
make_instr_helper(i2rm)
 8058c10:	53                   	push   %ebx
 8058c11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058c14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058c18:	83 c0 01             	add    $0x1,%eax
 8058c1b:	50                   	push   %eax
 8058c1c:	e8 bf 45 00 00       	call   805d1e0 <decode_i2rm_l>
 8058c21:	89 c3                	mov    %eax,%ebx
	execute();
 8058c23:	e8 38 fe ff ff       	call   8058a60 <do_add_l>
 8058c28:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058c2b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058c2e:	5b                   	pop    %ebx
 8058c2f:	c3                   	ret    

08058c30 <add_r2rm_l>:
make_instr_helper(r2rm)
 8058c30:	53                   	push   %ebx
 8058c31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058c34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058c38:	83 c0 01             	add    $0x1,%eax
 8058c3b:	50                   	push   %eax
 8058c3c:	e8 df 44 00 00       	call   805d120 <decode_r2rm_l>
 8058c41:	89 c3                	mov    %eax,%ebx
	execute();
 8058c43:	e8 18 fe ff ff       	call   8058a60 <do_add_l>
 8058c48:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058c4b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058c4e:	5b                   	pop    %ebx
 8058c4f:	c3                   	ret    

08058c50 <add_rm2r_l>:
make_instr_helper(rm2r)
 8058c50:	53                   	push   %ebx
 8058c51:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058c54:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058c58:	83 c0 01             	add    $0x1,%eax
 8058c5b:	50                   	push   %eax
 8058c5c:	e8 df 44 00 00       	call   805d140 <decode_rm2r_l>
 8058c61:	89 c3                	mov    %eax,%ebx
	execute();
 8058c63:	e8 f8 fd ff ff       	call   8058a60 <do_add_l>
 8058c68:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058c6b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058c6e:	5b                   	pop    %ebx
 8058c6f:	c3                   	ret    

08058c70 <add_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8058c70:	53                   	push   %ebx
 8058c71:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058c74:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058c78:	83 c0 01             	add    $0x1,%eax
 8058c7b:	50                   	push   %eax
 8058c7c:	e8 df 45 00 00       	call   805d260 <decode_si2rm_l>
 8058c81:	89 c3                	mov    %eax,%ebx
	execute();
 8058c83:	e8 d8 fd ff ff       	call   8058a60 <do_add_l>
 8058c88:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058c8b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058c8e:	5b                   	pop    %ebx
 8058c8f:	c3                   	ret    

08058c90 <add_i2a_b>:
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(i2a)
 8058c90:	53                   	push   %ebx
 8058c91:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058c94:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058c98:	83 c0 01             	add    $0x1,%eax
 8058c9b:	50                   	push   %eax
 8058c9c:	e8 bf 3d 00 00       	call   805ca60 <decode_i2a_b>
 8058ca1:	89 c3                	mov    %eax,%ebx
	execute();
 8058ca3:	e8 f8 f9 ff ff       	call   80586a0 <do_add_b>
 8058ca8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058cab:	8d 43 01             	lea    0x1(%ebx),%eax
 8058cae:	5b                   	pop    %ebx
 8058caf:	c3                   	ret    

08058cb0 <add_i2rm_b>:
make_instr_helper(i2rm)
 8058cb0:	53                   	push   %ebx
 8058cb1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058cb4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058cb8:	83 c0 01             	add    $0x1,%eax
 8058cbb:	50                   	push   %eax
 8058cbc:	e8 1f 3e 00 00       	call   805cae0 <decode_i2rm_b>
 8058cc1:	89 c3                	mov    %eax,%ebx
	execute();
 8058cc3:	e8 d8 f9 ff ff       	call   80586a0 <do_add_b>
 8058cc8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058ccb:	8d 43 01             	lea    0x1(%ebx),%eax
 8058cce:	5b                   	pop    %ebx
 8058ccf:	c3                   	ret    

08058cd0 <add_r2rm_b>:
make_instr_helper(r2rm)
 8058cd0:	53                   	push   %ebx
 8058cd1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058cd4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058cd8:	83 c0 01             	add    $0x1,%eax
 8058cdb:	50                   	push   %eax
 8058cdc:	e8 3f 3d 00 00       	call   805ca20 <decode_r2rm_b>
 8058ce1:	89 c3                	mov    %eax,%ebx
	execute();
 8058ce3:	e8 b8 f9 ff ff       	call   80586a0 <do_add_b>
 8058ce8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058ceb:	8d 43 01             	lea    0x1(%ebx),%eax
 8058cee:	5b                   	pop    %ebx
 8058cef:	c3                   	ret    

08058cf0 <add_rm2r_b>:
make_instr_helper(rm2r)
 8058cf0:	53                   	push   %ebx
 8058cf1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058cf4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058cf8:	83 c0 01             	add    $0x1,%eax
 8058cfb:	50                   	push   %eax
 8058cfc:	e8 3f 3d 00 00       	call   805ca40 <decode_rm2r_b>
 8058d01:	89 c3                	mov    %eax,%ebx
	execute();
 8058d03:	e8 98 f9 ff ff       	call   80586a0 <do_add_b>
 8058d08:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058d0b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058d0e:	5b                   	pop    %ebx
 8058d0f:	c3                   	ret    

08058d10 <add_r2rm_v>:
#include "add-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(add_r2rm)
 8058d10:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8058d17:	8b 54 24 04          	mov    0x4(%esp),%edx
 8058d1b:	b8 00 8a 05 08       	mov    $0x8058a00,%eax
 8058d20:	75 05                	jne    8058d27 <add_r2rm_v+0x17>
 8058d22:	b8 30 8c 05 08       	mov    $0x8058c30,%eax
 8058d27:	89 54 24 04          	mov    %edx,0x4(%esp)
 8058d2b:	ff e0                	jmp    *%eax
 8058d2d:	8d 76 00             	lea    0x0(%esi),%esi

08058d30 <add_rm2r_v>:
make_helper_v(add_rm2r)
 8058d30:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8058d37:	8b 54 24 04          	mov    0x4(%esp),%edx
 8058d3b:	b8 20 8a 05 08       	mov    $0x8058a20,%eax
 8058d40:	75 05                	jne    8058d47 <add_rm2r_v+0x17>
 8058d42:	b8 50 8c 05 08       	mov    $0x8058c50,%eax
 8058d47:	89 54 24 04          	mov    %edx,0x4(%esp)
 8058d4b:	ff e0                	jmp    *%eax
 8058d4d:	8d 76 00             	lea    0x0(%esi),%esi

08058d50 <add_i2rm_v>:
make_helper_v(add_i2rm)
 8058d50:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8058d57:	8b 54 24 04          	mov    0x4(%esp),%edx
 8058d5b:	b8 e0 89 05 08       	mov    $0x80589e0,%eax
 8058d60:	75 05                	jne    8058d67 <add_i2rm_v+0x17>
 8058d62:	b8 10 8c 05 08       	mov    $0x8058c10,%eax
 8058d67:	89 54 24 04          	mov    %edx,0x4(%esp)
 8058d6b:	ff e0                	jmp    *%eax
 8058d6d:	8d 76 00             	lea    0x0(%esi),%esi

08058d70 <add_si2rm_v>:
make_helper_v(add_si2rm)
 8058d70:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8058d77:	8b 54 24 04          	mov    0x4(%esp),%edx
 8058d7b:	b8 40 8a 05 08       	mov    $0x8058a40,%eax
 8058d80:	75 05                	jne    8058d87 <add_si2rm_v+0x17>
 8058d82:	b8 70 8c 05 08       	mov    $0x8058c70,%eax
 8058d87:	89 54 24 04          	mov    %edx,0x4(%esp)
 8058d8b:	ff e0                	jmp    *%eax
 8058d8d:	8d 76 00             	lea    0x0(%esi),%esi

08058d90 <add_i2a_v>:
make_helper_v(add_i2a)
 8058d90:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8058d97:	8b 54 24 04          	mov    0x4(%esp),%edx
 8058d9b:	b8 c0 89 05 08       	mov    $0x80589c0,%eax
 8058da0:	75 05                	jne    8058da7 <add_i2a_v+0x17>
 8058da2:	b8 f0 8b 05 08       	mov    $0x8058bf0,%eax
 8058da7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8058dab:	ff e0                	jmp    *%eax
 8058dad:	66 90                	xchg   %ax,%ax
 8058daf:	90                   	nop

08058db0 <mov_a2moffs_w>:
make_instr_helper(i2r)
make_instr_helper(i2rm)
make_instr_helper(r2rm)
make_instr_helper(rm2r)

make_helper(concat(mov_a2moffs_, SUFFIX)) {
 8058db0:	53                   	push   %ebx
 8058db1:	83 ec 10             	sub    $0x10,%esp

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 8058db4:	6a 04                	push   $0x4
	swaddr_t addr = instr_fetch(eip + 1, 4);
 8058db6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058dba:	83 c0 01             	add    $0x1,%eax
 8058dbd:	50                   	push   %eax
 8058dbe:	e8 9d 21 ff ff       	call   804af60 <swaddr_read>
 8058dc3:	89 c3                	mov    %eax,%ebx
	MEM_W(addr, REG(R_EAX));
 8058dc5:	0f b7 05 c0 ae 8f 14 	movzwl 0x148faec0,%eax
 8058dcc:	83 c4 0c             	add    $0xc,%esp
 8058dcf:	50                   	push   %eax
 8058dd0:	6a 02                	push   $0x2
 8058dd2:	53                   	push   %ebx
 8058dd3:	e8 d8 21 ff ff       	call   804afb0 <swaddr_write>

	print_asm("mov" str(SUFFIX) " %%%s,0x%x", REG_NAME(R_EAX), addr);
 8058dd8:	89 1c 24             	mov    %ebx,(%esp)
 8058ddb:	ff 35 a0 5b 07 08    	pushl  0x8075ba0
 8058de1:	68 de 47 06 08       	push   $0x80647de
 8058de6:	6a 50                	push   $0x50
 8058de8:	68 00 89 0c 08       	push   $0x80c8900
 8058ded:	e8 0e fd fe ff       	call   8048b00 <snprintf@plt>
 8058df2:	83 c4 20             	add    $0x20,%esp
 8058df5:	83 f8 4f             	cmp    $0x4f,%eax
 8058df8:	7f 0e                	jg     8058e08 <mov_a2moffs_w+0x58>
	return 5;
}
 8058dfa:	83 c4 08             	add    $0x8,%esp
 8058dfd:	b8 05 00 00 00       	mov    $0x5,%eax
 8058e02:	5b                   	pop    %ebx
 8058e03:	c3                   	ret    
 8058e04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

make_helper(concat(mov_a2moffs_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	MEM_W(addr, REG(R_EAX));

	print_asm("mov" str(SUFFIX) " %%%s,0x%x", REG_NAME(R_EAX), addr);
 8058e08:	83 ec 0c             	sub    $0xc,%esp
 8058e0b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8058e11:	e8 4a fb fe ff       	call   8048960 <fflush@plt>
 8058e16:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058e1c:	6a 07                	push   $0x7
 8058e1e:	6a 01                	push   $0x1
 8058e20:	68 92 ed 05 08       	push   $0x805ed92
 8058e25:	e8 e6 fb fe ff       	call   8048a10 <fwrite@plt>
 8058e2a:	83 c4 20             	add    $0x20,%esp
 8058e2d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058e33:	6a 10                	push   $0x10
 8058e35:	6a 01                	push   $0x1
 8058e37:	68 84 f8 05 08       	push   $0x805f884
 8058e3c:	e8 cf fb fe ff       	call   8048a10 <fwrite@plt>
 8058e41:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058e47:	6a 05                	push   $0x5
 8058e49:	6a 01                	push   $0x1
 8058e4b:	68 b1 ed 05 08       	push   $0x805edb1
 8058e50:	e8 bb fb fe ff       	call   8048a10 <fwrite@plt>
 8058e55:	83 c4 14             	add    $0x14,%esp
 8058e58:	53                   	push   %ebx
 8058e59:	ff 35 a0 5b 07 08    	pushl  0x8075ba0
 8058e5f:	68 de 47 06 08       	push   $0x80647de
 8058e64:	6a 50                	push   $0x50
 8058e66:	68 00 89 0c 08       	push   $0x80c8900
 8058e6b:	e8 90 fc fe ff       	call   8048b00 <snprintf@plt>
 8058e70:	83 c4 20             	add    $0x20,%esp
 8058e73:	83 f8 4f             	cmp    $0x4f,%eax
 8058e76:	7e 82                	jle    8058dfa <mov_a2moffs_w+0x4a>
 8058e78:	68 ac 4b 06 08       	push   $0x8064bac
 8058e7d:	6a 13                	push   $0x13
 8058e7f:	68 5c 48 06 08       	push   $0x806485c
 8058e84:	68 88 48 06 08       	push   $0x8064888
 8058e89:	e8 22 fd fe ff       	call   8048bb0 <__assert_fail@plt>
 8058e8e:	66 90                	xchg   %ax,%ax

08058e90 <mov_a2moffs_l>:
make_instr_helper(i2r)
make_instr_helper(i2rm)
make_instr_helper(r2rm)
make_instr_helper(rm2r)

make_helper(concat(mov_a2moffs_, SUFFIX)) {
 8058e90:	53                   	push   %ebx
 8058e91:	83 ec 10             	sub    $0x10,%esp
 8058e94:	6a 04                	push   $0x4
	swaddr_t addr = instr_fetch(eip + 1, 4);
 8058e96:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058e9a:	83 c0 01             	add    $0x1,%eax
 8058e9d:	50                   	push   %eax
 8058e9e:	e8 bd 20 ff ff       	call   804af60 <swaddr_read>
	MEM_W(addr, REG(R_EAX));
 8058ea3:	83 c4 0c             	add    $0xc,%esp
 8058ea6:	ff 35 c0 ae 8f 14    	pushl  0x148faec0
 8058eac:	89 c3                	mov    %eax,%ebx
 8058eae:	6a 04                	push   $0x4
 8058eb0:	50                   	push   %eax
 8058eb1:	e8 fa 20 ff ff       	call   804afb0 <swaddr_write>

	print_asm("mov" str(SUFFIX) " %%%s,0x%x", REG_NAME(R_EAX), addr);
 8058eb6:	89 1c 24             	mov    %ebx,(%esp)
 8058eb9:	ff 35 c0 5b 07 08    	pushl  0x8075bc0
 8058ebf:	68 ed 47 06 08       	push   $0x80647ed
 8058ec4:	6a 50                	push   $0x50
 8058ec6:	68 00 89 0c 08       	push   $0x80c8900
 8058ecb:	e8 30 fc fe ff       	call   8048b00 <snprintf@plt>
 8058ed0:	83 c4 20             	add    $0x20,%esp
 8058ed3:	83 f8 4f             	cmp    $0x4f,%eax
 8058ed6:	7f 10                	jg     8058ee8 <mov_a2moffs_l+0x58>
	return 5;
}
 8058ed8:	83 c4 08             	add    $0x8,%esp
 8058edb:	b8 05 00 00 00       	mov    $0x5,%eax
 8058ee0:	5b                   	pop    %ebx
 8058ee1:	c3                   	ret    
 8058ee2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

make_helper(concat(mov_a2moffs_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	MEM_W(addr, REG(R_EAX));

	print_asm("mov" str(SUFFIX) " %%%s,0x%x", REG_NAME(R_EAX), addr);
 8058ee8:	83 ec 0c             	sub    $0xc,%esp
 8058eeb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8058ef1:	e8 6a fa fe ff       	call   8048960 <fflush@plt>
 8058ef6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058efc:	6a 07                	push   $0x7
 8058efe:	6a 01                	push   $0x1
 8058f00:	68 92 ed 05 08       	push   $0x805ed92
 8058f05:	e8 06 fb fe ff       	call   8048a10 <fwrite@plt>
 8058f0a:	83 c4 20             	add    $0x20,%esp
 8058f0d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058f13:	6a 10                	push   $0x10
 8058f15:	6a 01                	push   $0x1
 8058f17:	68 84 f8 05 08       	push   $0x805f884
 8058f1c:	e8 ef fa fe ff       	call   8048a10 <fwrite@plt>
 8058f21:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058f27:	6a 05                	push   $0x5
 8058f29:	6a 01                	push   $0x1
 8058f2b:	68 b1 ed 05 08       	push   $0x805edb1
 8058f30:	e8 db fa fe ff       	call   8048a10 <fwrite@plt>
 8058f35:	83 c4 14             	add    $0x14,%esp
 8058f38:	53                   	push   %ebx
 8058f39:	ff 35 c0 5b 07 08    	pushl  0x8075bc0
 8058f3f:	68 ed 47 06 08       	push   $0x80647ed
 8058f44:	6a 50                	push   $0x50
 8058f46:	68 00 89 0c 08       	push   $0x80c8900
 8058f4b:	e8 b0 fb fe ff       	call   8048b00 <snprintf@plt>
 8058f50:	83 c4 20             	add    $0x20,%esp
 8058f53:	83 f8 4f             	cmp    $0x4f,%eax
 8058f56:	7e 80                	jle    8058ed8 <mov_a2moffs_l+0x48>
 8058f58:	68 87 4b 06 08       	push   $0x8064b87
 8058f5d:	6a 13                	push   $0x13
 8058f5f:	68 5c 48 06 08       	push   $0x806485c
 8058f64:	68 d4 48 06 08       	push   $0x80648d4
 8058f69:	e8 42 fc fe ff       	call   8048bb0 <__assert_fail@plt>
 8058f6e:	66 90                	xchg   %ax,%ax

08058f70 <mov_moffs2a_w>:
	return 5;
}

make_helper(concat(mov_moffs2a_, SUFFIX)) {
 8058f70:	53                   	push   %ebx
 8058f71:	83 ec 10             	sub    $0x10,%esp
 8058f74:	6a 04                	push   $0x4
	swaddr_t addr = instr_fetch(eip + 1, 4);
 8058f76:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058f7a:	83 c0 01             	add    $0x1,%eax
 8058f7d:	50                   	push   %eax
 8058f7e:	e8 dd 1f ff ff       	call   804af60 <swaddr_read>
 8058f83:	89 c3                	mov    %eax,%ebx
	REG(R_EAX) = MEM_R(addr);
 8058f85:	58                   	pop    %eax
 8058f86:	5a                   	pop    %edx
 8058f87:	6a 02                	push   $0x2
 8058f89:	53                   	push   %ebx
 8058f8a:	e8 d1 1f ff ff       	call   804af60 <swaddr_read>

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 8058f8f:	59                   	pop    %ecx
 8058f90:	ff 35 a0 5b 07 08    	pushl  0x8075ba0
 8058f96:	53                   	push   %ebx
 8058f97:	68 fc 47 06 08       	push   $0x80647fc
 8058f9c:	6a 50                	push   $0x50
 8058f9e:	68 00 89 0c 08       	push   $0x80c8900
	return 5;
}

make_helper(concat(mov_moffs2a_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	REG(R_EAX) = MEM_R(addr);
 8058fa3:	66 a3 c0 ae 8f 14    	mov    %ax,0x148faec0

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 8058fa9:	e8 52 fb fe ff       	call   8048b00 <snprintf@plt>
 8058fae:	83 c4 20             	add    $0x20,%esp
 8058fb1:	83 f8 4f             	cmp    $0x4f,%eax
 8058fb4:	7f 0a                	jg     8058fc0 <mov_moffs2a_w+0x50>
	return 5;
}
 8058fb6:	83 c4 08             	add    $0x8,%esp
 8058fb9:	b8 05 00 00 00       	mov    $0x5,%eax
 8058fbe:	5b                   	pop    %ebx
 8058fbf:	c3                   	ret    

make_helper(concat(mov_moffs2a_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	REG(R_EAX) = MEM_R(addr);

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 8058fc0:	83 ec 0c             	sub    $0xc,%esp
 8058fc3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8058fc9:	e8 92 f9 fe ff       	call   8048960 <fflush@plt>
 8058fce:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058fd4:	6a 07                	push   $0x7
 8058fd6:	6a 01                	push   $0x1
 8058fd8:	68 92 ed 05 08       	push   $0x805ed92
 8058fdd:	e8 2e fa fe ff       	call   8048a10 <fwrite@plt>
 8058fe2:	83 c4 20             	add    $0x20,%esp
 8058fe5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058feb:	6a 10                	push   $0x10
 8058fed:	6a 01                	push   $0x1
 8058fef:	68 84 f8 05 08       	push   $0x805f884
 8058ff4:	e8 17 fa fe ff       	call   8048a10 <fwrite@plt>
 8058ff9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8058fff:	6a 05                	push   $0x5
 8059001:	6a 01                	push   $0x1
 8059003:	68 b1 ed 05 08       	push   $0x805edb1
 8059008:	e8 03 fa fe ff       	call   8048a10 <fwrite@plt>
 805900d:	83 c4 14             	add    $0x14,%esp
 8059010:	ff 35 a0 5b 07 08    	pushl  0x8075ba0
 8059016:	53                   	push   %ebx
 8059017:	68 fc 47 06 08       	push   $0x80647fc
 805901c:	6a 50                	push   $0x50
 805901e:	68 00 89 0c 08       	push   $0x80c8900
 8059023:	e8 d8 fa fe ff       	call   8048b00 <snprintf@plt>
 8059028:	83 c4 20             	add    $0x20,%esp
 805902b:	83 f8 4f             	cmp    $0x4f,%eax
 805902e:	7e 86                	jle    8058fb6 <mov_moffs2a_w+0x46>
 8059030:	68 9e 4b 06 08       	push   $0x8064b9e
 8059035:	6a 1b                	push   $0x1b
 8059037:	68 5c 48 06 08       	push   $0x806485c
 805903c:	68 20 49 06 08       	push   $0x8064920
 8059041:	e8 6a fb fe ff       	call   8048bb0 <__assert_fail@plt>
 8059046:	8d 76 00             	lea    0x0(%esi),%esi
 8059049:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08059050 <mov_moffs2a_l>:

	print_asm("mov" str(SUFFIX) " %%%s,0x%x", REG_NAME(R_EAX), addr);
	return 5;
}

make_helper(concat(mov_moffs2a_, SUFFIX)) {
 8059050:	53                   	push   %ebx
 8059051:	83 ec 10             	sub    $0x10,%esp
 8059054:	6a 04                	push   $0x4
	swaddr_t addr = instr_fetch(eip + 1, 4);
 8059056:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805905a:	83 c0 01             	add    $0x1,%eax
 805905d:	50                   	push   %eax
 805905e:	e8 fd 1e ff ff       	call   804af60 <swaddr_read>
 8059063:	89 c3                	mov    %eax,%ebx
	REG(R_EAX) = MEM_R(addr);
 8059065:	58                   	pop    %eax
 8059066:	5a                   	pop    %edx
 8059067:	6a 04                	push   $0x4
 8059069:	53                   	push   %ebx
 805906a:	e8 f1 1e ff ff       	call   804af60 <swaddr_read>

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 805906f:	59                   	pop    %ecx
 8059070:	ff 35 c0 5b 07 08    	pushl  0x8075bc0
 8059076:	53                   	push   %ebx
 8059077:	68 0b 48 06 08       	push   $0x806480b
 805907c:	6a 50                	push   $0x50
 805907e:	68 00 89 0c 08       	push   $0x80c8900
	return 5;
}

make_helper(concat(mov_moffs2a_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	REG(R_EAX) = MEM_R(addr);
 8059083:	a3 c0 ae 8f 14       	mov    %eax,0x148faec0

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 8059088:	e8 73 fa fe ff       	call   8048b00 <snprintf@plt>
 805908d:	83 c4 20             	add    $0x20,%esp
 8059090:	83 f8 4f             	cmp    $0x4f,%eax
 8059093:	7f 0b                	jg     80590a0 <mov_moffs2a_l+0x50>
	return 5;
}
 8059095:	83 c4 08             	add    $0x8,%esp
 8059098:	b8 05 00 00 00       	mov    $0x5,%eax
 805909d:	5b                   	pop    %ebx
 805909e:	c3                   	ret    
 805909f:	90                   	nop

make_helper(concat(mov_moffs2a_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	REG(R_EAX) = MEM_R(addr);

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 80590a0:	83 ec 0c             	sub    $0xc,%esp
 80590a3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 80590a9:	e8 b2 f8 fe ff       	call   8048960 <fflush@plt>
 80590ae:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80590b4:	6a 07                	push   $0x7
 80590b6:	6a 01                	push   $0x1
 80590b8:	68 92 ed 05 08       	push   $0x805ed92
 80590bd:	e8 4e f9 fe ff       	call   8048a10 <fwrite@plt>
 80590c2:	83 c4 20             	add    $0x20,%esp
 80590c5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80590cb:	6a 10                	push   $0x10
 80590cd:	6a 01                	push   $0x1
 80590cf:	68 84 f8 05 08       	push   $0x805f884
 80590d4:	e8 37 f9 fe ff       	call   8048a10 <fwrite@plt>
 80590d9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80590df:	6a 05                	push   $0x5
 80590e1:	6a 01                	push   $0x1
 80590e3:	68 b1 ed 05 08       	push   $0x805edb1
 80590e8:	e8 23 f9 fe ff       	call   8048a10 <fwrite@plt>
 80590ed:	83 c4 14             	add    $0x14,%esp
 80590f0:	ff 35 c0 5b 07 08    	pushl  0x8075bc0
 80590f6:	53                   	push   %ebx
 80590f7:	68 0b 48 06 08       	push   $0x806480b
 80590fc:	6a 50                	push   $0x50
 80590fe:	68 00 89 0c 08       	push   $0x80c8900
 8059103:	e8 f8 f9 fe ff       	call   8048b00 <snprintf@plt>
 8059108:	83 c4 20             	add    $0x20,%esp
 805910b:	83 f8 4f             	cmp    $0x4f,%eax
 805910e:	7e 85                	jle    8059095 <mov_moffs2a_l+0x45>
 8059110:	68 79 4b 06 08       	push   $0x8064b79
 8059115:	6a 1b                	push   $0x1b
 8059117:	68 5c 48 06 08       	push   $0x806485c
 805911c:	68 6c 49 06 08       	push   $0x806496c
 8059121:	e8 8a fa fe ff       	call   8048bb0 <__assert_fail@plt>
 8059126:	8d 76 00             	lea    0x0(%esi),%esi
 8059129:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08059130 <do_mov_b>:
#include "cpu/exec/template-start.h"

#define instr mov

static void do_execute() {
 8059130:	83 ec 14             	sub    $0x14,%esp
 8059133:	0f b6 05 14 ae 8f 14 	movzbl 0x148fae14,%eax
	OPERAND_W(op_dest, op_src->val);
 805913a:	50                   	push   %eax
 805913b:	68 40 ae 8f 14       	push   $0x148fae40
 8059140:	e8 fb 3a 00 00       	call   805cc40 <write_operand_b>
	print_asm_template2();
 8059145:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 805914c:	68 18 ae 8f 14       	push   $0x148fae18
 8059151:	68 1a 48 06 08       	push   $0x806481a
 8059156:	6a 50                	push   $0x50
 8059158:	68 00 89 0c 08       	push   $0x80c8900
 805915d:	e8 9e f9 fe ff       	call   8048b00 <snprintf@plt>
 8059162:	83 c4 20             	add    $0x20,%esp
 8059165:	83 f8 4f             	cmp    $0x4f,%eax
 8059168:	7f 06                	jg     8059170 <do_mov_b+0x40>
}
 805916a:	83 c4 0c             	add    $0xc,%esp
 805916d:	c3                   	ret    
 805916e:	66 90                	xchg   %ax,%ax

#define instr mov

static void do_execute() {
	OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8059170:	83 ec 0c             	sub    $0xc,%esp
 8059173:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8059179:	e8 e2 f7 fe ff       	call   8048960 <fflush@plt>
 805917e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059184:	6a 07                	push   $0x7
 8059186:	6a 01                	push   $0x1
 8059188:	68 92 ed 05 08       	push   $0x805ed92
 805918d:	e8 7e f8 fe ff       	call   8048a10 <fwrite@plt>
 8059192:	83 c4 20             	add    $0x20,%esp
 8059195:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805919b:	6a 10                	push   $0x10
 805919d:	6a 01                	push   $0x1
 805919f:	68 84 f8 05 08       	push   $0x805f884
 80591a4:	e8 67 f8 fe ff       	call   8048a10 <fwrite@plt>
 80591a9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80591af:	6a 05                	push   $0x5
 80591b1:	6a 01                	push   $0x1
 80591b3:	68 b1 ed 05 08       	push   $0x805edb1
 80591b8:	e8 53 f8 fe ff       	call   8048a10 <fwrite@plt>
 80591bd:	83 c4 14             	add    $0x14,%esp
 80591c0:	68 50 ae 8f 14       	push   $0x148fae50
 80591c5:	68 18 ae 8f 14       	push   $0x148fae18
 80591ca:	68 1a 48 06 08       	push   $0x806481a
 80591cf:	6a 50                	push   $0x50
 80591d1:	68 00 89 0c 08       	push   $0x80c8900
 80591d6:	e8 25 f9 fe ff       	call   8048b00 <snprintf@plt>
 80591db:	83 c4 20             	add    $0x20,%esp
 80591de:	83 f8 4f             	cmp    $0x4f,%eax
 80591e1:	7e 87                	jle    805916a <do_mov_b+0x3a>
 80591e3:	68 df 4b 06 08       	push   $0x8064bdf
 80591e8:	6a 07                	push   $0x7
 80591ea:	68 5c 48 06 08       	push   $0x806485c
 80591ef:	68 b8 49 06 08       	push   $0x80649b8
 80591f4:	e8 b7 f9 fe ff       	call   8048bb0 <__assert_fail@plt>
 80591f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08059200 <do_mov_w>:
#include "cpu/exec/template-start.h"

#define instr mov

static void do_execute() {
 8059200:	83 ec 14             	sub    $0x14,%esp
 8059203:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
	OPERAND_W(op_dest, op_src->val);
 805920a:	50                   	push   %eax
 805920b:	68 40 ae 8f 14       	push   $0x148fae40
 8059210:	e8 bb 3d 00 00       	call   805cfd0 <write_operand_w>
	print_asm_template2();
 8059215:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 805921c:	68 18 ae 8f 14       	push   $0x148fae18
 8059221:	68 25 48 06 08       	push   $0x8064825
 8059226:	6a 50                	push   $0x50
 8059228:	68 00 89 0c 08       	push   $0x80c8900
 805922d:	e8 ce f8 fe ff       	call   8048b00 <snprintf@plt>
 8059232:	83 c4 20             	add    $0x20,%esp
 8059235:	83 f8 4f             	cmp    $0x4f,%eax
 8059238:	7f 06                	jg     8059240 <do_mov_w+0x40>
}
 805923a:	83 c4 0c             	add    $0xc,%esp
 805923d:	c3                   	ret    
 805923e:	66 90                	xchg   %ax,%ax

#define instr mov

static void do_execute() {
	OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8059240:	83 ec 0c             	sub    $0xc,%esp
 8059243:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8059249:	e8 12 f7 fe ff       	call   8048960 <fflush@plt>
 805924e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059254:	6a 07                	push   $0x7
 8059256:	6a 01                	push   $0x1
 8059258:	68 92 ed 05 08       	push   $0x805ed92
 805925d:	e8 ae f7 fe ff       	call   8048a10 <fwrite@plt>
 8059262:	83 c4 20             	add    $0x20,%esp
 8059265:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805926b:	6a 10                	push   $0x10
 805926d:	6a 01                	push   $0x1
 805926f:	68 84 f8 05 08       	push   $0x805f884
 8059274:	e8 97 f7 fe ff       	call   8048a10 <fwrite@plt>
 8059279:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805927f:	6a 05                	push   $0x5
 8059281:	6a 01                	push   $0x1
 8059283:	68 b1 ed 05 08       	push   $0x805edb1
 8059288:	e8 83 f7 fe ff       	call   8048a10 <fwrite@plt>
 805928d:	83 c4 14             	add    $0x14,%esp
 8059290:	68 50 ae 8f 14       	push   $0x148fae50
 8059295:	68 18 ae 8f 14       	push   $0x148fae18
 805929a:	68 25 48 06 08       	push   $0x8064825
 805929f:	6a 50                	push   $0x50
 80592a1:	68 00 89 0c 08       	push   $0x80c8900
 80592a6:	e8 55 f8 fe ff       	call   8048b00 <snprintf@plt>
 80592ab:	83 c4 20             	add    $0x20,%esp
 80592ae:	83 f8 4f             	cmp    $0x4f,%eax
 80592b1:	7e 87                	jle    805923a <do_mov_w+0x3a>
 80592b3:	68 ba 4b 06 08       	push   $0x8064bba
 80592b8:	6a 07                	push   $0x7
 80592ba:	68 5c 48 06 08       	push   $0x806485c
 80592bf:	68 1c 4a 06 08       	push   $0x8064a1c
 80592c4:	e8 e7 f8 fe ff       	call   8048bb0 <__assert_fail@plt>
 80592c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

080592d0 <mov_i2r_w>:
}

make_instr_helper(i2r)
 80592d0:	53                   	push   %ebx
 80592d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80592d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80592d8:	83 c0 01             	add    $0x1,%eax
 80592db:	50                   	push   %eax
 80592dc:	e8 5f 3b 00 00       	call   805ce40 <decode_i2r_w>
 80592e1:	89 c3                	mov    %eax,%ebx
	execute();
 80592e3:	e8 18 ff ff ff       	call   8059200 <do_mov_w>
 80592e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80592eb:	8d 43 01             	lea    0x1(%ebx),%eax
 80592ee:	5b                   	pop    %ebx
 80592ef:	c3                   	ret    

080592f0 <mov_i2rm_w>:
make_instr_helper(i2rm)
 80592f0:	53                   	push   %ebx
 80592f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80592f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80592f8:	83 c0 01             	add    $0x1,%eax
 80592fb:	50                   	push   %eax
 80592fc:	e8 0f 3b 00 00       	call   805ce10 <decode_i2rm_w>
 8059301:	89 c3                	mov    %eax,%ebx
	execute();
 8059303:	e8 f8 fe ff ff       	call   8059200 <do_mov_w>
 8059308:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805930b:	8d 43 01             	lea    0x1(%ebx),%eax
 805930e:	5b                   	pop    %ebx
 805930f:	c3                   	ret    

08059310 <mov_r2rm_w>:
make_instr_helper(r2rm)
 8059310:	53                   	push   %ebx
 8059311:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059314:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059318:	83 c0 01             	add    $0x1,%eax
 805931b:	50                   	push   %eax
 805931c:	e8 2f 3a 00 00       	call   805cd50 <decode_r2rm_w>
 8059321:	89 c3                	mov    %eax,%ebx
	execute();
 8059323:	e8 d8 fe ff ff       	call   8059200 <do_mov_w>
 8059328:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805932b:	8d 43 01             	lea    0x1(%ebx),%eax
 805932e:	5b                   	pop    %ebx
 805932f:	c3                   	ret    

08059330 <mov_rm2r_w>:
make_instr_helper(rm2r)
 8059330:	53                   	push   %ebx
 8059331:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059334:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059338:	83 c0 01             	add    $0x1,%eax
 805933b:	50                   	push   %eax
 805933c:	e8 2f 3a 00 00       	call   805cd70 <decode_rm2r_w>
 8059341:	89 c3                	mov    %eax,%ebx
	execute();
 8059343:	e8 b8 fe ff ff       	call   8059200 <do_mov_w>
 8059348:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805934b:	8d 43 01             	lea    0x1(%ebx),%eax
 805934e:	5b                   	pop    %ebx
 805934f:	c3                   	ret    

08059350 <do_mov_l>:
#include "cpu/exec/template-start.h"

#define instr mov

static void do_execute() {
 8059350:	83 ec 14             	sub    $0x14,%esp
	OPERAND_W(op_dest, op_src->val);
 8059353:	ff 35 14 ae 8f 14    	pushl  0x148fae14
 8059359:	68 40 ae 8f 14       	push   $0x148fae40
 805935e:	e8 3d 40 00 00       	call   805d3a0 <write_operand_l>
	print_asm_template2();
 8059363:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 805936a:	68 18 ae 8f 14       	push   $0x148fae18
 805936f:	68 30 48 06 08       	push   $0x8064830
 8059374:	6a 50                	push   $0x50
 8059376:	68 00 89 0c 08       	push   $0x80c8900
 805937b:	e8 80 f7 fe ff       	call   8048b00 <snprintf@plt>
 8059380:	83 c4 20             	add    $0x20,%esp
 8059383:	83 f8 4f             	cmp    $0x4f,%eax
 8059386:	7f 08                	jg     8059390 <do_mov_l+0x40>
}
 8059388:	83 c4 0c             	add    $0xc,%esp
 805938b:	c3                   	ret    
 805938c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

#define instr mov

static void do_execute() {
	OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8059390:	83 ec 0c             	sub    $0xc,%esp
 8059393:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8059399:	e8 c2 f5 fe ff       	call   8048960 <fflush@plt>
 805939e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80593a4:	6a 07                	push   $0x7
 80593a6:	6a 01                	push   $0x1
 80593a8:	68 92 ed 05 08       	push   $0x805ed92
 80593ad:	e8 5e f6 fe ff       	call   8048a10 <fwrite@plt>
 80593b2:	83 c4 20             	add    $0x20,%esp
 80593b5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80593bb:	6a 10                	push   $0x10
 80593bd:	6a 01                	push   $0x1
 80593bf:	68 84 f8 05 08       	push   $0x805f884
 80593c4:	e8 47 f6 fe ff       	call   8048a10 <fwrite@plt>
 80593c9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80593cf:	6a 05                	push   $0x5
 80593d1:	6a 01                	push   $0x1
 80593d3:	68 b1 ed 05 08       	push   $0x805edb1
 80593d8:	e8 33 f6 fe ff       	call   8048a10 <fwrite@plt>
 80593dd:	83 c4 14             	add    $0x14,%esp
 80593e0:	68 50 ae 8f 14       	push   $0x148fae50
 80593e5:	68 18 ae 8f 14       	push   $0x148fae18
 80593ea:	68 30 48 06 08       	push   $0x8064830
 80593ef:	6a 50                	push   $0x50
 80593f1:	68 00 89 0c 08       	push   $0x80c8900
 80593f6:	e8 05 f7 fe ff       	call   8048b00 <snprintf@plt>
 80593fb:	83 c4 20             	add    $0x20,%esp
 80593fe:	83 f8 4f             	cmp    $0x4f,%eax
 8059401:	7e 85                	jle    8059388 <do_mov_l+0x38>
 8059403:	68 95 4b 06 08       	push   $0x8064b95
 8059408:	6a 07                	push   $0x7
 805940a:	68 5c 48 06 08       	push   $0x806485c
 805940f:	68 80 4a 06 08       	push   $0x8064a80
 8059414:	e8 97 f7 fe ff       	call   8048bb0 <__assert_fail@plt>
 8059419:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08059420 <mov_i2r_l>:
}

make_instr_helper(i2r)
 8059420:	53                   	push   %ebx
 8059421:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059424:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059428:	83 c0 01             	add    $0x1,%eax
 805942b:	50                   	push   %eax
 805942c:	e8 df 3d 00 00       	call   805d210 <decode_i2r_l>
 8059431:	89 c3                	mov    %eax,%ebx
	execute();
 8059433:	e8 18 ff ff ff       	call   8059350 <do_mov_l>
 8059438:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805943b:	8d 43 01             	lea    0x1(%ebx),%eax
 805943e:	5b                   	pop    %ebx
 805943f:	c3                   	ret    

08059440 <mov_i2rm_l>:
make_instr_helper(i2rm)
 8059440:	53                   	push   %ebx
 8059441:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059444:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059448:	83 c0 01             	add    $0x1,%eax
 805944b:	50                   	push   %eax
 805944c:	e8 8f 3d 00 00       	call   805d1e0 <decode_i2rm_l>
 8059451:	89 c3                	mov    %eax,%ebx
	execute();
 8059453:	e8 f8 fe ff ff       	call   8059350 <do_mov_l>
 8059458:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805945b:	8d 43 01             	lea    0x1(%ebx),%eax
 805945e:	5b                   	pop    %ebx
 805945f:	c3                   	ret    

08059460 <mov_r2rm_l>:
make_instr_helper(r2rm)
 8059460:	53                   	push   %ebx
 8059461:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059464:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059468:	83 c0 01             	add    $0x1,%eax
 805946b:	50                   	push   %eax
 805946c:	e8 af 3c 00 00       	call   805d120 <decode_r2rm_l>
 8059471:	89 c3                	mov    %eax,%ebx
	execute();
 8059473:	e8 d8 fe ff ff       	call   8059350 <do_mov_l>
 8059478:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805947b:	8d 43 01             	lea    0x1(%ebx),%eax
 805947e:	5b                   	pop    %ebx
 805947f:	c3                   	ret    

08059480 <mov_rm2r_l>:
make_instr_helper(rm2r)
 8059480:	53                   	push   %ebx
 8059481:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059484:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059488:	83 c0 01             	add    $0x1,%eax
 805948b:	50                   	push   %eax
 805948c:	e8 af 3c 00 00       	call   805d140 <decode_rm2r_l>
 8059491:	89 c3                	mov    %eax,%ebx
	execute();
 8059493:	e8 b8 fe ff ff       	call   8059350 <do_mov_l>
 8059498:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805949b:	8d 43 01             	lea    0x1(%ebx),%eax
 805949e:	5b                   	pop    %ebx
 805949f:	c3                   	ret    

080594a0 <mov_i2r_b>:
static void do_execute() {
	OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
}

make_instr_helper(i2r)
 80594a0:	53                   	push   %ebx
 80594a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80594a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80594a8:	83 c0 01             	add    $0x1,%eax
 80594ab:	50                   	push   %eax
 80594ac:	e8 5f 36 00 00       	call   805cb10 <decode_i2r_b>
 80594b1:	89 c3                	mov    %eax,%ebx
	execute();
 80594b3:	e8 78 fc ff ff       	call   8059130 <do_mov_b>
 80594b8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80594bb:	8d 43 01             	lea    0x1(%ebx),%eax
 80594be:	5b                   	pop    %ebx
 80594bf:	c3                   	ret    

080594c0 <mov_i2rm_b>:
make_instr_helper(i2rm)
 80594c0:	53                   	push   %ebx
 80594c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80594c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80594c8:	83 c0 01             	add    $0x1,%eax
 80594cb:	50                   	push   %eax
 80594cc:	e8 0f 36 00 00       	call   805cae0 <decode_i2rm_b>
 80594d1:	89 c3                	mov    %eax,%ebx
	execute();
 80594d3:	e8 58 fc ff ff       	call   8059130 <do_mov_b>
 80594d8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80594db:	8d 43 01             	lea    0x1(%ebx),%eax
 80594de:	5b                   	pop    %ebx
 80594df:	c3                   	ret    

080594e0 <mov_r2rm_b>:
make_instr_helper(r2rm)
 80594e0:	53                   	push   %ebx
 80594e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80594e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80594e8:	83 c0 01             	add    $0x1,%eax
 80594eb:	50                   	push   %eax
 80594ec:	e8 2f 35 00 00       	call   805ca20 <decode_r2rm_b>
 80594f1:	89 c3                	mov    %eax,%ebx
	execute();
 80594f3:	e8 38 fc ff ff       	call   8059130 <do_mov_b>
 80594f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80594fb:	8d 43 01             	lea    0x1(%ebx),%eax
 80594fe:	5b                   	pop    %ebx
 80594ff:	c3                   	ret    

08059500 <mov_rm2r_b>:
make_instr_helper(rm2r)
 8059500:	53                   	push   %ebx
 8059501:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059504:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059508:	83 c0 01             	add    $0x1,%eax
 805950b:	50                   	push   %eax
 805950c:	e8 2f 35 00 00       	call   805ca40 <decode_rm2r_b>
 8059511:	89 c3                	mov    %eax,%ebx
	execute();
 8059513:	e8 18 fc ff ff       	call   8059130 <do_mov_b>
 8059518:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805951b:	8d 43 01             	lea    0x1(%ebx),%eax
 805951e:	5b                   	pop    %ebx
 805951f:	c3                   	ret    

08059520 <mov_a2moffs_b>:

make_helper(concat(mov_a2moffs_, SUFFIX)) {
 8059520:	53                   	push   %ebx
 8059521:	83 ec 10             	sub    $0x10,%esp

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 8059524:	6a 04                	push   $0x4
	swaddr_t addr = instr_fetch(eip + 1, 4);
 8059526:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805952a:	83 c0 01             	add    $0x1,%eax
 805952d:	50                   	push   %eax
 805952e:	e8 2d 1a ff ff       	call   804af60 <swaddr_read>
 8059533:	89 c3                	mov    %eax,%ebx
	MEM_W(addr, REG(R_EAX));
 8059535:	0f b6 05 c0 ae 8f 14 	movzbl 0x148faec0,%eax
 805953c:	83 c4 0c             	add    $0xc,%esp
 805953f:	50                   	push   %eax
 8059540:	6a 01                	push   $0x1
 8059542:	53                   	push   %ebx
 8059543:	e8 68 1a ff ff       	call   804afb0 <swaddr_write>

	print_asm("mov" str(SUFFIX) " %%%s,0x%x", REG_NAME(R_EAX), addr);
 8059548:	89 1c 24             	mov    %ebx,(%esp)
 805954b:	ff 35 80 5b 07 08    	pushl  0x8075b80
 8059551:	68 3b 48 06 08       	push   $0x806483b
 8059556:	6a 50                	push   $0x50
 8059558:	68 00 89 0c 08       	push   $0x80c8900
 805955d:	e8 9e f5 fe ff       	call   8048b00 <snprintf@plt>
 8059562:	83 c4 20             	add    $0x20,%esp
 8059565:	83 f8 4f             	cmp    $0x4f,%eax
 8059568:	7f 0e                	jg     8059578 <mov_a2moffs_b+0x58>
	return 5;
}
 805956a:	83 c4 08             	add    $0x8,%esp
 805956d:	b8 05 00 00 00       	mov    $0x5,%eax
 8059572:	5b                   	pop    %ebx
 8059573:	c3                   	ret    
 8059574:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

make_helper(concat(mov_a2moffs_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	MEM_W(addr, REG(R_EAX));

	print_asm("mov" str(SUFFIX) " %%%s,0x%x", REG_NAME(R_EAX), addr);
 8059578:	83 ec 0c             	sub    $0xc,%esp
 805957b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8059581:	e8 da f3 fe ff       	call   8048960 <fflush@plt>
 8059586:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805958c:	6a 07                	push   $0x7
 805958e:	6a 01                	push   $0x1
 8059590:	68 92 ed 05 08       	push   $0x805ed92
 8059595:	e8 76 f4 fe ff       	call   8048a10 <fwrite@plt>
 805959a:	83 c4 20             	add    $0x20,%esp
 805959d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80595a3:	6a 10                	push   $0x10
 80595a5:	6a 01                	push   $0x1
 80595a7:	68 84 f8 05 08       	push   $0x805f884
 80595ac:	e8 5f f4 fe ff       	call   8048a10 <fwrite@plt>
 80595b1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80595b7:	6a 05                	push   $0x5
 80595b9:	6a 01                	push   $0x1
 80595bb:	68 b1 ed 05 08       	push   $0x805edb1
 80595c0:	e8 4b f4 fe ff       	call   8048a10 <fwrite@plt>
 80595c5:	83 c4 14             	add    $0x14,%esp
 80595c8:	53                   	push   %ebx
 80595c9:	ff 35 80 5b 07 08    	pushl  0x8075b80
 80595cf:	68 3b 48 06 08       	push   $0x806483b
 80595d4:	6a 50                	push   $0x50
 80595d6:	68 00 89 0c 08       	push   $0x80c8900
 80595db:	e8 20 f5 fe ff       	call   8048b00 <snprintf@plt>
 80595e0:	83 c4 20             	add    $0x20,%esp
 80595e3:	83 f8 4f             	cmp    $0x4f,%eax
 80595e6:	7e 82                	jle    805956a <mov_a2moffs_b+0x4a>
 80595e8:	68 d1 4b 06 08       	push   $0x8064bd1
 80595ed:	6a 13                	push   $0x13
 80595ef:	68 5c 48 06 08       	push   $0x806485c
 80595f4:	68 e4 4a 06 08       	push   $0x8064ae4
 80595f9:	e8 b2 f5 fe ff       	call   8048bb0 <__assert_fail@plt>
 80595fe:	66 90                	xchg   %ax,%ax

08059600 <mov_moffs2a_b>:
	return 5;
}

make_helper(concat(mov_moffs2a_, SUFFIX)) {
 8059600:	53                   	push   %ebx
 8059601:	83 ec 10             	sub    $0x10,%esp
 8059604:	6a 04                	push   $0x4
	swaddr_t addr = instr_fetch(eip + 1, 4);
 8059606:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805960a:	83 c0 01             	add    $0x1,%eax
 805960d:	50                   	push   %eax
 805960e:	e8 4d 19 ff ff       	call   804af60 <swaddr_read>
 8059613:	89 c3                	mov    %eax,%ebx
	REG(R_EAX) = MEM_R(addr);
 8059615:	58                   	pop    %eax
 8059616:	5a                   	pop    %edx
 8059617:	6a 01                	push   $0x1
 8059619:	53                   	push   %ebx
 805961a:	e8 41 19 ff ff       	call   804af60 <swaddr_read>

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 805961f:	59                   	pop    %ecx
 8059620:	ff 35 80 5b 07 08    	pushl  0x8075b80
 8059626:	53                   	push   %ebx
 8059627:	68 4a 48 06 08       	push   $0x806484a
 805962c:	6a 50                	push   $0x50
 805962e:	68 00 89 0c 08       	push   $0x80c8900
	return 5;
}

make_helper(concat(mov_moffs2a_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	REG(R_EAX) = MEM_R(addr);
 8059633:	a2 c0 ae 8f 14       	mov    %al,0x148faec0

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 8059638:	e8 c3 f4 fe ff       	call   8048b00 <snprintf@plt>
 805963d:	83 c4 20             	add    $0x20,%esp
 8059640:	83 f8 4f             	cmp    $0x4f,%eax
 8059643:	7f 0b                	jg     8059650 <mov_moffs2a_b+0x50>
	return 5;
}
 8059645:	83 c4 08             	add    $0x8,%esp
 8059648:	b8 05 00 00 00       	mov    $0x5,%eax
 805964d:	5b                   	pop    %ebx
 805964e:	c3                   	ret    
 805964f:	90                   	nop

make_helper(concat(mov_moffs2a_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	REG(R_EAX) = MEM_R(addr);

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 8059650:	83 ec 0c             	sub    $0xc,%esp
 8059653:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8059659:	e8 02 f3 fe ff       	call   8048960 <fflush@plt>
 805965e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059664:	6a 07                	push   $0x7
 8059666:	6a 01                	push   $0x1
 8059668:	68 92 ed 05 08       	push   $0x805ed92
 805966d:	e8 9e f3 fe ff       	call   8048a10 <fwrite@plt>
 8059672:	83 c4 20             	add    $0x20,%esp
 8059675:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805967b:	6a 10                	push   $0x10
 805967d:	6a 01                	push   $0x1
 805967f:	68 84 f8 05 08       	push   $0x805f884
 8059684:	e8 87 f3 fe ff       	call   8048a10 <fwrite@plt>
 8059689:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805968f:	6a 05                	push   $0x5
 8059691:	6a 01                	push   $0x1
 8059693:	68 b1 ed 05 08       	push   $0x805edb1
 8059698:	e8 73 f3 fe ff       	call   8048a10 <fwrite@plt>
 805969d:	83 c4 14             	add    $0x14,%esp
 80596a0:	ff 35 80 5b 07 08    	pushl  0x8075b80
 80596a6:	53                   	push   %ebx
 80596a7:	68 4a 48 06 08       	push   $0x806484a
 80596ac:	6a 50                	push   $0x50
 80596ae:	68 00 89 0c 08       	push   $0x80c8900
 80596b3:	e8 48 f4 fe ff       	call   8048b00 <snprintf@plt>
 80596b8:	83 c4 20             	add    $0x20,%esp
 80596bb:	83 f8 4f             	cmp    $0x4f,%eax
 80596be:	7e 85                	jle    8059645 <mov_moffs2a_b+0x45>
 80596c0:	68 c3 4b 06 08       	push   $0x8064bc3
 80596c5:	6a 1b                	push   $0x1b
 80596c7:	68 5c 48 06 08       	push   $0x806485c
 80596cc:	68 30 4b 06 08       	push   $0x8064b30
 80596d1:	e8 da f4 fe ff       	call   8048bb0 <__assert_fail@plt>
 80596d6:	8d 76 00             	lea    0x0(%esi),%esi
 80596d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080596e0 <mov_i2r_v>:
#include "mov-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(mov_i2r)
 80596e0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 80596e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80596eb:	b8 d0 92 05 08       	mov    $0x80592d0,%eax
 80596f0:	75 05                	jne    80596f7 <mov_i2r_v+0x17>
 80596f2:	b8 20 94 05 08       	mov    $0x8059420,%eax
 80596f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80596fb:	ff e0                	jmp    *%eax
 80596fd:	8d 76 00             	lea    0x0(%esi),%esi

08059700 <mov_i2rm_v>:
make_helper_v(mov_i2rm)
 8059700:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8059707:	8b 54 24 04          	mov    0x4(%esp),%edx
 805970b:	b8 f0 92 05 08       	mov    $0x80592f0,%eax
 8059710:	75 05                	jne    8059717 <mov_i2rm_v+0x17>
 8059712:	b8 40 94 05 08       	mov    $0x8059440,%eax
 8059717:	89 54 24 04          	mov    %edx,0x4(%esp)
 805971b:	ff e0                	jmp    *%eax
 805971d:	8d 76 00             	lea    0x0(%esi),%esi

08059720 <mov_r2rm_v>:
make_helper_v(mov_r2rm)
 8059720:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8059727:	8b 54 24 04          	mov    0x4(%esp),%edx
 805972b:	b8 10 93 05 08       	mov    $0x8059310,%eax
 8059730:	75 05                	jne    8059737 <mov_r2rm_v+0x17>
 8059732:	b8 60 94 05 08       	mov    $0x8059460,%eax
 8059737:	89 54 24 04          	mov    %edx,0x4(%esp)
 805973b:	ff e0                	jmp    *%eax
 805973d:	8d 76 00             	lea    0x0(%esi),%esi

08059740 <mov_rm2r_v>:
make_helper_v(mov_rm2r)
 8059740:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8059747:	8b 54 24 04          	mov    0x4(%esp),%edx
 805974b:	b8 30 93 05 08       	mov    $0x8059330,%eax
 8059750:	75 05                	jne    8059757 <mov_rm2r_v+0x17>
 8059752:	b8 80 94 05 08       	mov    $0x8059480,%eax
 8059757:	89 54 24 04          	mov    %edx,0x4(%esp)
 805975b:	ff e0                	jmp    *%eax
 805975d:	8d 76 00             	lea    0x0(%esi),%esi

08059760 <mov_a2moffs_v>:
make_helper_v(mov_a2moffs)
 8059760:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8059767:	8b 54 24 04          	mov    0x4(%esp),%edx
 805976b:	b8 b0 8d 05 08       	mov    $0x8058db0,%eax
 8059770:	75 05                	jne    8059777 <mov_a2moffs_v+0x17>
 8059772:	b8 90 8e 05 08       	mov    $0x8058e90,%eax
 8059777:	89 54 24 04          	mov    %edx,0x4(%esp)
 805977b:	ff e0                	jmp    *%eax
 805977d:	8d 76 00             	lea    0x0(%esi),%esi

08059780 <mov_moffs2a_v>:
make_helper_v(mov_moffs2a)
 8059780:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8059787:	8b 54 24 04          	mov    0x4(%esp),%edx
 805978b:	b8 70 8f 05 08       	mov    $0x8058f70,%eax
 8059790:	75 05                	jne    8059797 <mov_moffs2a_v+0x17>
 8059792:	b8 50 90 05 08       	mov    $0x8059050,%eax
 8059797:	89 54 24 04          	mov    %edx,0x4(%esp)
 805979b:	ff e0                	jmp    *%eax
 805979d:	66 90                	xchg   %ax,%ax
 805979f:	90                   	nop

080597a0 <do_xchg_w>:
#include "cpu/exec/template-start.h"

#define instr xchg

static void do_execute () {
 80597a0:	53                   	push   %ebx
 80597a1:	83 ec 10             	sub    $0x10,%esp
 80597a4:	0f b7 05 4c ae 8f 14 	movzwl 0x148fae4c,%eax
	DATA_TYPE temp = op_src->val;
 80597ab:	8b 1d 14 ae 8f 14    	mov    0x148fae14,%ebx
 80597b1:	0f b7 db             	movzwl %bx,%ebx
	OPERAND_W(op_src, op_dest->val);
 80597b4:	50                   	push   %eax
 80597b5:	68 08 ae 8f 14       	push   $0x148fae08
 80597ba:	e8 11 38 00 00       	call   805cfd0 <write_operand_w>
	OPERAND_W(op_dest, temp);
 80597bf:	58                   	pop    %eax
 80597c0:	5a                   	pop    %edx
 80597c1:	53                   	push   %ebx
 80597c2:	68 40 ae 8f 14       	push   $0x148fae40
 80597c7:	e8 04 38 00 00       	call   805cfd0 <write_operand_w>
	print_asm_template2();
 80597cc:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 80597d3:	68 18 ae 8f 14       	push   $0x148fae18
 80597d8:	68 e8 4b 06 08       	push   $0x8064be8
 80597dd:	6a 50                	push   $0x50
 80597df:	68 00 89 0c 08       	push   $0x80c8900
 80597e4:	e8 17 f3 fe ff       	call   8048b00 <snprintf@plt>
 80597e9:	83 c4 20             	add    $0x20,%esp
 80597ec:	83 f8 4f             	cmp    $0x4f,%eax
 80597ef:	7f 0f                	jg     8059800 <do_xchg_w+0x60>
}
 80597f1:	83 c4 08             	add    $0x8,%esp
 80597f4:	5b                   	pop    %ebx
 80597f5:	c3                   	ret    
 80597f6:	8d 76 00             	lea    0x0(%esi),%esi
 80597f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

static void do_execute () {
	DATA_TYPE temp = op_src->val;
	OPERAND_W(op_src, op_dest->val);
	OPERAND_W(op_dest, temp);
	print_asm_template2();
 8059800:	83 ec 0c             	sub    $0xc,%esp
 8059803:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8059809:	e8 52 f1 fe ff       	call   8048960 <fflush@plt>
 805980e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059814:	6a 07                	push   $0x7
 8059816:	6a 01                	push   $0x1
 8059818:	68 92 ed 05 08       	push   $0x805ed92
 805981d:	e8 ee f1 fe ff       	call   8048a10 <fwrite@plt>
 8059822:	83 c4 20             	add    $0x20,%esp
 8059825:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805982b:	6a 10                	push   $0x10
 805982d:	6a 01                	push   $0x1
 805982f:	68 84 f8 05 08       	push   $0x805f884
 8059834:	e8 d7 f1 fe ff       	call   8048a10 <fwrite@plt>
 8059839:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805983f:	6a 05                	push   $0x5
 8059841:	6a 01                	push   $0x1
 8059843:	68 b1 ed 05 08       	push   $0x805edb1
 8059848:	e8 c3 f1 fe ff       	call   8048a10 <fwrite@plt>
 805984d:	83 c4 14             	add    $0x14,%esp
 8059850:	68 50 ae 8f 14       	push   $0x148fae50
 8059855:	68 18 ae 8f 14       	push   $0x148fae18
 805985a:	68 e8 4b 06 08       	push   $0x8064be8
 805985f:	6a 50                	push   $0x50
 8059861:	68 00 89 0c 08       	push   $0x80c8900
 8059866:	e8 95 f2 fe ff       	call   8048b00 <snprintf@plt>
 805986b:	83 c4 20             	add    $0x20,%esp
 805986e:	83 f8 4f             	cmp    $0x4f,%eax
 8059871:	0f 8e 7a ff ff ff    	jle    80597f1 <do_xchg_w+0x51>
 8059877:	68 6e 4d 06 08       	push   $0x8064d6e
 805987c:	6a 09                	push   $0x9
 805987e:	68 0c 4c 06 08       	push   $0x8064c0c
 8059883:	68 38 4c 06 08       	push   $0x8064c38
 8059888:	e8 23 f3 fe ff       	call   8048bb0 <__assert_fail@plt>
 805988d:	8d 76 00             	lea    0x0(%esi),%esi

08059890 <xchg_r2rm_w>:
	do_execute();
	return 1;
}
#endif

make_instr_helper(r2rm);
 8059890:	53                   	push   %ebx
 8059891:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059894:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059898:	83 c0 01             	add    $0x1,%eax
 805989b:	50                   	push   %eax
 805989c:	e8 af 34 00 00       	call   805cd50 <decode_r2rm_w>
 80598a1:	89 c3                	mov    %eax,%ebx
	execute();
 80598a3:	e8 f8 fe ff ff       	call   80597a0 <do_xchg_w>
 80598a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80598ab:	8d 43 01             	lea    0x1(%ebx),%eax
 80598ae:	5b                   	pop    %ebx
 80598af:	c3                   	ret    

080598b0 <xchg_a2r_w>:
	OPERAND_W(op_dest, temp);
	print_asm_template2();
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(xchg_a2r_, SUFFIX)) {
 80598b0:	83 ec 18             	sub    $0x18,%esp
	concat(decode_r_, SUFFIX)(eip);
 80598b3:	ff 74 24 1c          	pushl  0x1c(%esp)
 80598b7:	e8 c4 35 00 00       	call   805ce80 <decode_r_w>
	op_dest->type = OP_TYPE_REG;
	op_dest->reg = R_EAX;
	op_dest->val = REG(R_EAX);
 80598bc:	0f b7 05 c0 ae 8f 14 	movzwl 0x148faec0,%eax
	snprintf(op_dest->str, OP_STR_SIZE, "%s", REG_NAME(R_EAX));
 80598c3:	ff 35 a0 5b 07 08    	pushl  0x8075ba0
 80598c9:	68 ad fa 05 08       	push   $0x805faad
 80598ce:	6a 28                	push   $0x28
 80598d0:	68 50 ae 8f 14       	push   $0x148fae50
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(xchg_a2r_, SUFFIX)) {
	concat(decode_r_, SUFFIX)(eip);
	op_dest->type = OP_TYPE_REG;
 80598d5:	c7 05 40 ae 8f 14 00 	movl   $0x0,0x148fae40
 80598dc:	00 00 00 
	op_dest->reg = R_EAX;
 80598df:	c7 05 48 ae 8f 14 00 	movl   $0x0,0x148fae48
 80598e6:	00 00 00 
	op_dest->val = REG(R_EAX);
 80598e9:	a3 4c ae 8f 14       	mov    %eax,0x148fae4c
	snprintf(op_dest->str, OP_STR_SIZE, "%s", REG_NAME(R_EAX));
 80598ee:	e8 0d f2 fe ff       	call   8048b00 <snprintf@plt>
	do_execute();
 80598f3:	83 c4 20             	add    $0x20,%esp
 80598f6:	e8 a5 fe ff ff       	call   80597a0 <do_xchg_w>
	return 1;
}
 80598fb:	b8 01 00 00 00       	mov    $0x1,%eax
 8059900:	83 c4 0c             	add    $0xc,%esp
 8059903:	c3                   	ret    
 8059904:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805990a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08059910 <do_xchg_l>:
#include "cpu/exec/template-start.h"

#define instr xchg

static void do_execute () {
 8059910:	53                   	push   %ebx
 8059911:	83 ec 10             	sub    $0x10,%esp
	DATA_TYPE temp = op_src->val;
	OPERAND_W(op_src, op_dest->val);
 8059914:	ff 35 4c ae 8f 14    	pushl  0x148fae4c
#include "cpu/exec/template-start.h"

#define instr xchg

static void do_execute () {
	DATA_TYPE temp = op_src->val;
 805991a:	8b 1d 14 ae 8f 14    	mov    0x148fae14,%ebx
	OPERAND_W(op_src, op_dest->val);
 8059920:	68 08 ae 8f 14       	push   $0x148fae08
 8059925:	e8 76 3a 00 00       	call   805d3a0 <write_operand_l>
	OPERAND_W(op_dest, temp);
 805992a:	58                   	pop    %eax
 805992b:	5a                   	pop    %edx
 805992c:	53                   	push   %ebx
 805992d:	68 40 ae 8f 14       	push   $0x148fae40
 8059932:	e8 69 3a 00 00       	call   805d3a0 <write_operand_l>
	print_asm_template2();
 8059937:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 805993e:	68 18 ae 8f 14       	push   $0x148fae18
 8059943:	68 f4 4b 06 08       	push   $0x8064bf4
 8059948:	6a 50                	push   $0x50
 805994a:	68 00 89 0c 08       	push   $0x80c8900
 805994f:	e8 ac f1 fe ff       	call   8048b00 <snprintf@plt>
 8059954:	83 c4 20             	add    $0x20,%esp
 8059957:	83 f8 4f             	cmp    $0x4f,%eax
 805995a:	7f 0c                	jg     8059968 <do_xchg_l+0x58>
}
 805995c:	83 c4 08             	add    $0x8,%esp
 805995f:	5b                   	pop    %ebx
 8059960:	c3                   	ret    
 8059961:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

static void do_execute () {
	DATA_TYPE temp = op_src->val;
	OPERAND_W(op_src, op_dest->val);
	OPERAND_W(op_dest, temp);
	print_asm_template2();
 8059968:	83 ec 0c             	sub    $0xc,%esp
 805996b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8059971:	e8 ea ef fe ff       	call   8048960 <fflush@plt>
 8059976:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805997c:	6a 07                	push   $0x7
 805997e:	6a 01                	push   $0x1
 8059980:	68 92 ed 05 08       	push   $0x805ed92
 8059985:	e8 86 f0 fe ff       	call   8048a10 <fwrite@plt>
 805998a:	83 c4 20             	add    $0x20,%esp
 805998d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059993:	6a 10                	push   $0x10
 8059995:	6a 01                	push   $0x1
 8059997:	68 84 f8 05 08       	push   $0x805f884
 805999c:	e8 6f f0 fe ff       	call   8048a10 <fwrite@plt>
 80599a1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 80599a7:	6a 05                	push   $0x5
 80599a9:	6a 01                	push   $0x1
 80599ab:	68 b1 ed 05 08       	push   $0x805edb1
 80599b0:	e8 5b f0 fe ff       	call   8048a10 <fwrite@plt>
 80599b5:	83 c4 14             	add    $0x14,%esp
 80599b8:	68 50 ae 8f 14       	push   $0x148fae50
 80599bd:	68 18 ae 8f 14       	push   $0x148fae18
 80599c2:	68 f4 4b 06 08       	push   $0x8064bf4
 80599c7:	6a 50                	push   $0x50
 80599c9:	68 00 89 0c 08       	push   $0x80c8900
 80599ce:	e8 2d f1 fe ff       	call   8048b00 <snprintf@plt>
 80599d3:	83 c4 20             	add    $0x20,%esp
 80599d6:	83 f8 4f             	cmp    $0x4f,%eax
 80599d9:	7e 81                	jle    805995c <do_xchg_l+0x4c>
 80599db:	68 64 4d 06 08       	push   $0x8064d64
 80599e0:	6a 09                	push   $0x9
 80599e2:	68 0c 4c 06 08       	push   $0x8064c0c
 80599e7:	68 9c 4c 06 08       	push   $0x8064c9c
 80599ec:	e8 bf f1 fe ff       	call   8048bb0 <__assert_fail@plt>
 80599f1:	eb 0d                	jmp    8059a00 <xchg_r2rm_l>
 80599f3:	90                   	nop
 80599f4:	90                   	nop
 80599f5:	90                   	nop
 80599f6:	90                   	nop
 80599f7:	90                   	nop
 80599f8:	90                   	nop
 80599f9:	90                   	nop
 80599fa:	90                   	nop
 80599fb:	90                   	nop
 80599fc:	90                   	nop
 80599fd:	90                   	nop
 80599fe:	90                   	nop
 80599ff:	90                   	nop

08059a00 <xchg_r2rm_l>:
	do_execute();
	return 1;
}
#endif

make_instr_helper(r2rm);
 8059a00:	53                   	push   %ebx
 8059a01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059a04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059a08:	83 c0 01             	add    $0x1,%eax
 8059a0b:	50                   	push   %eax
 8059a0c:	e8 0f 37 00 00       	call   805d120 <decode_r2rm_l>
 8059a11:	89 c3                	mov    %eax,%ebx
	execute();
 8059a13:	e8 f8 fe ff ff       	call   8059910 <do_xchg_l>
 8059a18:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8059a1b:	8d 43 01             	lea    0x1(%ebx),%eax
 8059a1e:	5b                   	pop    %ebx
 8059a1f:	c3                   	ret    

08059a20 <xchg_a2r_l>:
	OPERAND_W(op_dest, temp);
	print_asm_template2();
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(xchg_a2r_, SUFFIX)) {
 8059a20:	83 ec 18             	sub    $0x18,%esp
	concat(decode_r_, SUFFIX)(eip);
 8059a23:	ff 74 24 1c          	pushl  0x1c(%esp)
 8059a27:	e8 24 38 00 00       	call   805d250 <decode_r_l>
	op_dest->type = OP_TYPE_REG;
	op_dest->reg = R_EAX;
	op_dest->val = REG(R_EAX);
 8059a2c:	a1 c0 ae 8f 14       	mov    0x148faec0,%eax
	snprintf(op_dest->str, OP_STR_SIZE, "%s", REG_NAME(R_EAX));
 8059a31:	ff 35 c0 5b 07 08    	pushl  0x8075bc0
 8059a37:	68 ad fa 05 08       	push   $0x805faad
 8059a3c:	6a 28                	push   $0x28
 8059a3e:	68 50 ae 8f 14       	push   $0x148fae50
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(xchg_a2r_, SUFFIX)) {
	concat(decode_r_, SUFFIX)(eip);
	op_dest->type = OP_TYPE_REG;
 8059a43:	c7 05 40 ae 8f 14 00 	movl   $0x0,0x148fae40
 8059a4a:	00 00 00 
	op_dest->reg = R_EAX;
 8059a4d:	c7 05 48 ae 8f 14 00 	movl   $0x0,0x148fae48
 8059a54:	00 00 00 
	op_dest->val = REG(R_EAX);
 8059a57:	a3 4c ae 8f 14       	mov    %eax,0x148fae4c
	snprintf(op_dest->str, OP_STR_SIZE, "%s", REG_NAME(R_EAX));
 8059a5c:	e8 9f f0 fe ff       	call   8048b00 <snprintf@plt>
	do_execute();
 8059a61:	83 c4 20             	add    $0x20,%esp
 8059a64:	e8 a7 fe ff ff       	call   8059910 <do_xchg_l>
	return 1;
}
 8059a69:	b8 01 00 00 00       	mov    $0x1,%eax
 8059a6e:	83 c4 0c             	add    $0xc,%esp
 8059a71:	c3                   	ret    
 8059a72:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8059a79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08059a80 <xchg_r2rm_b>:
#endif

make_instr_helper(r2rm);
 8059a80:	56                   	push   %esi
 8059a81:	53                   	push   %ebx
 8059a82:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059a85:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059a89:	83 c0 01             	add    $0x1,%eax
 8059a8c:	50                   	push   %eax
 8059a8d:	e8 8e 2f 00 00       	call   805ca20 <decode_r2rm_b>
 8059a92:	89 c6                	mov    %eax,%esi
#include "cpu/exec/template-start.h"

#define instr xchg

static void do_execute () {
	DATA_TYPE temp = op_src->val;
 8059a94:	8b 1d 14 ae 8f 14    	mov    0x148fae14,%ebx
	OPERAND_W(op_src, op_dest->val);
 8059a9a:	58                   	pop    %eax
 8059a9b:	0f b6 05 4c ae 8f 14 	movzbl 0x148fae4c,%eax
 8059aa2:	5a                   	pop    %edx
 8059aa3:	0f b6 db             	movzbl %bl,%ebx
 8059aa6:	50                   	push   %eax
 8059aa7:	68 08 ae 8f 14       	push   $0x148fae08
 8059aac:	e8 8f 31 00 00       	call   805cc40 <write_operand_b>
	OPERAND_W(op_dest, temp);
 8059ab1:	59                   	pop    %ecx
 8059ab2:	58                   	pop    %eax
 8059ab3:	53                   	push   %ebx
 8059ab4:	68 40 ae 8f 14       	push   $0x148fae40
 8059ab9:	e8 82 31 00 00       	call   805cc40 <write_operand_b>
	print_asm_template2();
 8059abe:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8059ac5:	68 18 ae 8f 14       	push   $0x148fae18
 8059aca:	68 00 4c 06 08       	push   $0x8064c00
 8059acf:	6a 50                	push   $0x50
 8059ad1:	68 00 89 0c 08       	push   $0x80c8900
 8059ad6:	e8 25 f0 fe ff       	call   8048b00 <snprintf@plt>
 8059adb:	83 c4 20             	add    $0x20,%esp
 8059ade:	83 f8 4f             	cmp    $0x4f,%eax
 8059ae1:	7f 0d                	jg     8059af0 <xchg_r2rm_b+0x70>
	do_execute();
	return 1;
}
#endif

make_instr_helper(r2rm);
 8059ae3:	83 c4 04             	add    $0x4,%esp
	execute();
	return len + 1;	// "1" for opcode
 8059ae6:	8d 46 01             	lea    0x1(%esi),%eax
 8059ae9:	5b                   	pop    %ebx
 8059aea:	5e                   	pop    %esi
 8059aeb:	c3                   	ret    
 8059aec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static void do_execute () {
	DATA_TYPE temp = op_src->val;
	OPERAND_W(op_src, op_dest->val);
	OPERAND_W(op_dest, temp);
	print_asm_template2();
 8059af0:	83 ec 0c             	sub    $0xc,%esp
 8059af3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8059af9:	e8 62 ee fe ff       	call   8048960 <fflush@plt>
 8059afe:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059b04:	6a 07                	push   $0x7
 8059b06:	6a 01                	push   $0x1
 8059b08:	68 92 ed 05 08       	push   $0x805ed92
 8059b0d:	e8 fe ee fe ff       	call   8048a10 <fwrite@plt>
 8059b12:	83 c4 20             	add    $0x20,%esp
 8059b15:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059b1b:	6a 10                	push   $0x10
 8059b1d:	6a 01                	push   $0x1
 8059b1f:	68 84 f8 05 08       	push   $0x805f884
 8059b24:	e8 e7 ee fe ff       	call   8048a10 <fwrite@plt>
 8059b29:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059b2f:	6a 05                	push   $0x5
 8059b31:	6a 01                	push   $0x1
 8059b33:	68 b1 ed 05 08       	push   $0x805edb1
 8059b38:	e8 d3 ee fe ff       	call   8048a10 <fwrite@plt>
 8059b3d:	83 c4 14             	add    $0x14,%esp
 8059b40:	68 50 ae 8f 14       	push   $0x148fae50
 8059b45:	68 18 ae 8f 14       	push   $0x148fae18
 8059b4a:	68 00 4c 06 08       	push   $0x8064c00
 8059b4f:	6a 50                	push   $0x50
 8059b51:	68 00 89 0c 08       	push   $0x80c8900
 8059b56:	e8 a5 ef fe ff       	call   8048b00 <snprintf@plt>
 8059b5b:	83 c4 20             	add    $0x20,%esp
 8059b5e:	83 f8 4f             	cmp    $0x4f,%eax
 8059b61:	7e 80                	jle    8059ae3 <xchg_r2rm_b+0x63>
 8059b63:	68 78 4d 06 08       	push   $0x8064d78
 8059b68:	6a 09                	push   $0x9
 8059b6a:	68 0c 4c 06 08       	push   $0x8064c0c
 8059b6f:	68 00 4d 06 08       	push   $0x8064d00
 8059b74:	e8 37 f0 fe ff       	call   8048bb0 <__assert_fail@plt>
 8059b79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08059b80 <xchg_a2r_v>:
#undef DATA_BYTE


/* for instruction encoding overloading */

make_helper_v(xchg_a2r)
 8059b80:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8059b87:	8b 54 24 04          	mov    0x4(%esp),%edx
 8059b8b:	b8 b0 98 05 08       	mov    $0x80598b0,%eax
 8059b90:	75 05                	jne    8059b97 <xchg_a2r_v+0x17>
 8059b92:	b8 20 9a 05 08       	mov    $0x8059a20,%eax
 8059b97:	89 54 24 04          	mov    %edx,0x4(%esp)
 8059b9b:	ff e0                	jmp    *%eax
 8059b9d:	8d 76 00             	lea    0x0(%esi),%esi

08059ba0 <xchg_r2rm_v>:
make_helper_v(xchg_r2rm)
 8059ba0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8059ba7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8059bab:	b8 90 98 05 08       	mov    $0x8059890,%eax
 8059bb0:	75 05                	jne    8059bb7 <xchg_r2rm_v+0x17>
 8059bb2:	b8 00 9a 05 08       	mov    $0x8059a00,%eax
 8059bb7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8059bbb:	ff e0                	jmp    *%eax
 8059bbd:	66 90                	xchg   %ax,%ax
 8059bbf:	90                   	nop

08059bc0 <movsx_rm2r_l>:
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(rm2r)
 8059bc0:	53                   	push   %ebx
 8059bc1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059bc4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059bc8:	83 c0 01             	add    $0x1,%eax
 8059bcb:	50                   	push   %eax
 8059bcc:	e8 6f 35 00 00       	call   805d140 <decode_rm2r_l>
 8059bd1:	89 c3                	mov    %eax,%ebx

static void do_execute() {
	DATA_TYPE_S res;
	res = op_src->val;
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
	OPERAND_W(op_dest, res);
 8059bd3:	58                   	pop    %eax
#define instr movsx

static void do_execute() {
	DATA_TYPE_S res;
	res = op_src->val;
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
 8059bd4:	0f be 05 14 ae 8f 14 	movsbl 0x148fae14,%eax
	OPERAND_W(op_dest, res);
 8059bdb:	5a                   	pop    %edx
 8059bdc:	50                   	push   %eax
 8059bdd:	68 40 ae 8f 14       	push   $0x148fae40
 8059be2:	e8 b9 37 00 00       	call   805d3a0 <write_operand_l>
	print_asm_template2();
 8059be7:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8059bee:	68 18 ae 8f 14       	push   $0x148fae18
 8059bf3:	68 82 4d 06 08       	push   $0x8064d82
 8059bf8:	6a 50                	push   $0x50
 8059bfa:	68 00 89 0c 08       	push   $0x80c8900
 8059bff:	e8 fc ee fe ff       	call   8048b00 <snprintf@plt>
 8059c04:	83 c4 20             	add    $0x20,%esp
 8059c07:	83 f8 4f             	cmp    $0x4f,%eax
 8059c0a:	7f 0c                	jg     8059c18 <movsx_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8059c0c:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8059c0f:	8d 43 01             	lea    0x1(%ebx),%eax
 8059c12:	5b                   	pop    %ebx
 8059c13:	c3                   	ret    
 8059c14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static void do_execute() {
	DATA_TYPE_S res;
	res = op_src->val;
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8059c18:	83 ec 0c             	sub    $0xc,%esp
 8059c1b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8059c21:	e8 3a ed fe ff       	call   8048960 <fflush@plt>
 8059c26:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059c2c:	6a 07                	push   $0x7
 8059c2e:	6a 01                	push   $0x1
 8059c30:	68 92 ed 05 08       	push   $0x805ed92
 8059c35:	e8 d6 ed fe ff       	call   8048a10 <fwrite@plt>
 8059c3a:	83 c4 20             	add    $0x20,%esp
 8059c3d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059c43:	6a 10                	push   $0x10
 8059c45:	6a 01                	push   $0x1
 8059c47:	68 84 f8 05 08       	push   $0x805f884
 8059c4c:	e8 bf ed fe ff       	call   8048a10 <fwrite@plt>
 8059c51:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059c57:	6a 05                	push   $0x5
 8059c59:	6a 01                	push   $0x1
 8059c5b:	68 b1 ed 05 08       	push   $0x805edb1
 8059c60:	e8 ab ed fe ff       	call   8048a10 <fwrite@plt>
 8059c65:	83 c4 14             	add    $0x14,%esp
 8059c68:	68 50 ae 8f 14       	push   $0x148fae50
 8059c6d:	68 18 ae 8f 14       	push   $0x148fae18
 8059c72:	68 82 4d 06 08       	push   $0x8064d82
 8059c77:	6a 50                	push   $0x50
 8059c79:	68 00 89 0c 08       	push   $0x80c8900
 8059c7e:	e8 7d ee fe ff       	call   8048b00 <snprintf@plt>
 8059c83:	83 c4 20             	add    $0x20,%esp
 8059c86:	83 f8 4f             	cmp    $0x4f,%eax
 8059c89:	7e 81                	jle    8059c0c <movsx_rm2r_l+0x4c>
 8059c8b:	68 0d 4f 06 08       	push   $0x8064f0d
 8059c90:	6a 0a                	push   $0xa
 8059c92:	68 ac 4d 06 08       	push   $0x8064dac
 8059c97:	68 d8 4d 06 08       	push   $0x8064dd8
 8059c9c:	e8 0f ef fe ff       	call   8048bb0 <__assert_fail@plt>
 8059ca1:	eb 0d                	jmp    8059cb0 <movsx_rm2r_w>
 8059ca3:	90                   	nop
 8059ca4:	90                   	nop
 8059ca5:	90                   	nop
 8059ca6:	90                   	nop
 8059ca7:	90                   	nop
 8059ca8:	90                   	nop
 8059ca9:	90                   	nop
 8059caa:	90                   	nop
 8059cab:	90                   	nop
 8059cac:	90                   	nop
 8059cad:	90                   	nop
 8059cae:	90                   	nop
 8059caf:	90                   	nop

08059cb0 <movsx_rm2r_w>:
}

make_instr_helper(rm2r)
 8059cb0:	53                   	push   %ebx
 8059cb1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059cb4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059cb8:	83 c0 01             	add    $0x1,%eax
 8059cbb:	50                   	push   %eax
 8059cbc:	e8 af 30 00 00       	call   805cd70 <decode_rm2r_w>
 8059cc1:	89 c3                	mov    %eax,%ebx

static void do_execute() {
	DATA_TYPE_S res;
	res = op_src->val;
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
	OPERAND_W(op_dest, res);
 8059cc3:	58                   	pop    %eax
 8059cc4:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
 8059ccb:	5a                   	pop    %edx
 8059ccc:	50                   	push   %eax
 8059ccd:	68 40 ae 8f 14       	push   $0x148fae40
 8059cd2:	e8 f9 32 00 00       	call   805cfd0 <write_operand_w>
	print_asm_template2();
 8059cd7:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8059cde:	68 18 ae 8f 14       	push   $0x148fae18
 8059ce3:	68 8f 4d 06 08       	push   $0x8064d8f
 8059ce8:	6a 50                	push   $0x50
 8059cea:	68 00 89 0c 08       	push   $0x80c8900
 8059cef:	e8 0c ee fe ff       	call   8048b00 <snprintf@plt>
 8059cf4:	83 c4 20             	add    $0x20,%esp
 8059cf7:	83 f8 4f             	cmp    $0x4f,%eax
 8059cfa:	7f 0c                	jg     8059d08 <movsx_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8059cfc:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8059cff:	8d 43 01             	lea    0x1(%ebx),%eax
 8059d02:	5b                   	pop    %ebx
 8059d03:	c3                   	ret    
 8059d04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static void do_execute() {
	DATA_TYPE_S res;
	res = op_src->val;
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8059d08:	83 ec 0c             	sub    $0xc,%esp
 8059d0b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8059d11:	e8 4a ec fe ff       	call   8048960 <fflush@plt>
 8059d16:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059d1c:	6a 07                	push   $0x7
 8059d1e:	6a 01                	push   $0x1
 8059d20:	68 92 ed 05 08       	push   $0x805ed92
 8059d25:	e8 e6 ec fe ff       	call   8048a10 <fwrite@plt>
 8059d2a:	83 c4 20             	add    $0x20,%esp
 8059d2d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059d33:	6a 10                	push   $0x10
 8059d35:	6a 01                	push   $0x1
 8059d37:	68 84 f8 05 08       	push   $0x805f884
 8059d3c:	e8 cf ec fe ff       	call   8048a10 <fwrite@plt>
 8059d41:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059d47:	6a 05                	push   $0x5
 8059d49:	6a 01                	push   $0x1
 8059d4b:	68 b1 ed 05 08       	push   $0x805edb1
 8059d50:	e8 bb ec fe ff       	call   8048a10 <fwrite@plt>
 8059d55:	83 c4 14             	add    $0x14,%esp
 8059d58:	68 50 ae 8f 14       	push   $0x148fae50
 8059d5d:	68 18 ae 8f 14       	push   $0x148fae18
 8059d62:	68 8f 4d 06 08       	push   $0x8064d8f
 8059d67:	6a 50                	push   $0x50
 8059d69:	68 00 89 0c 08       	push   $0x80c8900
 8059d6e:	e8 8d ed fe ff       	call   8048b00 <snprintf@plt>
 8059d73:	83 c4 20             	add    $0x20,%esp
 8059d76:	83 f8 4f             	cmp    $0x4f,%eax
 8059d79:	7e 81                	jle    8059cfc <movsx_rm2r_w+0x4c>
 8059d7b:	68 18 4f 06 08       	push   $0x8064f18
 8059d80:	6a 0a                	push   $0xa
 8059d82:	68 ac 4d 06 08       	push   $0x8064dac
 8059d87:	68 40 4e 06 08       	push   $0x8064e40
 8059d8c:	e8 1f ee fe ff       	call   8048bb0 <__assert_fail@plt>
 8059d91:	eb 0d                	jmp    8059da0 <movsx_rm2r_b>
 8059d93:	90                   	nop
 8059d94:	90                   	nop
 8059d95:	90                   	nop
 8059d96:	90                   	nop
 8059d97:	90                   	nop
 8059d98:	90                   	nop
 8059d99:	90                   	nop
 8059d9a:	90                   	nop
 8059d9b:	90                   	nop
 8059d9c:	90                   	nop
 8059d9d:	90                   	nop
 8059d9e:	90                   	nop
 8059d9f:	90                   	nop

08059da0 <movsx_rm2r_b>:
}

make_instr_helper(rm2r)
 8059da0:	53                   	push   %ebx
 8059da1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059da4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059da8:	83 c0 01             	add    $0x1,%eax
 8059dab:	50                   	push   %eax
 8059dac:	e8 8f 2c 00 00       	call   805ca40 <decode_rm2r_b>
 8059db1:	89 c3                	mov    %eax,%ebx

static void do_execute() {
	DATA_TYPE_S res;
	res = op_src->val;
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
	OPERAND_W(op_dest, res);
 8059db3:	58                   	pop    %eax
 8059db4:	0f b6 05 14 ae 8f 14 	movzbl 0x148fae14,%eax
 8059dbb:	5a                   	pop    %edx
 8059dbc:	50                   	push   %eax
 8059dbd:	68 40 ae 8f 14       	push   $0x148fae40
 8059dc2:	e8 79 2e 00 00       	call   805cc40 <write_operand_b>
	print_asm_template2();
 8059dc7:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8059dce:	68 18 ae 8f 14       	push   $0x148fae18
 8059dd3:	68 9c 4d 06 08       	push   $0x8064d9c
 8059dd8:	6a 50                	push   $0x50
 8059dda:	68 00 89 0c 08       	push   $0x80c8900
 8059ddf:	e8 1c ed fe ff       	call   8048b00 <snprintf@plt>
 8059de4:	83 c4 20             	add    $0x20,%esp
 8059de7:	83 f8 4f             	cmp    $0x4f,%eax
 8059dea:	7f 0c                	jg     8059df8 <movsx_rm2r_b+0x58>
}

make_instr_helper(rm2r)
 8059dec:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8059def:	8d 43 01             	lea    0x1(%ebx),%eax
 8059df2:	5b                   	pop    %ebx
 8059df3:	c3                   	ret    
 8059df4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static void do_execute() {
	DATA_TYPE_S res;
	res = op_src->val;
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8059df8:	83 ec 0c             	sub    $0xc,%esp
 8059dfb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8059e01:	e8 5a eb fe ff       	call   8048960 <fflush@plt>
 8059e06:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059e0c:	6a 07                	push   $0x7
 8059e0e:	6a 01                	push   $0x1
 8059e10:	68 92 ed 05 08       	push   $0x805ed92
 8059e15:	e8 f6 eb fe ff       	call   8048a10 <fwrite@plt>
 8059e1a:	83 c4 20             	add    $0x20,%esp
 8059e1d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059e23:	6a 10                	push   $0x10
 8059e25:	6a 01                	push   $0x1
 8059e27:	68 84 f8 05 08       	push   $0x805f884
 8059e2c:	e8 df eb fe ff       	call   8048a10 <fwrite@plt>
 8059e31:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059e37:	6a 05                	push   $0x5
 8059e39:	6a 01                	push   $0x1
 8059e3b:	68 b1 ed 05 08       	push   $0x805edb1
 8059e40:	e8 cb eb fe ff       	call   8048a10 <fwrite@plt>
 8059e45:	83 c4 14             	add    $0x14,%esp
 8059e48:	68 50 ae 8f 14       	push   $0x148fae50
 8059e4d:	68 18 ae 8f 14       	push   $0x148fae18
 8059e52:	68 9c 4d 06 08       	push   $0x8064d9c
 8059e57:	6a 50                	push   $0x50
 8059e59:	68 00 89 0c 08       	push   $0x80c8900
 8059e5e:	e8 9d ec fe ff       	call   8048b00 <snprintf@plt>
 8059e63:	83 c4 20             	add    $0x20,%esp
 8059e66:	83 f8 4f             	cmp    $0x4f,%eax
 8059e69:	7e 81                	jle    8059dec <movsx_rm2r_b+0x4c>
 8059e6b:	68 23 4f 06 08       	push   $0x8064f23
 8059e70:	6a 0a                	push   $0xa
 8059e72:	68 ac 4d 06 08       	push   $0x8064dac
 8059e77:	68 a8 4e 06 08       	push   $0x8064ea8
 8059e7c:	e8 2f ed fe ff       	call   8048bb0 <__assert_fail@plt>
 8059e81:	eb 0d                	jmp    8059e90 <movsx_rm2r_v>
 8059e83:	90                   	nop
 8059e84:	90                   	nop
 8059e85:	90                   	nop
 8059e86:	90                   	nop
 8059e87:	90                   	nop
 8059e88:	90                   	nop
 8059e89:	90                   	nop
 8059e8a:	90                   	nop
 8059e8b:	90                   	nop
 8059e8c:	90                   	nop
 8059e8d:	90                   	nop
 8059e8e:	90                   	nop
 8059e8f:	90                   	nop

08059e90 <movsx_rm2r_v>:
#include "movsx-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(movsx_rm2r)
 8059e90:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8059e97:	8b 54 24 04          	mov    0x4(%esp),%edx
 8059e9b:	b8 b0 9c 05 08       	mov    $0x8059cb0,%eax
 8059ea0:	75 05                	jne    8059ea7 <movsx_rm2r_v+0x17>
 8059ea2:	b8 c0 9b 05 08       	mov    $0x8059bc0,%eax
 8059ea7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8059eab:	ff e0                	jmp    *%eax
 8059ead:	66 90                	xchg   %ax,%ax
 8059eaf:	90                   	nop

08059eb0 <cwdcdq_l>:

/* for instruction encoding overloading */

int cwdcdq_l(uint32_t eip) {
	int res = reg_l(R_EAX);
	reg_l(R_EDX) = res >> 31;
 8059eb0:	a1 c0 ae 8f 14       	mov    0x148faec0,%eax
 8059eb5:	c1 f8 1f             	sar    $0x1f,%eax
 8059eb8:	a3 c8 ae 8f 14       	mov    %eax,0x148faec8
	return 1;
}
 8059ebd:	b8 01 00 00 00       	mov    $0x1,%eax
 8059ec2:	c3                   	ret    
 8059ec3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8059ec9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08059ed0 <cwdcdq_w>:

int cwdcdq_w(uint32_t eip) {
	short res = reg_w(R_AX);
	reg_w(R_DX) = res >> 15;
 8059ed0:	0f b7 05 c0 ae 8f 14 	movzwl 0x148faec0,%eax
 8059ed7:	66 c1 f8 0f          	sar    $0xf,%ax
 8059edb:	66 a3 c8 ae 8f 14    	mov    %ax,0x148faec8
	return 1;
}
 8059ee1:	b8 01 00 00 00       	mov    $0x1,%eax
 8059ee6:	c3                   	ret    
 8059ee7:	89 f6                	mov    %esi,%esi
 8059ee9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08059ef0 <cwdcdq_v>:

make_helper_v(cwdcdq)
 8059ef0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 8059ef7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8059efb:	b8 d0 9e 05 08       	mov    $0x8059ed0,%eax
 8059f00:	75 05                	jne    8059f07 <cwdcdq_v+0x17>
 8059f02:	b8 b0 9e 05 08       	mov    $0x8059eb0,%eax
 8059f07:	89 54 24 04          	mov    %edx,0x4(%esp)
 8059f0b:	ff e0                	jmp    *%eax
 8059f0d:	66 90                	xchg   %ax,%ax
 8059f0f:	90                   	nop

08059f10 <movzx_rm2r_l>:
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(rm2r)
 8059f10:	53                   	push   %ebx
 8059f11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059f14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059f18:	83 c0 01             	add    $0x1,%eax
 8059f1b:	50                   	push   %eax
 8059f1c:	e8 1f 32 00 00       	call   805d140 <decode_rm2r_l>
 8059f21:	89 c3                	mov    %eax,%ebx
#define instr movzx

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
	OPERAND_W(op_dest, res);
 8059f23:	58                   	pop    %eax

#define instr movzx

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
 8059f24:	0f b6 05 14 ae 8f 14 	movzbl 0x148fae14,%eax
	OPERAND_W(op_dest, res);
 8059f2b:	5a                   	pop    %edx
 8059f2c:	50                   	push   %eax
 8059f2d:	68 40 ae 8f 14       	push   $0x148fae40
 8059f32:	e8 69 34 00 00       	call   805d3a0 <write_operand_l>
	print_asm_template2();
 8059f37:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 8059f3e:	68 18 ae 8f 14       	push   $0x148fae18
 8059f43:	68 2e 4f 06 08       	push   $0x8064f2e
 8059f48:	6a 50                	push   $0x50
 8059f4a:	68 00 89 0c 08       	push   $0x80c8900
 8059f4f:	e8 ac eb fe ff       	call   8048b00 <snprintf@plt>
 8059f54:	83 c4 20             	add    $0x20,%esp
 8059f57:	83 f8 4f             	cmp    $0x4f,%eax
 8059f5a:	7f 0c                	jg     8059f68 <movzx_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8059f5c:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8059f5f:	8d 43 01             	lea    0x1(%ebx),%eax
 8059f62:	5b                   	pop    %ebx
 8059f63:	c3                   	ret    
 8059f64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8059f68:	83 ec 0c             	sub    $0xc,%esp
 8059f6b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 8059f71:	e8 ea e9 fe ff       	call   8048960 <fflush@plt>
 8059f76:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059f7c:	6a 07                	push   $0x7
 8059f7e:	6a 01                	push   $0x1
 8059f80:	68 92 ed 05 08       	push   $0x805ed92
 8059f85:	e8 86 ea fe ff       	call   8048a10 <fwrite@plt>
 8059f8a:	83 c4 20             	add    $0x20,%esp
 8059f8d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059f93:	6a 10                	push   $0x10
 8059f95:	6a 01                	push   $0x1
 8059f97:	68 84 f8 05 08       	push   $0x805f884
 8059f9c:	e8 6f ea fe ff       	call   8048a10 <fwrite@plt>
 8059fa1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 8059fa7:	6a 05                	push   $0x5
 8059fa9:	6a 01                	push   $0x1
 8059fab:	68 b1 ed 05 08       	push   $0x805edb1
 8059fb0:	e8 5b ea fe ff       	call   8048a10 <fwrite@plt>
 8059fb5:	83 c4 14             	add    $0x14,%esp
 8059fb8:	68 50 ae 8f 14       	push   $0x148fae50
 8059fbd:	68 18 ae 8f 14       	push   $0x148fae18
 8059fc2:	68 2e 4f 06 08       	push   $0x8064f2e
 8059fc7:	6a 50                	push   $0x50
 8059fc9:	68 00 89 0c 08       	push   $0x80c8900
 8059fce:	e8 2d eb fe ff       	call   8048b00 <snprintf@plt>
 8059fd3:	83 c4 20             	add    $0x20,%esp
 8059fd6:	83 f8 4f             	cmp    $0x4f,%eax
 8059fd9:	7e 81                	jle    8059f5c <movzx_rm2r_l+0x4c>
 8059fdb:	68 b9 50 06 08       	push   $0x80650b9
 8059fe0:	6a 09                	push   $0x9
 8059fe2:	68 58 4f 06 08       	push   $0x8064f58
 8059fe7:	68 84 4f 06 08       	push   $0x8064f84
 8059fec:	e8 bf eb fe ff       	call   8048bb0 <__assert_fail@plt>
 8059ff1:	eb 0d                	jmp    805a000 <movzx_rm2r_w>
 8059ff3:	90                   	nop
 8059ff4:	90                   	nop
 8059ff5:	90                   	nop
 8059ff6:	90                   	nop
 8059ff7:	90                   	nop
 8059ff8:	90                   	nop
 8059ff9:	90                   	nop
 8059ffa:	90                   	nop
 8059ffb:	90                   	nop
 8059ffc:	90                   	nop
 8059ffd:	90                   	nop
 8059ffe:	90                   	nop
 8059fff:	90                   	nop

0805a000 <movzx_rm2r_w>:
}

make_instr_helper(rm2r)
 805a000:	53                   	push   %ebx
 805a001:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a004:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a008:	83 c0 01             	add    $0x1,%eax
 805a00b:	50                   	push   %eax
 805a00c:	e8 5f 2d 00 00       	call   805cd70 <decode_rm2r_w>
 805a011:	89 c3                	mov    %eax,%ebx
#define instr movzx

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
	OPERAND_W(op_dest, res);
 805a013:	58                   	pop    %eax

#define instr movzx

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
 805a014:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
	OPERAND_W(op_dest, res);
 805a01b:	5a                   	pop    %edx
 805a01c:	50                   	push   %eax
 805a01d:	68 40 ae 8f 14       	push   $0x148fae40
 805a022:	e8 a9 2f 00 00       	call   805cfd0 <write_operand_w>
	print_asm_template2();
 805a027:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 805a02e:	68 18 ae 8f 14       	push   $0x148fae18
 805a033:	68 3b 4f 06 08       	push   $0x8064f3b
 805a038:	6a 50                	push   $0x50
 805a03a:	68 00 89 0c 08       	push   $0x80c8900
 805a03f:	e8 bc ea fe ff       	call   8048b00 <snprintf@plt>
 805a044:	83 c4 20             	add    $0x20,%esp
 805a047:	83 f8 4f             	cmp    $0x4f,%eax
 805a04a:	7f 0c                	jg     805a058 <movzx_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 805a04c:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805a04f:	8d 43 01             	lea    0x1(%ebx),%eax
 805a052:	5b                   	pop    %ebx
 805a053:	c3                   	ret    
 805a054:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
	OPERAND_W(op_dest, res);
	print_asm_template2();
 805a058:	83 ec 0c             	sub    $0xc,%esp
 805a05b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805a061:	e8 fa e8 fe ff       	call   8048960 <fflush@plt>
 805a066:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a06c:	6a 07                	push   $0x7
 805a06e:	6a 01                	push   $0x1
 805a070:	68 92 ed 05 08       	push   $0x805ed92
 805a075:	e8 96 e9 fe ff       	call   8048a10 <fwrite@plt>
 805a07a:	83 c4 20             	add    $0x20,%esp
 805a07d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a083:	6a 10                	push   $0x10
 805a085:	6a 01                	push   $0x1
 805a087:	68 84 f8 05 08       	push   $0x805f884
 805a08c:	e8 7f e9 fe ff       	call   8048a10 <fwrite@plt>
 805a091:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a097:	6a 05                	push   $0x5
 805a099:	6a 01                	push   $0x1
 805a09b:	68 b1 ed 05 08       	push   $0x805edb1
 805a0a0:	e8 6b e9 fe ff       	call   8048a10 <fwrite@plt>
 805a0a5:	83 c4 14             	add    $0x14,%esp
 805a0a8:	68 50 ae 8f 14       	push   $0x148fae50
 805a0ad:	68 18 ae 8f 14       	push   $0x148fae18
 805a0b2:	68 3b 4f 06 08       	push   $0x8064f3b
 805a0b7:	6a 50                	push   $0x50
 805a0b9:	68 00 89 0c 08       	push   $0x80c8900
 805a0be:	e8 3d ea fe ff       	call   8048b00 <snprintf@plt>
 805a0c3:	83 c4 20             	add    $0x20,%esp
 805a0c6:	83 f8 4f             	cmp    $0x4f,%eax
 805a0c9:	7e 81                	jle    805a04c <movzx_rm2r_w+0x4c>
 805a0cb:	68 c4 50 06 08       	push   $0x80650c4
 805a0d0:	6a 09                	push   $0x9
 805a0d2:	68 58 4f 06 08       	push   $0x8064f58
 805a0d7:	68 ec 4f 06 08       	push   $0x8064fec
 805a0dc:	e8 cf ea fe ff       	call   8048bb0 <__assert_fail@plt>
 805a0e1:	eb 0d                	jmp    805a0f0 <movzx_rm2r_b>
 805a0e3:	90                   	nop
 805a0e4:	90                   	nop
 805a0e5:	90                   	nop
 805a0e6:	90                   	nop
 805a0e7:	90                   	nop
 805a0e8:	90                   	nop
 805a0e9:	90                   	nop
 805a0ea:	90                   	nop
 805a0eb:	90                   	nop
 805a0ec:	90                   	nop
 805a0ed:	90                   	nop
 805a0ee:	90                   	nop
 805a0ef:	90                   	nop

0805a0f0 <movzx_rm2r_b>:
}

make_instr_helper(rm2r)
 805a0f0:	53                   	push   %ebx
 805a0f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a0f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a0f8:	83 c0 01             	add    $0x1,%eax
 805a0fb:	50                   	push   %eax
 805a0fc:	e8 3f 29 00 00       	call   805ca40 <decode_rm2r_b>
 805a101:	89 c3                	mov    %eax,%ebx
#define instr movzx

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
	OPERAND_W(op_dest, res);
 805a103:	58                   	pop    %eax
 805a104:	0f b6 05 14 ae 8f 14 	movzbl 0x148fae14,%eax
 805a10b:	5a                   	pop    %edx
 805a10c:	50                   	push   %eax
 805a10d:	68 40 ae 8f 14       	push   $0x148fae40
 805a112:	e8 29 2b 00 00       	call   805cc40 <write_operand_b>
	print_asm_template2();
 805a117:	c7 04 24 50 ae 8f 14 	movl   $0x148fae50,(%esp)
 805a11e:	68 18 ae 8f 14       	push   $0x148fae18
 805a123:	68 48 4f 06 08       	push   $0x8064f48
 805a128:	6a 50                	push   $0x50
 805a12a:	68 00 89 0c 08       	push   $0x80c8900
 805a12f:	e8 cc e9 fe ff       	call   8048b00 <snprintf@plt>
 805a134:	83 c4 20             	add    $0x20,%esp
 805a137:	83 f8 4f             	cmp    $0x4f,%eax
 805a13a:	7f 0c                	jg     805a148 <movzx_rm2r_b+0x58>
}

make_instr_helper(rm2r)
 805a13c:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805a13f:	8d 43 01             	lea    0x1(%ebx),%eax
 805a142:	5b                   	pop    %ebx
 805a143:	c3                   	ret    
 805a144:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
	OPERAND_W(op_dest, res);
	print_asm_template2();
 805a148:	83 ec 0c             	sub    $0xc,%esp
 805a14b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805a151:	e8 0a e8 fe ff       	call   8048960 <fflush@plt>
 805a156:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a15c:	6a 07                	push   $0x7
 805a15e:	6a 01                	push   $0x1
 805a160:	68 92 ed 05 08       	push   $0x805ed92
 805a165:	e8 a6 e8 fe ff       	call   8048a10 <fwrite@plt>
 805a16a:	83 c4 20             	add    $0x20,%esp
 805a16d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a173:	6a 10                	push   $0x10
 805a175:	6a 01                	push   $0x1
 805a177:	68 84 f8 05 08       	push   $0x805f884
 805a17c:	e8 8f e8 fe ff       	call   8048a10 <fwrite@plt>
 805a181:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a187:	6a 05                	push   $0x5
 805a189:	6a 01                	push   $0x1
 805a18b:	68 b1 ed 05 08       	push   $0x805edb1
 805a190:	e8 7b e8 fe ff       	call   8048a10 <fwrite@plt>
 805a195:	83 c4 14             	add    $0x14,%esp
 805a198:	68 50 ae 8f 14       	push   $0x148fae50
 805a19d:	68 18 ae 8f 14       	push   $0x148fae18
 805a1a2:	68 48 4f 06 08       	push   $0x8064f48
 805a1a7:	6a 50                	push   $0x50
 805a1a9:	68 00 89 0c 08       	push   $0x80c8900
 805a1ae:	e8 4d e9 fe ff       	call   8048b00 <snprintf@plt>
 805a1b3:	83 c4 20             	add    $0x20,%esp
 805a1b6:	83 f8 4f             	cmp    $0x4f,%eax
 805a1b9:	7e 81                	jle    805a13c <movzx_rm2r_b+0x4c>
 805a1bb:	68 cf 50 06 08       	push   $0x80650cf
 805a1c0:	6a 09                	push   $0x9
 805a1c2:	68 58 4f 06 08       	push   $0x8064f58
 805a1c7:	68 54 50 06 08       	push   $0x8065054
 805a1cc:	e8 df e9 fe ff       	call   8048bb0 <__assert_fail@plt>
 805a1d1:	eb 0d                	jmp    805a1e0 <movzx_rm2r_v>
 805a1d3:	90                   	nop
 805a1d4:	90                   	nop
 805a1d5:	90                   	nop
 805a1d6:	90                   	nop
 805a1d7:	90                   	nop
 805a1d8:	90                   	nop
 805a1d9:	90                   	nop
 805a1da:	90                   	nop
 805a1db:	90                   	nop
 805a1dc:	90                   	nop
 805a1dd:	90                   	nop
 805a1de:	90                   	nop
 805a1df:	90                   	nop

0805a1e0 <movzx_rm2r_v>:
#include "movzx-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(movzx_rm2r)
 805a1e0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805a1e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805a1eb:	b8 00 a0 05 08       	mov    $0x805a000,%eax
 805a1f0:	75 05                	jne    805a1f7 <movzx_rm2r_v+0x17>
 805a1f2:	b8 10 9f 05 08       	mov    $0x8059f10,%eax
 805a1f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 805a1fb:	ff e0                	jmp    *%eax
 805a1fd:	66 90                	xchg   %ax,%ax
 805a1ff:	90                   	nop

0805a200 <mul_rm_w>:
	 */

	print_asm_template1();
}

make_instr_helper(rm)
 805a200:	53                   	push   %ebx
 805a201:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a204:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a208:	83 c0 01             	add    $0x1,%eax
 805a20b:	50                   	push   %eax
 805a20c:	e8 4f 2c 00 00       	call   805ce60 <decode_rm_w>

#define instr mul

static void do_execute() {
	uint64_t src = op_src->val;
	uint64_t result = REG(R_EAX) * src;
 805a211:	0f b7 0d c0 ae 8f 14 	movzwl 0x148faec0,%ecx
 805a218:	89 c3                	mov    %eax,%ebx

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a21a:	68 18 ae 8f 14       	push   $0x148fae18
 805a21f:	68 b2 56 06 08       	push   $0x80656b2
 805a224:	6a 50                	push   $0x50
 805a226:	68 00 89 0c 08       	push   $0x80c8900

#define instr mul

static void do_execute() {
	uint64_t src = op_src->val;
	uint64_t result = REG(R_EAX) * src;
 805a22b:	89 c8                	mov    %ecx,%eax
 805a22d:	f7 25 14 ae 8f 14    	mull   0x148fae14
#if DATA_BYTE == 1
	reg_w(R_AX) = result;
#elif DATA_BYTE == 2
	REG(R_EAX) = result & 0xffff;
 805a233:	66 a3 c0 ae 8f 14    	mov    %ax,0x148faec0
	REG(R_EDX) = result >> 16;
 805a239:	0f ac d0 10          	shrd   $0x10,%edx,%eax
 805a23d:	66 a3 c8 ae 8f 14    	mov    %ax,0x148faec8

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a243:	e8 b8 e8 fe ff       	call   8048b00 <snprintf@plt>
 805a248:	83 c4 20             	add    $0x20,%esp
 805a24b:	83 f8 4f             	cmp    $0x4f,%eax
 805a24e:	7f 10                	jg     805a260 <mul_rm_w+0x60>
}

make_instr_helper(rm)
 805a250:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805a253:	8d 43 01             	lea    0x1(%ebx),%eax
 805a256:	5b                   	pop    %ebx
 805a257:	c3                   	ret    
 805a258:	90                   	nop
 805a259:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a260:	83 ec 0c             	sub    $0xc,%esp
 805a263:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805a269:	e8 f2 e6 fe ff       	call   8048960 <fflush@plt>
 805a26e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a274:	6a 07                	push   $0x7
 805a276:	6a 01                	push   $0x1
 805a278:	68 92 ed 05 08       	push   $0x805ed92
 805a27d:	e8 8e e7 fe ff       	call   8048a10 <fwrite@plt>
 805a282:	83 c4 20             	add    $0x20,%esp
 805a285:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a28b:	6a 10                	push   $0x10
 805a28d:	6a 01                	push   $0x1
 805a28f:	68 84 f8 05 08       	push   $0x805f884
 805a294:	e8 77 e7 fe ff       	call   8048a10 <fwrite@plt>
 805a299:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a29f:	6a 05                	push   $0x5
 805a2a1:	6a 01                	push   $0x1
 805a2a3:	68 b1 ed 05 08       	push   $0x805edb1
 805a2a8:	e8 63 e7 fe ff       	call   8048a10 <fwrite@plt>
 805a2ad:	83 c4 20             	add    $0x20,%esp
 805a2b0:	68 18 ae 8f 14       	push   $0x148fae18
 805a2b5:	68 b2 56 06 08       	push   $0x80656b2
 805a2ba:	6a 50                	push   $0x50
 805a2bc:	68 00 89 0c 08       	push   $0x80c8900
 805a2c1:	e8 3a e8 fe ff       	call   8048b00 <snprintf@plt>
 805a2c6:	83 c4 10             	add    $0x10,%esp
 805a2c9:	83 f8 4f             	cmp    $0x4f,%eax
 805a2cc:	7e 82                	jle    805a250 <mul_rm_w+0x50>
 805a2ce:	68 e3 51 06 08       	push   $0x80651e3
 805a2d3:	6a 16                	push   $0x16
 805a2d5:	68 dc 50 06 08       	push   $0x80650dc
 805a2da:	68 04 51 06 08       	push   $0x8065104
 805a2df:	e8 cc e8 fe ff       	call   8048bb0 <__assert_fail@plt>
 805a2e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805a2ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805a2f0 <mul_rm_l>:
}

make_instr_helper(rm)
 805a2f0:	53                   	push   %ebx
 805a2f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a2f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a2f8:	83 c0 01             	add    $0x1,%eax
 805a2fb:	50                   	push   %eax
 805a2fc:	e8 2f 2f 00 00       	call   805d230 <decode_rm_l>
 805a301:	89 c3                	mov    %eax,%ebx

#define instr mul

static void do_execute() {
	uint64_t src = op_src->val;
	uint64_t result = REG(R_EAX) * src;
 805a303:	a1 c0 ae 8f 14       	mov    0x148faec0,%eax

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a308:	68 18 ae 8f 14       	push   $0x148fae18

#define instr mul

static void do_execute() {
	uint64_t src = op_src->val;
	uint64_t result = REG(R_EAX) * src;
 805a30d:	f7 25 14 ae 8f 14    	mull   0x148fae14

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a313:	68 bb 56 06 08       	push   $0x80656bb
 805a318:	6a 50                	push   $0x50
 805a31a:	68 00 89 0c 08       	push   $0x80c8900
	reg_w(R_AX) = result;
#elif DATA_BYTE == 2
	REG(R_EAX) = result & 0xffff;
	REG(R_EDX) = result >> 16;
#else
	REG(R_EAX) = result & 0xffffffff;
 805a31f:	a3 c0 ae 8f 14       	mov    %eax,0x148faec0
	REG(R_EDX) = result >> 32;
 805a324:	89 15 c8 ae 8f 14    	mov    %edx,0x148faec8

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a32a:	e8 d1 e7 fe ff       	call   8048b00 <snprintf@plt>
 805a32f:	83 c4 20             	add    $0x20,%esp
 805a332:	83 f8 4f             	cmp    $0x4f,%eax
 805a335:	7f 09                	jg     805a340 <mul_rm_l+0x50>
}

make_instr_helper(rm)
 805a337:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805a33a:	8d 43 01             	lea    0x1(%ebx),%eax
 805a33d:	5b                   	pop    %ebx
 805a33e:	c3                   	ret    
 805a33f:	90                   	nop

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a340:	83 ec 0c             	sub    $0xc,%esp
 805a343:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805a349:	e8 12 e6 fe ff       	call   8048960 <fflush@plt>
 805a34e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a354:	6a 07                	push   $0x7
 805a356:	6a 01                	push   $0x1
 805a358:	68 92 ed 05 08       	push   $0x805ed92
 805a35d:	e8 ae e6 fe ff       	call   8048a10 <fwrite@plt>
 805a362:	83 c4 20             	add    $0x20,%esp
 805a365:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a36b:	6a 10                	push   $0x10
 805a36d:	6a 01                	push   $0x1
 805a36f:	68 84 f8 05 08       	push   $0x805f884
 805a374:	e8 97 e6 fe ff       	call   8048a10 <fwrite@plt>
 805a379:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a37f:	6a 05                	push   $0x5
 805a381:	6a 01                	push   $0x1
 805a383:	68 b1 ed 05 08       	push   $0x805edb1
 805a388:	e8 83 e6 fe ff       	call   8048a10 <fwrite@plt>
 805a38d:	83 c4 20             	add    $0x20,%esp
 805a390:	68 18 ae 8f 14       	push   $0x148fae18
 805a395:	68 bb 56 06 08       	push   $0x80656bb
 805a39a:	6a 50                	push   $0x50
 805a39c:	68 00 89 0c 08       	push   $0x80c8900
 805a3a1:	e8 5a e7 fe ff       	call   8048b00 <snprintf@plt>
 805a3a6:	83 c4 10             	add    $0x10,%esp
 805a3a9:	83 f8 4f             	cmp    $0x4f,%eax
 805a3ac:	7e 89                	jle    805a337 <mul_rm_l+0x47>
 805a3ae:	68 da 51 06 08       	push   $0x80651da
 805a3b3:	6a 16                	push   $0x16
 805a3b5:	68 dc 50 06 08       	push   $0x80650dc
 805a3ba:	68 4c 51 06 08       	push   $0x806514c
 805a3bf:	e8 ec e7 fe ff       	call   8048bb0 <__assert_fail@plt>
 805a3c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805a3ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805a3d0 <mul_rm_b>:
}

make_instr_helper(rm)
 805a3d0:	53                   	push   %ebx
 805a3d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a3d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a3d8:	83 c0 01             	add    $0x1,%eax
 805a3db:	50                   	push   %eax
 805a3dc:	e8 4f 27 00 00       	call   805cb30 <decode_rm_b>
 805a3e1:	89 c3                	mov    %eax,%ebx

#define instr mul

static void do_execute() {
	uint64_t src = op_src->val;
	uint64_t result = REG(R_EAX) * src;
 805a3e3:	0f b6 05 c0 ae 8f 14 	movzbl 0x148faec0,%eax

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a3ea:	68 18 ae 8f 14       	push   $0x148fae18

#define instr mul

static void do_execute() {
	uint64_t src = op_src->val;
	uint64_t result = REG(R_EAX) * src;
 805a3ef:	f7 25 14 ae 8f 14    	mull   0x148fae14

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a3f5:	68 e2 56 06 08       	push   $0x80656e2
 805a3fa:	6a 50                	push   $0x50
 805a3fc:	68 00 89 0c 08       	push   $0x80c8900

static void do_execute() {
	uint64_t src = op_src->val;
	uint64_t result = REG(R_EAX) * src;
#if DATA_BYTE == 1
	reg_w(R_AX) = result;
 805a401:	66 a3 c0 ae 8f 14    	mov    %ax,0x148faec0

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a407:	e8 f4 e6 fe ff       	call   8048b00 <snprintf@plt>
 805a40c:	83 c4 20             	add    $0x20,%esp
 805a40f:	83 f8 4f             	cmp    $0x4f,%eax
 805a412:	7f 0c                	jg     805a420 <mul_rm_b+0x50>
}

make_instr_helper(rm)
 805a414:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805a417:	8d 43 01             	lea    0x1(%ebx),%eax
 805a41a:	5b                   	pop    %ebx
 805a41b:	c3                   	ret    
 805a41c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a420:	83 ec 0c             	sub    $0xc,%esp
 805a423:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805a429:	e8 32 e5 fe ff       	call   8048960 <fflush@plt>
 805a42e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a434:	6a 07                	push   $0x7
 805a436:	6a 01                	push   $0x1
 805a438:	68 92 ed 05 08       	push   $0x805ed92
 805a43d:	e8 ce e5 fe ff       	call   8048a10 <fwrite@plt>
 805a442:	83 c4 20             	add    $0x20,%esp
 805a445:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a44b:	6a 10                	push   $0x10
 805a44d:	6a 01                	push   $0x1
 805a44f:	68 84 f8 05 08       	push   $0x805f884
 805a454:	e8 b7 e5 fe ff       	call   8048a10 <fwrite@plt>
 805a459:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a45f:	6a 05                	push   $0x5
 805a461:	6a 01                	push   $0x1
 805a463:	68 b1 ed 05 08       	push   $0x805edb1
 805a468:	e8 a3 e5 fe ff       	call   8048a10 <fwrite@plt>
 805a46d:	83 c4 20             	add    $0x20,%esp
 805a470:	68 18 ae 8f 14       	push   $0x148fae18
 805a475:	68 e2 56 06 08       	push   $0x80656e2
 805a47a:	6a 50                	push   $0x50
 805a47c:	68 00 89 0c 08       	push   $0x80c8900
 805a481:	e8 7a e6 fe ff       	call   8048b00 <snprintf@plt>
 805a486:	83 c4 10             	add    $0x10,%esp
 805a489:	83 f8 4f             	cmp    $0x4f,%eax
 805a48c:	7e 86                	jle    805a414 <mul_rm_b+0x44>
 805a48e:	68 ec 51 06 08       	push   $0x80651ec
 805a493:	6a 16                	push   $0x16
 805a495:	68 dc 50 06 08       	push   $0x80650dc
 805a49a:	68 94 51 06 08       	push   $0x8065194
 805a49f:	e8 0c e7 fe ff       	call   8048bb0 <__assert_fail@plt>
 805a4a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805a4aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805a4b0 <mul_rm_v>:
#include "mul-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(mul_rm)
 805a4b0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805a4b7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805a4bb:	b8 00 a2 05 08       	mov    $0x805a200,%eax
 805a4c0:	75 05                	jne    805a4c7 <mul_rm_v+0x17>
 805a4c2:	b8 f0 a2 05 08       	mov    $0x805a2f0,%eax
 805a4c7:	89 54 24 04          	mov    %edx,0x4(%esp)
 805a4cb:	ff e0                	jmp    *%eax
 805a4cd:	66 90                	xchg   %ax,%ax
 805a4cf:	90                   	nop

0805a4d0 <neg_rm_l>:
	 */

	print_asm_template1();
}

make_instr_helper(rm)
 805a4d0:	53                   	push   %ebx
 805a4d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a4d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a4d8:	83 c0 01             	add    $0x1,%eax
 805a4db:	50                   	push   %eax
 805a4dc:	e8 4f 2d 00 00       	call   805d230 <decode_rm_l>
 805a4e1:	89 c3                	mov    %eax,%ebx

#define instr neg

static void do_execute() {
	DATA_TYPE result = -op_src->val;
	OPERAND_W(op_src, result);
 805a4e3:	58                   	pop    %eax
 805a4e4:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr neg

static void do_execute() {
	DATA_TYPE result = -op_src->val;
 805a4e5:	8b 15 14 ae 8f 14    	mov    0x148fae14,%edx
 805a4eb:	f7 da                	neg    %edx
	OPERAND_W(op_src, result);
 805a4ed:	52                   	push   %edx
 805a4ee:	68 08 ae 8f 14       	push   $0x148fae08
 805a4f3:	e8 a8 2e 00 00       	call   805d3a0 <write_operand_l>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a4f8:	68 18 ae 8f 14       	push   $0x148fae18
 805a4fd:	68 f5 51 06 08       	push   $0x80651f5
 805a502:	6a 50                	push   $0x50
 805a504:	68 00 89 0c 08       	push   $0x80c8900
 805a509:	e8 f2 e5 fe ff       	call   8048b00 <snprintf@plt>
 805a50e:	83 c4 20             	add    $0x20,%esp
 805a511:	83 f8 4f             	cmp    $0x4f,%eax
 805a514:	7f 0a                	jg     805a520 <neg_rm_l+0x50>
}

make_instr_helper(rm)
 805a516:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805a519:	8d 43 01             	lea    0x1(%ebx),%eax
 805a51c:	5b                   	pop    %ebx
 805a51d:	c3                   	ret    
 805a51e:	66 90                	xchg   %ax,%ax

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a520:	83 ec 0c             	sub    $0xc,%esp
 805a523:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805a529:	e8 32 e4 fe ff       	call   8048960 <fflush@plt>
 805a52e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a534:	6a 07                	push   $0x7
 805a536:	6a 01                	push   $0x1
 805a538:	68 92 ed 05 08       	push   $0x805ed92
 805a53d:	e8 ce e4 fe ff       	call   8048a10 <fwrite@plt>
 805a542:	83 c4 20             	add    $0x20,%esp
 805a545:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a54b:	6a 10                	push   $0x10
 805a54d:	6a 01                	push   $0x1
 805a54f:	68 84 f8 05 08       	push   $0x805f884
 805a554:	e8 b7 e4 fe ff       	call   8048a10 <fwrite@plt>
 805a559:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a55f:	6a 05                	push   $0x5
 805a561:	6a 01                	push   $0x1
 805a563:	68 b1 ed 05 08       	push   $0x805edb1
 805a568:	e8 a3 e4 fe ff       	call   8048a10 <fwrite@plt>
 805a56d:	83 c4 20             	add    $0x20,%esp
 805a570:	68 18 ae 8f 14       	push   $0x148fae18
 805a575:	68 f5 51 06 08       	push   $0x80651f5
 805a57a:	6a 50                	push   $0x50
 805a57c:	68 00 89 0c 08       	push   $0x80c8900
 805a581:	e8 7a e5 fe ff       	call   8048b00 <snprintf@plt>
 805a586:	83 c4 10             	add    $0x10,%esp
 805a589:	83 f8 4f             	cmp    $0x4f,%eax
 805a58c:	7e 88                	jle    805a516 <neg_rm_l+0x46>
 805a58e:	68 0e 53 06 08       	push   $0x806530e
 805a593:	6a 0d                	push   $0xd
 805a595:	68 10 52 06 08       	push   $0x8065210
 805a59a:	68 38 52 06 08       	push   $0x8065238
 805a59f:	e8 0c e6 fe ff       	call   8048bb0 <__assert_fail@plt>
 805a5a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805a5aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805a5b0 <neg_rm_w>:
}

make_instr_helper(rm)
 805a5b0:	53                   	push   %ebx
 805a5b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a5b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a5b8:	83 c0 01             	add    $0x1,%eax
 805a5bb:	50                   	push   %eax
 805a5bc:	e8 9f 28 00 00       	call   805ce60 <decode_rm_w>
 805a5c1:	89 c3                	mov    %eax,%ebx

#define instr neg

static void do_execute() {
	DATA_TYPE result = -op_src->val;
	OPERAND_W(op_src, result);
 805a5c3:	58                   	pop    %eax
 805a5c4:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr neg

static void do_execute() {
	DATA_TYPE result = -op_src->val;
 805a5c5:	0f b7 15 14 ae 8f 14 	movzwl 0x148fae14,%edx
 805a5cc:	f7 da                	neg    %edx
	OPERAND_W(op_src, result);
 805a5ce:	0f b7 d2             	movzwl %dx,%edx
 805a5d1:	52                   	push   %edx
 805a5d2:	68 08 ae 8f 14       	push   $0x148fae08
 805a5d7:	e8 f4 29 00 00       	call   805cfd0 <write_operand_w>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a5dc:	68 18 ae 8f 14       	push   $0x148fae18
 805a5e1:	68 fd 51 06 08       	push   $0x80651fd
 805a5e6:	6a 50                	push   $0x50
 805a5e8:	68 00 89 0c 08       	push   $0x80c8900
 805a5ed:	e8 0e e5 fe ff       	call   8048b00 <snprintf@plt>
 805a5f2:	83 c4 20             	add    $0x20,%esp
 805a5f5:	83 f8 4f             	cmp    $0x4f,%eax
 805a5f8:	7f 0e                	jg     805a608 <neg_rm_w+0x58>
}

make_instr_helper(rm)
 805a5fa:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805a5fd:	8d 43 01             	lea    0x1(%ebx),%eax
 805a600:	5b                   	pop    %ebx
 805a601:	c3                   	ret    
 805a602:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a608:	83 ec 0c             	sub    $0xc,%esp
 805a60b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805a611:	e8 4a e3 fe ff       	call   8048960 <fflush@plt>
 805a616:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a61c:	6a 07                	push   $0x7
 805a61e:	6a 01                	push   $0x1
 805a620:	68 92 ed 05 08       	push   $0x805ed92
 805a625:	e8 e6 e3 fe ff       	call   8048a10 <fwrite@plt>
 805a62a:	83 c4 20             	add    $0x20,%esp
 805a62d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a633:	6a 10                	push   $0x10
 805a635:	6a 01                	push   $0x1
 805a637:	68 84 f8 05 08       	push   $0x805f884
 805a63c:	e8 cf e3 fe ff       	call   8048a10 <fwrite@plt>
 805a641:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a647:	6a 05                	push   $0x5
 805a649:	6a 01                	push   $0x1
 805a64b:	68 b1 ed 05 08       	push   $0x805edb1
 805a650:	e8 bb e3 fe ff       	call   8048a10 <fwrite@plt>
 805a655:	83 c4 20             	add    $0x20,%esp
 805a658:	68 18 ae 8f 14       	push   $0x148fae18
 805a65d:	68 fd 51 06 08       	push   $0x80651fd
 805a662:	6a 50                	push   $0x50
 805a664:	68 00 89 0c 08       	push   $0x80c8900
 805a669:	e8 92 e4 fe ff       	call   8048b00 <snprintf@plt>
 805a66e:	83 c4 10             	add    $0x10,%esp
 805a671:	83 f8 4f             	cmp    $0x4f,%eax
 805a674:	7e 84                	jle    805a5fa <neg_rm_w+0x4a>
 805a676:	68 17 53 06 08       	push   $0x8065317
 805a67b:	6a 0d                	push   $0xd
 805a67d:	68 10 52 06 08       	push   $0x8065210
 805a682:	68 80 52 06 08       	push   $0x8065280
 805a687:	e8 24 e5 fe ff       	call   8048bb0 <__assert_fail@plt>
 805a68c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805a690 <neg_rm_b>:
}

make_instr_helper(rm)
 805a690:	53                   	push   %ebx
 805a691:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a694:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a698:	83 c0 01             	add    $0x1,%eax
 805a69b:	50                   	push   %eax
 805a69c:	e8 8f 24 00 00       	call   805cb30 <decode_rm_b>
 805a6a1:	89 c3                	mov    %eax,%ebx

#define instr neg

static void do_execute() {
	DATA_TYPE result = -op_src->val;
	OPERAND_W(op_src, result);
 805a6a3:	58                   	pop    %eax
 805a6a4:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr neg

static void do_execute() {
	DATA_TYPE result = -op_src->val;
 805a6a5:	0f b6 15 14 ae 8f 14 	movzbl 0x148fae14,%edx
 805a6ac:	f7 da                	neg    %edx
	OPERAND_W(op_src, result);
 805a6ae:	0f b6 d2             	movzbl %dl,%edx
 805a6b1:	52                   	push   %edx
 805a6b2:	68 08 ae 8f 14       	push   $0x148fae08
 805a6b7:	e8 84 25 00 00       	call   805cc40 <write_operand_b>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a6bc:	68 18 ae 8f 14       	push   $0x148fae18
 805a6c1:	68 05 52 06 08       	push   $0x8065205
 805a6c6:	6a 50                	push   $0x50
 805a6c8:	68 00 89 0c 08       	push   $0x80c8900
 805a6cd:	e8 2e e4 fe ff       	call   8048b00 <snprintf@plt>
 805a6d2:	83 c4 20             	add    $0x20,%esp
 805a6d5:	83 f8 4f             	cmp    $0x4f,%eax
 805a6d8:	7f 0e                	jg     805a6e8 <neg_rm_b+0x58>
}

make_instr_helper(rm)
 805a6da:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805a6dd:	8d 43 01             	lea    0x1(%ebx),%eax
 805a6e0:	5b                   	pop    %ebx
 805a6e1:	c3                   	ret    
 805a6e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a6e8:	83 ec 0c             	sub    $0xc,%esp
 805a6eb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805a6f1:	e8 6a e2 fe ff       	call   8048960 <fflush@plt>
 805a6f6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a6fc:	6a 07                	push   $0x7
 805a6fe:	6a 01                	push   $0x1
 805a700:	68 92 ed 05 08       	push   $0x805ed92
 805a705:	e8 06 e3 fe ff       	call   8048a10 <fwrite@plt>
 805a70a:	83 c4 20             	add    $0x20,%esp
 805a70d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a713:	6a 10                	push   $0x10
 805a715:	6a 01                	push   $0x1
 805a717:	68 84 f8 05 08       	push   $0x805f884
 805a71c:	e8 ef e2 fe ff       	call   8048a10 <fwrite@plt>
 805a721:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a727:	6a 05                	push   $0x5
 805a729:	6a 01                	push   $0x1
 805a72b:	68 b1 ed 05 08       	push   $0x805edb1
 805a730:	e8 db e2 fe ff       	call   8048a10 <fwrite@plt>
 805a735:	83 c4 20             	add    $0x20,%esp
 805a738:	68 18 ae 8f 14       	push   $0x148fae18
 805a73d:	68 05 52 06 08       	push   $0x8065205
 805a742:	6a 50                	push   $0x50
 805a744:	68 00 89 0c 08       	push   $0x80c8900
 805a749:	e8 b2 e3 fe ff       	call   8048b00 <snprintf@plt>
 805a74e:	83 c4 10             	add    $0x10,%esp
 805a751:	83 f8 4f             	cmp    $0x4f,%eax
 805a754:	7e 84                	jle    805a6da <neg_rm_b+0x4a>
 805a756:	68 20 53 06 08       	push   $0x8065320
 805a75b:	6a 0d                	push   $0xd
 805a75d:	68 10 52 06 08       	push   $0x8065210
 805a762:	68 c8 52 06 08       	push   $0x80652c8
 805a767:	e8 44 e4 fe ff       	call   8048bb0 <__assert_fail@plt>
 805a76c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805a770 <neg_rm_v>:
#include "neg-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(neg_rm)
 805a770:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805a777:	8b 54 24 04          	mov    0x4(%esp),%edx
 805a77b:	b8 b0 a5 05 08       	mov    $0x805a5b0,%eax
 805a780:	75 05                	jne    805a787 <neg_rm_v+0x17>
 805a782:	b8 d0 a4 05 08       	mov    $0x805a4d0,%eax
 805a787:	89 54 24 04          	mov    %edx,0x4(%esp)
 805a78b:	ff e0                	jmp    *%eax
 805a78d:	66 90                	xchg   %ax,%ax
 805a78f:	90                   	nop

0805a790 <do_inc_w>:
#include "cpu/exec/template-start.h"

#define instr inc

static void do_execute () {
 805a790:	55                   	push   %ebp
 805a791:	57                   	push   %edi
 805a792:	56                   	push   %esi
 805a793:	53                   	push   %ebx
 805a794:	83 ec 24             	sub    $0x24,%esp
	DATA_TYPE result = op_src->val + 1;
 805a797:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
 805a79e:	8d 58 01             	lea    0x1(%eax),%ebx
	OPERAND_W(op_src, result);
 805a7a1:	0f b7 c3             	movzwl %bx,%eax
 805a7a4:	50                   	push   %eax
 805a7a5:	68 08 ae 8f 14       	push   $0x148fae08
 805a7aa:	e8 21 28 00 00       	call   805cfd0 <write_operand_w>

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
 805a7af:	0f b6 c3             	movzbl %bl,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805a7b2:	8b 0d 4c ae 8f 14    	mov    0x148fae4c,%ecx
 805a7b8:	8b 35 14 ae 8f 14    	mov    0x148fae14,%esi
	DATA_TYPE result = op_src->val + 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805a7be:	89 c2                	mov    %eax,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805a7c0:	0f b6 2d e4 ae 8f 14 	movzbl 0x148faee4,%ebp
	DATA_TYPE result = op_src->val + 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805a7c7:	c1 ea 04             	shr    $0x4,%edx
 805a7ca:	31 d0                	xor    %edx,%eax
	pf = (pf >> 2) ^ pf;
 805a7cc:	89 c2                	mov    %eax,%edx
 805a7ce:	c1 ea 02             	shr    $0x2,%edx
 805a7d1:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 805a7d3:	89 c2                	mov    %eax,%edx
 805a7d5:	d1 ea                	shr    %edx
 805a7d7:	89 54 24 1c          	mov    %edx,0x1c(%esp)
	cpu.CF = op_dest->val < op_src->val;
 805a7db:	83 c4 10             	add    $0x10,%esp
 805a7de:	39 f1                	cmp    %esi,%ecx
 805a7e0:	0f 92 c2             	setb   %dl

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805a7e3:	33 44 24 0c          	xor    0xc(%esp),%eax
	cpu.CF = op_dest->val < op_src->val;
 805a7e7:	83 e5 fa             	and    $0xfffffffa,%ebp
 805a7ea:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805a7ec:	68 18 ae 8f 14       	push   $0x148fae18
 805a7f1:	68 29 53 06 08       	push   $0x8065329
 805a7f6:	6a 50                	push   $0x50
 805a7f8:	68 00 89 0c 08       	push   $0x80c8900
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
 805a7fd:	83 e0 01             	and    $0x1,%eax
 805a800:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805a807:	89 e8                	mov    %ebp,%eax
 805a809:	09 f8                	or     %edi,%eax
 805a80b:	09 d0                	or     %edx,%eax
	cpu.ZF = (result == 0);
 805a80d:	66 85 db             	test   %bx,%bx
 805a810:	0f 94 c2             	sete   %dl
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a813:	c1 e9 1f             	shr    $0x1f,%ecx
 805a816:	c1 ee 1f             	shr    $0x1f,%esi
 805a819:	31 ce                	xor    %ecx,%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
 805a81b:	c1 e2 06             	shl    $0x6,%edx
 805a81e:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a821:	21 f1                	and    %esi,%ecx
 805a823:	0f b6 35 e5 ae 8f 14 	movzbl 0x148faee5,%esi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805a82a:	09 d0                	or     %edx,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a82c:	c1 e1 03             	shl    $0x3,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805a82f:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a834:	83 e6 f7             	and    $0xfffffff7,%esi
 805a837:	09 f1                	or     %esi,%ecx
 805a839:	88 0d e5 ae 8f 14    	mov    %cl,0x148faee5

	print_asm_template1();
 805a83f:	e8 bc e2 fe ff       	call   8048b00 <snprintf@plt>
 805a844:	83 c4 10             	add    $0x10,%esp
 805a847:	83 f8 4f             	cmp    $0x4f,%eax
 805a84a:	7f 0c                	jg     805a858 <do_inc_w+0xc8>
}
 805a84c:	83 c4 1c             	add    $0x1c,%esp
 805a84f:	5b                   	pop    %ebx
 805a850:	5e                   	pop    %esi
 805a851:	5f                   	pop    %edi
 805a852:	5d                   	pop    %ebp
 805a853:	c3                   	ret    
 805a854:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805a858:	83 ec 0c             	sub    $0xc,%esp
 805a85b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805a861:	e8 fa e0 fe ff       	call   8048960 <fflush@plt>
 805a866:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a86c:	6a 07                	push   $0x7
 805a86e:	6a 01                	push   $0x1
 805a870:	68 92 ed 05 08       	push   $0x805ed92
 805a875:	e8 96 e1 fe ff       	call   8048a10 <fwrite@plt>
 805a87a:	83 c4 20             	add    $0x20,%esp
 805a87d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a883:	6a 10                	push   $0x10
 805a885:	6a 01                	push   $0x1
 805a887:	68 84 f8 05 08       	push   $0x805f884
 805a88c:	e8 7f e1 fe ff       	call   8048a10 <fwrite@plt>
 805a891:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805a897:	6a 05                	push   $0x5
 805a899:	6a 01                	push   $0x1
 805a89b:	68 b1 ed 05 08       	push   $0x805edb1
 805a8a0:	e8 6b e1 fe ff       	call   8048a10 <fwrite@plt>
 805a8a5:	83 c4 20             	add    $0x20,%esp
 805a8a8:	68 18 ae 8f 14       	push   $0x148fae18
 805a8ad:	68 29 53 06 08       	push   $0x8065329
 805a8b2:	6a 50                	push   $0x50
 805a8b4:	68 00 89 0c 08       	push   $0x80c8900
 805a8b9:	e8 42 e2 fe ff       	call   8048b00 <snprintf@plt>
 805a8be:	83 c4 10             	add    $0x10,%esp
 805a8c1:	83 f8 4f             	cmp    $0x4f,%eax
 805a8c4:	7e 86                	jle    805a84c <do_inc_w+0xbc>
 805a8c6:	68 4b 54 06 08       	push   $0x806544b
 805a8cb:	6a 14                	push   $0x14
 805a8cd:	68 44 53 06 08       	push   $0x8065344
 805a8d2:	68 6c 53 06 08       	push   $0x806536c
 805a8d7:	e8 d4 e2 fe ff       	call   8048bb0 <__assert_fail@plt>
 805a8dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805a8e0 <inc_rm_w>:
}

make_instr_helper(rm)
 805a8e0:	53                   	push   %ebx
 805a8e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a8e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a8e8:	83 c0 01             	add    $0x1,%eax
 805a8eb:	50                   	push   %eax
 805a8ec:	e8 6f 25 00 00       	call   805ce60 <decode_rm_w>
 805a8f1:	89 c3                	mov    %eax,%ebx
	execute();
 805a8f3:	e8 98 fe ff ff       	call   805a790 <do_inc_w>
 805a8f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805a8fb:	8d 43 01             	lea    0x1(%ebx),%eax
 805a8fe:	5b                   	pop    %ebx
 805a8ff:	c3                   	ret    

0805a900 <inc_r_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(r)
 805a900:	53                   	push   %ebx
 805a901:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a904:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a908:	83 c0 01             	add    $0x1,%eax
 805a90b:	50                   	push   %eax
 805a90c:	e8 6f 25 00 00       	call   805ce80 <decode_r_w>
 805a911:	89 c3                	mov    %eax,%ebx
	execute();
 805a913:	e8 78 fe ff ff       	call   805a790 <do_inc_w>
 805a918:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805a91b:	8d 43 01             	lea    0x1(%ebx),%eax
 805a91e:	5b                   	pop    %ebx
 805a91f:	c3                   	ret    

0805a920 <do_inc_l>:
#include "cpu/exec/template-start.h"

#define instr inc

static void do_execute () {
 805a920:	55                   	push   %ebp
 805a921:	57                   	push   %edi
 805a922:	56                   	push   %esi
 805a923:	53                   	push   %ebx
 805a924:	83 ec 24             	sub    $0x24,%esp
	DATA_TYPE result = op_src->val + 1;
 805a927:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
 805a92c:	8d 58 01             	lea    0x1(%eax),%ebx
	OPERAND_W(op_src, result);
 805a92f:	53                   	push   %ebx
 805a930:	68 08 ae 8f 14       	push   $0x148fae08
 805a935:	e8 66 2a 00 00       	call   805d3a0 <write_operand_l>

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
 805a93a:	0f b6 c3             	movzbl %bl,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805a93d:	8b 0d 14 ae 8f 14    	mov    0x148fae14,%ecx
 805a943:	8b 35 4c ae 8f 14    	mov    0x148fae4c,%esi
	DATA_TYPE result = op_src->val + 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805a949:	89 c2                	mov    %eax,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805a94b:	0f b6 2d e4 ae 8f 14 	movzbl 0x148faee4,%ebp
	DATA_TYPE result = op_src->val + 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805a952:	c1 ea 04             	shr    $0x4,%edx
 805a955:	31 d0                	xor    %edx,%eax
	pf = (pf >> 2) ^ pf;
 805a957:	89 c2                	mov    %eax,%edx
 805a959:	c1 ea 02             	shr    $0x2,%edx
 805a95c:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 805a95e:	89 c2                	mov    %eax,%edx
 805a960:	d1 ea                	shr    %edx
 805a962:	89 54 24 1c          	mov    %edx,0x1c(%esp)
	cpu.CF = op_dest->val < op_src->val;
 805a966:	83 c4 10             	add    $0x10,%esp
 805a969:	39 ce                	cmp    %ecx,%esi
 805a96b:	0f 92 c2             	setb   %dl

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805a96e:	33 44 24 0c          	xor    0xc(%esp),%eax
	cpu.CF = op_dest->val < op_src->val;
 805a972:	83 e5 fa             	and    $0xfffffffa,%ebp
 805a975:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805a977:	68 18 ae 8f 14       	push   $0x148fae18
 805a97c:	68 31 53 06 08       	push   $0x8065331
 805a981:	6a 50                	push   $0x50
 805a983:	68 00 89 0c 08       	push   $0x80c8900
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
 805a988:	83 e0 01             	and    $0x1,%eax
 805a98b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805a992:	89 e8                	mov    %ebp,%eax
 805a994:	09 f8                	or     %edi,%eax
 805a996:	09 d0                	or     %edx,%eax
	cpu.ZF = (result == 0);
 805a998:	85 db                	test   %ebx,%ebx
 805a99a:	0f 94 c2             	sete   %dl
	cpu.SF = (result >> 31) & 1;
 805a99d:	c1 eb 1f             	shr    $0x1f,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
 805a9a0:	83 e0 3f             	and    $0x3f,%eax
 805a9a3:	c1 e2 06             	shl    $0x6,%edx
	cpu.SF = (result >> 31) & 1;
 805a9a6:	89 df                	mov    %ebx,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a9a8:	c1 ee 1f             	shr    $0x1f,%esi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805a9ab:	09 d0                	or     %edx,%eax
 805a9ad:	c1 e7 07             	shl    $0x7,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a9b0:	31 f3                	xor    %esi,%ebx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805a9b2:	09 f8                	or     %edi,%eax
 805a9b4:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a9b9:	89 c8                	mov    %ecx,%eax
 805a9bb:	89 f1                	mov    %esi,%ecx
 805a9bd:	c1 e8 1f             	shr    $0x1f,%eax
 805a9c0:	31 c1                	xor    %eax,%ecx
 805a9c2:	21 d9                	and    %ebx,%ecx
 805a9c4:	0f b6 1d e5 ae 8f 14 	movzbl 0x148faee5,%ebx
 805a9cb:	c1 e1 03             	shl    $0x3,%ecx
 805a9ce:	83 e3 f7             	and    $0xfffffff7,%ebx
 805a9d1:	09 d9                	or     %ebx,%ecx
 805a9d3:	88 0d e5 ae 8f 14    	mov    %cl,0x148faee5

	print_asm_template1();
 805a9d9:	e8 22 e1 fe ff       	call   8048b00 <snprintf@plt>
 805a9de:	83 c4 10             	add    $0x10,%esp
 805a9e1:	83 f8 4f             	cmp    $0x4f,%eax
 805a9e4:	7f 0a                	jg     805a9f0 <do_inc_l+0xd0>
}
 805a9e6:	83 c4 1c             	add    $0x1c,%esp
 805a9e9:	5b                   	pop    %ebx
 805a9ea:	5e                   	pop    %esi
 805a9eb:	5f                   	pop    %edi
 805a9ec:	5d                   	pop    %ebp
 805a9ed:	c3                   	ret    
 805a9ee:	66 90                	xchg   %ax,%ax
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805a9f0:	83 ec 0c             	sub    $0xc,%esp
 805a9f3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805a9f9:	e8 62 df fe ff       	call   8048960 <fflush@plt>
 805a9fe:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805aa04:	6a 07                	push   $0x7
 805aa06:	6a 01                	push   $0x1
 805aa08:	68 92 ed 05 08       	push   $0x805ed92
 805aa0d:	e8 fe df fe ff       	call   8048a10 <fwrite@plt>
 805aa12:	83 c4 20             	add    $0x20,%esp
 805aa15:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805aa1b:	6a 10                	push   $0x10
 805aa1d:	6a 01                	push   $0x1
 805aa1f:	68 84 f8 05 08       	push   $0x805f884
 805aa24:	e8 e7 df fe ff       	call   8048a10 <fwrite@plt>
 805aa29:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805aa2f:	6a 05                	push   $0x5
 805aa31:	6a 01                	push   $0x1
 805aa33:	68 b1 ed 05 08       	push   $0x805edb1
 805aa38:	e8 d3 df fe ff       	call   8048a10 <fwrite@plt>
 805aa3d:	83 c4 20             	add    $0x20,%esp
 805aa40:	68 18 ae 8f 14       	push   $0x148fae18
 805aa45:	68 31 53 06 08       	push   $0x8065331
 805aa4a:	6a 50                	push   $0x50
 805aa4c:	68 00 89 0c 08       	push   $0x80c8900
 805aa51:	e8 aa e0 fe ff       	call   8048b00 <snprintf@plt>
 805aa56:	83 c4 10             	add    $0x10,%esp
 805aa59:	83 f8 4f             	cmp    $0x4f,%eax
 805aa5c:	7e 88                	jle    805a9e6 <do_inc_l+0xc6>
 805aa5e:	68 42 54 06 08       	push   $0x8065442
 805aa63:	6a 14                	push   $0x14
 805aa65:	68 44 53 06 08       	push   $0x8065344
 805aa6a:	68 b4 53 06 08       	push   $0x80653b4
 805aa6f:	e8 3c e1 fe ff       	call   8048bb0 <__assert_fail@plt>
 805aa74:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805aa7a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805aa80 <inc_rm_l>:
}

make_instr_helper(rm)
 805aa80:	53                   	push   %ebx
 805aa81:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805aa84:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805aa88:	83 c0 01             	add    $0x1,%eax
 805aa8b:	50                   	push   %eax
 805aa8c:	e8 9f 27 00 00       	call   805d230 <decode_rm_l>
 805aa91:	89 c3                	mov    %eax,%ebx
	execute();
 805aa93:	e8 88 fe ff ff       	call   805a920 <do_inc_l>
 805aa98:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805aa9b:	8d 43 01             	lea    0x1(%ebx),%eax
 805aa9e:	5b                   	pop    %ebx
 805aa9f:	c3                   	ret    

0805aaa0 <inc_r_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(r)
 805aaa0:	53                   	push   %ebx
 805aaa1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805aaa4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805aaa8:	83 c0 01             	add    $0x1,%eax
 805aaab:	50                   	push   %eax
 805aaac:	e8 9f 27 00 00       	call   805d250 <decode_r_l>
 805aab1:	89 c3                	mov    %eax,%ebx
	execute();
 805aab3:	e8 68 fe ff ff       	call   805a920 <do_inc_l>
 805aab8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805aabb:	8d 43 01             	lea    0x1(%ebx),%eax
 805aabe:	5b                   	pop    %ebx
 805aabf:	c3                   	ret    

0805aac0 <inc_rm_b>:
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
}

make_instr_helper(rm)
 805aac0:	55                   	push   %ebp
 805aac1:	57                   	push   %edi
 805aac2:	56                   	push   %esi
 805aac3:	53                   	push   %ebx
 805aac4:	83 ec 18             	sub    $0x18,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805aac7:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 805aacb:	83 c0 01             	add    $0x1,%eax
 805aace:	50                   	push   %eax
 805aacf:	e8 5c 20 00 00       	call   805cb30 <decode_rm_b>
 805aad4:	89 c6                	mov    %eax,%esi
#include "cpu/exec/template-start.h"

#define instr inc

static void do_execute () {
	DATA_TYPE result = op_src->val + 1;
 805aad6:	0f b6 05 14 ae 8f 14 	movzbl 0x148fae14,%eax
 805aadd:	8d 58 01             	lea    0x1(%eax),%ebx
	OPERAND_W(op_src, result);
 805aae0:	58                   	pop    %eax
 805aae1:	5a                   	pop    %edx
 805aae2:	0f b6 fb             	movzbl %bl,%edi
 805aae5:	57                   	push   %edi
 805aae6:	68 08 ae 8f 14       	push   $0x148fae08
 805aaeb:	e8 50 21 00 00       	call   805cc40 <write_operand_b>

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805aaf0:	89 fa                	mov    %edi,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805aaf2:	83 c4 10             	add    $0x10,%esp
 805aaf5:	8b 0d 4c ae 8f 14    	mov    0x148fae4c,%ecx
	DATA_TYPE result = op_src->val + 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805aafb:	c1 ea 04             	shr    $0x4,%edx
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805aafe:	68 18 ae 8f 14       	push   $0x148fae18
 805ab03:	68 39 53 06 08       	push   $0x8065339
	DATA_TYPE result = op_src->val + 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805ab08:	31 d7                	xor    %edx,%edi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805ab0a:	6a 50                	push   $0x50
 805ab0c:	68 00 89 0c 08       	push   $0x80c8900
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 805ab11:	89 fa                	mov    %edi,%edx
 805ab13:	c1 ea 02             	shr    $0x2,%edx
 805ab16:	31 fa                	xor    %edi,%edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805ab18:	0f b6 3d e4 ae 8f 14 	movzbl 0x148faee4,%edi

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805ab1f:	89 d5                	mov    %edx,%ebp
 805ab21:	d1 ed                	shr    %ebp
	cpu.CF = op_dest->val < op_src->val;
 805ab23:	3b 0d 14 ae 8f 14    	cmp    0x148fae14,%ecx
 805ab29:	0f 92 c0             	setb   %al

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805ab2c:	31 ea                	xor    %ebp,%edx
	cpu.CF = op_dest->val < op_src->val;
 805ab2e:	83 e7 fa             	and    $0xfffffffa,%edi
	cpu.PF = (pf & 1);
 805ab31:	83 e2 01             	and    $0x1,%edx
 805ab34:	09 f8                	or     %edi,%eax
 805ab36:	c1 e2 02             	shl    $0x2,%edx
 805ab39:	09 d0                	or     %edx,%eax
	cpu.ZF = (result == 0);
 805ab3b:	84 db                	test   %bl,%bl
 805ab3d:	0f 94 c3             	sete   %bl
 805ab40:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805ab43:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
 805ab46:	c1 e3 06             	shl    $0x6,%ebx
	cpu.SF = (result >> 31) & 1;
 805ab49:	09 d8                	or     %ebx,%eax
 805ab4b:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805ab50:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
 805ab55:	c1 e8 1f             	shr    $0x1f,%eax
 805ab58:	31 c8                	xor    %ecx,%eax
 805ab5a:	21 c1                	and    %eax,%ecx
 805ab5c:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
 805ab63:	c1 e1 03             	shl    $0x3,%ecx
 805ab66:	83 e0 f7             	and    $0xfffffff7,%eax
 805ab69:	09 c1                	or     %eax,%ecx
 805ab6b:	88 0d e5 ae 8f 14    	mov    %cl,0x148faee5

	print_asm_template1();
 805ab71:	e8 8a df fe ff       	call   8048b00 <snprintf@plt>
 805ab76:	83 c4 10             	add    $0x10,%esp
 805ab79:	83 f8 4f             	cmp    $0x4f,%eax
 805ab7c:	7f 12                	jg     805ab90 <inc_rm_b+0xd0>
}

make_instr_helper(rm)
 805ab7e:	83 c4 0c             	add    $0xc,%esp
	execute();
	return len + 1;	// "1" for opcode
 805ab81:	8d 46 01             	lea    0x1(%esi),%eax
 805ab84:	5b                   	pop    %ebx
 805ab85:	5e                   	pop    %esi
 805ab86:	5f                   	pop    %edi
 805ab87:	5d                   	pop    %ebp
 805ab88:	c3                   	ret    
 805ab89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805ab90:	83 ec 0c             	sub    $0xc,%esp
 805ab93:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805ab99:	e8 c2 dd fe ff       	call   8048960 <fflush@plt>
 805ab9e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805aba4:	6a 07                	push   $0x7
 805aba6:	6a 01                	push   $0x1
 805aba8:	68 92 ed 05 08       	push   $0x805ed92
 805abad:	e8 5e de fe ff       	call   8048a10 <fwrite@plt>
 805abb2:	83 c4 20             	add    $0x20,%esp
 805abb5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805abbb:	6a 10                	push   $0x10
 805abbd:	6a 01                	push   $0x1
 805abbf:	68 84 f8 05 08       	push   $0x805f884
 805abc4:	e8 47 de fe ff       	call   8048a10 <fwrite@plt>
 805abc9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805abcf:	6a 05                	push   $0x5
 805abd1:	6a 01                	push   $0x1
 805abd3:	68 b1 ed 05 08       	push   $0x805edb1
 805abd8:	e8 33 de fe ff       	call   8048a10 <fwrite@plt>
 805abdd:	83 c4 20             	add    $0x20,%esp
 805abe0:	68 18 ae 8f 14       	push   $0x148fae18
 805abe5:	68 39 53 06 08       	push   $0x8065339
 805abea:	6a 50                	push   $0x50
 805abec:	68 00 89 0c 08       	push   $0x80c8900
 805abf1:	e8 0a df fe ff       	call   8048b00 <snprintf@plt>
 805abf6:	83 c4 10             	add    $0x10,%esp
 805abf9:	83 f8 4f             	cmp    $0x4f,%eax
 805abfc:	7e 80                	jle    805ab7e <inc_rm_b+0xbe>
 805abfe:	68 54 54 06 08       	push   $0x8065454
 805ac03:	6a 14                	push   $0x14
 805ac05:	68 44 53 06 08       	push   $0x8065344
 805ac0a:	68 fc 53 06 08       	push   $0x80653fc
 805ac0f:	e8 9c df fe ff       	call   8048bb0 <__assert_fail@plt>
 805ac14:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805ac1a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805ac20 <inc_rm_v>:
#include "inc-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(inc_rm)
 805ac20:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805ac27:	8b 54 24 04          	mov    0x4(%esp),%edx
 805ac2b:	b8 e0 a8 05 08       	mov    $0x805a8e0,%eax
 805ac30:	75 05                	jne    805ac37 <inc_rm_v+0x17>
 805ac32:	b8 80 aa 05 08       	mov    $0x805aa80,%eax
 805ac37:	89 54 24 04          	mov    %edx,0x4(%esp)
 805ac3b:	ff e0                	jmp    *%eax
 805ac3d:	8d 76 00             	lea    0x0(%esi),%esi

0805ac40 <inc_r_v>:
make_helper_v(inc_r)
 805ac40:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805ac47:	8b 54 24 04          	mov    0x4(%esp),%edx
 805ac4b:	b8 00 a9 05 08       	mov    $0x805a900,%eax
 805ac50:	75 05                	jne    805ac57 <inc_r_v+0x17>
 805ac52:	b8 a0 aa 05 08       	mov    $0x805aaa0,%eax
 805ac57:	89 54 24 04          	mov    %edx,0x4(%esp)
 805ac5b:	ff e0                	jmp    *%eax
 805ac5d:	66 90                	xchg   %ax,%ax
 805ac5f:	90                   	nop

0805ac60 <idiv_rm_w>:
	REG(R_EDX) = a % b;

	print_asm_template1();
}

make_instr_helper(rm)
 805ac60:	55                   	push   %ebp
 805ac61:	57                   	push   %edi
 805ac62:	56                   	push   %esi
 805ac63:	53                   	push   %ebx
 805ac64:	83 ec 28             	sub    $0x28,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805ac67:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 805ac6b:	83 c0 01             	add    $0x1,%eax
 805ac6e:	50                   	push   %eax
 805ac6f:	e8 ec 21 00 00       	call   805ce60 <decode_rm_w>
 805ac74:	89 c5                	mov    %eax,%ebp
	int64_t a;
	int32_t b = (DATA_TYPE_S)op_src->val;
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
 805ac76:	0f b7 05 c8 ae 8f 14 	movzwl 0x148faec8,%eax
 805ac7d:	0f b7 0d c0 ae 8f 14 	movzwl 0x148faec0,%ecx
 805ac84:	31 d2                	xor    %edx,%edx
 805ac86:	0f a4 c2 10          	shld   $0x10,%eax,%edx
 805ac8a:	c1 e0 10             	shl    $0x10,%eax
 805ac8d:	09 c1                	or     %eax,%ecx
 805ac8f:	89 d7                	mov    %edx,%edi
 805ac91:	89 ce                	mov    %ecx,%esi
#endif
	REG(R_EAX) = a / b;
 805ac93:	0f bf 0d 14 ae 8f 14 	movswl 0x148fae14,%ecx
 805ac9a:	89 cb                	mov    %ecx,%ebx
 805ac9c:	c1 fb 1f             	sar    $0x1f,%ebx
 805ac9f:	53                   	push   %ebx
 805aca0:	51                   	push   %ecx
 805aca1:	89 4c 24 20          	mov    %ecx,0x20(%esp)
 805aca5:	89 5c 24 24          	mov    %ebx,0x24(%esp)
 805aca9:	52                   	push   %edx
 805acaa:	56                   	push   %esi
 805acab:	e8 90 39 00 00       	call   805e640 <__divdi3>
 805acb0:	83 c4 10             	add    $0x10,%esp
	REG(R_EDX) = a % b;
 805acb3:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 805acb7:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805acbb:	66 a3 c0 ae 8f 14    	mov    %ax,0x148faec0
	REG(R_EDX) = a % b;
 805acc1:	53                   	push   %ebx
 805acc2:	51                   	push   %ecx
 805acc3:	57                   	push   %edi
 805acc4:	56                   	push   %esi
 805acc5:	e8 46 3b 00 00       	call   805e810 <__moddi3>
 805acca:	83 c4 10             	add    $0x10,%esp
 805accd:	66 a3 c8 ae 8f 14    	mov    %ax,0x148faec8

	print_asm_template1();
 805acd3:	68 18 ae 8f 14       	push   $0x148fae18
 805acd8:	68 5d 54 06 08       	push   $0x806545d
 805acdd:	6a 50                	push   $0x50
 805acdf:	68 00 89 0c 08       	push   $0x80c8900
 805ace4:	e8 17 de fe ff       	call   8048b00 <snprintf@plt>
 805ace9:	83 c4 20             	add    $0x20,%esp
 805acec:	83 f8 4f             	cmp    $0x4f,%eax
 805acef:	7f 0f                	jg     805ad00 <idiv_rm_w+0xa0>
}

make_instr_helper(rm)
 805acf1:	83 c4 1c             	add    $0x1c,%esp
	execute();
	return len + 1;	// "1" for opcode
 805acf4:	8d 45 01             	lea    0x1(%ebp),%eax
 805acf7:	5b                   	pop    %ebx
 805acf8:	5e                   	pop    %esi
 805acf9:	5f                   	pop    %edi
 805acfa:	5d                   	pop    %ebp
 805acfb:	c3                   	ret    
 805acfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
	REG(R_EDX) = a % b;

	print_asm_template1();
 805ad00:	83 ec 0c             	sub    $0xc,%esp
 805ad03:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805ad09:	e8 52 dc fe ff       	call   8048960 <fflush@plt>
 805ad0e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805ad14:	6a 07                	push   $0x7
 805ad16:	6a 01                	push   $0x1
 805ad18:	68 92 ed 05 08       	push   $0x805ed92
 805ad1d:	e8 ee dc fe ff       	call   8048a10 <fwrite@plt>
 805ad22:	83 c4 20             	add    $0x20,%esp
 805ad25:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805ad2b:	6a 10                	push   $0x10
 805ad2d:	6a 01                	push   $0x1
 805ad2f:	68 84 f8 05 08       	push   $0x805f884
 805ad34:	e8 d7 dc fe ff       	call   8048a10 <fwrite@plt>
 805ad39:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805ad3f:	6a 05                	push   $0x5
 805ad41:	6a 01                	push   $0x1
 805ad43:	68 b1 ed 05 08       	push   $0x805edb1
 805ad48:	e8 c3 dc fe ff       	call   8048a10 <fwrite@plt>
 805ad4d:	83 c4 20             	add    $0x20,%esp
 805ad50:	68 18 ae 8f 14       	push   $0x148fae18
 805ad55:	68 5d 54 06 08       	push   $0x806545d
 805ad5a:	6a 50                	push   $0x50
 805ad5c:	68 00 89 0c 08       	push   $0x80c8900
 805ad61:	e8 9a dd fe ff       	call   8048b00 <snprintf@plt>
 805ad66:	83 c4 10             	add    $0x10,%esp
 805ad69:	83 f8 4f             	cmp    $0x4f,%eax
 805ad6c:	7e 83                	jle    805acf1 <idiv_rm_w+0x91>
 805ad6e:	68 81 55 06 08       	push   $0x8065581
 805ad73:	6a 10                	push   $0x10
 805ad75:	68 78 54 06 08       	push   $0x8065478
 805ad7a:	68 a0 54 06 08       	push   $0x80654a0
 805ad7f:	e8 2c de fe ff       	call   8048bb0 <__assert_fail@plt>
 805ad84:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805ad8a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805ad90 <idiv_rm_l>:
}

make_instr_helper(rm)
 805ad90:	55                   	push   %ebp
 805ad91:	57                   	push   %edi
 805ad92:	56                   	push   %esi
 805ad93:	53                   	push   %ebx
 805ad94:	83 ec 28             	sub    $0x28,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805ad97:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 805ad9b:	83 c0 01             	add    $0x1,%eax
 805ad9e:	50                   	push   %eax
 805ad9f:	e8 8c 24 00 00       	call   805d230 <decode_rm_l>
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805ada4:	8b 0d 14 ae 8f 14    	mov    0x148fae14,%ecx
	int64_t a;
	int32_t b = (DATA_TYPE_S)op_src->val;
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
 805adaa:	8b 35 c0 ae 8f 14    	mov    0x148faec0,%esi
 805adb0:	89 c5                	mov    %eax,%ebp
 805adb2:	8b 3d c8 ae 8f 14    	mov    0x148faec8,%edi
#endif
	REG(R_EAX) = a / b;
 805adb8:	89 cb                	mov    %ecx,%ebx
 805adba:	c1 fb 1f             	sar    $0x1f,%ebx
 805adbd:	53                   	push   %ebx
 805adbe:	51                   	push   %ecx
 805adbf:	89 4c 24 20          	mov    %ecx,0x20(%esp)
 805adc3:	89 5c 24 24          	mov    %ebx,0x24(%esp)
 805adc7:	57                   	push   %edi
 805adc8:	56                   	push   %esi
 805adc9:	e8 72 38 00 00       	call   805e640 <__divdi3>
 805adce:	83 c4 10             	add    $0x10,%esp
	REG(R_EDX) = a % b;
 805add1:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 805add5:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805add9:	a3 c0 ae 8f 14       	mov    %eax,0x148faec0
	REG(R_EDX) = a % b;
 805adde:	53                   	push   %ebx
 805addf:	51                   	push   %ecx
 805ade0:	57                   	push   %edi
 805ade1:	56                   	push   %esi
 805ade2:	e8 29 3a 00 00       	call   805e810 <__moddi3>
 805ade7:	83 c4 10             	add    $0x10,%esp
 805adea:	a3 c8 ae 8f 14       	mov    %eax,0x148faec8

	print_asm_template1();
 805adef:	68 18 ae 8f 14       	push   $0x148fae18
 805adf4:	68 66 54 06 08       	push   $0x8065466
 805adf9:	6a 50                	push   $0x50
 805adfb:	68 00 89 0c 08       	push   $0x80c8900
 805ae00:	e8 fb dc fe ff       	call   8048b00 <snprintf@plt>
 805ae05:	83 c4 20             	add    $0x20,%esp
 805ae08:	83 f8 4f             	cmp    $0x4f,%eax
 805ae0b:	7f 13                	jg     805ae20 <idiv_rm_l+0x90>
}

make_instr_helper(rm)
 805ae0d:	83 c4 1c             	add    $0x1c,%esp
	execute();
	return len + 1;	// "1" for opcode
 805ae10:	8d 45 01             	lea    0x1(%ebp),%eax
 805ae13:	5b                   	pop    %ebx
 805ae14:	5e                   	pop    %esi
 805ae15:	5f                   	pop    %edi
 805ae16:	5d                   	pop    %ebp
 805ae17:	c3                   	ret    
 805ae18:	90                   	nop
 805ae19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
	REG(R_EDX) = a % b;

	print_asm_template1();
 805ae20:	83 ec 0c             	sub    $0xc,%esp
 805ae23:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805ae29:	e8 32 db fe ff       	call   8048960 <fflush@plt>
 805ae2e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805ae34:	6a 07                	push   $0x7
 805ae36:	6a 01                	push   $0x1
 805ae38:	68 92 ed 05 08       	push   $0x805ed92
 805ae3d:	e8 ce db fe ff       	call   8048a10 <fwrite@plt>
 805ae42:	83 c4 20             	add    $0x20,%esp
 805ae45:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805ae4b:	6a 10                	push   $0x10
 805ae4d:	6a 01                	push   $0x1
 805ae4f:	68 84 f8 05 08       	push   $0x805f884
 805ae54:	e8 b7 db fe ff       	call   8048a10 <fwrite@plt>
 805ae59:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805ae5f:	6a 05                	push   $0x5
 805ae61:	6a 01                	push   $0x1
 805ae63:	68 b1 ed 05 08       	push   $0x805edb1
 805ae68:	e8 a3 db fe ff       	call   8048a10 <fwrite@plt>
 805ae6d:	83 c4 20             	add    $0x20,%esp
 805ae70:	68 18 ae 8f 14       	push   $0x148fae18
 805ae75:	68 66 54 06 08       	push   $0x8065466
 805ae7a:	6a 50                	push   $0x50
 805ae7c:	68 00 89 0c 08       	push   $0x80c8900
 805ae81:	e8 7a dc fe ff       	call   8048b00 <snprintf@plt>
 805ae86:	83 c4 10             	add    $0x10,%esp
 805ae89:	83 f8 4f             	cmp    $0x4f,%eax
 805ae8c:	0f 8e 7b ff ff ff    	jle    805ae0d <idiv_rm_l+0x7d>
 805ae92:	68 77 55 06 08       	push   $0x8065577
 805ae97:	6a 10                	push   $0x10
 805ae99:	68 78 54 06 08       	push   $0x8065478
 805ae9e:	68 e8 54 06 08       	push   $0x80654e8
 805aea3:	e8 08 dd fe ff       	call   8048bb0 <__assert_fail@plt>
 805aea8:	90                   	nop
 805aea9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0805aeb0 <idiv_rm_b>:
}

make_instr_helper(rm)
 805aeb0:	55                   	push   %ebp
 805aeb1:	57                   	push   %edi
 805aeb2:	56                   	push   %esi
 805aeb3:	53                   	push   %ebx
 805aeb4:	83 ec 28             	sub    $0x28,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805aeb7:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 805aebb:	83 c0 01             	add    $0x1,%eax
 805aebe:	50                   	push   %eax
 805aebf:	e8 6c 1c 00 00       	call   805cb30 <decode_rm_b>
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805aec4:	0f be 0d 14 ae 8f 14 	movsbl 0x148fae14,%ecx

static void do_execute() {
	int64_t a;
	int32_t b = (DATA_TYPE_S)op_src->val;
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
 805aecb:	0f bf 35 c0 ae 8f 14 	movswl 0x148faec0,%esi
 805aed2:	89 c5                	mov    %eax,%ebp
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805aed4:	89 cb                	mov    %ecx,%ebx

static void do_execute() {
	int64_t a;
	int32_t b = (DATA_TYPE_S)op_src->val;
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
 805aed6:	89 f7                	mov    %esi,%edi
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805aed8:	c1 fb 1f             	sar    $0x1f,%ebx

static void do_execute() {
	int64_t a;
	int32_t b = (DATA_TYPE_S)op_src->val;
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
 805aedb:	c1 ff 1f             	sar    $0x1f,%edi
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805aede:	53                   	push   %ebx
 805aedf:	51                   	push   %ecx
 805aee0:	89 4c 24 20          	mov    %ecx,0x20(%esp)
 805aee4:	89 5c 24 24          	mov    %ebx,0x24(%esp)
 805aee8:	57                   	push   %edi
 805aee9:	56                   	push   %esi
 805aeea:	e8 51 37 00 00       	call   805e640 <__divdi3>
 805aeef:	83 c4 10             	add    $0x10,%esp
	REG(R_EDX) = a % b;
 805aef2:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 805aef6:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805aefa:	a2 c0 ae 8f 14       	mov    %al,0x148faec0
	REG(R_EDX) = a % b;
 805aeff:	53                   	push   %ebx
 805af00:	51                   	push   %ecx
 805af01:	57                   	push   %edi
 805af02:	56                   	push   %esi
 805af03:	e8 08 39 00 00       	call   805e810 <__moddi3>
 805af08:	83 c4 10             	add    $0x10,%esp
 805af0b:	a2 c8 ae 8f 14       	mov    %al,0x148faec8

	print_asm_template1();
 805af10:	68 18 ae 8f 14       	push   $0x148fae18
 805af15:	68 6f 54 06 08       	push   $0x806546f
 805af1a:	6a 50                	push   $0x50
 805af1c:	68 00 89 0c 08       	push   $0x80c8900
 805af21:	e8 da db fe ff       	call   8048b00 <snprintf@plt>
 805af26:	83 c4 20             	add    $0x20,%esp
 805af29:	83 f8 4f             	cmp    $0x4f,%eax
 805af2c:	7f 12                	jg     805af40 <idiv_rm_b+0x90>
}

make_instr_helper(rm)
 805af2e:	83 c4 1c             	add    $0x1c,%esp
	execute();
	return len + 1;	// "1" for opcode
 805af31:	8d 45 01             	lea    0x1(%ebp),%eax
 805af34:	5b                   	pop    %ebx
 805af35:	5e                   	pop    %esi
 805af36:	5f                   	pop    %edi
 805af37:	5d                   	pop    %ebp
 805af38:	c3                   	ret    
 805af39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
	REG(R_EDX) = a % b;

	print_asm_template1();
 805af40:	83 ec 0c             	sub    $0xc,%esp
 805af43:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805af49:	e8 12 da fe ff       	call   8048960 <fflush@plt>
 805af4e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805af54:	6a 07                	push   $0x7
 805af56:	6a 01                	push   $0x1
 805af58:	68 92 ed 05 08       	push   $0x805ed92
 805af5d:	e8 ae da fe ff       	call   8048a10 <fwrite@plt>
 805af62:	83 c4 20             	add    $0x20,%esp
 805af65:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805af6b:	6a 10                	push   $0x10
 805af6d:	6a 01                	push   $0x1
 805af6f:	68 84 f8 05 08       	push   $0x805f884
 805af74:	e8 97 da fe ff       	call   8048a10 <fwrite@plt>
 805af79:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805af7f:	6a 05                	push   $0x5
 805af81:	6a 01                	push   $0x1
 805af83:	68 b1 ed 05 08       	push   $0x805edb1
 805af88:	e8 83 da fe ff       	call   8048a10 <fwrite@plt>
 805af8d:	83 c4 20             	add    $0x20,%esp
 805af90:	68 18 ae 8f 14       	push   $0x148fae18
 805af95:	68 6f 54 06 08       	push   $0x806546f
 805af9a:	6a 50                	push   $0x50
 805af9c:	68 00 89 0c 08       	push   $0x80c8900
 805afa1:	e8 5a db fe ff       	call   8048b00 <snprintf@plt>
 805afa6:	83 c4 10             	add    $0x10,%esp
 805afa9:	83 f8 4f             	cmp    $0x4f,%eax
 805afac:	7e 80                	jle    805af2e <idiv_rm_b+0x7e>
 805afae:	68 8b 55 06 08       	push   $0x806558b
 805afb3:	6a 10                	push   $0x10
 805afb5:	68 78 54 06 08       	push   $0x8065478
 805afba:	68 30 55 06 08       	push   $0x8065530
 805afbf:	e8 ec db fe ff       	call   8048bb0 <__assert_fail@plt>
 805afc4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805afca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805afd0 <idiv_rm_v>:
#include "idiv-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(idiv_rm)
 805afd0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805afd7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805afdb:	b8 60 ac 05 08       	mov    $0x805ac60,%eax
 805afe0:	75 05                	jne    805afe7 <idiv_rm_v+0x17>
 805afe2:	b8 90 ad 05 08       	mov    $0x805ad90,%eax
 805afe7:	89 54 24 04          	mov    %edx,0x4(%esp)
 805afeb:	ff e0                	jmp    *%eax
 805afed:	66 90                	xchg   %ax,%ax
 805afef:	90                   	nop

0805aff0 <div_rm_l>:
	REG(R_EDX) = a % b;

	print_asm_template1();
}

make_instr_helper(rm)
 805aff0:	55                   	push   %ebp
 805aff1:	57                   	push   %edi
 805aff2:	56                   	push   %esi
 805aff3:	53                   	push   %ebx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805aff4:	31 db                	xor    %ebx,%ebx
	REG(R_EDX) = a % b;

	print_asm_template1();
}

make_instr_helper(rm)
 805aff6:	83 ec 28             	sub    $0x28,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805aff9:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 805affd:	83 c0 01             	add    $0x1,%eax
 805b000:	50                   	push   %eax
 805b001:	e8 2a 22 00 00       	call   805d230 <decode_rm_l>
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805b006:	8b 0d 14 ae 8f 14    	mov    0x148fae14,%ecx
	uint64_t a;
	uint32_t b = (DATA_TYPE)op_src->val;
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
 805b00c:	8b 35 c0 ae 8f 14    	mov    0x148faec0,%esi
 805b012:	89 c5                	mov    %eax,%ebp
 805b014:	8b 3d c8 ae 8f 14    	mov    0x148faec8,%edi
#endif
	REG(R_EAX) = a / b;
 805b01a:	53                   	push   %ebx
 805b01b:	51                   	push   %ecx
 805b01c:	89 4c 24 20          	mov    %ecx,0x20(%esp)
 805b020:	89 5c 24 24          	mov    %ebx,0x24(%esp)
 805b024:	57                   	push   %edi
 805b025:	56                   	push   %esi
 805b026:	e8 05 3a 00 00       	call   805ea30 <__udivdi3>
 805b02b:	83 c4 10             	add    $0x10,%esp
	REG(R_EDX) = a % b;
 805b02e:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 805b032:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805b036:	a3 c0 ae 8f 14       	mov    %eax,0x148faec0
	REG(R_EDX) = a % b;
 805b03b:	53                   	push   %ebx
 805b03c:	51                   	push   %ecx
 805b03d:	57                   	push   %edi
 805b03e:	56                   	push   %esi
 805b03f:	e8 1c 3b 00 00       	call   805eb60 <__umoddi3>
 805b044:	83 c4 10             	add    $0x10,%esp
 805b047:	a3 c8 ae 8f 14       	mov    %eax,0x148faec8

	print_asm_template1();
 805b04c:	68 18 ae 8f 14       	push   $0x148fae18
 805b051:	68 67 54 06 08       	push   $0x8065467
 805b056:	6a 50                	push   $0x50
 805b058:	68 00 89 0c 08       	push   $0x80c8900
 805b05d:	e8 9e da fe ff       	call   8048b00 <snprintf@plt>
 805b062:	83 c4 20             	add    $0x20,%esp
 805b065:	83 f8 4f             	cmp    $0x4f,%eax
 805b068:	7f 0e                	jg     805b078 <div_rm_l+0x88>
}

make_instr_helper(rm)
 805b06a:	83 c4 1c             	add    $0x1c,%esp
	execute();
	return len + 1;	// "1" for opcode
 805b06d:	8d 45 01             	lea    0x1(%ebp),%eax
 805b070:	5b                   	pop    %ebx
 805b071:	5e                   	pop    %esi
 805b072:	5f                   	pop    %edi
 805b073:	5d                   	pop    %ebp
 805b074:	c3                   	ret    
 805b075:	8d 76 00             	lea    0x0(%esi),%esi
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
	REG(R_EDX) = a % b;

	print_asm_template1();
 805b078:	83 ec 0c             	sub    $0xc,%esp
 805b07b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805b081:	e8 da d8 fe ff       	call   8048960 <fflush@plt>
 805b086:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b08c:	6a 07                	push   $0x7
 805b08e:	6a 01                	push   $0x1
 805b090:	68 92 ed 05 08       	push   $0x805ed92
 805b095:	e8 76 d9 fe ff       	call   8048a10 <fwrite@plt>
 805b09a:	83 c4 20             	add    $0x20,%esp
 805b09d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b0a3:	6a 10                	push   $0x10
 805b0a5:	6a 01                	push   $0x1
 805b0a7:	68 84 f8 05 08       	push   $0x805f884
 805b0ac:	e8 5f d9 fe ff       	call   8048a10 <fwrite@plt>
 805b0b1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b0b7:	6a 05                	push   $0x5
 805b0b9:	6a 01                	push   $0x1
 805b0bb:	68 b1 ed 05 08       	push   $0x805edb1
 805b0c0:	e8 4b d9 fe ff       	call   8048a10 <fwrite@plt>
 805b0c5:	83 c4 20             	add    $0x20,%esp
 805b0c8:	68 18 ae 8f 14       	push   $0x148fae18
 805b0cd:	68 67 54 06 08       	push   $0x8065467
 805b0d2:	6a 50                	push   $0x50
 805b0d4:	68 00 89 0c 08       	push   $0x80c8900
 805b0d9:	e8 22 da fe ff       	call   8048b00 <snprintf@plt>
 805b0de:	83 c4 10             	add    $0x10,%esp
 805b0e1:	83 f8 4f             	cmp    $0x4f,%eax
 805b0e4:	7e 84                	jle    805b06a <div_rm_l+0x7a>
 805b0e6:	68 96 56 06 08       	push   $0x8065696
 805b0eb:	6a 10                	push   $0x10
 805b0ed:	68 98 55 06 08       	push   $0x8065598
 805b0f2:	68 c0 55 06 08       	push   $0x80655c0
 805b0f7:	e8 b4 da fe ff       	call   8048bb0 <__assert_fail@plt>
 805b0fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805b100 <div_rm_w>:
}

make_instr_helper(rm)
 805b100:	55                   	push   %ebp
 805b101:	57                   	push   %edi
 805b102:	56                   	push   %esi
 805b103:	53                   	push   %ebx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805b104:	31 db                	xor    %ebx,%ebx
	REG(R_EDX) = a % b;

	print_asm_template1();
}

make_instr_helper(rm)
 805b106:	83 ec 28             	sub    $0x28,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b109:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 805b10d:	83 c0 01             	add    $0x1,%eax
 805b110:	50                   	push   %eax
 805b111:	e8 4a 1d 00 00       	call   805ce60 <decode_rm_w>
 805b116:	89 c5                	mov    %eax,%ebp
	uint64_t a;
	uint32_t b = (DATA_TYPE)op_src->val;
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
 805b118:	0f b7 05 c8 ae 8f 14 	movzwl 0x148faec8,%eax
 805b11f:	0f b7 0d c0 ae 8f 14 	movzwl 0x148faec0,%ecx
 805b126:	31 d2                	xor    %edx,%edx
#endif
	REG(R_EAX) = a / b;
 805b128:	53                   	push   %ebx
	uint64_t a;
	uint32_t b = (DATA_TYPE)op_src->val;
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
 805b129:	0f a4 c2 10          	shld   $0x10,%eax,%edx
 805b12d:	c1 e0 10             	shl    $0x10,%eax
 805b130:	09 c1                	or     %eax,%ecx
 805b132:	89 d7                	mov    %edx,%edi
 805b134:	89 ce                	mov    %ecx,%esi

#define instr div

static void do_execute() {
	uint64_t a;
	uint32_t b = (DATA_TYPE)op_src->val;
 805b136:	0f b7 0d 14 ae 8f 14 	movzwl 0x148fae14,%ecx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805b13d:	51                   	push   %ecx
 805b13e:	89 4c 24 20          	mov    %ecx,0x20(%esp)
 805b142:	89 5c 24 24          	mov    %ebx,0x24(%esp)
 805b146:	52                   	push   %edx
 805b147:	56                   	push   %esi
 805b148:	e8 e3 38 00 00       	call   805ea30 <__udivdi3>
 805b14d:	83 c4 10             	add    $0x10,%esp
	REG(R_EDX) = a % b;
 805b150:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 805b154:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805b158:	66 a3 c0 ae 8f 14    	mov    %ax,0x148faec0
	REG(R_EDX) = a % b;
 805b15e:	53                   	push   %ebx
 805b15f:	51                   	push   %ecx
 805b160:	57                   	push   %edi
 805b161:	56                   	push   %esi
 805b162:	e8 f9 39 00 00       	call   805eb60 <__umoddi3>
 805b167:	83 c4 10             	add    $0x10,%esp
 805b16a:	66 a3 c8 ae 8f 14    	mov    %ax,0x148faec8

	print_asm_template1();
 805b170:	68 18 ae 8f 14       	push   $0x148fae18
 805b175:	68 5e 54 06 08       	push   $0x806545e
 805b17a:	6a 50                	push   $0x50
 805b17c:	68 00 89 0c 08       	push   $0x80c8900
 805b181:	e8 7a d9 fe ff       	call   8048b00 <snprintf@plt>
 805b186:	83 c4 20             	add    $0x20,%esp
 805b189:	83 f8 4f             	cmp    $0x4f,%eax
 805b18c:	7f 12                	jg     805b1a0 <div_rm_w+0xa0>
}

make_instr_helper(rm)
 805b18e:	83 c4 1c             	add    $0x1c,%esp
	execute();
	return len + 1;	// "1" for opcode
 805b191:	8d 45 01             	lea    0x1(%ebp),%eax
 805b194:	5b                   	pop    %ebx
 805b195:	5e                   	pop    %esi
 805b196:	5f                   	pop    %edi
 805b197:	5d                   	pop    %ebp
 805b198:	c3                   	ret    
 805b199:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
	REG(R_EDX) = a % b;

	print_asm_template1();
 805b1a0:	83 ec 0c             	sub    $0xc,%esp
 805b1a3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805b1a9:	e8 b2 d7 fe ff       	call   8048960 <fflush@plt>
 805b1ae:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b1b4:	6a 07                	push   $0x7
 805b1b6:	6a 01                	push   $0x1
 805b1b8:	68 92 ed 05 08       	push   $0x805ed92
 805b1bd:	e8 4e d8 fe ff       	call   8048a10 <fwrite@plt>
 805b1c2:	83 c4 20             	add    $0x20,%esp
 805b1c5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b1cb:	6a 10                	push   $0x10
 805b1cd:	6a 01                	push   $0x1
 805b1cf:	68 84 f8 05 08       	push   $0x805f884
 805b1d4:	e8 37 d8 fe ff       	call   8048a10 <fwrite@plt>
 805b1d9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b1df:	6a 05                	push   $0x5
 805b1e1:	6a 01                	push   $0x1
 805b1e3:	68 b1 ed 05 08       	push   $0x805edb1
 805b1e8:	e8 23 d8 fe ff       	call   8048a10 <fwrite@plt>
 805b1ed:	83 c4 20             	add    $0x20,%esp
 805b1f0:	68 18 ae 8f 14       	push   $0x148fae18
 805b1f5:	68 5e 54 06 08       	push   $0x806545e
 805b1fa:	6a 50                	push   $0x50
 805b1fc:	68 00 89 0c 08       	push   $0x80c8900
 805b201:	e8 fa d8 fe ff       	call   8048b00 <snprintf@plt>
 805b206:	83 c4 10             	add    $0x10,%esp
 805b209:	83 f8 4f             	cmp    $0x4f,%eax
 805b20c:	7e 80                	jle    805b18e <div_rm_w+0x8e>
 805b20e:	68 9f 56 06 08       	push   $0x806569f
 805b213:	6a 10                	push   $0x10
 805b215:	68 98 55 06 08       	push   $0x8065598
 805b21a:	68 08 56 06 08       	push   $0x8065608
 805b21f:	e8 8c d9 fe ff       	call   8048bb0 <__assert_fail@plt>
 805b224:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805b22a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805b230 <div_rm_b>:
}

make_instr_helper(rm)
 805b230:	55                   	push   %ebp
 805b231:	57                   	push   %edi

static void do_execute() {
	uint64_t a;
	uint32_t b = (DATA_TYPE)op_src->val;
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
 805b232:	31 ff                	xor    %edi,%edi
	REG(R_EDX) = a % b;

	print_asm_template1();
}

make_instr_helper(rm)
 805b234:	56                   	push   %esi
 805b235:	53                   	push   %ebx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805b236:	31 db                	xor    %ebx,%ebx
	REG(R_EDX) = a % b;

	print_asm_template1();
}

make_instr_helper(rm)
 805b238:	83 ec 28             	sub    $0x28,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b23b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 805b23f:	83 c0 01             	add    $0x1,%eax
 805b242:	50                   	push   %eax
 805b243:	e8 e8 18 00 00       	call   805cb30 <decode_rm_b>

#define instr div

static void do_execute() {
	uint64_t a;
	uint32_t b = (DATA_TYPE)op_src->val;
 805b248:	0f b6 0d 14 ae 8f 14 	movzbl 0x148fae14,%ecx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
 805b24f:	0f b7 35 c0 ae 8f 14 	movzwl 0x148faec0,%esi
 805b256:	89 c5                	mov    %eax,%ebp
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805b258:	53                   	push   %ebx
 805b259:	51                   	push   %ecx
 805b25a:	89 4c 24 20          	mov    %ecx,0x20(%esp)
 805b25e:	89 5c 24 24          	mov    %ebx,0x24(%esp)
 805b262:	57                   	push   %edi
 805b263:	56                   	push   %esi
 805b264:	e8 c7 37 00 00       	call   805ea30 <__udivdi3>
 805b269:	83 c4 10             	add    $0x10,%esp
	REG(R_EDX) = a % b;
 805b26c:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 805b270:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805b274:	a2 c0 ae 8f 14       	mov    %al,0x148faec0
	REG(R_EDX) = a % b;
 805b279:	53                   	push   %ebx
 805b27a:	51                   	push   %ecx
 805b27b:	57                   	push   %edi
 805b27c:	56                   	push   %esi
 805b27d:	e8 de 38 00 00       	call   805eb60 <__umoddi3>
 805b282:	83 c4 10             	add    $0x10,%esp
 805b285:	a2 c8 ae 8f 14       	mov    %al,0x148faec8

	print_asm_template1();
 805b28a:	68 18 ae 8f 14       	push   $0x148fae18
 805b28f:	68 70 54 06 08       	push   $0x8065470
 805b294:	6a 50                	push   $0x50
 805b296:	68 00 89 0c 08       	push   $0x80c8900
 805b29b:	e8 60 d8 fe ff       	call   8048b00 <snprintf@plt>
 805b2a0:	83 c4 20             	add    $0x20,%esp
 805b2a3:	83 f8 4f             	cmp    $0x4f,%eax
 805b2a6:	7f 10                	jg     805b2b8 <div_rm_b+0x88>
}

make_instr_helper(rm)
 805b2a8:	83 c4 1c             	add    $0x1c,%esp
	execute();
	return len + 1;	// "1" for opcode
 805b2ab:	8d 45 01             	lea    0x1(%ebp),%eax
 805b2ae:	5b                   	pop    %ebx
 805b2af:	5e                   	pop    %esi
 805b2b0:	5f                   	pop    %edi
 805b2b1:	5d                   	pop    %ebp
 805b2b2:	c3                   	ret    
 805b2b3:	90                   	nop
 805b2b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
	REG(R_EDX) = a % b;

	print_asm_template1();
 805b2b8:	83 ec 0c             	sub    $0xc,%esp
 805b2bb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805b2c1:	e8 9a d6 fe ff       	call   8048960 <fflush@plt>
 805b2c6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b2cc:	6a 07                	push   $0x7
 805b2ce:	6a 01                	push   $0x1
 805b2d0:	68 92 ed 05 08       	push   $0x805ed92
 805b2d5:	e8 36 d7 fe ff       	call   8048a10 <fwrite@plt>
 805b2da:	83 c4 20             	add    $0x20,%esp
 805b2dd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b2e3:	6a 10                	push   $0x10
 805b2e5:	6a 01                	push   $0x1
 805b2e7:	68 84 f8 05 08       	push   $0x805f884
 805b2ec:	e8 1f d7 fe ff       	call   8048a10 <fwrite@plt>
 805b2f1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b2f7:	6a 05                	push   $0x5
 805b2f9:	6a 01                	push   $0x1
 805b2fb:	68 b1 ed 05 08       	push   $0x805edb1
 805b300:	e8 0b d7 fe ff       	call   8048a10 <fwrite@plt>
 805b305:	83 c4 20             	add    $0x20,%esp
 805b308:	68 18 ae 8f 14       	push   $0x148fae18
 805b30d:	68 70 54 06 08       	push   $0x8065470
 805b312:	6a 50                	push   $0x50
 805b314:	68 00 89 0c 08       	push   $0x80c8900
 805b319:	e8 e2 d7 fe ff       	call   8048b00 <snprintf@plt>
 805b31e:	83 c4 10             	add    $0x10,%esp
 805b321:	83 f8 4f             	cmp    $0x4f,%eax
 805b324:	7e 82                	jle    805b2a8 <div_rm_b+0x78>
 805b326:	68 a8 56 06 08       	push   $0x80656a8
 805b32b:	6a 10                	push   $0x10
 805b32d:	68 98 55 06 08       	push   $0x8065598
 805b332:	68 50 56 06 08       	push   $0x8065650
 805b337:	e8 74 d8 fe ff       	call   8048bb0 <__assert_fail@plt>
 805b33c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805b340 <div_rm_v>:
#include "div-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(div_rm)
 805b340:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805b347:	8b 54 24 04          	mov    0x4(%esp),%edx
 805b34b:	b8 00 b1 05 08       	mov    $0x805b100,%eax
 805b350:	75 05                	jne    805b357 <div_rm_v+0x17>
 805b352:	b8 f0 af 05 08       	mov    $0x805aff0,%eax
 805b357:	89 54 24 04          	mov    %edx,0x4(%esp)
 805b35b:	ff e0                	jmp    *%eax
 805b35d:	66 90                	xchg   %ax,%ax
 805b35f:	90                   	nop

0805b360 <imul_rm2a_w>:

make_instr_helper(si_rm2r)
make_instr_helper(i_rm2r)
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
 805b360:	53                   	push   %ebx
 805b361:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
 805b364:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b368:	83 c0 01             	add    $0x1,%eax
 805b36b:	50                   	push   %eax
 805b36c:	e8 ef 1a 00 00       	call   805ce60 <decode_rm_w>
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805b371:	0f bf 15 c0 ae 8f 14 	movswl 0x148faec0,%edx
make_instr_helper(si_rm2r)
make_instr_helper(i_rm2r)
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
 805b378:	89 c3                	mov    %eax,%ebx
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805b37a:	0f bf 05 14 ae 8f 14 	movswl 0x148fae14,%eax

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805b381:	68 18 ae 8f 14       	push   $0x148fae18
 805b386:	68 b1 56 06 08       	push   $0x80656b1
 805b38b:	6a 50                	push   $0x50
 805b38d:	68 00 89 0c 08       	push   $0x80c8900
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805b392:	f7 ea                	imul   %edx
#if DATA_BYTE == 1
	reg_w(R_AX) = result;
#elif DATA_BYTE == 2
	REG(R_EAX) = result & 0xffff;
 805b394:	66 a3 c0 ae 8f 14    	mov    %ax,0x148faec0
	REG(R_EDX) = result >> 16;
 805b39a:	0f ac d0 10          	shrd   $0x10,%edx,%eax
 805b39e:	66 a3 c8 ae 8f 14    	mov    %ax,0x148faec8

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805b3a4:	e8 57 d7 fe ff       	call   8048b00 <snprintf@plt>
 805b3a9:	83 c4 20             	add    $0x20,%esp
 805b3ac:	83 f8 4f             	cmp    $0x4f,%eax
 805b3af:	7f 0f                	jg     805b3c0 <imul_rm2a_w+0x60>
	return len + 1;
}
 805b3b1:	83 c4 08             	add    $0x8,%esp
	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
	return len + 1;
 805b3b4:	8d 43 01             	lea    0x1(%ebx),%eax
}
 805b3b7:	5b                   	pop    %ebx
 805b3b8:	c3                   	ret    
 805b3b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805b3c0:	83 ec 0c             	sub    $0xc,%esp
 805b3c3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805b3c9:	e8 92 d5 fe ff       	call   8048960 <fflush@plt>
 805b3ce:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b3d4:	6a 07                	push   $0x7
 805b3d6:	6a 01                	push   $0x1
 805b3d8:	68 92 ed 05 08       	push   $0x805ed92
 805b3dd:	e8 2e d6 fe ff       	call   8048a10 <fwrite@plt>
 805b3e2:	83 c4 20             	add    $0x20,%esp
 805b3e5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b3eb:	6a 10                	push   $0x10
 805b3ed:	6a 01                	push   $0x1
 805b3ef:	68 84 f8 05 08       	push   $0x805f884
 805b3f4:	e8 17 d6 fe ff       	call   8048a10 <fwrite@plt>
 805b3f9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b3ff:	6a 05                	push   $0x5
 805b401:	6a 01                	push   $0x1
 805b403:	68 b1 ed 05 08       	push   $0x805edb1
 805b408:	e8 03 d6 fe ff       	call   8048a10 <fwrite@plt>
 805b40d:	83 c4 20             	add    $0x20,%esp
 805b410:	68 18 ae 8f 14       	push   $0x148fae18
 805b415:	68 b1 56 06 08       	push   $0x80656b1
 805b41a:	6a 50                	push   $0x50
 805b41c:	68 00 89 0c 08       	push   $0x80c8900
 805b421:	e8 da d6 fe ff       	call   8048b00 <snprintf@plt>
 805b426:	83 c4 10             	add    $0x10,%esp
 805b429:	83 f8 4f             	cmp    $0x4f,%eax
 805b42c:	7e 83                	jle    805b3b1 <imul_rm2a_w+0x51>
 805b42e:	68 09 59 06 08       	push   $0x8065909
 805b433:	6a 36                	push   $0x36
 805b435:	68 ec 56 06 08       	push   $0x80656ec
 805b43a:	68 14 57 06 08       	push   $0x8065714
 805b43f:	e8 6c d7 fe ff       	call   8048bb0 <__assert_fail@plt>
 805b444:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805b44a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805b450 <imul_rm2a_l>:

make_instr_helper(si_rm2r)
make_instr_helper(i_rm2r)
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
 805b450:	53                   	push   %ebx
 805b451:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
 805b454:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b458:	83 c0 01             	add    $0x1,%eax
 805b45b:	50                   	push   %eax
 805b45c:	e8 cf 1d 00 00       	call   805d230 <decode_rm_l>
 805b461:	89 c3                	mov    %eax,%ebx
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805b463:	a1 c0 ae 8f 14       	mov    0x148faec0,%eax

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805b468:	68 18 ae 8f 14       	push   $0x148fae18
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805b46d:	f7 2d 14 ae 8f 14    	imull  0x148fae14

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805b473:	68 ba 56 06 08       	push   $0x80656ba
 805b478:	6a 50                	push   $0x50
 805b47a:	68 00 89 0c 08       	push   $0x80c8900
	reg_w(R_AX) = result;
#elif DATA_BYTE == 2
	REG(R_EAX) = result & 0xffff;
	REG(R_EDX) = result >> 16;
#else
	REG(R_EAX) = result & 0xffffffff;
 805b47f:	a3 c0 ae 8f 14       	mov    %eax,0x148faec0
	REG(R_EDX) = result >> 32;
 805b484:	89 15 c8 ae 8f 14    	mov    %edx,0x148faec8

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805b48a:	e8 71 d6 fe ff       	call   8048b00 <snprintf@plt>
 805b48f:	83 c4 20             	add    $0x20,%esp
 805b492:	83 f8 4f             	cmp    $0x4f,%eax
 805b495:	7f 09                	jg     805b4a0 <imul_rm2a_l+0x50>
	return len + 1;
}
 805b497:	83 c4 08             	add    $0x8,%esp
	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
	return len + 1;
 805b49a:	8d 43 01             	lea    0x1(%ebx),%eax
}
 805b49d:	5b                   	pop    %ebx
 805b49e:	c3                   	ret    
 805b49f:	90                   	nop

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805b4a0:	83 ec 0c             	sub    $0xc,%esp
 805b4a3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805b4a9:	e8 b2 d4 fe ff       	call   8048960 <fflush@plt>
 805b4ae:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b4b4:	6a 07                	push   $0x7
 805b4b6:	6a 01                	push   $0x1
 805b4b8:	68 92 ed 05 08       	push   $0x805ed92
 805b4bd:	e8 4e d5 fe ff       	call   8048a10 <fwrite@plt>
 805b4c2:	83 c4 20             	add    $0x20,%esp
 805b4c5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b4cb:	6a 10                	push   $0x10
 805b4cd:	6a 01                	push   $0x1
 805b4cf:	68 84 f8 05 08       	push   $0x805f884
 805b4d4:	e8 37 d5 fe ff       	call   8048a10 <fwrite@plt>
 805b4d9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b4df:	6a 05                	push   $0x5
 805b4e1:	6a 01                	push   $0x1
 805b4e3:	68 b1 ed 05 08       	push   $0x805edb1
 805b4e8:	e8 23 d5 fe ff       	call   8048a10 <fwrite@plt>
 805b4ed:	83 c4 20             	add    $0x20,%esp
 805b4f0:	68 18 ae 8f 14       	push   $0x148fae18
 805b4f5:	68 ba 56 06 08       	push   $0x80656ba
 805b4fa:	6a 50                	push   $0x50
 805b4fc:	68 00 89 0c 08       	push   $0x80c8900
 805b501:	e8 fa d5 fe ff       	call   8048b00 <snprintf@plt>
 805b506:	83 c4 10             	add    $0x10,%esp
 805b509:	83 f8 4f             	cmp    $0x4f,%eax
 805b50c:	7e 89                	jle    805b497 <imul_rm2a_l+0x47>
 805b50e:	68 f3 58 06 08       	push   $0x80658f3
 805b513:	6a 36                	push   $0x36
 805b515:	68 ec 56 06 08       	push   $0x80656ec
 805b51a:	68 5c 57 06 08       	push   $0x806575c
 805b51f:	e8 8c d6 fe ff       	call   8048bb0 <__assert_fail@plt>
 805b524:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805b52a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805b530 <do_imul_w>:
#endif

#define instr imul

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute() {
 805b530:	83 ec 14             	sub    $0x14,%esp
	RET_DATA_TYPE result = (RET_DATA_TYPE)op_src->val * (RET_DATA_TYPE)op_src2->val;
 805b533:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
 805b538:	0f af 05 84 ae 8f 14 	imul   0x148fae84,%eax
	OPERAND_W(op_dest, result);
 805b53f:	0f b7 c0             	movzwl %ax,%eax
 805b542:	50                   	push   %eax
 805b543:	68 40 ae 8f 14       	push   $0x148fae40
 805b548:	e8 83 1a 00 00       	call   805cfd0 <write_operand_w>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template3();
 805b54d:	58                   	pop    %eax
 805b54e:	5a                   	pop    %edx
 805b54f:	68 50 ae 8f 14       	push   $0x148fae50
 805b554:	68 88 ae 8f 14       	push   $0x148fae88
 805b559:	68 18 ae 8f 14       	push   $0x148fae18
 805b55e:	68 c3 56 06 08       	push   $0x80656c3
 805b563:	6a 50                	push   $0x50
 805b565:	68 00 89 0c 08       	push   $0x80c8900
 805b56a:	e8 91 d5 fe ff       	call   8048b00 <snprintf@plt>
 805b56f:	83 c4 20             	add    $0x20,%esp
 805b572:	83 f8 4f             	cmp    $0x4f,%eax
 805b575:	7f 09                	jg     805b580 <do_imul_w+0x50>
}
 805b577:	83 c4 0c             	add    $0xc,%esp
 805b57a:	c3                   	ret    
 805b57b:	90                   	nop
 805b57c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template3();
 805b580:	83 ec 0c             	sub    $0xc,%esp
 805b583:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805b589:	e8 d2 d3 fe ff       	call   8048960 <fflush@plt>
 805b58e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b594:	6a 07                	push   $0x7
 805b596:	6a 01                	push   $0x1
 805b598:	68 92 ed 05 08       	push   $0x805ed92
 805b59d:	e8 6e d4 fe ff       	call   8048a10 <fwrite@plt>
 805b5a2:	83 c4 20             	add    $0x20,%esp
 805b5a5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b5ab:	6a 10                	push   $0x10
 805b5ad:	6a 01                	push   $0x1
 805b5af:	68 84 f8 05 08       	push   $0x805f884
 805b5b4:	e8 57 d4 fe ff       	call   8048a10 <fwrite@plt>
 805b5b9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b5bf:	6a 05                	push   $0x5
 805b5c1:	6a 01                	push   $0x1
 805b5c3:	68 b1 ed 05 08       	push   $0x805edb1
 805b5c8:	e8 43 d4 fe ff       	call   8048a10 <fwrite@plt>
 805b5cd:	83 c4 18             	add    $0x18,%esp
 805b5d0:	68 50 ae 8f 14       	push   $0x148fae50
 805b5d5:	68 88 ae 8f 14       	push   $0x148fae88
 805b5da:	68 18 ae 8f 14       	push   $0x148fae18
 805b5df:	68 c3 56 06 08       	push   $0x80656c3
 805b5e4:	6a 50                	push   $0x50
 805b5e6:	68 00 89 0c 08       	push   $0x80c8900
 805b5eb:	e8 10 d5 fe ff       	call   8048b00 <snprintf@plt>
 805b5f0:	83 c4 20             	add    $0x20,%esp
 805b5f3:	83 f8 4f             	cmp    $0x4f,%eax
 805b5f6:	0f 8e 7b ff ff ff    	jle    805b577 <do_imul_w+0x47>
 805b5fc:	68 15 59 06 08       	push   $0x8065915
 805b601:	6a 16                	push   $0x16
 805b603:	68 ec 56 06 08       	push   $0x80656ec
 805b608:	68 a4 57 06 08       	push   $0x80657a4
 805b60d:	e8 9e d5 fe ff       	call   8048bb0 <__assert_fail@plt>
 805b612:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805b619:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805b620 <imul_si_rm2r_w>:
	ops_decoded.src2 = ops_decoded.dest;
	do_execute();
	return len + 1;
}

make_instr_helper(si_rm2r)
 805b620:	53                   	push   %ebx
 805b621:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b624:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b628:	83 c0 01             	add    $0x1,%eax
 805b62b:	50                   	push   %eax
 805b62c:	e8 8f 18 00 00       	call   805cec0 <decode_si_rm2r_w>
 805b631:	89 c3                	mov    %eax,%ebx
	execute();
 805b633:	e8 f8 fe ff ff       	call   805b530 <do_imul_w>
 805b638:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805b63b:	8d 43 01             	lea    0x1(%ebx),%eax
 805b63e:	5b                   	pop    %ebx
 805b63f:	c3                   	ret    

0805b640 <imul_i_rm2r_w>:
make_instr_helper(i_rm2r)
 805b640:	53                   	push   %ebx
 805b641:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b644:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b648:	83 c0 01             	add    $0x1,%eax
 805b64b:	50                   	push   %eax
 805b64c:	e8 8f 17 00 00       	call   805cde0 <decode_i_rm2r_w>
 805b651:	89 c3                	mov    %eax,%ebx
	execute();
 805b653:	e8 d8 fe ff ff       	call   805b530 <do_imul_w>
 805b658:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805b65b:	8d 43 01             	lea    0x1(%ebx),%eax
 805b65e:	5b                   	pop    %ebx
 805b65f:	c3                   	ret    

0805b660 <imul_rm2r_w>:
	 */

	print_asm_template3();
}

make_helper(concat(imul_rm2r_, SUFFIX)) {
 805b660:	53                   	push   %ebx
 805b661:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_rm2r_, SUFFIX)(eip + 1);
 805b664:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b668:	83 c0 01             	add    $0x1,%eax
 805b66b:	50                   	push   %eax
 805b66c:	e8 ff 16 00 00       	call   805cd70 <decode_rm2r_w>
 805b671:	89 c3                	mov    %eax,%ebx
	ops_decoded.src2 = ops_decoded.dest;
 805b673:	a1 40 ae 8f 14       	mov    0x148fae40,%eax
 805b678:	a3 78 ae 8f 14       	mov    %eax,0x148fae78
 805b67d:	a1 44 ae 8f 14       	mov    0x148fae44,%eax
 805b682:	a3 7c ae 8f 14       	mov    %eax,0x148fae7c
 805b687:	a1 48 ae 8f 14       	mov    0x148fae48,%eax
 805b68c:	a3 80 ae 8f 14       	mov    %eax,0x148fae80
 805b691:	a1 4c ae 8f 14       	mov    0x148fae4c,%eax
 805b696:	a3 84 ae 8f 14       	mov    %eax,0x148fae84
 805b69b:	a1 50 ae 8f 14       	mov    0x148fae50,%eax
 805b6a0:	a3 88 ae 8f 14       	mov    %eax,0x148fae88
 805b6a5:	a1 54 ae 8f 14       	mov    0x148fae54,%eax
 805b6aa:	a3 8c ae 8f 14       	mov    %eax,0x148fae8c
 805b6af:	a1 58 ae 8f 14       	mov    0x148fae58,%eax
 805b6b4:	a3 90 ae 8f 14       	mov    %eax,0x148fae90
 805b6b9:	a1 5c ae 8f 14       	mov    0x148fae5c,%eax
 805b6be:	a3 94 ae 8f 14       	mov    %eax,0x148fae94
 805b6c3:	a1 60 ae 8f 14       	mov    0x148fae60,%eax
 805b6c8:	a3 98 ae 8f 14       	mov    %eax,0x148fae98
 805b6cd:	a1 64 ae 8f 14       	mov    0x148fae64,%eax
 805b6d2:	a3 9c ae 8f 14       	mov    %eax,0x148fae9c
 805b6d7:	a1 68 ae 8f 14       	mov    0x148fae68,%eax
 805b6dc:	a3 a0 ae 8f 14       	mov    %eax,0x148faea0
 805b6e1:	a1 6c ae 8f 14       	mov    0x148fae6c,%eax
 805b6e6:	a3 a4 ae 8f 14       	mov    %eax,0x148faea4
 805b6eb:	a1 70 ae 8f 14       	mov    0x148fae70,%eax
 805b6f0:	a3 a8 ae 8f 14       	mov    %eax,0x148faea8
 805b6f5:	a1 74 ae 8f 14       	mov    0x148fae74,%eax
 805b6fa:	a3 ac ae 8f 14       	mov    %eax,0x148faeac
	do_execute();
 805b6ff:	e8 2c fe ff ff       	call   805b530 <do_imul_w>
	return len + 1;
}
 805b704:	83 c4 18             	add    $0x18,%esp

make_helper(concat(imul_rm2r_, SUFFIX)) {
	int len = concat(decode_rm2r_, SUFFIX)(eip + 1);
	ops_decoded.src2 = ops_decoded.dest;
	do_execute();
	return len + 1;
 805b707:	8d 43 01             	lea    0x1(%ebx),%eax
}
 805b70a:	5b                   	pop    %ebx
 805b70b:	c3                   	ret    
 805b70c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805b710 <do_imul_l>:
#endif

#define instr imul

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute() {
 805b710:	83 ec 14             	sub    $0x14,%esp
	RET_DATA_TYPE result = (RET_DATA_TYPE)op_src->val * (RET_DATA_TYPE)op_src2->val;
 805b713:	a1 84 ae 8f 14       	mov    0x148fae84,%eax
 805b718:	f7 25 14 ae 8f 14    	mull   0x148fae14
	OPERAND_W(op_dest, result);
 805b71e:	50                   	push   %eax
 805b71f:	68 40 ae 8f 14       	push   $0x148fae40
 805b724:	e8 77 1c 00 00       	call   805d3a0 <write_operand_l>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template3();
 805b729:	58                   	pop    %eax
 805b72a:	5a                   	pop    %edx
 805b72b:	68 50 ae 8f 14       	push   $0x148fae50
 805b730:	68 88 ae 8f 14       	push   $0x148fae88
 805b735:	68 18 ae 8f 14       	push   $0x148fae18
 805b73a:	68 d2 56 06 08       	push   $0x80656d2
 805b73f:	6a 50                	push   $0x50
 805b741:	68 00 89 0c 08       	push   $0x80c8900
 805b746:	e8 b5 d3 fe ff       	call   8048b00 <snprintf@plt>
 805b74b:	83 c4 20             	add    $0x20,%esp
 805b74e:	83 f8 4f             	cmp    $0x4f,%eax
 805b751:	7f 0d                	jg     805b760 <do_imul_l+0x50>
}
 805b753:	83 c4 0c             	add    $0xc,%esp
 805b756:	c3                   	ret    
 805b757:	89 f6                	mov    %esi,%esi
 805b759:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template3();
 805b760:	83 ec 0c             	sub    $0xc,%esp
 805b763:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805b769:	e8 f2 d1 fe ff       	call   8048960 <fflush@plt>
 805b76e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b774:	6a 07                	push   $0x7
 805b776:	6a 01                	push   $0x1
 805b778:	68 92 ed 05 08       	push   $0x805ed92
 805b77d:	e8 8e d2 fe ff       	call   8048a10 <fwrite@plt>
 805b782:	83 c4 20             	add    $0x20,%esp
 805b785:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b78b:	6a 10                	push   $0x10
 805b78d:	6a 01                	push   $0x1
 805b78f:	68 84 f8 05 08       	push   $0x805f884
 805b794:	e8 77 d2 fe ff       	call   8048a10 <fwrite@plt>
 805b799:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b79f:	6a 05                	push   $0x5
 805b7a1:	6a 01                	push   $0x1
 805b7a3:	68 b1 ed 05 08       	push   $0x805edb1
 805b7a8:	e8 63 d2 fe ff       	call   8048a10 <fwrite@plt>
 805b7ad:	83 c4 18             	add    $0x18,%esp
 805b7b0:	68 50 ae 8f 14       	push   $0x148fae50
 805b7b5:	68 88 ae 8f 14       	push   $0x148fae88
 805b7ba:	68 18 ae 8f 14       	push   $0x148fae18
 805b7bf:	68 d2 56 06 08       	push   $0x80656d2
 805b7c4:	6a 50                	push   $0x50
 805b7c6:	68 00 89 0c 08       	push   $0x80c8900
 805b7cb:	e8 30 d3 fe ff       	call   8048b00 <snprintf@plt>
 805b7d0:	83 c4 20             	add    $0x20,%esp
 805b7d3:	83 f8 4f             	cmp    $0x4f,%eax
 805b7d6:	0f 8e 77 ff ff ff    	jle    805b753 <do_imul_l+0x43>
 805b7dc:	68 ff 58 06 08       	push   $0x80658ff
 805b7e1:	6a 16                	push   $0x16
 805b7e3:	68 ec 56 06 08       	push   $0x80656ec
 805b7e8:	68 28 58 06 08       	push   $0x8065828
 805b7ed:	e8 be d3 fe ff       	call   8048bb0 <__assert_fail@plt>
 805b7f2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805b7f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805b800 <imul_si_rm2r_l>:
	ops_decoded.src2 = ops_decoded.dest;
	do_execute();
	return len + 1;
}

make_instr_helper(si_rm2r)
 805b800:	53                   	push   %ebx
 805b801:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b804:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b808:	83 c0 01             	add    $0x1,%eax
 805b80b:	50                   	push   %eax
 805b80c:	e8 7f 1a 00 00       	call   805d290 <decode_si_rm2r_l>
 805b811:	89 c3                	mov    %eax,%ebx
	execute();
 805b813:	e8 f8 fe ff ff       	call   805b710 <do_imul_l>
 805b818:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805b81b:	8d 43 01             	lea    0x1(%ebx),%eax
 805b81e:	5b                   	pop    %ebx
 805b81f:	c3                   	ret    

0805b820 <imul_i_rm2r_l>:
make_instr_helper(i_rm2r)
 805b820:	53                   	push   %ebx
 805b821:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b824:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b828:	83 c0 01             	add    $0x1,%eax
 805b82b:	50                   	push   %eax
 805b82c:	e8 7f 19 00 00       	call   805d1b0 <decode_i_rm2r_l>
 805b831:	89 c3                	mov    %eax,%ebx
	execute();
 805b833:	e8 d8 fe ff ff       	call   805b710 <do_imul_l>
 805b838:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805b83b:	8d 43 01             	lea    0x1(%ebx),%eax
 805b83e:	5b                   	pop    %ebx
 805b83f:	c3                   	ret    

0805b840 <imul_rm2r_l>:
	 */

	print_asm_template3();
}

make_helper(concat(imul_rm2r_, SUFFIX)) {
 805b840:	53                   	push   %ebx
 805b841:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_rm2r_, SUFFIX)(eip + 1);
 805b844:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b848:	83 c0 01             	add    $0x1,%eax
 805b84b:	50                   	push   %eax
 805b84c:	e8 ef 18 00 00       	call   805d140 <decode_rm2r_l>
 805b851:	89 c3                	mov    %eax,%ebx
	ops_decoded.src2 = ops_decoded.dest;
 805b853:	a1 40 ae 8f 14       	mov    0x148fae40,%eax
 805b858:	a3 78 ae 8f 14       	mov    %eax,0x148fae78
 805b85d:	a1 44 ae 8f 14       	mov    0x148fae44,%eax
 805b862:	a3 7c ae 8f 14       	mov    %eax,0x148fae7c
 805b867:	a1 48 ae 8f 14       	mov    0x148fae48,%eax
 805b86c:	a3 80 ae 8f 14       	mov    %eax,0x148fae80
 805b871:	a1 4c ae 8f 14       	mov    0x148fae4c,%eax
 805b876:	a3 84 ae 8f 14       	mov    %eax,0x148fae84
 805b87b:	a1 50 ae 8f 14       	mov    0x148fae50,%eax
 805b880:	a3 88 ae 8f 14       	mov    %eax,0x148fae88
 805b885:	a1 54 ae 8f 14       	mov    0x148fae54,%eax
 805b88a:	a3 8c ae 8f 14       	mov    %eax,0x148fae8c
 805b88f:	a1 58 ae 8f 14       	mov    0x148fae58,%eax
 805b894:	a3 90 ae 8f 14       	mov    %eax,0x148fae90
 805b899:	a1 5c ae 8f 14       	mov    0x148fae5c,%eax
 805b89e:	a3 94 ae 8f 14       	mov    %eax,0x148fae94
 805b8a3:	a1 60 ae 8f 14       	mov    0x148fae60,%eax
 805b8a8:	a3 98 ae 8f 14       	mov    %eax,0x148fae98
 805b8ad:	a1 64 ae 8f 14       	mov    0x148fae64,%eax
 805b8b2:	a3 9c ae 8f 14       	mov    %eax,0x148fae9c
 805b8b7:	a1 68 ae 8f 14       	mov    0x148fae68,%eax
 805b8bc:	a3 a0 ae 8f 14       	mov    %eax,0x148faea0
 805b8c1:	a1 6c ae 8f 14       	mov    0x148fae6c,%eax
 805b8c6:	a3 a4 ae 8f 14       	mov    %eax,0x148faea4
 805b8cb:	a1 70 ae 8f 14       	mov    0x148fae70,%eax
 805b8d0:	a3 a8 ae 8f 14       	mov    %eax,0x148faea8
 805b8d5:	a1 74 ae 8f 14       	mov    0x148fae74,%eax
 805b8da:	a3 ac ae 8f 14       	mov    %eax,0x148faeac
	do_execute();
 805b8df:	e8 2c fe ff ff       	call   805b710 <do_imul_l>
	return len + 1;
}
 805b8e4:	83 c4 18             	add    $0x18,%esp

make_helper(concat(imul_rm2r_, SUFFIX)) {
	int len = concat(decode_rm2r_, SUFFIX)(eip + 1);
	ops_decoded.src2 = ops_decoded.dest;
	do_execute();
	return len + 1;
 805b8e7:	8d 43 01             	lea    0x1(%ebx),%eax
}
 805b8ea:	5b                   	pop    %ebx
 805b8eb:	c3                   	ret    
 805b8ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805b8f0 <imul_rm2a_b>:

make_instr_helper(si_rm2r)
make_instr_helper(i_rm2r)
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
 805b8f0:	53                   	push   %ebx
 805b8f1:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
 805b8f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b8f8:	83 c0 01             	add    $0x1,%eax
 805b8fb:	50                   	push   %eax
 805b8fc:	e8 2f 12 00 00       	call   805cb30 <decode_rm_b>
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805b901:	0f be 15 c0 ae 8f 14 	movsbl 0x148faec0,%edx
make_instr_helper(si_rm2r)
make_instr_helper(i_rm2r)
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
 805b908:	89 c3                	mov    %eax,%ebx
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805b90a:	0f be 05 14 ae 8f 14 	movsbl 0x148fae14,%eax

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805b911:	68 18 ae 8f 14       	push   $0x148fae18
 805b916:	68 e1 56 06 08       	push   $0x80656e1
 805b91b:	6a 50                	push   $0x50
 805b91d:	68 00 89 0c 08       	push   $0x80c8900
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805b922:	f7 ea                	imul   %edx
#if DATA_BYTE == 1
	reg_w(R_AX) = result;
 805b924:	66 a3 c0 ae 8f 14    	mov    %ax,0x148faec0

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805b92a:	e8 d1 d1 fe ff       	call   8048b00 <snprintf@plt>
 805b92f:	83 c4 20             	add    $0x20,%esp
 805b932:	83 f8 4f             	cmp    $0x4f,%eax
 805b935:	7f 09                	jg     805b940 <imul_rm2a_b+0x50>
	return len + 1;
}
 805b937:	83 c4 08             	add    $0x8,%esp
	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
	return len + 1;
 805b93a:	8d 43 01             	lea    0x1(%ebx),%eax
}
 805b93d:	5b                   	pop    %ebx
 805b93e:	c3                   	ret    
 805b93f:	90                   	nop

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805b940:	83 ec 0c             	sub    $0xc,%esp
 805b943:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805b949:	e8 12 d0 fe ff       	call   8048960 <fflush@plt>
 805b94e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b954:	6a 07                	push   $0x7
 805b956:	6a 01                	push   $0x1
 805b958:	68 92 ed 05 08       	push   $0x805ed92
 805b95d:	e8 ae d0 fe ff       	call   8048a10 <fwrite@plt>
 805b962:	83 c4 20             	add    $0x20,%esp
 805b965:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b96b:	6a 10                	push   $0x10
 805b96d:	6a 01                	push   $0x1
 805b96f:	68 84 f8 05 08       	push   $0x805f884
 805b974:	e8 97 d0 fe ff       	call   8048a10 <fwrite@plt>
 805b979:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805b97f:	6a 05                	push   $0x5
 805b981:	6a 01                	push   $0x1
 805b983:	68 b1 ed 05 08       	push   $0x805edb1
 805b988:	e8 83 d0 fe ff       	call   8048a10 <fwrite@plt>
 805b98d:	83 c4 20             	add    $0x20,%esp
 805b990:	68 18 ae 8f 14       	push   $0x148fae18
 805b995:	68 e1 56 06 08       	push   $0x80656e1
 805b99a:	6a 50                	push   $0x50
 805b99c:	68 00 89 0c 08       	push   $0x80c8900
 805b9a1:	e8 5a d1 fe ff       	call   8048b00 <snprintf@plt>
 805b9a6:	83 c4 10             	add    $0x10,%esp
 805b9a9:	83 f8 4f             	cmp    $0x4f,%eax
 805b9ac:	7e 89                	jle    805b937 <imul_rm2a_b+0x47>
 805b9ae:	68 1f 59 06 08       	push   $0x806591f
 805b9b3:	6a 36                	push   $0x36
 805b9b5:	68 ec 56 06 08       	push   $0x80656ec
 805b9ba:	68 ac 58 06 08       	push   $0x80658ac
 805b9bf:	e8 ec d1 fe ff       	call   8048bb0 <__assert_fail@plt>
 805b9c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805b9ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805b9d0 <imul_rm2a_v>:
#include "imul-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(imul_rm2a)
 805b9d0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805b9d7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805b9db:	b8 60 b3 05 08       	mov    $0x805b360,%eax
 805b9e0:	75 05                	jne    805b9e7 <imul_rm2a_v+0x17>
 805b9e2:	b8 50 b4 05 08       	mov    $0x805b450,%eax
 805b9e7:	89 54 24 04          	mov    %edx,0x4(%esp)
 805b9eb:	ff e0                	jmp    *%eax
 805b9ed:	8d 76 00             	lea    0x0(%esi),%esi

0805b9f0 <imul_rm2r_v>:
make_helper_v(imul_rm2r)
 805b9f0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805b9f7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805b9fb:	b8 60 b6 05 08       	mov    $0x805b660,%eax
 805ba00:	75 05                	jne    805ba07 <imul_rm2r_v+0x17>
 805ba02:	b8 40 b8 05 08       	mov    $0x805b840,%eax
 805ba07:	89 54 24 04          	mov    %edx,0x4(%esp)
 805ba0b:	ff e0                	jmp    *%eax
 805ba0d:	8d 76 00             	lea    0x0(%esi),%esi

0805ba10 <imul_si_rm2r_v>:
make_helper_v(imul_si_rm2r)
 805ba10:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805ba17:	8b 54 24 04          	mov    0x4(%esp),%edx
 805ba1b:	b8 20 b6 05 08       	mov    $0x805b620,%eax
 805ba20:	75 05                	jne    805ba27 <imul_si_rm2r_v+0x17>
 805ba22:	b8 00 b8 05 08       	mov    $0x805b800,%eax
 805ba27:	89 54 24 04          	mov    %edx,0x4(%esp)
 805ba2b:	ff e0                	jmp    *%eax
 805ba2d:	8d 76 00             	lea    0x0(%esi),%esi

0805ba30 <imul_i_rm2r_v>:
make_helper_v(imul_i_rm2r)
 805ba30:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805ba37:	8b 54 24 04          	mov    0x4(%esp),%edx
 805ba3b:	b8 40 b6 05 08       	mov    $0x805b640,%eax
 805ba40:	75 05                	jne    805ba47 <imul_i_rm2r_v+0x17>
 805ba42:	b8 20 b8 05 08       	mov    $0x805b820,%eax
 805ba47:	89 54 24 04          	mov    %edx,0x4(%esp)
 805ba4b:	ff e0                	jmp    *%eax
 805ba4d:	66 90                	xchg   %ax,%ax
 805ba4f:	90                   	nop

0805ba50 <do_dec_w>:
#include "cpu/exec/template-start.h"

#define instr dec

static void do_execute () {
 805ba50:	55                   	push   %ebp
 805ba51:	57                   	push   %edi
 805ba52:	56                   	push   %esi
 805ba53:	53                   	push   %ebx
 805ba54:	83 ec 24             	sub    $0x24,%esp
	DATA_TYPE result = op_src->val - 1;
 805ba57:	0f b7 05 14 ae 8f 14 	movzwl 0x148fae14,%eax
 805ba5e:	8d 58 ff             	lea    -0x1(%eax),%ebx
	OPERAND_W(op_src, result);
 805ba61:	0f b7 c3             	movzwl %bx,%eax
 805ba64:	50                   	push   %eax
 805ba65:	68 08 ae 8f 14       	push   $0x148fae08
 805ba6a:	e8 61 15 00 00       	call   805cfd0 <write_operand_w>

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
 805ba6f:	0f b6 c3             	movzbl %bl,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805ba72:	8b 0d 4c ae 8f 14    	mov    0x148fae4c,%ecx
 805ba78:	8b 35 14 ae 8f 14    	mov    0x148fae14,%esi
	DATA_TYPE result = op_src->val - 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805ba7e:	89 c2                	mov    %eax,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805ba80:	0f b6 2d e4 ae 8f 14 	movzbl 0x148faee4,%ebp
	DATA_TYPE result = op_src->val - 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805ba87:	c1 ea 04             	shr    $0x4,%edx
 805ba8a:	31 d0                	xor    %edx,%eax
	pf = (pf >> 2) ^ pf;
 805ba8c:	89 c2                	mov    %eax,%edx
 805ba8e:	c1 ea 02             	shr    $0x2,%edx
 805ba91:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 805ba93:	89 c2                	mov    %eax,%edx
 805ba95:	d1 ea                	shr    %edx
 805ba97:	89 54 24 1c          	mov    %edx,0x1c(%esp)
	cpu.CF = op_dest->val < op_src->val;
 805ba9b:	83 c4 10             	add    $0x10,%esp
 805ba9e:	39 f1                	cmp    %esi,%ecx
 805baa0:	0f 92 c2             	setb   %dl

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805baa3:	33 44 24 0c          	xor    0xc(%esp),%eax
	cpu.CF = op_dest->val < op_src->val;
 805baa7:	83 e5 fa             	and    $0xfffffffa,%ebp
 805baaa:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805baac:	68 18 ae 8f 14       	push   $0x148fae18
 805bab1:	68 2b 59 06 08       	push   $0x806592b
 805bab6:	6a 50                	push   $0x50
 805bab8:	68 00 89 0c 08       	push   $0x80c8900
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
 805babd:	83 e0 01             	and    $0x1,%eax
 805bac0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805bac7:	89 e8                	mov    %ebp,%eax
 805bac9:	09 f8                	or     %edi,%eax
 805bacb:	09 d0                	or     %edx,%eax
	cpu.ZF = (result == 0);
 805bacd:	66 85 db             	test   %bx,%bx
 805bad0:	0f 94 c2             	sete   %dl
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805bad3:	c1 e9 1f             	shr    $0x1f,%ecx
 805bad6:	c1 ee 1f             	shr    $0x1f,%esi
 805bad9:	31 ce                	xor    %ecx,%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
 805badb:	c1 e2 06             	shl    $0x6,%edx
 805bade:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805bae1:	21 f1                	and    %esi,%ecx
 805bae3:	0f b6 35 e5 ae 8f 14 	movzbl 0x148faee5,%esi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805baea:	09 d0                	or     %edx,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805baec:	c1 e1 03             	shl    $0x3,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805baef:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805baf4:	83 e6 f7             	and    $0xfffffff7,%esi
 805baf7:	09 f1                	or     %esi,%ecx
 805baf9:	88 0d e5 ae 8f 14    	mov    %cl,0x148faee5

	print_asm_template1();
 805baff:	e8 fc cf fe ff       	call   8048b00 <snprintf@plt>
 805bb04:	83 c4 10             	add    $0x10,%esp
 805bb07:	83 f8 4f             	cmp    $0x4f,%eax
 805bb0a:	7f 0c                	jg     805bb18 <do_dec_w+0xc8>
}
 805bb0c:	83 c4 1c             	add    $0x1c,%esp
 805bb0f:	5b                   	pop    %ebx
 805bb10:	5e                   	pop    %esi
 805bb11:	5f                   	pop    %edi
 805bb12:	5d                   	pop    %ebp
 805bb13:	c3                   	ret    
 805bb14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805bb18:	83 ec 0c             	sub    $0xc,%esp
 805bb1b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805bb21:	e8 3a ce fe ff       	call   8048960 <fflush@plt>
 805bb26:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805bb2c:	6a 07                	push   $0x7
 805bb2e:	6a 01                	push   $0x1
 805bb30:	68 92 ed 05 08       	push   $0x805ed92
 805bb35:	e8 d6 ce fe ff       	call   8048a10 <fwrite@plt>
 805bb3a:	83 c4 20             	add    $0x20,%esp
 805bb3d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805bb43:	6a 10                	push   $0x10
 805bb45:	6a 01                	push   $0x1
 805bb47:	68 84 f8 05 08       	push   $0x805f884
 805bb4c:	e8 bf ce fe ff       	call   8048a10 <fwrite@plt>
 805bb51:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805bb57:	6a 05                	push   $0x5
 805bb59:	6a 01                	push   $0x1
 805bb5b:	68 b1 ed 05 08       	push   $0x805edb1
 805bb60:	e8 ab ce fe ff       	call   8048a10 <fwrite@plt>
 805bb65:	83 c4 20             	add    $0x20,%esp
 805bb68:	68 18 ae 8f 14       	push   $0x148fae18
 805bb6d:	68 2b 59 06 08       	push   $0x806592b
 805bb72:	6a 50                	push   $0x50
 805bb74:	68 00 89 0c 08       	push   $0x80c8900
 805bb79:	e8 82 cf fe ff       	call   8048b00 <snprintf@plt>
 805bb7e:	83 c4 10             	add    $0x10,%esp
 805bb81:	83 f8 4f             	cmp    $0x4f,%eax
 805bb84:	7e 86                	jle    805bb0c <do_dec_w+0xbc>
 805bb86:	68 4b 5a 06 08       	push   $0x8065a4b
 805bb8b:	6a 14                	push   $0x14
 805bb8d:	68 44 59 06 08       	push   $0x8065944
 805bb92:	68 6c 59 06 08       	push   $0x806596c
 805bb97:	e8 14 d0 fe ff       	call   8048bb0 <__assert_fail@plt>
 805bb9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805bba0 <dec_rm_w>:
}

make_instr_helper(rm)
 805bba0:	53                   	push   %ebx
 805bba1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805bba4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805bba8:	83 c0 01             	add    $0x1,%eax
 805bbab:	50                   	push   %eax
 805bbac:	e8 af 12 00 00       	call   805ce60 <decode_rm_w>
 805bbb1:	89 c3                	mov    %eax,%ebx
	execute();
 805bbb3:	e8 98 fe ff ff       	call   805ba50 <do_dec_w>
 805bbb8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805bbbb:	8d 43 01             	lea    0x1(%ebx),%eax
 805bbbe:	5b                   	pop    %ebx
 805bbbf:	c3                   	ret    

0805bbc0 <dec_r_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(r)
 805bbc0:	53                   	push   %ebx
 805bbc1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805bbc4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805bbc8:	83 c0 01             	add    $0x1,%eax
 805bbcb:	50                   	push   %eax
 805bbcc:	e8 af 12 00 00       	call   805ce80 <decode_r_w>
 805bbd1:	89 c3                	mov    %eax,%ebx
	execute();
 805bbd3:	e8 78 fe ff ff       	call   805ba50 <do_dec_w>
 805bbd8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805bbdb:	8d 43 01             	lea    0x1(%ebx),%eax
 805bbde:	5b                   	pop    %ebx
 805bbdf:	c3                   	ret    

0805bbe0 <do_dec_l>:
#include "cpu/exec/template-start.h"

#define instr dec

static void do_execute () {
 805bbe0:	55                   	push   %ebp
 805bbe1:	57                   	push   %edi
 805bbe2:	56                   	push   %esi
 805bbe3:	53                   	push   %ebx
 805bbe4:	83 ec 24             	sub    $0x24,%esp
	DATA_TYPE result = op_src->val - 1;
 805bbe7:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
 805bbec:	8d 58 ff             	lea    -0x1(%eax),%ebx
	OPERAND_W(op_src, result);
 805bbef:	53                   	push   %ebx
 805bbf0:	68 08 ae 8f 14       	push   $0x148fae08
 805bbf5:	e8 a6 17 00 00       	call   805d3a0 <write_operand_l>

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
 805bbfa:	0f b6 c3             	movzbl %bl,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805bbfd:	8b 0d 14 ae 8f 14    	mov    0x148fae14,%ecx
 805bc03:	8b 35 4c ae 8f 14    	mov    0x148fae4c,%esi
	DATA_TYPE result = op_src->val - 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805bc09:	89 c2                	mov    %eax,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805bc0b:	0f b6 2d e4 ae 8f 14 	movzbl 0x148faee4,%ebp
	DATA_TYPE result = op_src->val - 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805bc12:	c1 ea 04             	shr    $0x4,%edx
 805bc15:	31 d0                	xor    %edx,%eax
	pf = (pf >> 2) ^ pf;
 805bc17:	89 c2                	mov    %eax,%edx
 805bc19:	c1 ea 02             	shr    $0x2,%edx
 805bc1c:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 805bc1e:	89 c2                	mov    %eax,%edx
 805bc20:	d1 ea                	shr    %edx
 805bc22:	89 54 24 1c          	mov    %edx,0x1c(%esp)
	cpu.CF = op_dest->val < op_src->val;
 805bc26:	83 c4 10             	add    $0x10,%esp
 805bc29:	39 ce                	cmp    %ecx,%esi
 805bc2b:	0f 92 c2             	setb   %dl

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805bc2e:	33 44 24 0c          	xor    0xc(%esp),%eax
	cpu.CF = op_dest->val < op_src->val;
 805bc32:	83 e5 fa             	and    $0xfffffffa,%ebp
 805bc35:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805bc37:	68 18 ae 8f 14       	push   $0x148fae18
 805bc3c:	68 33 59 06 08       	push   $0x8065933
 805bc41:	6a 50                	push   $0x50
 805bc43:	68 00 89 0c 08       	push   $0x80c8900
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
 805bc48:	83 e0 01             	and    $0x1,%eax
 805bc4b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805bc52:	89 e8                	mov    %ebp,%eax
 805bc54:	09 f8                	or     %edi,%eax
 805bc56:	09 d0                	or     %edx,%eax
	cpu.ZF = (result == 0);
 805bc58:	85 db                	test   %ebx,%ebx
 805bc5a:	0f 94 c2             	sete   %dl
	cpu.SF = (result >> 31) & 1;
 805bc5d:	c1 eb 1f             	shr    $0x1f,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
 805bc60:	83 e0 3f             	and    $0x3f,%eax
 805bc63:	c1 e2 06             	shl    $0x6,%edx
	cpu.SF = (result >> 31) & 1;
 805bc66:	89 df                	mov    %ebx,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805bc68:	c1 ee 1f             	shr    $0x1f,%esi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805bc6b:	09 d0                	or     %edx,%eax
 805bc6d:	c1 e7 07             	shl    $0x7,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805bc70:	31 f3                	xor    %esi,%ebx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805bc72:	09 f8                	or     %edi,%eax
 805bc74:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805bc79:	89 c8                	mov    %ecx,%eax
 805bc7b:	89 f1                	mov    %esi,%ecx
 805bc7d:	c1 e8 1f             	shr    $0x1f,%eax
 805bc80:	31 c1                	xor    %eax,%ecx
 805bc82:	21 d9                	and    %ebx,%ecx
 805bc84:	0f b6 1d e5 ae 8f 14 	movzbl 0x148faee5,%ebx
 805bc8b:	c1 e1 03             	shl    $0x3,%ecx
 805bc8e:	83 e3 f7             	and    $0xfffffff7,%ebx
 805bc91:	09 d9                	or     %ebx,%ecx
 805bc93:	88 0d e5 ae 8f 14    	mov    %cl,0x148faee5

	print_asm_template1();
 805bc99:	e8 62 ce fe ff       	call   8048b00 <snprintf@plt>
 805bc9e:	83 c4 10             	add    $0x10,%esp
 805bca1:	83 f8 4f             	cmp    $0x4f,%eax
 805bca4:	7f 0a                	jg     805bcb0 <do_dec_l+0xd0>
}
 805bca6:	83 c4 1c             	add    $0x1c,%esp
 805bca9:	5b                   	pop    %ebx
 805bcaa:	5e                   	pop    %esi
 805bcab:	5f                   	pop    %edi
 805bcac:	5d                   	pop    %ebp
 805bcad:	c3                   	ret    
 805bcae:	66 90                	xchg   %ax,%ax
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805bcb0:	83 ec 0c             	sub    $0xc,%esp
 805bcb3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805bcb9:	e8 a2 cc fe ff       	call   8048960 <fflush@plt>
 805bcbe:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805bcc4:	6a 07                	push   $0x7
 805bcc6:	6a 01                	push   $0x1
 805bcc8:	68 92 ed 05 08       	push   $0x805ed92
 805bccd:	e8 3e cd fe ff       	call   8048a10 <fwrite@plt>
 805bcd2:	83 c4 20             	add    $0x20,%esp
 805bcd5:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805bcdb:	6a 10                	push   $0x10
 805bcdd:	6a 01                	push   $0x1
 805bcdf:	68 84 f8 05 08       	push   $0x805f884
 805bce4:	e8 27 cd fe ff       	call   8048a10 <fwrite@plt>
 805bce9:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805bcef:	6a 05                	push   $0x5
 805bcf1:	6a 01                	push   $0x1
 805bcf3:	68 b1 ed 05 08       	push   $0x805edb1
 805bcf8:	e8 13 cd fe ff       	call   8048a10 <fwrite@plt>
 805bcfd:	83 c4 20             	add    $0x20,%esp
 805bd00:	68 18 ae 8f 14       	push   $0x148fae18
 805bd05:	68 33 59 06 08       	push   $0x8065933
 805bd0a:	6a 50                	push   $0x50
 805bd0c:	68 00 89 0c 08       	push   $0x80c8900
 805bd11:	e8 ea cd fe ff       	call   8048b00 <snprintf@plt>
 805bd16:	83 c4 10             	add    $0x10,%esp
 805bd19:	83 f8 4f             	cmp    $0x4f,%eax
 805bd1c:	7e 88                	jle    805bca6 <do_dec_l+0xc6>
 805bd1e:	68 42 5a 06 08       	push   $0x8065a42
 805bd23:	6a 14                	push   $0x14
 805bd25:	68 44 59 06 08       	push   $0x8065944
 805bd2a:	68 b4 59 06 08       	push   $0x80659b4
 805bd2f:	e8 7c ce fe ff       	call   8048bb0 <__assert_fail@plt>
 805bd34:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805bd3a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805bd40 <dec_rm_l>:
}

make_instr_helper(rm)
 805bd40:	53                   	push   %ebx
 805bd41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805bd44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805bd48:	83 c0 01             	add    $0x1,%eax
 805bd4b:	50                   	push   %eax
 805bd4c:	e8 df 14 00 00       	call   805d230 <decode_rm_l>
 805bd51:	89 c3                	mov    %eax,%ebx
	execute();
 805bd53:	e8 88 fe ff ff       	call   805bbe0 <do_dec_l>
 805bd58:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805bd5b:	8d 43 01             	lea    0x1(%ebx),%eax
 805bd5e:	5b                   	pop    %ebx
 805bd5f:	c3                   	ret    

0805bd60 <dec_r_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(r)
 805bd60:	53                   	push   %ebx
 805bd61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805bd64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805bd68:	83 c0 01             	add    $0x1,%eax
 805bd6b:	50                   	push   %eax
 805bd6c:	e8 df 14 00 00       	call   805d250 <decode_r_l>
 805bd71:	89 c3                	mov    %eax,%ebx
	execute();
 805bd73:	e8 68 fe ff ff       	call   805bbe0 <do_dec_l>
 805bd78:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805bd7b:	8d 43 01             	lea    0x1(%ebx),%eax
 805bd7e:	5b                   	pop    %ebx
 805bd7f:	c3                   	ret    

0805bd80 <dec_rm_b>:
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
}

make_instr_helper(rm)
 805bd80:	55                   	push   %ebp
 805bd81:	57                   	push   %edi
 805bd82:	56                   	push   %esi
 805bd83:	53                   	push   %ebx
 805bd84:	83 ec 18             	sub    $0x18,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805bd87:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 805bd8b:	83 c0 01             	add    $0x1,%eax
 805bd8e:	50                   	push   %eax
 805bd8f:	e8 9c 0d 00 00       	call   805cb30 <decode_rm_b>
 805bd94:	89 c6                	mov    %eax,%esi
#include "cpu/exec/template-start.h"

#define instr dec

static void do_execute () {
	DATA_TYPE result = op_src->val - 1;
 805bd96:	0f b6 05 14 ae 8f 14 	movzbl 0x148fae14,%eax
 805bd9d:	8d 58 ff             	lea    -0x1(%eax),%ebx
	OPERAND_W(op_src, result);
 805bda0:	58                   	pop    %eax
 805bda1:	5a                   	pop    %edx
 805bda2:	0f b6 fb             	movzbl %bl,%edi
 805bda5:	57                   	push   %edi
 805bda6:	68 08 ae 8f 14       	push   $0x148fae08
 805bdab:	e8 90 0e 00 00       	call   805cc40 <write_operand_b>

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805bdb0:	89 fa                	mov    %edi,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805bdb2:	83 c4 10             	add    $0x10,%esp
 805bdb5:	8b 0d 4c ae 8f 14    	mov    0x148fae4c,%ecx
	DATA_TYPE result = op_src->val - 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805bdbb:	c1 ea 04             	shr    $0x4,%edx
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805bdbe:	68 18 ae 8f 14       	push   $0x148fae18
 805bdc3:	68 3b 59 06 08       	push   $0x806593b
	DATA_TYPE result = op_src->val - 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805bdc8:	31 d7                	xor    %edx,%edi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805bdca:	6a 50                	push   $0x50
 805bdcc:	68 00 89 0c 08       	push   $0x80c8900
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 805bdd1:	89 fa                	mov    %edi,%edx
 805bdd3:	c1 ea 02             	shr    $0x2,%edx
 805bdd6:	31 fa                	xor    %edi,%edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805bdd8:	0f b6 3d e4 ae 8f 14 	movzbl 0x148faee4,%edi

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805bddf:	89 d5                	mov    %edx,%ebp
 805bde1:	d1 ed                	shr    %ebp
	cpu.CF = op_dest->val < op_src->val;
 805bde3:	3b 0d 14 ae 8f 14    	cmp    0x148fae14,%ecx
 805bde9:	0f 92 c0             	setb   %al

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805bdec:	31 ea                	xor    %ebp,%edx
	cpu.CF = op_dest->val < op_src->val;
 805bdee:	83 e7 fa             	and    $0xfffffffa,%edi
	cpu.PF = (pf & 1);
 805bdf1:	83 e2 01             	and    $0x1,%edx
 805bdf4:	09 f8                	or     %edi,%eax
 805bdf6:	c1 e2 02             	shl    $0x2,%edx
 805bdf9:	09 d0                	or     %edx,%eax
	cpu.ZF = (result == 0);
 805bdfb:	84 db                	test   %bl,%bl
 805bdfd:	0f 94 c3             	sete   %bl
 805be00:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805be03:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
 805be06:	c1 e3 06             	shl    $0x6,%ebx
	cpu.SF = (result >> 31) & 1;
 805be09:	09 d8                	or     %ebx,%eax
 805be0b:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805be10:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
 805be15:	c1 e8 1f             	shr    $0x1f,%eax
 805be18:	31 c8                	xor    %ecx,%eax
 805be1a:	21 c1                	and    %eax,%ecx
 805be1c:	0f b6 05 e5 ae 8f 14 	movzbl 0x148faee5,%eax
 805be23:	c1 e1 03             	shl    $0x3,%ecx
 805be26:	83 e0 f7             	and    $0xfffffff7,%eax
 805be29:	09 c1                	or     %eax,%ecx
 805be2b:	88 0d e5 ae 8f 14    	mov    %cl,0x148faee5

	print_asm_template1();
 805be31:	e8 ca cc fe ff       	call   8048b00 <snprintf@plt>
 805be36:	83 c4 10             	add    $0x10,%esp
 805be39:	83 f8 4f             	cmp    $0x4f,%eax
 805be3c:	7f 12                	jg     805be50 <dec_rm_b+0xd0>
}

make_instr_helper(rm)
 805be3e:	83 c4 0c             	add    $0xc,%esp
	execute();
	return len + 1;	// "1" for opcode
 805be41:	8d 46 01             	lea    0x1(%esi),%eax
 805be44:	5b                   	pop    %ebx
 805be45:	5e                   	pop    %esi
 805be46:	5f                   	pop    %edi
 805be47:	5d                   	pop    %ebp
 805be48:	c3                   	ret    
 805be49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805be50:	83 ec 0c             	sub    $0xc,%esp
 805be53:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805be59:	e8 02 cb fe ff       	call   8048960 <fflush@plt>
 805be5e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805be64:	6a 07                	push   $0x7
 805be66:	6a 01                	push   $0x1
 805be68:	68 92 ed 05 08       	push   $0x805ed92
 805be6d:	e8 9e cb fe ff       	call   8048a10 <fwrite@plt>
 805be72:	83 c4 20             	add    $0x20,%esp
 805be75:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805be7b:	6a 10                	push   $0x10
 805be7d:	6a 01                	push   $0x1
 805be7f:	68 84 f8 05 08       	push   $0x805f884
 805be84:	e8 87 cb fe ff       	call   8048a10 <fwrite@plt>
 805be89:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805be8f:	6a 05                	push   $0x5
 805be91:	6a 01                	push   $0x1
 805be93:	68 b1 ed 05 08       	push   $0x805edb1
 805be98:	e8 73 cb fe ff       	call   8048a10 <fwrite@plt>
 805be9d:	83 c4 20             	add    $0x20,%esp
 805bea0:	68 18 ae 8f 14       	push   $0x148fae18
 805bea5:	68 3b 59 06 08       	push   $0x806593b
 805beaa:	6a 50                	push   $0x50
 805beac:	68 00 89 0c 08       	push   $0x80c8900
 805beb1:	e8 4a cc fe ff       	call   8048b00 <snprintf@plt>
 805beb6:	83 c4 10             	add    $0x10,%esp
 805beb9:	83 f8 4f             	cmp    $0x4f,%eax
 805bebc:	7e 80                	jle    805be3e <dec_rm_b+0xbe>
 805bebe:	68 54 5a 06 08       	push   $0x8065a54
 805bec3:	6a 14                	push   $0x14
 805bec5:	68 44 59 06 08       	push   $0x8065944
 805beca:	68 fc 59 06 08       	push   $0x80659fc
 805becf:	e8 dc cc fe ff       	call   8048bb0 <__assert_fail@plt>
 805bed4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805beda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805bee0 <dec_rm_v>:
#include "dec-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(dec_rm)
 805bee0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805bee7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805beeb:	b8 a0 bb 05 08       	mov    $0x805bba0,%eax
 805bef0:	75 05                	jne    805bef7 <dec_rm_v+0x17>
 805bef2:	b8 40 bd 05 08       	mov    $0x805bd40,%eax
 805bef7:	89 54 24 04          	mov    %edx,0x4(%esp)
 805befb:	ff e0                	jmp    *%eax
 805befd:	8d 76 00             	lea    0x0(%esi),%esi

0805bf00 <dec_r_v>:
make_helper_v(dec_r)
 805bf00:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805bf07:	8b 54 24 04          	mov    0x4(%esp),%edx
 805bf0b:	b8 c0 bb 05 08       	mov    $0x805bbc0,%eax
 805bf10:	75 05                	jne    805bf17 <dec_r_v+0x17>
 805bf12:	b8 60 bd 05 08       	mov    $0x805bd60,%eax
 805bf17:	89 54 24 04          	mov    %edx,0x4(%esp)
 805bf1b:	ff e0                	jmp    *%eax
 805bf1d:	66 90                	xchg   %ax,%ax
 805bf1f:	90                   	nop

0805bf20 <inv>:
#include "cpu/exec/helper.h"
#include "monitor/monitor.h"

make_helper(inv) {
 805bf20:	53                   	push   %ebx
 805bf21:	83 ec 30             	sub    $0x30,%esp
 805bf24:	8b 5c 24 38          	mov    0x38(%esp),%ebx

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 805bf28:	6a 04                	push   $0x4
 805bf2a:	53                   	push   %ebx
 805bf2b:	e8 30 f0 fe ff       	call   804af60 <swaddr_read>
	/* invalid opcode */

	uint32_t temp[8];
	temp[0] = instr_fetch(eip, 4);
 805bf30:	89 44 24 10          	mov    %eax,0x10(%esp)
 805bf34:	58                   	pop    %eax
	temp[1] = instr_fetch(eip + 4, 4);
 805bf35:	8d 43 04             	lea    0x4(%ebx),%eax
 805bf38:	5a                   	pop    %edx
 805bf39:	6a 04                	push   $0x4
 805bf3b:	50                   	push   %eax
 805bf3c:	e8 1f f0 fe ff       	call   804af60 <swaddr_read>
 805bf41:	89 c1                	mov    %eax,%ecx

	uint8_t *p = (void *)temp;
	printf("invalid opcode(eip = 0x%08x): %02x %02x %02x %02x %02x %02x %02x %02x ...\n\n", 
 805bf43:	83 c4 08             	add    $0x8,%esp
make_helper(inv) {
	/* invalid opcode */

	uint32_t temp[8];
	temp[0] = instr_fetch(eip, 4);
	temp[1] = instr_fetch(eip + 4, 4);
 805bf46:	c1 e9 10             	shr    $0x10,%ecx
 805bf49:	89 ca                	mov    %ecx,%edx

	uint8_t *p = (void *)temp;
	printf("invalid opcode(eip = 0x%08x): %02x %02x %02x %02x %02x %02x %02x %02x ...\n\n", 
 805bf4b:	89 c1                	mov    %eax,%ecx
 805bf4d:	c1 e9 18             	shr    $0x18,%ecx
 805bf50:	0f b6 d2             	movzbl %dl,%edx
 805bf53:	51                   	push   %ecx
 805bf54:	52                   	push   %edx
 805bf55:	0f b6 d4             	movzbl %ah,%edx
 805bf58:	0f b6 c0             	movzbl %al,%eax
 805bf5b:	52                   	push   %edx
 805bf5c:	50                   	push   %eax
 805bf5d:	0f b6 44 24 1b       	movzbl 0x1b(%esp),%eax
 805bf62:	50                   	push   %eax
 805bf63:	0f b6 44 24 1e       	movzbl 0x1e(%esp),%eax
 805bf68:	50                   	push   %eax
 805bf69:	0f b6 44 24 21       	movzbl 0x21(%esp),%eax
 805bf6e:	50                   	push   %eax
 805bf6f:	0f b6 44 24 24       	movzbl 0x24(%esp),%eax
 805bf74:	50                   	push   %eax
 805bf75:	53                   	push   %ebx
 805bf76:	68 60 5a 06 08       	push   $0x8065a60
 805bf7b:	e8 d0 c9 fe ff       	call   8048950 <printf@plt>
			eip, p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);

	extern char logo [];
	printf("There are two cases which will trigger this unexpected exception:\n\
 805bf80:	83 c4 28             	add    $0x28,%esp
 805bf83:	53                   	push   %ebx
 805bf84:	68 ac 5a 06 08       	push   $0x8065aac
 805bf89:	e8 c2 c9 fe ff       	call   8048950 <printf@plt>
1. The instruction at eip = 0x%08x is not implemented.\n\
2. Something is implemented incorrectly.\n", eip);
	printf("Find this eip value(0x%08x) in the disassembling result to distinguish which case it is.\n\n", eip);
 805bf8e:	58                   	pop    %eax
 805bf8f:	5a                   	pop    %edx
 805bf90:	53                   	push   %ebx
 805bf91:	68 50 5b 06 08       	push   $0x8065b50
 805bf96:	e8 b5 c9 fe ff       	call   8048950 <printf@plt>
	printf("\33[1;31mIf it is the first case, see\n%s\nfor more details.\n\nIf it is the second case, remember:\n\
 805bf9b:	59                   	pop    %ecx
 805bf9c:	5b                   	pop    %ebx
 805bf9d:	68 00 52 07 08       	push   $0x8075200
 805bfa2:	68 ac 5b 06 08       	push   $0x8065bac
 805bfa7:	e8 a4 c9 fe ff       	call   8048950 <printf@plt>
* The machine is always right!\n\
* Every line of untested code is always wrong!\33[0m\n\n", logo);

	assert(0);
 805bfac:	68 1b 5d 06 08       	push   $0x8065d1b
 805bfb1:	6a 18                	push   $0x18
 805bfb3:	68 60 5c 06 08       	push   $0x8065c60
 805bfb8:	68 20 ef 05 08       	push   $0x805ef20
 805bfbd:	e8 ee cb fe ff       	call   8048bb0 <__assert_fail@plt>
 805bfc2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805bfc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805bfd0 <nemu_trap>:
}

make_helper(nemu_trap) {
 805bfd0:	83 ec 0c             	sub    $0xc,%esp
	print_asm("nemu trap (eax = %d)", cpu.eax);
 805bfd3:	ff 35 c0 ae 8f 14    	pushl  0x148faec0
 805bfd9:	68 fc 5c 06 08       	push   $0x8065cfc
 805bfde:	6a 50                	push   $0x50
 805bfe0:	68 00 89 0c 08       	push   $0x80c8900
 805bfe5:	e8 16 cb fe ff       	call   8048b00 <snprintf@plt>
 805bfea:	83 c4 10             	add    $0x10,%esp
 805bfed:	83 f8 4f             	cmp    $0x4f,%eax
 805bff0:	7f 4e                	jg     805c040 <nemu_trap+0x70>

	switch(cpu.eax) {
 805bff2:	a1 c0 ae 8f 14       	mov    0x148faec0,%eax
 805bff7:	83 f8 02             	cmp    $0x2,%eax
 805bffa:	74 2b                	je     805c027 <nemu_trap+0x57>
		case 2:
		   	break;

		default:
			printf("\33[1;31mnemu: HIT %s TRAP\33[0m at eip = 0x%08x\n\n",
 805bffc:	85 c0                	test   %eax,%eax
 805bffe:	8b 0d e0 ae 8f 14    	mov    0x148faee0,%ecx
 805c004:	ba f3 5c 06 08       	mov    $0x8065cf3,%edx
 805c009:	75 25                	jne    805c030 <nemu_trap+0x60>
 805c00b:	83 ec 04             	sub    $0x4,%esp
 805c00e:	51                   	push   %ecx
 805c00f:	52                   	push   %edx
 805c010:	68 c4 5c 06 08       	push   $0x8065cc4
 805c015:	e8 36 c9 fe ff       	call   8048950 <printf@plt>
					(cpu.eax == 0 ? "GOOD" : "BAD"), cpu.eip);
			nemu_state = END;
 805c01a:	c7 05 80 81 07 08 02 	movl   $0x2,0x8078180
 805c021:	00 00 00 
 805c024:	83 c4 10             	add    $0x10,%esp
	}

	return 1;
}
 805c027:	b8 01 00 00 00       	mov    $0x1,%eax
 805c02c:	83 c4 0c             	add    $0xc,%esp
 805c02f:	c3                   	ret    
	switch(cpu.eax) {
		case 2:
		   	break;

		default:
			printf("\33[1;31mnemu: HIT %s TRAP\33[0m at eip = 0x%08x\n\n",
 805c030:	ba f8 5c 06 08       	mov    $0x8065cf8,%edx
 805c035:	eb d4                	jmp    805c00b <nemu_trap+0x3b>
 805c037:	89 f6                	mov    %esi,%esi
 805c039:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

	assert(0);
}

make_helper(nemu_trap) {
	print_asm("nemu trap (eax = %d)", cpu.eax);
 805c040:	83 ec 0c             	sub    $0xc,%esp
 805c043:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805c049:	e8 12 c9 fe ff       	call   8048960 <fflush@plt>
 805c04e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805c054:	6a 07                	push   $0x7
 805c056:	6a 01                	push   $0x1
 805c058:	68 92 ed 05 08       	push   $0x805ed92
 805c05d:	e8 ae c9 fe ff       	call   8048a10 <fwrite@plt>
 805c062:	83 c4 20             	add    $0x20,%esp
 805c065:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805c06b:	6a 10                	push   $0x10
 805c06d:	6a 01                	push   $0x1
 805c06f:	68 84 f8 05 08       	push   $0x805f884
 805c074:	e8 97 c9 fe ff       	call   8048a10 <fwrite@plt>
 805c079:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805c07f:	6a 05                	push   $0x5
 805c081:	6a 01                	push   $0x1
 805c083:	68 b1 ed 05 08       	push   $0x805edb1
 805c088:	e8 83 c9 fe ff       	call   8048a10 <fwrite@plt>
 805c08d:	83 c4 20             	add    $0x20,%esp
 805c090:	ff 35 c0 ae 8f 14    	pushl  0x148faec0
 805c096:	68 fc 5c 06 08       	push   $0x8065cfc
 805c09b:	6a 50                	push   $0x50
 805c09d:	68 00 89 0c 08       	push   $0x80c8900
 805c0a2:	e8 59 ca fe ff       	call   8048b00 <snprintf@plt>
 805c0a7:	83 c4 10             	add    $0x10,%esp
 805c0aa:	83 f8 4f             	cmp    $0x4f,%eax
 805c0ad:	0f 8e 3f ff ff ff    	jle    805bff2 <nemu_trap+0x22>
 805c0b3:	68 11 5d 06 08       	push   $0x8065d11
 805c0b8:	6a 1c                	push   $0x1c
 805c0ba:	68 60 5c 06 08       	push   $0x8065c60
 805c0bf:	68 84 5c 06 08       	push   $0x8065c84
 805c0c4:	e8 e7 ca fe ff       	call   8048bb0 <__assert_fail@plt>
 805c0c9:	66 90                	xchg   %ax,%ax
 805c0cb:	66 90                	xchg   %ax,%ax
 805c0cd:	66 90                	xchg   %ax,%ax
 805c0cf:	90                   	nop

0805c0d0 <do_cmp_b>:
#include "cpu/exec/template-start.h"

#define instr cmp

static void do_execute() {
 805c0d0:	55                   	push   %ebp
 805c0d1:	57                   	push   %edi
 805c0d2:	56                   	push   %esi
 805c0d3:	53                   	push   %ebx
 805c0d4:	83 ec 18             	sub    $0x18,%esp
	uint32_t res = op_dest->val - op_src->val;
 805c0d7:	8b 1d 4c ae 8f 14    	mov    0x148fae4c,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805c0dd:	0f b6 2d e4 ae 8f 14 	movzbl 0x148faee4,%ebp
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805c0e4:	68 50 ae 8f 14       	push   $0x148fae50
 805c0e9:	68 18 ae 8f 14       	push   $0x148fae18
 805c0ee:	68 1f 5d 06 08       	push   $0x8065d1f
 805c0f3:	6a 50                	push   $0x50
#include "cpu/exec/template-start.h"

#define instr cmp

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
 805c0f5:	89 d9                	mov    %ebx,%ecx
 805c0f7:	2b 0d 14 ae 8f 14    	sub    0x148fae14,%ecx
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805c0fd:	68 00 89 0c 08       	push   $0x80c8900

#define instr cmp

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
 805c102:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
 805c105:	89 c6                	mov    %eax,%esi
 805c107:	c1 ee 04             	shr    $0x4,%esi
 805c10a:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 805c10c:	89 c6                	mov    %eax,%esi
 805c10e:	c1 ee 02             	shr    $0x2,%esi
 805c111:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 805c113:	89 c6                	mov    %eax,%esi
 805c115:	d1 ee                	shr    %esi
	cpu.CF = op_dest->val < op_src->val;
 805c117:	3b 1d 14 ae 8f 14    	cmp    0x148fae14,%ebx
 805c11d:	0f 92 c2             	setb   %dl
static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805c120:	31 f0                	xor    %esi,%eax
	cpu.CF = op_dest->val < op_src->val;
 805c122:	83 e5 fa             	and    $0xfffffffa,%ebp
	cpu.PF = (pf & 1);
 805c125:	83 e0 01             	and    $0x1,%eax
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805c128:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
 805c12a:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 805c131:	89 e8                	mov    %ebp,%eax
 805c133:	09 f8                	or     %edi,%eax
 805c135:	09 f0                	or     %esi,%eax
	cpu.ZF = (res == 0);
 805c137:	85 c9                	test   %ecx,%ecx
 805c139:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 805c13c:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 805c13f:	83 e0 3f             	and    $0x3f,%eax
 805c142:	89 d6                	mov    %edx,%esi
	cpu.SF = (res >> 31) & 1;
 805c144:	89 cf                	mov    %ecx,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805c146:	c1 eb 1f             	shr    $0x1f,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 805c149:	c1 e6 06             	shl    $0x6,%esi
	cpu.SF = (res >> 31) & 1;
 805c14c:	c1 e7 07             	shl    $0x7,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805c14f:	89 da                	mov    %ebx,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 805c151:	09 f0                	or     %esi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805c153:	31 d9                	xor    %ebx,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 805c155:	09 f8                	or     %edi,%eax
 805c157:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805c15c:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
 805c161:	c1 e8 1f             	shr    $0x1f,%eax
 805c164:	31 c2                	xor    %eax,%edx
 805c166:	21 ca                	and    %ecx,%edx
 805c168:	0f b6 0d e5 ae 8f 14 	movzbl 0x148faee5,%ecx
 805c16f:	c1 e2 03             	shl    $0x3,%edx
 805c172:	83 e1 f7             	and    $0xfffffff7,%ecx
 805c175:	09 ca                	or     %ecx,%edx
 805c177:	88 15 e5 ae 8f 14    	mov    %dl,0x148faee5
	print_asm_template2();
 805c17d:	e8 7e c9 fe ff       	call   8048b00 <snprintf@plt>
 805c182:	83 c4 20             	add    $0x20,%esp
 805c185:	83 f8 4f             	cmp    $0x4f,%eax
 805c188:	7f 0e                	jg     805c198 <do_cmp_b+0xc8>
}
 805c18a:	83 c4 0c             	add    $0xc,%esp
 805c18d:	5b                   	pop    %ebx
 805c18e:	5e                   	pop    %esi
 805c18f:	5f                   	pop    %edi
 805c190:	5d                   	pop    %ebp
 805c191:	c3                   	ret    
 805c192:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805c198:	83 ec 0c             	sub    $0xc,%esp
 805c19b:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805c1a1:	e8 ba c7 fe ff       	call   8048960 <fflush@plt>
 805c1a6:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805c1ac:	6a 07                	push   $0x7
 805c1ae:	6a 01                	push   $0x1
 805c1b0:	68 92 ed 05 08       	push   $0x805ed92
 805c1b5:	e8 56 c8 fe ff       	call   8048a10 <fwrite@plt>
 805c1ba:	83 c4 20             	add    $0x20,%esp
 805c1bd:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805c1c3:	6a 10                	push   $0x10
 805c1c5:	6a 01                	push   $0x1
 805c1c7:	68 84 f8 05 08       	push   $0x805f884
 805c1cc:	e8 3f c8 fe ff       	call   8048a10 <fwrite@plt>
 805c1d1:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805c1d7:	6a 05                	push   $0x5
 805c1d9:	6a 01                	push   $0x1
 805c1db:	68 b1 ed 05 08       	push   $0x805edb1
 805c1e0:	e8 2b c8 fe ff       	call   8048a10 <fwrite@plt>
 805c1e5:	83 c4 14             	add    $0x14,%esp
 805c1e8:	68 50 ae 8f 14       	push   $0x148fae50
 805c1ed:	68 18 ae 8f 14       	push   $0x148fae18
 805c1f2:	68 1f 5d 06 08       	push   $0x8065d1f
 805c1f7:	6a 50                	push   $0x50
 805c1f9:	68 00 89 0c 08       	push   $0x80c8900
 805c1fe:	e8 fd c8 fe ff       	call   8048b00 <snprintf@plt>
 805c203:	83 c4 20             	add    $0x20,%esp
 805c206:	83 f8 4f             	cmp    $0x4f,%eax
 805c209:	0f 8e 7b ff ff ff    	jle    805c18a <do_cmp_b+0xba>
 805c20f:	68 a5 5e 06 08       	push   $0x8065ea5
 805c214:	6a 10                	push   $0x10
 805c216:	68 40 5d 06 08       	push   $0x8065d40
 805c21b:	68 68 5d 06 08       	push   $0x8065d68
 805c220:	e8 8b c9 fe ff       	call   8048bb0 <__assert_fail@plt>
 805c225:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805c229:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c230 <do_cmp_w>:
#include "cpu/exec/template-start.h"

#define instr cmp

static void do_execute() {
 805c230:	55                   	push   %ebp
 805c231:	57                   	push   %edi
 805c232:	56                   	push   %esi
 805c233:	53                   	push   %ebx
 805c234:	83 ec 18             	sub    $0x18,%esp
	uint32_t res = op_dest->val - op_src->val;
 805c237:	8b 1d 4c ae 8f 14    	mov    0x148fae4c,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805c23d:	0f b6 2d e4 ae 8f 14 	movzbl 0x148faee4,%ebp
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805c244:	68 50 ae 8f 14       	push   $0x148fae50
 805c249:	68 18 ae 8f 14       	push   $0x148fae18
 805c24e:	68 2a 5d 06 08       	push   $0x8065d2a
 805c253:	6a 50                	push   $0x50
#include "cpu/exec/template-start.h"

#define instr cmp

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
 805c255:	89 d9                	mov    %ebx,%ecx
 805c257:	2b 0d 14 ae 8f 14    	sub    0x148fae14,%ecx
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805c25d:	68 00 89 0c 08       	push   $0x80c8900

#define instr cmp

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
 805c262:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
 805c265:	89 c6                	mov    %eax,%esi
 805c267:	c1 ee 04             	shr    $0x4,%esi
 805c26a:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 805c26c:	89 c6                	mov    %eax,%esi
 805c26e:	c1 ee 02             	shr    $0x2,%esi
 805c271:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 805c273:	89 c6                	mov    %eax,%esi
 805c275:	d1 ee                	shr    %esi
	cpu.CF = op_dest->val < op_src->val;
 805c277:	3b 1d 14 ae 8f 14    	cmp    0x148fae14,%ebx
 805c27d:	0f 92 c2             	setb   %dl
static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805c280:	31 f0                	xor    %esi,%eax
	cpu.CF = op_dest->val < op_src->val;
 805c282:	83 e5 fa             	and    $0xfffffffa,%ebp
	cpu.PF = (pf & 1);
 805c285:	83 e0 01             	and    $0x1,%eax
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805c288:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
 805c28a:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 805c291:	89 e8                	mov    %ebp,%eax
 805c293:	09 f8                	or     %edi,%eax
 805c295:	09 f0                	or     %esi,%eax
	cpu.ZF = (res == 0);
 805c297:	85 c9                	test   %ecx,%ecx
 805c299:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 805c29c:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 805c29f:	83 e0 3f             	and    $0x3f,%eax
 805c2a2:	89 d6                	mov    %edx,%esi
	cpu.SF = (res >> 31) & 1;
 805c2a4:	89 cf                	mov    %ecx,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805c2a6:	c1 eb 1f             	shr    $0x1f,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 805c2a9:	c1 e6 06             	shl    $0x6,%esi
	cpu.SF = (res >> 31) & 1;
 805c2ac:	c1 e7 07             	shl    $0x7,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805c2af:	89 da                	mov    %ebx,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 805c2b1:	09 f0                	or     %esi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805c2b3:	31 d9                	xor    %ebx,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 805c2b5:	09 f8                	or     %edi,%eax
 805c2b7:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805c2bc:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
 805c2c1:	c1 e8 1f             	shr    $0x1f,%eax
 805c2c4:	31 c2                	xor    %eax,%edx
 805c2c6:	21 ca                	and    %ecx,%edx
 805c2c8:	0f b6 0d e5 ae 8f 14 	movzbl 0x148faee5,%ecx
 805c2cf:	c1 e2 03             	shl    $0x3,%edx
 805c2d2:	83 e1 f7             	and    $0xfffffff7,%ecx
 805c2d5:	09 ca                	or     %ecx,%edx
 805c2d7:	88 15 e5 ae 8f 14    	mov    %dl,0x148faee5
	print_asm_template2();
 805c2dd:	e8 1e c8 fe ff       	call   8048b00 <snprintf@plt>
 805c2e2:	83 c4 20             	add    $0x20,%esp
 805c2e5:	83 f8 4f             	cmp    $0x4f,%eax
 805c2e8:	7f 0e                	jg     805c2f8 <do_cmp_w+0xc8>
}
 805c2ea:	83 c4 0c             	add    $0xc,%esp
 805c2ed:	5b                   	pop    %ebx
 805c2ee:	5e                   	pop    %esi
 805c2ef:	5f                   	pop    %edi
 805c2f0:	5d                   	pop    %ebp
 805c2f1:	c3                   	ret    
 805c2f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805c2f8:	83 ec 0c             	sub    $0xc,%esp
 805c2fb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805c301:	e8 5a c6 fe ff       	call   8048960 <fflush@plt>
 805c306:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805c30c:	6a 07                	push   $0x7
 805c30e:	6a 01                	push   $0x1
 805c310:	68 92 ed 05 08       	push   $0x805ed92
 805c315:	e8 f6 c6 fe ff       	call   8048a10 <fwrite@plt>
 805c31a:	83 c4 20             	add    $0x20,%esp
 805c31d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805c323:	6a 10                	push   $0x10
 805c325:	6a 01                	push   $0x1
 805c327:	68 84 f8 05 08       	push   $0x805f884
 805c32c:	e8 df c6 fe ff       	call   8048a10 <fwrite@plt>
 805c331:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805c337:	6a 05                	push   $0x5
 805c339:	6a 01                	push   $0x1
 805c33b:	68 b1 ed 05 08       	push   $0x805edb1
 805c340:	e8 cb c6 fe ff       	call   8048a10 <fwrite@plt>
 805c345:	83 c4 14             	add    $0x14,%esp
 805c348:	68 50 ae 8f 14       	push   $0x148fae50
 805c34d:	68 18 ae 8f 14       	push   $0x148fae18
 805c352:	68 2a 5d 06 08       	push   $0x8065d2a
 805c357:	6a 50                	push   $0x50
 805c359:	68 00 89 0c 08       	push   $0x80c8900
 805c35e:	e8 9d c7 fe ff       	call   8048b00 <snprintf@plt>
 805c363:	83 c4 20             	add    $0x20,%esp
 805c366:	83 f8 4f             	cmp    $0x4f,%eax
 805c369:	0f 8e 7b ff ff ff    	jle    805c2ea <do_cmp_w+0xba>
 805c36f:	68 9c 5e 06 08       	push   $0x8065e9c
 805c374:	6a 10                	push   $0x10
 805c376:	68 40 5d 06 08       	push   $0x8065d40
 805c37b:	68 cc 5d 06 08       	push   $0x8065dcc
 805c380:	e8 2b c8 fe ff       	call   8048bb0 <__assert_fail@plt>
 805c385:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805c389:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c390 <cmp_i2rm_w>:
}

make_instr_helper(i2rm)
 805c390:	53                   	push   %ebx
 805c391:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c394:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c398:	83 c0 01             	add    $0x1,%eax
 805c39b:	50                   	push   %eax
 805c39c:	e8 6f 0a 00 00       	call   805ce10 <decode_i2rm_w>
 805c3a1:	89 c3                	mov    %eax,%ebx
	execute();
 805c3a3:	e8 88 fe ff ff       	call   805c230 <do_cmp_w>
 805c3a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c3ab:	8d 43 01             	lea    0x1(%ebx),%eax
 805c3ae:	5b                   	pop    %ebx
 805c3af:	c3                   	ret    

0805c3b0 <cmp_i2a_w>:
make_instr_helper(i2a)
 805c3b0:	53                   	push   %ebx
 805c3b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c3b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c3b8:	83 c0 01             	add    $0x1,%eax
 805c3bb:	50                   	push   %eax
 805c3bc:	e8 cf 09 00 00       	call   805cd90 <decode_i2a_w>
 805c3c1:	89 c3                	mov    %eax,%ebx
	execute();
 805c3c3:	e8 68 fe ff ff       	call   805c230 <do_cmp_w>
 805c3c8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c3cb:	8d 43 01             	lea    0x1(%ebx),%eax
 805c3ce:	5b                   	pop    %ebx
 805c3cf:	c3                   	ret    

0805c3d0 <cmp_r2rm_w>:
make_instr_helper(r2rm)
 805c3d0:	53                   	push   %ebx
 805c3d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c3d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c3d8:	83 c0 01             	add    $0x1,%eax
 805c3db:	50                   	push   %eax
 805c3dc:	e8 6f 09 00 00       	call   805cd50 <decode_r2rm_w>
 805c3e1:	89 c3                	mov    %eax,%ebx
	execute();
 805c3e3:	e8 48 fe ff ff       	call   805c230 <do_cmp_w>
 805c3e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c3eb:	8d 43 01             	lea    0x1(%ebx),%eax
 805c3ee:	5b                   	pop    %ebx
 805c3ef:	c3                   	ret    

0805c3f0 <cmp_rm2r_w>:
make_instr_helper(rm2r)
 805c3f0:	53                   	push   %ebx
 805c3f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c3f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c3f8:	83 c0 01             	add    $0x1,%eax
 805c3fb:	50                   	push   %eax
 805c3fc:	e8 6f 09 00 00       	call   805cd70 <decode_rm2r_w>
 805c401:	89 c3                	mov    %eax,%ebx
	execute();
 805c403:	e8 28 fe ff ff       	call   805c230 <do_cmp_w>
 805c408:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c40b:	8d 43 01             	lea    0x1(%ebx),%eax
 805c40e:	5b                   	pop    %ebx
 805c40f:	c3                   	ret    

0805c410 <cmp_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 805c410:	53                   	push   %ebx
 805c411:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c414:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c418:	83 c0 01             	add    $0x1,%eax
 805c41b:	50                   	push   %eax
 805c41c:	e8 6f 0a 00 00       	call   805ce90 <decode_si2rm_w>
 805c421:	89 c3                	mov    %eax,%ebx
	execute();
 805c423:	e8 08 fe ff ff       	call   805c230 <do_cmp_w>
 805c428:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c42b:	8d 43 01             	lea    0x1(%ebx),%eax
 805c42e:	5b                   	pop    %ebx
 805c42f:	c3                   	ret    

0805c430 <do_cmp_l>:
#include "cpu/exec/template-start.h"

#define instr cmp

static void do_execute() {
 805c430:	55                   	push   %ebp
 805c431:	57                   	push   %edi
 805c432:	56                   	push   %esi
 805c433:	53                   	push   %ebx
 805c434:	83 ec 18             	sub    $0x18,%esp
	uint32_t res = op_dest->val - op_src->val;
 805c437:	8b 1d 4c ae 8f 14    	mov    0x148fae4c,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805c43d:	0f b6 2d e4 ae 8f 14 	movzbl 0x148faee4,%ebp
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805c444:	68 50 ae 8f 14       	push   $0x148fae50
 805c449:	68 18 ae 8f 14       	push   $0x148fae18
 805c44e:	68 35 5d 06 08       	push   $0x8065d35
 805c453:	6a 50                	push   $0x50
#include "cpu/exec/template-start.h"

#define instr cmp

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
 805c455:	89 d9                	mov    %ebx,%ecx
 805c457:	2b 0d 14 ae 8f 14    	sub    0x148fae14,%ecx
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805c45d:	68 00 89 0c 08       	push   $0x80c8900

#define instr cmp

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
 805c462:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
 805c465:	89 c6                	mov    %eax,%esi
 805c467:	c1 ee 04             	shr    $0x4,%esi
 805c46a:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 805c46c:	89 c6                	mov    %eax,%esi
 805c46e:	c1 ee 02             	shr    $0x2,%esi
 805c471:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 805c473:	89 c6                	mov    %eax,%esi
 805c475:	d1 ee                	shr    %esi
	cpu.CF = op_dest->val < op_src->val;
 805c477:	3b 1d 14 ae 8f 14    	cmp    0x148fae14,%ebx
 805c47d:	0f 92 c2             	setb   %dl
static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805c480:	31 f0                	xor    %esi,%eax
	cpu.CF = op_dest->val < op_src->val;
 805c482:	83 e5 fa             	and    $0xfffffffa,%ebp
	cpu.PF = (pf & 1);
 805c485:	83 e0 01             	and    $0x1,%eax
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805c488:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
 805c48a:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 805c491:	89 e8                	mov    %ebp,%eax
 805c493:	09 f8                	or     %edi,%eax
 805c495:	09 f0                	or     %esi,%eax
	cpu.ZF = (res == 0);
 805c497:	85 c9                	test   %ecx,%ecx
 805c499:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 805c49c:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 805c49f:	83 e0 3f             	and    $0x3f,%eax
 805c4a2:	89 d6                	mov    %edx,%esi
	cpu.SF = (res >> 31) & 1;
 805c4a4:	89 cf                	mov    %ecx,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805c4a6:	c1 eb 1f             	shr    $0x1f,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 805c4a9:	c1 e6 06             	shl    $0x6,%esi
	cpu.SF = (res >> 31) & 1;
 805c4ac:	c1 e7 07             	shl    $0x7,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805c4af:	89 da                	mov    %ebx,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 805c4b1:	09 f0                	or     %esi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805c4b3:	31 d9                	xor    %ebx,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 805c4b5:	09 f8                	or     %edi,%eax
 805c4b7:	a2 e4 ae 8f 14       	mov    %al,0x148faee4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805c4bc:	a1 14 ae 8f 14       	mov    0x148fae14,%eax
 805c4c1:	c1 e8 1f             	shr    $0x1f,%eax
 805c4c4:	31 c2                	xor    %eax,%edx
 805c4c6:	21 ca                	and    %ecx,%edx
 805c4c8:	0f b6 0d e5 ae 8f 14 	movzbl 0x148faee5,%ecx
 805c4cf:	c1 e2 03             	shl    $0x3,%edx
 805c4d2:	83 e1 f7             	and    $0xfffffff7,%ecx
 805c4d5:	09 ca                	or     %ecx,%edx
 805c4d7:	88 15 e5 ae 8f 14    	mov    %dl,0x148faee5
	print_asm_template2();
 805c4dd:	e8 1e c6 fe ff       	call   8048b00 <snprintf@plt>
 805c4e2:	83 c4 20             	add    $0x20,%esp
 805c4e5:	83 f8 4f             	cmp    $0x4f,%eax
 805c4e8:	7f 0e                	jg     805c4f8 <do_cmp_l+0xc8>
}
 805c4ea:	83 c4 0c             	add    $0xc,%esp
 805c4ed:	5b                   	pop    %ebx
 805c4ee:	5e                   	pop    %esi
 805c4ef:	5f                   	pop    %edi
 805c4f0:	5d                   	pop    %ebp
 805c4f1:	c3                   	ret    
 805c4f2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805c4f8:	83 ec 0c             	sub    $0xc,%esp
 805c4fb:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805c501:	e8 5a c4 fe ff       	call   8048960 <fflush@plt>
 805c506:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805c50c:	6a 07                	push   $0x7
 805c50e:	6a 01                	push   $0x1
 805c510:	68 92 ed 05 08       	push   $0x805ed92
 805c515:	e8 f6 c4 fe ff       	call   8048a10 <fwrite@plt>
 805c51a:	83 c4 20             	add    $0x20,%esp
 805c51d:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805c523:	6a 10                	push   $0x10
 805c525:	6a 01                	push   $0x1
 805c527:	68 84 f8 05 08       	push   $0x805f884
 805c52c:	e8 df c4 fe ff       	call   8048a10 <fwrite@plt>
 805c531:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805c537:	6a 05                	push   $0x5
 805c539:	6a 01                	push   $0x1
 805c53b:	68 b1 ed 05 08       	push   $0x805edb1
 805c540:	e8 cb c4 fe ff       	call   8048a10 <fwrite@plt>
 805c545:	83 c4 14             	add    $0x14,%esp
 805c548:	68 50 ae 8f 14       	push   $0x148fae50
 805c54d:	68 18 ae 8f 14       	push   $0x148fae18
 805c552:	68 35 5d 06 08       	push   $0x8065d35
 805c557:	6a 50                	push   $0x50
 805c559:	68 00 89 0c 08       	push   $0x80c8900
 805c55e:	e8 9d c5 fe ff       	call   8048b00 <snprintf@plt>
 805c563:	83 c4 20             	add    $0x20,%esp
 805c566:	83 f8 4f             	cmp    $0x4f,%eax
 805c569:	0f 8e 7b ff ff ff    	jle    805c4ea <do_cmp_l+0xba>
 805c56f:	68 93 5e 06 08       	push   $0x8065e93
 805c574:	6a 10                	push   $0x10
 805c576:	68 40 5d 06 08       	push   $0x8065d40
 805c57b:	68 30 5e 06 08       	push   $0x8065e30
 805c580:	e8 2b c6 fe ff       	call   8048bb0 <__assert_fail@plt>
 805c585:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805c589:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c590 <cmp_i2rm_l>:
}

make_instr_helper(i2rm)
 805c590:	53                   	push   %ebx
 805c591:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c594:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c598:	83 c0 01             	add    $0x1,%eax
 805c59b:	50                   	push   %eax
 805c59c:	e8 3f 0c 00 00       	call   805d1e0 <decode_i2rm_l>
 805c5a1:	89 c3                	mov    %eax,%ebx
	execute();
 805c5a3:	e8 88 fe ff ff       	call   805c430 <do_cmp_l>
 805c5a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c5ab:	8d 43 01             	lea    0x1(%ebx),%eax
 805c5ae:	5b                   	pop    %ebx
 805c5af:	c3                   	ret    

0805c5b0 <cmp_i2a_l>:
make_instr_helper(i2a)
 805c5b0:	53                   	push   %ebx
 805c5b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c5b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c5b8:	83 c0 01             	add    $0x1,%eax
 805c5bb:	50                   	push   %eax
 805c5bc:	e8 9f 0b 00 00       	call   805d160 <decode_i2a_l>
 805c5c1:	89 c3                	mov    %eax,%ebx
	execute();
 805c5c3:	e8 68 fe ff ff       	call   805c430 <do_cmp_l>
 805c5c8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c5cb:	8d 43 01             	lea    0x1(%ebx),%eax
 805c5ce:	5b                   	pop    %ebx
 805c5cf:	c3                   	ret    

0805c5d0 <cmp_r2rm_l>:
make_instr_helper(r2rm)
 805c5d0:	53                   	push   %ebx
 805c5d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c5d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c5d8:	83 c0 01             	add    $0x1,%eax
 805c5db:	50                   	push   %eax
 805c5dc:	e8 3f 0b 00 00       	call   805d120 <decode_r2rm_l>
 805c5e1:	89 c3                	mov    %eax,%ebx
	execute();
 805c5e3:	e8 48 fe ff ff       	call   805c430 <do_cmp_l>
 805c5e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c5eb:	8d 43 01             	lea    0x1(%ebx),%eax
 805c5ee:	5b                   	pop    %ebx
 805c5ef:	c3                   	ret    

0805c5f0 <cmp_rm2r_l>:
make_instr_helper(rm2r)
 805c5f0:	53                   	push   %ebx
 805c5f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c5f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c5f8:	83 c0 01             	add    $0x1,%eax
 805c5fb:	50                   	push   %eax
 805c5fc:	e8 3f 0b 00 00       	call   805d140 <decode_rm2r_l>
 805c601:	89 c3                	mov    %eax,%ebx
	execute();
 805c603:	e8 28 fe ff ff       	call   805c430 <do_cmp_l>
 805c608:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c60b:	8d 43 01             	lea    0x1(%ebx),%eax
 805c60e:	5b                   	pop    %ebx
 805c60f:	c3                   	ret    

0805c610 <cmp_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 805c610:	53                   	push   %ebx
 805c611:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c614:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c618:	83 c0 01             	add    $0x1,%eax
 805c61b:	50                   	push   %eax
 805c61c:	e8 3f 0c 00 00       	call   805d260 <decode_si2rm_l>
 805c621:	89 c3                	mov    %eax,%ebx
	execute();
 805c623:	e8 08 fe ff ff       	call   805c430 <do_cmp_l>
 805c628:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c62b:	8d 43 01             	lea    0x1(%ebx),%eax
 805c62e:	5b                   	pop    %ebx
 805c62f:	c3                   	ret    

0805c630 <cmp_i2rm_b>:
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
}

make_instr_helper(i2rm)
 805c630:	53                   	push   %ebx
 805c631:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c634:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c638:	83 c0 01             	add    $0x1,%eax
 805c63b:	50                   	push   %eax
 805c63c:	e8 9f 04 00 00       	call   805cae0 <decode_i2rm_b>
 805c641:	89 c3                	mov    %eax,%ebx
	execute();
 805c643:	e8 88 fa ff ff       	call   805c0d0 <do_cmp_b>
 805c648:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c64b:	8d 43 01             	lea    0x1(%ebx),%eax
 805c64e:	5b                   	pop    %ebx
 805c64f:	c3                   	ret    

0805c650 <cmp_i2a_b>:
make_instr_helper(i2a)
 805c650:	53                   	push   %ebx
 805c651:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c654:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c658:	83 c0 01             	add    $0x1,%eax
 805c65b:	50                   	push   %eax
 805c65c:	e8 ff 03 00 00       	call   805ca60 <decode_i2a_b>
 805c661:	89 c3                	mov    %eax,%ebx
	execute();
 805c663:	e8 68 fa ff ff       	call   805c0d0 <do_cmp_b>
 805c668:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c66b:	8d 43 01             	lea    0x1(%ebx),%eax
 805c66e:	5b                   	pop    %ebx
 805c66f:	c3                   	ret    

0805c670 <cmp_r2rm_b>:
make_instr_helper(r2rm)
 805c670:	53                   	push   %ebx
 805c671:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c674:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c678:	83 c0 01             	add    $0x1,%eax
 805c67b:	50                   	push   %eax
 805c67c:	e8 9f 03 00 00       	call   805ca20 <decode_r2rm_b>
 805c681:	89 c3                	mov    %eax,%ebx
	execute();
 805c683:	e8 48 fa ff ff       	call   805c0d0 <do_cmp_b>
 805c688:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c68b:	8d 43 01             	lea    0x1(%ebx),%eax
 805c68e:	5b                   	pop    %ebx
 805c68f:	c3                   	ret    

0805c690 <cmp_rm2r_b>:
make_instr_helper(rm2r)
 805c690:	53                   	push   %ebx
 805c691:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c694:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c698:	83 c0 01             	add    $0x1,%eax
 805c69b:	50                   	push   %eax
 805c69c:	e8 9f 03 00 00       	call   805ca40 <decode_rm2r_b>
 805c6a1:	89 c3                	mov    %eax,%ebx
	execute();
 805c6a3:	e8 28 fa ff ff       	call   805c0d0 <do_cmp_b>
 805c6a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c6ab:	8d 43 01             	lea    0x1(%ebx),%eax
 805c6ae:	5b                   	pop    %ebx
 805c6af:	c3                   	ret    

0805c6b0 <cmp_si2rm_v>:
#include "cmp-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(cmp_si2rm)
 805c6b0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805c6b7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805c6bb:	b8 10 c4 05 08       	mov    $0x805c410,%eax
 805c6c0:	75 05                	jne    805c6c7 <cmp_si2rm_v+0x17>
 805c6c2:	b8 10 c6 05 08       	mov    $0x805c610,%eax
 805c6c7:	89 54 24 04          	mov    %edx,0x4(%esp)
 805c6cb:	ff e0                	jmp    *%eax
 805c6cd:	8d 76 00             	lea    0x0(%esi),%esi

0805c6d0 <cmp_i2rm_v>:
make_helper_v(cmp_i2rm)
 805c6d0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805c6d7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805c6db:	b8 90 c3 05 08       	mov    $0x805c390,%eax
 805c6e0:	75 05                	jne    805c6e7 <cmp_i2rm_v+0x17>
 805c6e2:	b8 90 c5 05 08       	mov    $0x805c590,%eax
 805c6e7:	89 54 24 04          	mov    %edx,0x4(%esp)
 805c6eb:	ff e0                	jmp    *%eax
 805c6ed:	8d 76 00             	lea    0x0(%esi),%esi

0805c6f0 <cmp_r2rm_v>:
make_helper_v(cmp_r2rm)
 805c6f0:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805c6f7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805c6fb:	b8 d0 c3 05 08       	mov    $0x805c3d0,%eax
 805c700:	75 05                	jne    805c707 <cmp_r2rm_v+0x17>
 805c702:	b8 d0 c5 05 08       	mov    $0x805c5d0,%eax
 805c707:	89 54 24 04          	mov    %edx,0x4(%esp)
 805c70b:	ff e0                	jmp    *%eax
 805c70d:	8d 76 00             	lea    0x0(%esi),%esi

0805c710 <cmp_rm2r_v>:
make_helper_v(cmp_rm2r)
 805c710:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805c717:	8b 54 24 04          	mov    0x4(%esp),%edx
 805c71b:	b8 f0 c3 05 08       	mov    $0x805c3f0,%eax
 805c720:	75 05                	jne    805c727 <cmp_rm2r_v+0x17>
 805c722:	b8 f0 c5 05 08       	mov    $0x805c5f0,%eax
 805c727:	89 54 24 04          	mov    %edx,0x4(%esp)
 805c72b:	ff e0                	jmp    *%eax
 805c72d:	8d 76 00             	lea    0x0(%esi),%esi

0805c730 <cmp_i2a_v>:
make_helper_v(cmp_i2a)
 805c730:	80 3d 04 ae 8f 14 00 	cmpb   $0x0,0x148fae04
 805c737:	8b 54 24 04          	mov    0x4(%esp),%edx
 805c73b:	b8 b0 c3 05 08       	mov    $0x805c3b0,%eax
 805c740:	75 05                	jne    805c747 <cmp_i2a_v+0x17>
 805c742:	b8 b0 c5 05 08       	mov    $0x805c5b0,%eax
 805c747:	89 54 24 04          	mov    %edx,0x4(%esp)
 805c74b:	ff e0                	jmp    *%eax
 805c74d:	66 90                	xchg   %ax,%ax
 805c74f:	90                   	nop

0805c750 <decode_rm_b_internal>:
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
#endif
	return 0;
}

static int concat3(decode_rm_, SUFFIX, _internal) (swaddr_t eip, Operand *rm, Operand *reg) {
 805c750:	56                   	push   %esi
 805c751:	53                   	push   %ebx
 805c752:	89 cb                	mov    %ecx,%ebx
 805c754:	83 ec 08             	sub    $0x8,%esp
	rm->size = DATA_BYTE;
 805c757:	c7 42 04 01 00 00 00 	movl   $0x1,0x4(%edx)
	int len = read_ModR_M(eip, rm, reg);
 805c75e:	51                   	push   %ecx
 805c75f:	52                   	push   %edx
 805c760:	50                   	push   %eax
 805c761:	e8 2a 0f 00 00       	call   805d690 <read_ModR_M>
	reg->val = REG(reg->reg);
 805c766:	8b 53 08             	mov    0x8(%ebx),%edx
 805c769:	83 c4 10             	add    $0x10,%esp
 805c76c:	83 fa 07             	cmp    $0x7,%edx
 805c76f:	77 36                	ja     805c7a7 <decode_rm_b_internal+0x57>
 805c771:	89 c6                	mov    %eax,%esi
 805c773:	89 d1                	mov    %edx,%ecx
 805c775:	89 d0                	mov    %edx,%eax
 805c777:	83 e1 03             	and    $0x3,%ecx
 805c77a:	c1 e8 02             	shr    $0x2,%eax

#ifdef DEBUG
	snprintf(reg->str, OP_STR_SIZE, "%%%s", REG_NAME(reg->reg));
 805c77d:	83 c3 10             	add    $0x10,%ebx
}

static int concat3(decode_rm_, SUFFIX, _internal) (swaddr_t eip, Operand *rm, Operand *reg) {
	rm->size = DATA_BYTE;
	int len = read_ModR_M(eip, rm, reg);
	reg->val = REG(reg->reg);
 805c780:	0f b6 84 88 c0 ae 8f 	movzbl 0x148faec0(%eax,%ecx,4),%eax
 805c787:	14 
 805c788:	89 43 fc             	mov    %eax,-0x4(%ebx)

#ifdef DEBUG
	snprintf(reg->str, OP_STR_SIZE, "%%%s", REG_NAME(reg->reg));
 805c78b:	ff 34 95 80 5b 07 08 	pushl  0x8075b80(,%edx,4)
 805c792:	68 1a 2e 06 08       	push   $0x8062e1a
 805c797:	6a 28                	push   $0x28
 805c799:	53                   	push   %ebx
 805c79a:	e8 61 c3 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return len;
}
 805c79f:	83 c4 14             	add    $0x14,%esp
 805c7a2:	89 f0                	mov    %esi,%eax
 805c7a4:	5b                   	pop    %ebx
 805c7a5:	5e                   	pop    %esi
 805c7a6:	c3                   	ret    
 805c7a7:	e8 5f c4 fe ff       	call   8048c0b <check_reg_index.part.0>
 805c7ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805c7b0 <decode_rm_w_internal>:
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
#endif
	return 0;
}

static int concat3(decode_rm_, SUFFIX, _internal) (swaddr_t eip, Operand *rm, Operand *reg) {
 805c7b0:	56                   	push   %esi
 805c7b1:	53                   	push   %ebx
 805c7b2:	89 cb                	mov    %ecx,%ebx
 805c7b4:	83 ec 08             	sub    $0x8,%esp
	rm->size = DATA_BYTE;
 805c7b7:	c7 42 04 02 00 00 00 	movl   $0x2,0x4(%edx)
	int len = read_ModR_M(eip, rm, reg);
 805c7be:	51                   	push   %ecx
 805c7bf:	52                   	push   %edx
 805c7c0:	50                   	push   %eax
 805c7c1:	e8 ca 0e 00 00       	call   805d690 <read_ModR_M>
	reg->val = REG(reg->reg);
 805c7c6:	8b 53 08             	mov    0x8(%ebx),%edx
 805c7c9:	83 c4 10             	add    $0x10,%esp
 805c7cc:	83 fa 07             	cmp    $0x7,%edx
 805c7cf:	77 2c                	ja     805c7fd <decode_rm_w_internal+0x4d>
 805c7d1:	89 c6                	mov    %eax,%esi
 805c7d3:	0f b7 04 95 c0 ae 8f 	movzwl 0x148faec0(,%edx,4),%eax
 805c7da:	14 

#ifdef DEBUG
	snprintf(reg->str, OP_STR_SIZE, "%%%s", REG_NAME(reg->reg));
 805c7db:	83 c3 10             	add    $0x10,%ebx
}

static int concat3(decode_rm_, SUFFIX, _internal) (swaddr_t eip, Operand *rm, Operand *reg) {
	rm->size = DATA_BYTE;
	int len = read_ModR_M(eip, rm, reg);
	reg->val = REG(reg->reg);
 805c7de:	89 43 fc             	mov    %eax,-0x4(%ebx)

#ifdef DEBUG
	snprintf(reg->str, OP_STR_SIZE, "%%%s", REG_NAME(reg->reg));
 805c7e1:	ff 34 95 a0 5b 07 08 	pushl  0x8075ba0(,%edx,4)
 805c7e8:	68 1a 2e 06 08       	push   $0x8062e1a
 805c7ed:	6a 28                	push   $0x28
 805c7ef:	53                   	push   %ebx
 805c7f0:	e8 0b c3 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return len;
}
 805c7f5:	83 c4 14             	add    $0x14,%esp
 805c7f8:	89 f0                	mov    %esi,%eax
 805c7fa:	5b                   	pop    %ebx
 805c7fb:	5e                   	pop    %esi
 805c7fc:	c3                   	ret    
 805c7fd:	e8 09 c4 fe ff       	call   8048c0b <check_reg_index.part.0>
 805c802:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805c809:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c810 <decode_rm_l_internal>:
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
#endif
	return 0;
}

static int concat3(decode_rm_, SUFFIX, _internal) (swaddr_t eip, Operand *rm, Operand *reg) {
 805c810:	56                   	push   %esi
 805c811:	53                   	push   %ebx
 805c812:	89 cb                	mov    %ecx,%ebx
 805c814:	83 ec 08             	sub    $0x8,%esp
	rm->size = DATA_BYTE;
 805c817:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
	int len = read_ModR_M(eip, rm, reg);
 805c81e:	51                   	push   %ecx
 805c81f:	52                   	push   %edx
 805c820:	50                   	push   %eax
 805c821:	e8 6a 0e 00 00       	call   805d690 <read_ModR_M>
	reg->val = REG(reg->reg);
 805c826:	8b 53 08             	mov    0x8(%ebx),%edx
 805c829:	83 c4 10             	add    $0x10,%esp
 805c82c:	83 fa 07             	cmp    $0x7,%edx
 805c82f:	77 2b                	ja     805c85c <decode_rm_l_internal+0x4c>
 805c831:	89 c6                	mov    %eax,%esi
 805c833:	8b 04 95 c0 ae 8f 14 	mov    0x148faec0(,%edx,4),%eax

#ifdef DEBUG
	snprintf(reg->str, OP_STR_SIZE, "%%%s", REG_NAME(reg->reg));
 805c83a:	83 c3 10             	add    $0x10,%ebx
}

static int concat3(decode_rm_, SUFFIX, _internal) (swaddr_t eip, Operand *rm, Operand *reg) {
	rm->size = DATA_BYTE;
	int len = read_ModR_M(eip, rm, reg);
	reg->val = REG(reg->reg);
 805c83d:	89 43 fc             	mov    %eax,-0x4(%ebx)

#ifdef DEBUG
	snprintf(reg->str, OP_STR_SIZE, "%%%s", REG_NAME(reg->reg));
 805c840:	ff 34 95 c0 5b 07 08 	pushl  0x8075bc0(,%edx,4)
 805c847:	68 1a 2e 06 08       	push   $0x8062e1a
 805c84c:	6a 28                	push   $0x28
 805c84e:	53                   	push   %ebx
 805c84f:	e8 ac c2 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return len;
}
 805c854:	83 c4 14             	add    $0x14,%esp
 805c857:	89 f0                	mov    %esi,%eax
 805c859:	5b                   	pop    %ebx
 805c85a:	5e                   	pop    %esi
 805c85b:	c3                   	ret    
 805c85c:	e8 aa c3 fe ff       	call   8048c0b <check_reg_index.part.0>
 805c861:	eb 0d                	jmp    805c870 <decode_r_b_internal.isra.2>
 805c863:	90                   	nop
 805c864:	90                   	nop
 805c865:	90                   	nop
 805c866:	90                   	nop
 805c867:	90                   	nop
 805c868:	90                   	nop
 805c869:	90                   	nop
 805c86a:	90                   	nop
 805c86b:	90                   	nop
 805c86c:	90                   	nop
 805c86d:	90                   	nop
 805c86e:	90                   	nop
 805c86f:	90                   	nop

0805c870 <decode_r_b_internal.isra.2>:
#endif
	return 0;
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
 805c870:	53                   	push   %ebx
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
	op->val = REG(op->reg);

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
 805c871:	83 c0 10             	add    $0x10,%eax
#endif
	return 0;
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
 805c874:	83 ec 08             	sub    $0x8,%esp
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
 805c877:	8b 15 00 ae 8f 14    	mov    0x148fae00,%edx
	return 0;
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
 805c87d:	c7 40 f0 00 00 00 00 	movl   $0x0,-0x10(%eax)
	op->reg = ops_decoded.opcode & 0x7;
 805c884:	89 d1                	mov    %edx,%ecx
	op->val = REG(op->reg);
 805c886:	83 e2 03             	and    $0x3,%edx
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
 805c889:	83 e1 07             	and    $0x7,%ecx
	op->val = REG(op->reg);
 805c88c:	89 cb                	mov    %ecx,%ebx
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
 805c88e:	89 48 f8             	mov    %ecx,-0x8(%eax)
	op->val = REG(op->reg);
 805c891:	c1 eb 02             	shr    $0x2,%ebx
 805c894:	0f b6 94 93 c0 ae 8f 	movzbl 0x148faec0(%ebx,%edx,4),%edx
 805c89b:	14 
 805c89c:	89 50 fc             	mov    %edx,-0x4(%eax)

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
 805c89f:	ff 34 8d 80 5b 07 08 	pushl  0x8075b80(,%ecx,4)
 805c8a6:	68 1a 2e 06 08       	push   $0x8062e1a
 805c8ab:	6a 28                	push   $0x28
 805c8ad:	50                   	push   %eax
 805c8ae:	e8 4d c2 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return 0;
}
 805c8b3:	83 c4 18             	add    $0x18,%esp
 805c8b6:	31 c0                	xor    %eax,%eax
 805c8b8:	5b                   	pop    %ebx
 805c8b9:	c3                   	ret    
 805c8ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0805c8c0 <decode_r_w_internal.isra.4>:
#endif
	return 0;
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
 805c8c0:	83 ec 0c             	sub    $0xc,%esp
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
 805c8c3:	8b 15 00 ae 8f 14    	mov    0x148fae00,%edx
	return 0;
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
 805c8c9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	op->reg = ops_decoded.opcode & 0x7;
	op->val = REG(op->reg);

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
 805c8cf:	83 c0 10             	add    $0x10,%eax
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
 805c8d2:	83 e2 07             	and    $0x7,%edx
 805c8d5:	89 50 f8             	mov    %edx,-0x8(%eax)
	op->val = REG(op->reg);
 805c8d8:	0f b7 0c 95 c0 ae 8f 	movzwl 0x148faec0(,%edx,4),%ecx
 805c8df:	14 
 805c8e0:	89 48 fc             	mov    %ecx,-0x4(%eax)

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
 805c8e3:	ff 34 95 a0 5b 07 08 	pushl  0x8075ba0(,%edx,4)
 805c8ea:	68 1a 2e 06 08       	push   $0x8062e1a
 805c8ef:	6a 28                	push   $0x28
 805c8f1:	50                   	push   %eax
 805c8f2:	e8 09 c2 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return 0;
}
 805c8f7:	31 c0                	xor    %eax,%eax
 805c8f9:	83 c4 1c             	add    $0x1c,%esp
 805c8fc:	c3                   	ret    
 805c8fd:	8d 76 00             	lea    0x0(%esi),%esi

0805c900 <decode_r_l_internal.isra.6>:
#endif
	return 0;
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
 805c900:	83 ec 0c             	sub    $0xc,%esp
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
 805c903:	8b 15 00 ae 8f 14    	mov    0x148fae00,%edx
	return 0;
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
 805c909:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	op->reg = ops_decoded.opcode & 0x7;
	op->val = REG(op->reg);

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
 805c90f:	83 c0 10             	add    $0x10,%eax
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
 805c912:	83 e2 07             	and    $0x7,%edx
 805c915:	89 50 f8             	mov    %edx,-0x8(%eax)
	op->val = REG(op->reg);
 805c918:	8b 0c 95 c0 ae 8f 14 	mov    0x148faec0(,%edx,4),%ecx
 805c91f:	89 48 fc             	mov    %ecx,-0x4(%eax)

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
 805c922:	ff 34 95 c0 5b 07 08 	pushl  0x8075bc0(,%edx,4)
 805c929:	68 1a 2e 06 08       	push   $0x8062e1a
 805c92e:	6a 28                	push   $0x28
 805c930:	50                   	push   %eax
 805c931:	e8 ca c1 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return 0;
}
 805c936:	31 c0                	xor    %eax,%eax
 805c938:	83 c4 1c             	add    $0x1c,%esp
 805c93b:	c3                   	ret    
 805c93c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805c940 <decode_i_b>:
#define decode_m_internal concat3(decode_m_, SUFFIX, _internal)
#define decode_a concat(decode_a_, SUFFIX)
#define decode_r2rm concat(decode_r2rm_, SUFFIX)

/* Ib, Iv */
make_helper(concat(decode_i_, SUFFIX)) {
 805c940:	83 ec 14             	sub    $0x14,%esp
	/* eip here is pointing to the immediate */
	op_src->type = OP_TYPE_IMM;
 805c943:	c7 05 08 ae 8f 14 02 	movl   $0x2,0x148fae08
 805c94a:	00 00 00 

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 805c94d:	6a 01                	push   $0x1
 805c94f:	ff 74 24 1c          	pushl  0x1c(%esp)
 805c953:	e8 08 e6 fe ff       	call   804af60 <swaddr_read>
	op_src->imm = instr_fetch(eip, DATA_BYTE);
	op_src->val = op_src->imm;

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->imm);
 805c958:	50                   	push   %eax
 805c959:	68 ae 5e 06 08       	push   $0x8065eae
 805c95e:	6a 28                	push   $0x28
 805c960:	68 18 ae 8f 14       	push   $0x148fae18

/* Ib, Iv */
make_helper(concat(decode_i_, SUFFIX)) {
	/* eip here is pointing to the immediate */
	op_src->type = OP_TYPE_IMM;
	op_src->imm = instr_fetch(eip, DATA_BYTE);
 805c965:	a3 10 ae 8f 14       	mov    %eax,0x148fae10
	op_src->val = op_src->imm;
 805c96a:	a3 14 ae 8f 14       	mov    %eax,0x148fae14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->imm);
 805c96f:	e8 8c c1 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805c974:	b8 01 00 00 00       	mov    $0x1,%eax
 805c979:	83 c4 2c             	add    $0x2c,%esp
 805c97c:	c3                   	ret    
 805c97d:	8d 76 00             	lea    0x0(%esi),%esi

0805c980 <decode_si_b>:

#if DATA_BYTE == 1 || DATA_BYTE == 4
/* sign immediate */
make_helper(concat(decode_si_, SUFFIX)) {
 805c980:	83 ec 14             	sub    $0x14,%esp
	op_src->type = OP_TYPE_IMM;
 805c983:	c7 05 08 ae 8f 14 02 	movl   $0x2,0x148fae08
 805c98a:	00 00 00 
 805c98d:	6a 01                	push   $0x1
 805c98f:	ff 74 24 1c          	pushl  0x1c(%esp)
 805c993:	e8 c8 e5 fe ff       	call   804af60 <swaddr_read>
	 * by ``eip''. Interpret the result as an signed immediate, and assign
	 * it to op_src->simm.
	 */
	op_src->simm = instr_fetch(eip, DATA_BYTE);
#if DATA_BYTE == 1
	op_src->simm = op_src->simm << 24 >> 24;
 805c998:	0f be c0             	movsbl %al,%eax
//	panic("please implement me");

	op_src->val = op_src->simm;

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->val);
 805c99b:	50                   	push   %eax
 805c99c:	68 ae 5e 06 08       	push   $0x8065eae
 805c9a1:	6a 28                	push   $0x28
 805c9a3:	68 18 ae 8f 14       	push   $0x148fae18
	 * by ``eip''. Interpret the result as an signed immediate, and assign
	 * it to op_src->simm.
	 */
	op_src->simm = instr_fetch(eip, DATA_BYTE);
#if DATA_BYTE == 1
	op_src->simm = op_src->simm << 24 >> 24;
 805c9a8:	a3 10 ae 8f 14       	mov    %eax,0x148fae10
#endif
//	panic("please implement me");

	op_src->val = op_src->simm;
 805c9ad:	a3 14 ae 8f 14       	mov    %eax,0x148fae14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->val);
 805c9b2:	e8 49 c1 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805c9b7:	b8 01 00 00 00       	mov    $0x1,%eax
 805c9bc:	83 c4 2c             	add    $0x2c,%esp
 805c9bf:	c3                   	ret    

0805c9c0 <decode_m_b_internal>:
#endif
	return len;
}

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
 805c9c0:	83 ec 14             	sub    $0x14,%esp
	op_src->type = OP_TYPE_MEM;
 805c9c3:	c7 05 08 ae 8f 14 01 	movl   $0x1,0x148fae08
 805c9ca:	00 00 00 
 805c9cd:	6a 01                	push   $0x1
 805c9cf:	ff 74 24 1c          	pushl  0x1c(%esp)
 805c9d3:	e8 88 e5 fe ff       	call   804af60 <swaddr_read>
	op_src->addr = instr_fetch(eip, DATA_BYTE);
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805c9d8:	5a                   	pop    %edx
 805c9d9:	59                   	pop    %ecx
 805c9da:	6a 01                	push   $0x1
 805c9dc:	50                   	push   %eax
}

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
	op_src->type = OP_TYPE_MEM;
	op_src->addr = instr_fetch(eip, DATA_BYTE);
 805c9dd:	a3 10 ae 8f 14       	mov    %eax,0x148fae10
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805c9e2:	e8 f9 e4 fe ff       	call   804aee0 <hwaddr_read>

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->addr);
 805c9e7:	ff 35 10 ae 8f 14    	pushl  0x148fae10
 805c9ed:	68 ae 5e 06 08       	push   $0x8065eae
 805c9f2:	6a 28                	push   $0x28
 805c9f4:	68 18 ae 8f 14       	push   $0x148fae18

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
	op_src->type = OP_TYPE_MEM;
	op_src->addr = instr_fetch(eip, DATA_BYTE);
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805c9f9:	a3 14 ae 8f 14       	mov    %eax,0x148fae14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->addr);
 805c9fe:	e8 fd c0 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805ca03:	b8 01 00 00 00       	mov    $0x1,%eax
 805ca08:	83 c4 2c             	add    $0x2c,%esp
 805ca0b:	c3                   	ret    
 805ca0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805ca10 <decode_m_b>:

/* Mb, Mv */
make_helper(concat(decode_m_, SUFFIX)) {
	return decode_m_internal(eip);
 805ca10:	e9 ab ff ff ff       	jmp    805c9c0 <decode_m_b_internal>
 805ca15:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805ca19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805ca20 <decode_r2rm_b>:

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805ca20:	8b 44 24 04          	mov    0x4(%esp),%eax
 805ca24:	b9 08 ae 8f 14       	mov    $0x148fae08,%ecx
 805ca29:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
 805ca2e:	e9 1d fd ff ff       	jmp    805c750 <decode_rm_b_internal>
 805ca33:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805ca39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805ca40 <decode_rm2r_b>:

/* Gb <- Eb
 * Gv <- Ev
 */
make_helper(concat(decode_rm2r_, SUFFIX)) {
	return decode_rm_internal(eip, op_src, op_dest);
 805ca40:	8b 44 24 04          	mov    0x4(%esp),%eax
 805ca44:	b9 40 ae 8f 14       	mov    $0x148fae40,%ecx
 805ca49:	ba 08 ae 8f 14       	mov    $0x148fae08,%edx
 805ca4e:	e9 fd fc ff ff       	jmp    805c750 <decode_rm_b_internal>
 805ca53:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805ca59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805ca60 <decode_i2a_b>:


/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
 805ca60:	53                   	push   %ebx
 805ca61:	83 ec 08             	sub    $0x8,%esp

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
	op->val = REG(R_EAX);
 805ca64:	0f b6 05 c0 ae 8f 14 	movzbl 0x148faec0,%eax
}
#endif

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
 805ca6b:	c7 05 40 ae 8f 14 00 	movl   $0x0,0x148fae40
 805ca72:	00 00 00 


/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
 805ca75:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
	op->val = REG(R_EAX);

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(R_EAX));
 805ca79:	ff 35 80 5b 07 08    	pushl  0x8075b80
 805ca7f:	68 1a 2e 06 08       	push   $0x8062e1a
 805ca84:	6a 28                	push   $0x28
 805ca86:	68 50 ae 8f 14       	push   $0x148fae50
#endif

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
 805ca8b:	c7 05 48 ae 8f 14 00 	movl   $0x0,0x148fae48
 805ca92:	00 00 00 
	op->val = REG(R_EAX);
 805ca95:	a3 4c ae 8f 14       	mov    %eax,0x148fae4c

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(R_EAX));
 805ca9a:	e8 61 c0 fe ff       	call   8048b00 <snprintf@plt>
/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
	decode_a(eip, op_dest);
	return decode_i(eip);
 805ca9f:	89 5c 24 20          	mov    %ebx,0x20(%esp)
}
 805caa3:	83 c4 18             	add    $0x18,%esp
 805caa6:	5b                   	pop    %ebx
/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
	decode_a(eip, op_dest);
	return decode_i(eip);
 805caa7:	e9 94 fe ff ff       	jmp    805c940 <decode_i_b>
 805caac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805cab0 <decode_i_rm2r_b>:
}

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
 805cab0:	56                   	push   %esi
 805cab1:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805cab2:	b9 40 ae 8f 14       	mov    $0x148fae40,%ecx
 805cab7:	ba 78 ae 8f 14       	mov    $0x148fae78,%edx
}

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
 805cabc:	83 ec 04             	sub    $0x4,%esp
 805cabf:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805cac3:	89 f0                	mov    %esi,%eax
 805cac5:	e8 86 fc ff ff       	call   805c750 <decode_rm_b_internal>
	len += decode_i(eip + len);
 805caca:	83 ec 0c             	sub    $0xc,%esp
 805cacd:	01 c6                	add    %eax,%esi

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805cacf:	89 c3                	mov    %eax,%ebx
	len += decode_i(eip + len);
 805cad1:	56                   	push   %esi
 805cad2:	e8 69 fe ff ff       	call   805c940 <decode_i_b>
	return len;
}
 805cad7:	83 c4 14             	add    $0x14,%esp
/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
	len += decode_i(eip + len);
 805cada:	01 d8                	add    %ebx,%eax
	return len;
}
 805cadc:	5b                   	pop    %ebx
 805cadd:	5e                   	pop    %esi
 805cade:	c3                   	ret    
 805cadf:	90                   	nop

0805cae0 <decode_i2rm_b>:

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
 805cae0:	56                   	push   %esi
 805cae1:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805cae2:	b9 78 ae 8f 14       	mov    $0x148fae78,%ecx
 805cae7:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
}

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
 805caec:	83 ec 04             	sub    $0x4,%esp
 805caef:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805caf3:	89 f0                	mov    %esi,%eax
 805caf5:	e8 56 fc ff ff       	call   805c750 <decode_rm_b_internal>
	len += decode_i(eip + len);
 805cafa:	83 ec 0c             	sub    $0xc,%esp
 805cafd:	01 c6                	add    %eax,%esi

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805caff:	89 c3                	mov    %eax,%ebx
	len += decode_i(eip + len);
 805cb01:	56                   	push   %esi
 805cb02:	e8 39 fe ff ff       	call   805c940 <decode_i_b>
	return len;
}
 805cb07:	83 c4 14             	add    $0x14,%esp
/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
	len += decode_i(eip + len);
 805cb0a:	01 d8                	add    %ebx,%eax
	return len;
}
 805cb0c:	5b                   	pop    %ebx
 805cb0d:	5e                   	pop    %esi
 805cb0e:	c3                   	ret    
 805cb0f:	90                   	nop

0805cb10 <decode_i2r_b>:

/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
 805cb10:	53                   	push   %ebx
	decode_r_internal(eip, op_dest);
 805cb11:	b8 40 ae 8f 14       	mov    $0x148fae40,%eax
}

/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
 805cb16:	83 ec 08             	sub    $0x8,%esp
 805cb19:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	decode_r_internal(eip, op_dest);
 805cb1d:	e8 4e fd ff ff       	call   805c870 <decode_r_b_internal.isra.2>
	return decode_i(eip);
 805cb22:	89 5c 24 10          	mov    %ebx,0x10(%esp)
}
 805cb26:	83 c4 08             	add    $0x8,%esp
 805cb29:	5b                   	pop    %ebx
/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
	decode_r_internal(eip, op_dest);
	return decode_i(eip);
 805cb2a:	e9 11 fe ff ff       	jmp    805c940 <decode_i_b>
 805cb2f:	90                   	nop

0805cb30 <decode_rm_b>:
}

/* used by unary operations */
make_helper(concat(decode_rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_src, op_src2);		/* op_src2 not use here */
 805cb30:	8b 44 24 04          	mov    0x4(%esp),%eax
 805cb34:	b9 78 ae 8f 14       	mov    $0x148fae78,%ecx
 805cb39:	ba 08 ae 8f 14       	mov    $0x148fae08,%edx
 805cb3e:	e9 0d fc ff ff       	jmp    805c750 <decode_rm_b_internal>
 805cb43:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805cb49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805cb50 <decode_r_b>:
}

make_helper(concat(decode_r_, SUFFIX)) {
	return decode_r_internal(eip, op_src);
 805cb50:	b8 08 ae 8f 14       	mov    $0x148fae08,%eax
 805cb55:	e9 16 fd ff ff       	jmp    805c870 <decode_r_b_internal.isra.2>
 805cb5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0805cb60 <decode_rm_1_b>:
	return len;
}
#endif

/* used by shift instructions */
make_helper(concat(decode_rm_1_, SUFFIX)) {
 805cb60:	83 ec 0c             	sub    $0xc,%esp

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cb63:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
 805cb68:	b9 08 ae 8f 14       	mov    $0x148fae08,%ecx
 805cb6d:	8b 44 24 10          	mov    0x10(%esp),%eax
 805cb71:	e8 da fb ff ff       	call   805c750 <decode_rm_b_internal>
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_IMM;
	op_src->imm = 1;
	op_src->val = 1;
#ifdef DEBUG
	sprintf(op_src->str, "$1");
 805cb76:	ba 24 31 00 00       	mov    $0x3124,%edx
#endif

/* used by shift instructions */
make_helper(concat(decode_rm_1_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_IMM;
 805cb7b:	c7 05 08 ae 8f 14 02 	movl   $0x2,0x148fae08
 805cb82:	00 00 00 
	op_src->imm = 1;
 805cb85:	c7 05 10 ae 8f 14 01 	movl   $0x1,0x148fae10
 805cb8c:	00 00 00 
	op_src->val = 1;
 805cb8f:	c7 05 14 ae 8f 14 01 	movl   $0x1,0x148fae14
 805cb96:	00 00 00 
#ifdef DEBUG
	sprintf(op_src->str, "$1");
 805cb99:	66 89 15 18 ae 8f 14 	mov    %dx,0x148fae18
 805cba0:	c6 05 1a ae 8f 14 00 	movb   $0x0,0x148fae1a
#endif
	return len;
}
 805cba7:	83 c4 0c             	add    $0xc,%esp
 805cbaa:	c3                   	ret    
 805cbab:	90                   	nop
 805cbac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805cbb0 <decode_rm_cl_b>:

make_helper(concat(decode_rm_cl_, SUFFIX)) {
 805cbb0:	53                   	push   %ebx

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cbb1:	b9 08 ae 8f 14       	mov    $0x148fae08,%ecx
 805cbb6:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
	sprintf(op_src->str, "$1");
#endif
	return len;
}

make_helper(concat(decode_rm_cl_, SUFFIX)) {
 805cbbb:	83 ec 08             	sub    $0x8,%esp

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cbbe:	8b 44 24 10          	mov    0x10(%esp),%eax
 805cbc2:	e8 89 fb ff ff       	call   805c750 <decode_rm_b_internal>
 805cbc7:	89 c3                	mov    %eax,%ebx

make_helper(concat(decode_rm_cl_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_REG;
	op_src->reg = R_CL;
	op_src->val = reg_b(R_CL);
 805cbc9:	0f b6 05 c4 ae 8f 14 	movzbl 0x148faec4,%eax
#ifdef DEBUG
	sprintf(op_src->str, "%%cl");
 805cbd0:	83 ec 08             	sub    $0x8,%esp
 805cbd3:	68 b4 5e 06 08       	push   $0x8065eb4
 805cbd8:	68 18 ae 8f 14       	push   $0x148fae18
	return len;
}

make_helper(concat(decode_rm_cl_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_REG;
 805cbdd:	c7 05 08 ae 8f 14 00 	movl   $0x0,0x148fae08
 805cbe4:	00 00 00 
	op_src->reg = R_CL;
 805cbe7:	c7 05 10 ae 8f 14 01 	movl   $0x1,0x148fae10
 805cbee:	00 00 00 
	op_src->val = reg_b(R_CL);
 805cbf1:	a3 14 ae 8f 14       	mov    %eax,0x148fae14
#ifdef DEBUG
	sprintf(op_src->str, "%%cl");
 805cbf6:	e8 95 bf fe ff       	call   8048b90 <sprintf@plt>
#endif
	return len;
}
 805cbfb:	83 c4 18             	add    $0x18,%esp
 805cbfe:	89 d8                	mov    %ebx,%eax
 805cc00:	5b                   	pop    %ebx
 805cc01:	c3                   	ret    
 805cc02:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805cc09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805cc10 <decode_rm_imm_b>:

make_helper(concat(decode_rm_imm_, SUFFIX)) {
 805cc10:	56                   	push   %esi
 805cc11:	53                   	push   %ebx

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cc12:	b9 08 ae 8f 14       	mov    $0x148fae08,%ecx
 805cc17:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
	sprintf(op_src->str, "%%cl");
#endif
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
 805cc1c:	83 ec 04             	sub    $0x4,%esp
 805cc1f:	8b 74 24 10          	mov    0x10(%esp),%esi

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cc23:	89 f0                	mov    %esi,%eax
 805cc25:	e8 26 fb ff ff       	call   805c750 <decode_rm_b_internal>
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805cc2a:	83 ec 0c             	sub    $0xc,%esp
 805cc2d:	01 c6                	add    %eax,%esi

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cc2f:	89 c3                	mov    %eax,%ebx
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805cc31:	56                   	push   %esi
 805cc32:	e8 09 fd ff ff       	call   805c940 <decode_i_b>
	return len;
}
 805cc37:	83 c4 14             	add    $0x14,%esp
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805cc3a:	01 d8                	add    %ebx,%eax
	return len;
}
 805cc3c:	5b                   	pop    %ebx
 805cc3d:	5e                   	pop    %esi
 805cc3e:	c3                   	ret    
 805cc3f:	90                   	nop

0805cc40 <write_operand_b>:

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
 805cc40:	83 ec 0c             	sub    $0xc,%esp
 805cc43:	8b 44 24 10          	mov    0x10(%esp),%eax
 805cc47:	8b 54 24 14          	mov    0x14(%esp),%edx
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
 805cc4b:	8b 08                	mov    (%eax),%ecx
 805cc4d:	85 c9                	test   %ecx,%ecx
 805cc4f:	75 1f                	jne    805cc70 <write_operand_b+0x30>
 805cc51:	8b 40 08             	mov    0x8(%eax),%eax
 805cc54:	83 f8 07             	cmp    $0x7,%eax
 805cc57:	77 35                	ja     805cc8e <write_operand_b+0x4e>
 805cc59:	89 c1                	mov    %eax,%ecx
 805cc5b:	c1 e8 02             	shr    $0x2,%eax
 805cc5e:	83 e1 03             	and    $0x3,%ecx
 805cc61:	88 94 88 c0 ae 8f 14 	mov    %dl,0x148faec0(%eax,%ecx,4)
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
	else { assert(0); }
}
 805cc68:	83 c4 0c             	add    $0xc,%esp
 805cc6b:	c3                   	ret    
 805cc6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return len;
}

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
 805cc70:	83 f9 01             	cmp    $0x1,%ecx
 805cc73:	75 1e                	jne    805cc93 <write_operand_b+0x53>
 805cc75:	83 ec 04             	sub    $0x4,%esp
 805cc78:	0f b6 d2             	movzbl %dl,%edx
 805cc7b:	52                   	push   %edx
 805cc7c:	ff 70 04             	pushl  0x4(%eax)
 805cc7f:	ff 70 08             	pushl  0x8(%eax)
 805cc82:	e8 29 e3 fe ff       	call   804afb0 <swaddr_write>
 805cc87:	83 c4 10             	add    $0x10,%esp
	else { assert(0); }
}
 805cc8a:	83 c4 0c             	add    $0xc,%esp
 805cc8d:	c3                   	ret    
 805cc8e:	e8 78 bf fe ff       	call   8048c0b <check_reg_index.part.0>
}

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
	else { assert(0); }
 805cc93:	68 02 5f 06 08       	push   $0x8065f02
 805cc98:	68 cd 00 00 00       	push   $0xcd
 805cc9d:	68 bc 5e 06 08       	push   $0x8065ebc
 805cca2:	68 20 ef 05 08       	push   $0x805ef20
 805cca7:	e8 04 bf fe ff       	call   8048bb0 <__assert_fail@plt>
 805ccac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805ccb0 <decode_i_w>:
#define decode_m_internal concat3(decode_m_, SUFFIX, _internal)
#define decode_a concat(decode_a_, SUFFIX)
#define decode_r2rm concat(decode_r2rm_, SUFFIX)

/* Ib, Iv */
make_helper(concat(decode_i_, SUFFIX)) {
 805ccb0:	83 ec 14             	sub    $0x14,%esp
	/* eip here is pointing to the immediate */
	op_src->type = OP_TYPE_IMM;
 805ccb3:	c7 05 08 ae 8f 14 02 	movl   $0x2,0x148fae08
 805ccba:	00 00 00 
 805ccbd:	6a 02                	push   $0x2
 805ccbf:	ff 74 24 1c          	pushl  0x1c(%esp)
 805ccc3:	e8 98 e2 fe ff       	call   804af60 <swaddr_read>
	op_src->imm = instr_fetch(eip, DATA_BYTE);
	op_src->val = op_src->imm;

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->imm);
 805ccc8:	50                   	push   %eax
 805ccc9:	68 ae 5e 06 08       	push   $0x8065eae
 805ccce:	6a 28                	push   $0x28
 805ccd0:	68 18 ae 8f 14       	push   $0x148fae18

/* Ib, Iv */
make_helper(concat(decode_i_, SUFFIX)) {
	/* eip here is pointing to the immediate */
	op_src->type = OP_TYPE_IMM;
	op_src->imm = instr_fetch(eip, DATA_BYTE);
 805ccd5:	a3 10 ae 8f 14       	mov    %eax,0x148fae10
	op_src->val = op_src->imm;
 805ccda:	a3 14 ae 8f 14       	mov    %eax,0x148fae14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->imm);
 805ccdf:	e8 1c be fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805cce4:	b8 02 00 00 00       	mov    $0x2,%eax
 805cce9:	83 c4 2c             	add    $0x2c,%esp
 805ccec:	c3                   	ret    
 805cced:	8d 76 00             	lea    0x0(%esi),%esi

0805ccf0 <decode_m_w_internal>:
#endif
	return len;
}

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
 805ccf0:	83 ec 14             	sub    $0x14,%esp
	op_src->type = OP_TYPE_MEM;
 805ccf3:	c7 05 08 ae 8f 14 01 	movl   $0x1,0x148fae08
 805ccfa:	00 00 00 
 805ccfd:	6a 02                	push   $0x2
 805ccff:	ff 74 24 1c          	pushl  0x1c(%esp)
 805cd03:	e8 58 e2 fe ff       	call   804af60 <swaddr_read>
	op_src->addr = instr_fetch(eip, DATA_BYTE);
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805cd08:	5a                   	pop    %edx
 805cd09:	59                   	pop    %ecx
 805cd0a:	6a 02                	push   $0x2
 805cd0c:	50                   	push   %eax
}

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
	op_src->type = OP_TYPE_MEM;
	op_src->addr = instr_fetch(eip, DATA_BYTE);
 805cd0d:	a3 10 ae 8f 14       	mov    %eax,0x148fae10
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805cd12:	e8 c9 e1 fe ff       	call   804aee0 <hwaddr_read>

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->addr);
 805cd17:	ff 35 10 ae 8f 14    	pushl  0x148fae10
 805cd1d:	68 ae 5e 06 08       	push   $0x8065eae
 805cd22:	6a 28                	push   $0x28
 805cd24:	68 18 ae 8f 14       	push   $0x148fae18

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
	op_src->type = OP_TYPE_MEM;
	op_src->addr = instr_fetch(eip, DATA_BYTE);
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805cd29:	a3 14 ae 8f 14       	mov    %eax,0x148fae14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->addr);
 805cd2e:	e8 cd bd fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805cd33:	b8 02 00 00 00       	mov    $0x2,%eax
 805cd38:	83 c4 2c             	add    $0x2c,%esp
 805cd3b:	c3                   	ret    
 805cd3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805cd40 <decode_m_w>:

/* Mb, Mv */
make_helper(concat(decode_m_, SUFFIX)) {
	return decode_m_internal(eip);
 805cd40:	e9 ab ff ff ff       	jmp    805ccf0 <decode_m_w_internal>
 805cd45:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805cd49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805cd50 <decode_r2rm_w>:

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cd50:	8b 44 24 04          	mov    0x4(%esp),%eax
 805cd54:	b9 08 ae 8f 14       	mov    $0x148fae08,%ecx
 805cd59:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
 805cd5e:	e9 4d fa ff ff       	jmp    805c7b0 <decode_rm_w_internal>
 805cd63:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805cd69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805cd70 <decode_rm2r_w>:

/* Gb <- Eb
 * Gv <- Ev
 */
make_helper(concat(decode_rm2r_, SUFFIX)) {
	return decode_rm_internal(eip, op_src, op_dest);
 805cd70:	8b 44 24 04          	mov    0x4(%esp),%eax
 805cd74:	b9 40 ae 8f 14       	mov    $0x148fae40,%ecx
 805cd79:	ba 08 ae 8f 14       	mov    $0x148fae08,%edx
 805cd7e:	e9 2d fa ff ff       	jmp    805c7b0 <decode_rm_w_internal>
 805cd83:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805cd89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805cd90 <decode_i2a_w>:


/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
 805cd90:	53                   	push   %ebx
 805cd91:	83 ec 08             	sub    $0x8,%esp

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
	op->val = REG(R_EAX);
 805cd94:	0f b7 05 c0 ae 8f 14 	movzwl 0x148faec0,%eax
}
#endif

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
 805cd9b:	c7 05 40 ae 8f 14 00 	movl   $0x0,0x148fae40
 805cda2:	00 00 00 


/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
 805cda5:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
	op->val = REG(R_EAX);

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(R_EAX));
 805cda9:	ff 35 a0 5b 07 08    	pushl  0x8075ba0
 805cdaf:	68 1a 2e 06 08       	push   $0x8062e1a
 805cdb4:	6a 28                	push   $0x28
 805cdb6:	68 50 ae 8f 14       	push   $0x148fae50
#endif

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
 805cdbb:	c7 05 48 ae 8f 14 00 	movl   $0x0,0x148fae48
 805cdc2:	00 00 00 
	op->val = REG(R_EAX);
 805cdc5:	a3 4c ae 8f 14       	mov    %eax,0x148fae4c

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(R_EAX));
 805cdca:	e8 31 bd fe ff       	call   8048b00 <snprintf@plt>
/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
	decode_a(eip, op_dest);
	return decode_i(eip);
 805cdcf:	89 5c 24 20          	mov    %ebx,0x20(%esp)
}
 805cdd3:	83 c4 18             	add    $0x18,%esp
 805cdd6:	5b                   	pop    %ebx
/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
	decode_a(eip, op_dest);
	return decode_i(eip);
 805cdd7:	e9 d4 fe ff ff       	jmp    805ccb0 <decode_i_w>
 805cddc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805cde0 <decode_i_rm2r_w>:
}

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
 805cde0:	56                   	push   %esi
 805cde1:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805cde2:	b9 40 ae 8f 14       	mov    $0x148fae40,%ecx
 805cde7:	ba 78 ae 8f 14       	mov    $0x148fae78,%edx
}

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
 805cdec:	83 ec 04             	sub    $0x4,%esp
 805cdef:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805cdf3:	89 f0                	mov    %esi,%eax
 805cdf5:	e8 b6 f9 ff ff       	call   805c7b0 <decode_rm_w_internal>
	len += decode_i(eip + len);
 805cdfa:	83 ec 0c             	sub    $0xc,%esp
 805cdfd:	01 c6                	add    %eax,%esi

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805cdff:	89 c3                	mov    %eax,%ebx
	len += decode_i(eip + len);
 805ce01:	56                   	push   %esi
 805ce02:	e8 a9 fe ff ff       	call   805ccb0 <decode_i_w>
	return len;
}
 805ce07:	83 c4 14             	add    $0x14,%esp
/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
	len += decode_i(eip + len);
 805ce0a:	01 d8                	add    %ebx,%eax
	return len;
}
 805ce0c:	5b                   	pop    %ebx
 805ce0d:	5e                   	pop    %esi
 805ce0e:	c3                   	ret    
 805ce0f:	90                   	nop

0805ce10 <decode_i2rm_w>:

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
 805ce10:	56                   	push   %esi
 805ce11:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805ce12:	b9 78 ae 8f 14       	mov    $0x148fae78,%ecx
 805ce17:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
}

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
 805ce1c:	83 ec 04             	sub    $0x4,%esp
 805ce1f:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805ce23:	89 f0                	mov    %esi,%eax
 805ce25:	e8 86 f9 ff ff       	call   805c7b0 <decode_rm_w_internal>
	len += decode_i(eip + len);
 805ce2a:	83 ec 0c             	sub    $0xc,%esp
 805ce2d:	01 c6                	add    %eax,%esi

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805ce2f:	89 c3                	mov    %eax,%ebx
	len += decode_i(eip + len);
 805ce31:	56                   	push   %esi
 805ce32:	e8 79 fe ff ff       	call   805ccb0 <decode_i_w>
	return len;
}
 805ce37:	83 c4 14             	add    $0x14,%esp
/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
	len += decode_i(eip + len);
 805ce3a:	01 d8                	add    %ebx,%eax
	return len;
}
 805ce3c:	5b                   	pop    %ebx
 805ce3d:	5e                   	pop    %esi
 805ce3e:	c3                   	ret    
 805ce3f:	90                   	nop

0805ce40 <decode_i2r_w>:

/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
 805ce40:	53                   	push   %ebx
	decode_r_internal(eip, op_dest);
 805ce41:	b8 40 ae 8f 14       	mov    $0x148fae40,%eax
}

/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
 805ce46:	83 ec 08             	sub    $0x8,%esp
 805ce49:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	decode_r_internal(eip, op_dest);
 805ce4d:	e8 6e fa ff ff       	call   805c8c0 <decode_r_w_internal.isra.4>
	return decode_i(eip);
 805ce52:	89 5c 24 10          	mov    %ebx,0x10(%esp)
}
 805ce56:	83 c4 08             	add    $0x8,%esp
 805ce59:	5b                   	pop    %ebx
/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
	decode_r_internal(eip, op_dest);
	return decode_i(eip);
 805ce5a:	e9 51 fe ff ff       	jmp    805ccb0 <decode_i_w>
 805ce5f:	90                   	nop

0805ce60 <decode_rm_w>:
}

/* used by unary operations */
make_helper(concat(decode_rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_src, op_src2);		/* op_src2 not use here */
 805ce60:	8b 44 24 04          	mov    0x4(%esp),%eax
 805ce64:	b9 78 ae 8f 14       	mov    $0x148fae78,%ecx
 805ce69:	ba 08 ae 8f 14       	mov    $0x148fae08,%edx
 805ce6e:	e9 3d f9 ff ff       	jmp    805c7b0 <decode_rm_w_internal>
 805ce73:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805ce79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805ce80 <decode_r_w>:
}

make_helper(concat(decode_r_, SUFFIX)) {
	return decode_r_internal(eip, op_src);
 805ce80:	b8 08 ae 8f 14       	mov    $0x148fae08,%eax
 805ce85:	e9 36 fa ff ff       	jmp    805c8c0 <decode_r_w_internal.isra.4>
 805ce8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0805ce90 <decode_si2rm_w>:
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
 805ce90:	56                   	push   %esi
 805ce91:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
 805ce92:	b9 78 ae 8f 14       	mov    $0x148fae78,%ecx
 805ce97:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
make_helper(concat(decode_r_, SUFFIX)) {
	return decode_r_internal(eip, op_src);
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
 805ce9c:	83 ec 04             	sub    $0x4,%esp
 805ce9f:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
 805cea3:	89 f0                	mov    %esi,%eax
 805cea5:	e8 06 f9 ff ff       	call   805c7b0 <decode_rm_w_internal>
	len += decode_si_b(eip + len);
 805ceaa:	83 ec 0c             	sub    $0xc,%esp
 805cead:	01 c6                	add    %eax,%esi
	return decode_r_internal(eip, op_src);
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
 805ceaf:	89 c3                	mov    %eax,%ebx
	len += decode_si_b(eip + len);
 805ceb1:	56                   	push   %esi
 805ceb2:	e8 c9 fa ff ff       	call   805c980 <decode_si_b>
	return len;
}
 805ceb7:	83 c4 14             	add    $0x14,%esp
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
	len += decode_si_b(eip + len);
 805ceba:	01 d8                	add    %ebx,%eax
	return len;
}
 805cebc:	5b                   	pop    %ebx
 805cebd:	5e                   	pop    %esi
 805cebe:	c3                   	ret    
 805cebf:	90                   	nop

0805cec0 <decode_si_rm2r_w>:

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
 805cec0:	56                   	push   %esi
 805cec1:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805cec2:	b9 40 ae 8f 14       	mov    $0x148fae40,%ecx
 805cec7:	ba 78 ae 8f 14       	mov    $0x148fae78,%edx
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
	len += decode_si_b(eip + len);
	return len;
}

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
 805cecc:	83 ec 04             	sub    $0x4,%esp
 805cecf:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805ced3:	89 f0                	mov    %esi,%eax
 805ced5:	e8 d6 f8 ff ff       	call   805c7b0 <decode_rm_w_internal>
	len += decode_si_b(eip + len);
 805ceda:	83 ec 0c             	sub    $0xc,%esp
 805cedd:	01 c6                	add    %eax,%esi
	len += decode_si_b(eip + len);
	return len;
}

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805cedf:	89 c3                	mov    %eax,%ebx
	len += decode_si_b(eip + len);
 805cee1:	56                   	push   %esi
 805cee2:	e8 99 fa ff ff       	call   805c980 <decode_si_b>
	return len;
}
 805cee7:	83 c4 14             	add    $0x14,%esp
	return len;
}

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
	len += decode_si_b(eip + len);
 805ceea:	01 d8                	add    %ebx,%eax
	return len;
}
 805ceec:	5b                   	pop    %ebx
 805ceed:	5e                   	pop    %esi
 805ceee:	c3                   	ret    
 805ceef:	90                   	nop

0805cef0 <decode_rm_1_w>:
#endif

/* used by shift instructions */
make_helper(concat(decode_rm_1_, SUFFIX)) {
 805cef0:	83 ec 0c             	sub    $0xc,%esp

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cef3:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
 805cef8:	b9 08 ae 8f 14       	mov    $0x148fae08,%ecx
 805cefd:	8b 44 24 10          	mov    0x10(%esp),%eax
 805cf01:	e8 aa f8 ff ff       	call   805c7b0 <decode_rm_w_internal>
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_IMM;
	op_src->imm = 1;
	op_src->val = 1;
#ifdef DEBUG
	sprintf(op_src->str, "$1");
 805cf06:	ba 24 31 00 00       	mov    $0x3124,%edx
#endif

/* used by shift instructions */
make_helper(concat(decode_rm_1_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_IMM;
 805cf0b:	c7 05 08 ae 8f 14 02 	movl   $0x2,0x148fae08
 805cf12:	00 00 00 
	op_src->imm = 1;
 805cf15:	c7 05 10 ae 8f 14 01 	movl   $0x1,0x148fae10
 805cf1c:	00 00 00 
	op_src->val = 1;
 805cf1f:	c7 05 14 ae 8f 14 01 	movl   $0x1,0x148fae14
 805cf26:	00 00 00 
#ifdef DEBUG
	sprintf(op_src->str, "$1");
 805cf29:	66 89 15 18 ae 8f 14 	mov    %dx,0x148fae18
 805cf30:	c6 05 1a ae 8f 14 00 	movb   $0x0,0x148fae1a
#endif
	return len;
}
 805cf37:	83 c4 0c             	add    $0xc,%esp
 805cf3a:	c3                   	ret    
 805cf3b:	90                   	nop
 805cf3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805cf40 <decode_rm_cl_w>:

make_helper(concat(decode_rm_cl_, SUFFIX)) {
 805cf40:	53                   	push   %ebx

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cf41:	b9 08 ae 8f 14       	mov    $0x148fae08,%ecx
 805cf46:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
	sprintf(op_src->str, "$1");
#endif
	return len;
}

make_helper(concat(decode_rm_cl_, SUFFIX)) {
 805cf4b:	83 ec 08             	sub    $0x8,%esp

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cf4e:	8b 44 24 10          	mov    0x10(%esp),%eax
 805cf52:	e8 59 f8 ff ff       	call   805c7b0 <decode_rm_w_internal>
 805cf57:	89 c3                	mov    %eax,%ebx

make_helper(concat(decode_rm_cl_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_REG;
	op_src->reg = R_CL;
	op_src->val = reg_b(R_CL);
 805cf59:	0f b6 05 c4 ae 8f 14 	movzbl 0x148faec4,%eax
#ifdef DEBUG
	sprintf(op_src->str, "%%cl");
 805cf60:	83 ec 08             	sub    $0x8,%esp
 805cf63:	68 b4 5e 06 08       	push   $0x8065eb4
 805cf68:	68 18 ae 8f 14       	push   $0x148fae18
	return len;
}

make_helper(concat(decode_rm_cl_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_REG;
 805cf6d:	c7 05 08 ae 8f 14 00 	movl   $0x0,0x148fae08
 805cf74:	00 00 00 
	op_src->reg = R_CL;
 805cf77:	c7 05 10 ae 8f 14 01 	movl   $0x1,0x148fae10
 805cf7e:	00 00 00 
	op_src->val = reg_b(R_CL);
 805cf81:	a3 14 ae 8f 14       	mov    %eax,0x148fae14
#ifdef DEBUG
	sprintf(op_src->str, "%%cl");
 805cf86:	e8 05 bc fe ff       	call   8048b90 <sprintf@plt>
#endif
	return len;
}
 805cf8b:	83 c4 18             	add    $0x18,%esp
 805cf8e:	89 d8                	mov    %ebx,%eax
 805cf90:	5b                   	pop    %ebx
 805cf91:	c3                   	ret    
 805cf92:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805cf99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805cfa0 <decode_rm_imm_w>:

make_helper(concat(decode_rm_imm_, SUFFIX)) {
 805cfa0:	56                   	push   %esi
 805cfa1:	53                   	push   %ebx

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cfa2:	b9 08 ae 8f 14       	mov    $0x148fae08,%ecx
 805cfa7:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
	sprintf(op_src->str, "%%cl");
#endif
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
 805cfac:	83 ec 04             	sub    $0x4,%esp
 805cfaf:	8b 74 24 10          	mov    0x10(%esp),%esi

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cfb3:	89 f0                	mov    %esi,%eax
 805cfb5:	e8 f6 f7 ff ff       	call   805c7b0 <decode_rm_w_internal>
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805cfba:	83 ec 0c             	sub    $0xc,%esp
 805cfbd:	01 c6                	add    %eax,%esi

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cfbf:	89 c3                	mov    %eax,%ebx
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805cfc1:	56                   	push   %esi
 805cfc2:	e8 79 f9 ff ff       	call   805c940 <decode_i_b>
	return len;
}
 805cfc7:	83 c4 14             	add    $0x14,%esp
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805cfca:	01 d8                	add    %ebx,%eax
	return len;
}
 805cfcc:	5b                   	pop    %ebx
 805cfcd:	5e                   	pop    %esi
 805cfce:	c3                   	ret    
 805cfcf:	90                   	nop

0805cfd0 <write_operand_w>:

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
 805cfd0:	83 ec 0c             	sub    $0xc,%esp
 805cfd3:	8b 44 24 10          	mov    0x10(%esp),%eax
 805cfd7:	8b 54 24 14          	mov    0x14(%esp),%edx
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
 805cfdb:	8b 08                	mov    (%eax),%ecx
 805cfdd:	85 c9                	test   %ecx,%ecx
 805cfdf:	75 17                	jne    805cff8 <write_operand_w+0x28>
 805cfe1:	8b 40 08             	mov    0x8(%eax),%eax
 805cfe4:	83 f8 07             	cmp    $0x7,%eax
 805cfe7:	77 2d                	ja     805d016 <write_operand_w+0x46>
 805cfe9:	66 89 14 85 c0 ae 8f 	mov    %dx,0x148faec0(,%eax,4)
 805cff0:	14 
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
	else { assert(0); }
}
 805cff1:	83 c4 0c             	add    $0xc,%esp
 805cff4:	c3                   	ret    
 805cff5:	8d 76 00             	lea    0x0(%esi),%esi
	return len;
}

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
 805cff8:	83 f9 01             	cmp    $0x1,%ecx
 805cffb:	75 1e                	jne    805d01b <write_operand_w+0x4b>
 805cffd:	83 ec 04             	sub    $0x4,%esp
 805d000:	0f b7 d2             	movzwl %dx,%edx
 805d003:	52                   	push   %edx
 805d004:	ff 70 04             	pushl  0x4(%eax)
 805d007:	ff 70 08             	pushl  0x8(%eax)
 805d00a:	e8 a1 df fe ff       	call   804afb0 <swaddr_write>
 805d00f:	83 c4 10             	add    $0x10,%esp
	else { assert(0); }
}
 805d012:	83 c4 0c             	add    $0xc,%esp
 805d015:	c3                   	ret    
 805d016:	e8 f0 bb fe ff       	call   8048c0b <check_reg_index.part.0>
}

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
	else { assert(0); }
 805d01b:	68 f2 5e 06 08       	push   $0x8065ef2
 805d020:	68 cd 00 00 00       	push   $0xcd
 805d025:	68 bc 5e 06 08       	push   $0x8065ebc
 805d02a:	68 20 ef 05 08       	push   $0x805ef20
 805d02f:	e8 7c bb fe ff       	call   8048bb0 <__assert_fail@plt>
 805d034:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805d03a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805d040 <decode_i_l>:
#define decode_m_internal concat3(decode_m_, SUFFIX, _internal)
#define decode_a concat(decode_a_, SUFFIX)
#define decode_r2rm concat(decode_r2rm_, SUFFIX)

/* Ib, Iv */
make_helper(concat(decode_i_, SUFFIX)) {
 805d040:	83 ec 14             	sub    $0x14,%esp
	/* eip here is pointing to the immediate */
	op_src->type = OP_TYPE_IMM;
 805d043:	c7 05 08 ae 8f 14 02 	movl   $0x2,0x148fae08
 805d04a:	00 00 00 
 805d04d:	6a 04                	push   $0x4
 805d04f:	ff 74 24 1c          	pushl  0x1c(%esp)
 805d053:	e8 08 df fe ff       	call   804af60 <swaddr_read>
	op_src->imm = instr_fetch(eip, DATA_BYTE);
	op_src->val = op_src->imm;

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->imm);
 805d058:	50                   	push   %eax
 805d059:	68 ae 5e 06 08       	push   $0x8065eae
 805d05e:	6a 28                	push   $0x28
 805d060:	68 18 ae 8f 14       	push   $0x148fae18

/* Ib, Iv */
make_helper(concat(decode_i_, SUFFIX)) {
	/* eip here is pointing to the immediate */
	op_src->type = OP_TYPE_IMM;
	op_src->imm = instr_fetch(eip, DATA_BYTE);
 805d065:	a3 10 ae 8f 14       	mov    %eax,0x148fae10
	op_src->val = op_src->imm;
 805d06a:	a3 14 ae 8f 14       	mov    %eax,0x148fae14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->imm);
 805d06f:	e8 8c ba fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805d074:	b8 04 00 00 00       	mov    $0x4,%eax
 805d079:	83 c4 2c             	add    $0x2c,%esp
 805d07c:	c3                   	ret    
 805d07d:	8d 76 00             	lea    0x0(%esi),%esi

0805d080 <decode_si_l>:

#if DATA_BYTE == 1 || DATA_BYTE == 4
/* sign immediate */
make_helper(concat(decode_si_, SUFFIX)) {
 805d080:	83 ec 14             	sub    $0x14,%esp
	op_src->type = OP_TYPE_IMM;
 805d083:	c7 05 08 ae 8f 14 02 	movl   $0x2,0x148fae08
 805d08a:	00 00 00 
 805d08d:	6a 04                	push   $0x4
 805d08f:	ff 74 24 1c          	pushl  0x1c(%esp)
 805d093:	e8 c8 de fe ff       	call   804af60 <swaddr_read>
//	panic("please implement me");

	op_src->val = op_src->simm;

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->val);
 805d098:	50                   	push   %eax
 805d099:	68 ae 5e 06 08       	push   $0x8065eae
 805d09e:	6a 28                	push   $0x28
 805d0a0:	68 18 ae 8f 14       	push   $0x148fae18

	/* TODO: Use instr_fetch() to read ``DATA_BYTE'' bytes of memory pointed 
	 * by ``eip''. Interpret the result as an signed immediate, and assign
	 * it to op_src->simm.
	 */
	op_src->simm = instr_fetch(eip, DATA_BYTE);
 805d0a5:	a3 10 ae 8f 14       	mov    %eax,0x148fae10
#if DATA_BYTE == 1
	op_src->simm = op_src->simm << 24 >> 24;
#endif
//	panic("please implement me");

	op_src->val = op_src->simm;
 805d0aa:	a3 14 ae 8f 14       	mov    %eax,0x148fae14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->val);
 805d0af:	e8 4c ba fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805d0b4:	b8 04 00 00 00       	mov    $0x4,%eax
 805d0b9:	83 c4 2c             	add    $0x2c,%esp
 805d0bc:	c3                   	ret    
 805d0bd:	8d 76 00             	lea    0x0(%esi),%esi

0805d0c0 <decode_m_l_internal>:
#endif
	return len;
}

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
 805d0c0:	83 ec 14             	sub    $0x14,%esp
	op_src->type = OP_TYPE_MEM;
 805d0c3:	c7 05 08 ae 8f 14 01 	movl   $0x1,0x148fae08
 805d0ca:	00 00 00 
 805d0cd:	6a 04                	push   $0x4
 805d0cf:	ff 74 24 1c          	pushl  0x1c(%esp)
 805d0d3:	e8 88 de fe ff       	call   804af60 <swaddr_read>
	op_src->addr = instr_fetch(eip, DATA_BYTE);
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805d0d8:	5a                   	pop    %edx
 805d0d9:	59                   	pop    %ecx
 805d0da:	6a 04                	push   $0x4
 805d0dc:	50                   	push   %eax
}

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
	op_src->type = OP_TYPE_MEM;
	op_src->addr = instr_fetch(eip, DATA_BYTE);
 805d0dd:	a3 10 ae 8f 14       	mov    %eax,0x148fae10
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805d0e2:	e8 f9 dd fe ff       	call   804aee0 <hwaddr_read>

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->addr);
 805d0e7:	ff 35 10 ae 8f 14    	pushl  0x148fae10
 805d0ed:	68 ae 5e 06 08       	push   $0x8065eae
 805d0f2:	6a 28                	push   $0x28
 805d0f4:	68 18 ae 8f 14       	push   $0x148fae18

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
	op_src->type = OP_TYPE_MEM;
	op_src->addr = instr_fetch(eip, DATA_BYTE);
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805d0f9:	a3 14 ae 8f 14       	mov    %eax,0x148fae14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->addr);
 805d0fe:	e8 fd b9 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805d103:	b8 04 00 00 00       	mov    $0x4,%eax
 805d108:	83 c4 2c             	add    $0x2c,%esp
 805d10b:	c3                   	ret    
 805d10c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805d110 <decode_m_l>:

/* Mb, Mv */
make_helper(concat(decode_m_, SUFFIX)) {
	return decode_m_internal(eip);
 805d110:	e9 ab ff ff ff       	jmp    805d0c0 <decode_m_l_internal>
 805d115:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805d119:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805d120 <decode_r2rm_l>:

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805d120:	8b 44 24 04          	mov    0x4(%esp),%eax
 805d124:	b9 08 ae 8f 14       	mov    $0x148fae08,%ecx
 805d129:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
 805d12e:	e9 dd f6 ff ff       	jmp    805c810 <decode_rm_l_internal>
 805d133:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805d139:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805d140 <decode_rm2r_l>:

/* Gb <- Eb
 * Gv <- Ev
 */
make_helper(concat(decode_rm2r_, SUFFIX)) {
	return decode_rm_internal(eip, op_src, op_dest);
 805d140:	8b 44 24 04          	mov    0x4(%esp),%eax
 805d144:	b9 40 ae 8f 14       	mov    $0x148fae40,%ecx
 805d149:	ba 08 ae 8f 14       	mov    $0x148fae08,%edx
 805d14e:	e9 bd f6 ff ff       	jmp    805c810 <decode_rm_l_internal>
 805d153:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805d159:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805d160 <decode_i2a_l>:


/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
 805d160:	53                   	push   %ebx
 805d161:	83 ec 08             	sub    $0x8,%esp

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
	op->val = REG(R_EAX);
 805d164:	a1 c0 ae 8f 14       	mov    0x148faec0,%eax
}
#endif

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
 805d169:	c7 05 40 ae 8f 14 00 	movl   $0x0,0x148fae40
 805d170:	00 00 00 


/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
 805d173:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
	op->val = REG(R_EAX);

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(R_EAX));
 805d177:	ff 35 c0 5b 07 08    	pushl  0x8075bc0
 805d17d:	68 1a 2e 06 08       	push   $0x8062e1a
 805d182:	6a 28                	push   $0x28
 805d184:	68 50 ae 8f 14       	push   $0x148fae50
#endif

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
 805d189:	c7 05 48 ae 8f 14 00 	movl   $0x0,0x148fae48
 805d190:	00 00 00 
	op->val = REG(R_EAX);
 805d193:	a3 4c ae 8f 14       	mov    %eax,0x148fae4c

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(R_EAX));
 805d198:	e8 63 b9 fe ff       	call   8048b00 <snprintf@plt>
/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
	decode_a(eip, op_dest);
	return decode_i(eip);
 805d19d:	89 5c 24 20          	mov    %ebx,0x20(%esp)
}
 805d1a1:	83 c4 18             	add    $0x18,%esp
 805d1a4:	5b                   	pop    %ebx
/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
	decode_a(eip, op_dest);
	return decode_i(eip);
 805d1a5:	e9 96 fe ff ff       	jmp    805d040 <decode_i_l>
 805d1aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0805d1b0 <decode_i_rm2r_l>:
}

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
 805d1b0:	56                   	push   %esi
 805d1b1:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805d1b2:	b9 40 ae 8f 14       	mov    $0x148fae40,%ecx
 805d1b7:	ba 78 ae 8f 14       	mov    $0x148fae78,%edx
}

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
 805d1bc:	83 ec 04             	sub    $0x4,%esp
 805d1bf:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805d1c3:	89 f0                	mov    %esi,%eax
 805d1c5:	e8 46 f6 ff ff       	call   805c810 <decode_rm_l_internal>
	len += decode_i(eip + len);
 805d1ca:	83 ec 0c             	sub    $0xc,%esp
 805d1cd:	01 c6                	add    %eax,%esi

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805d1cf:	89 c3                	mov    %eax,%ebx
	len += decode_i(eip + len);
 805d1d1:	56                   	push   %esi
 805d1d2:	e8 69 fe ff ff       	call   805d040 <decode_i_l>
	return len;
}
 805d1d7:	83 c4 14             	add    $0x14,%esp
/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
	len += decode_i(eip + len);
 805d1da:	01 d8                	add    %ebx,%eax
	return len;
}
 805d1dc:	5b                   	pop    %ebx
 805d1dd:	5e                   	pop    %esi
 805d1de:	c3                   	ret    
 805d1df:	90                   	nop

0805d1e0 <decode_i2rm_l>:

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
 805d1e0:	56                   	push   %esi
 805d1e1:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805d1e2:	b9 78 ae 8f 14       	mov    $0x148fae78,%ecx
 805d1e7:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
}

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
 805d1ec:	83 ec 04             	sub    $0x4,%esp
 805d1ef:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805d1f3:	89 f0                	mov    %esi,%eax
 805d1f5:	e8 16 f6 ff ff       	call   805c810 <decode_rm_l_internal>
	len += decode_i(eip + len);
 805d1fa:	83 ec 0c             	sub    $0xc,%esp
 805d1fd:	01 c6                	add    %eax,%esi

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805d1ff:	89 c3                	mov    %eax,%ebx
	len += decode_i(eip + len);
 805d201:	56                   	push   %esi
 805d202:	e8 39 fe ff ff       	call   805d040 <decode_i_l>
	return len;
}
 805d207:	83 c4 14             	add    $0x14,%esp
/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
	len += decode_i(eip + len);
 805d20a:	01 d8                	add    %ebx,%eax
	return len;
}
 805d20c:	5b                   	pop    %ebx
 805d20d:	5e                   	pop    %esi
 805d20e:	c3                   	ret    
 805d20f:	90                   	nop

0805d210 <decode_i2r_l>:

/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
 805d210:	53                   	push   %ebx
	decode_r_internal(eip, op_dest);
 805d211:	b8 40 ae 8f 14       	mov    $0x148fae40,%eax
}

/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
 805d216:	83 ec 08             	sub    $0x8,%esp
 805d219:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	decode_r_internal(eip, op_dest);
 805d21d:	e8 de f6 ff ff       	call   805c900 <decode_r_l_internal.isra.6>
	return decode_i(eip);
 805d222:	89 5c 24 10          	mov    %ebx,0x10(%esp)
}
 805d226:	83 c4 08             	add    $0x8,%esp
 805d229:	5b                   	pop    %ebx
/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
	decode_r_internal(eip, op_dest);
	return decode_i(eip);
 805d22a:	e9 11 fe ff ff       	jmp    805d040 <decode_i_l>
 805d22f:	90                   	nop

0805d230 <decode_rm_l>:
}

/* used by unary operations */
make_helper(concat(decode_rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_src, op_src2);		/* op_src2 not use here */
 805d230:	8b 44 24 04          	mov    0x4(%esp),%eax
 805d234:	b9 78 ae 8f 14       	mov    $0x148fae78,%ecx
 805d239:	ba 08 ae 8f 14       	mov    $0x148fae08,%edx
 805d23e:	e9 cd f5 ff ff       	jmp    805c810 <decode_rm_l_internal>
 805d243:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805d249:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805d250 <decode_r_l>:
}

make_helper(concat(decode_r_, SUFFIX)) {
	return decode_r_internal(eip, op_src);
 805d250:	b8 08 ae 8f 14       	mov    $0x148fae08,%eax
 805d255:	e9 a6 f6 ff ff       	jmp    805c900 <decode_r_l_internal.isra.6>
 805d25a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0805d260 <decode_si2rm_l>:
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
 805d260:	56                   	push   %esi
 805d261:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
 805d262:	b9 78 ae 8f 14       	mov    $0x148fae78,%ecx
 805d267:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
make_helper(concat(decode_r_, SUFFIX)) {
	return decode_r_internal(eip, op_src);
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
 805d26c:	83 ec 04             	sub    $0x4,%esp
 805d26f:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
 805d273:	89 f0                	mov    %esi,%eax
 805d275:	e8 96 f5 ff ff       	call   805c810 <decode_rm_l_internal>
	len += decode_si_b(eip + len);
 805d27a:	83 ec 0c             	sub    $0xc,%esp
 805d27d:	01 c6                	add    %eax,%esi
	return decode_r_internal(eip, op_src);
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
 805d27f:	89 c3                	mov    %eax,%ebx
	len += decode_si_b(eip + len);
 805d281:	56                   	push   %esi
 805d282:	e8 f9 f6 ff ff       	call   805c980 <decode_si_b>
	return len;
}
 805d287:	83 c4 14             	add    $0x14,%esp
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
	len += decode_si_b(eip + len);
 805d28a:	01 d8                	add    %ebx,%eax
	return len;
}
 805d28c:	5b                   	pop    %ebx
 805d28d:	5e                   	pop    %esi
 805d28e:	c3                   	ret    
 805d28f:	90                   	nop

0805d290 <decode_si_rm2r_l>:

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
 805d290:	56                   	push   %esi
 805d291:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805d292:	b9 40 ae 8f 14       	mov    $0x148fae40,%ecx
 805d297:	ba 78 ae 8f 14       	mov    $0x148fae78,%edx
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
	len += decode_si_b(eip + len);
	return len;
}

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
 805d29c:	83 ec 04             	sub    $0x4,%esp
 805d29f:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805d2a3:	89 f0                	mov    %esi,%eax
 805d2a5:	e8 66 f5 ff ff       	call   805c810 <decode_rm_l_internal>
	len += decode_si_b(eip + len);
 805d2aa:	83 ec 0c             	sub    $0xc,%esp
 805d2ad:	01 c6                	add    %eax,%esi
	len += decode_si_b(eip + len);
	return len;
}

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805d2af:	89 c3                	mov    %eax,%ebx
	len += decode_si_b(eip + len);
 805d2b1:	56                   	push   %esi
 805d2b2:	e8 c9 f6 ff ff       	call   805c980 <decode_si_b>
	return len;
}
 805d2b7:	83 c4 14             	add    $0x14,%esp
	return len;
}

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
	len += decode_si_b(eip + len);
 805d2ba:	01 d8                	add    %ebx,%eax
	return len;
}
 805d2bc:	5b                   	pop    %ebx
 805d2bd:	5e                   	pop    %esi
 805d2be:	c3                   	ret    
 805d2bf:	90                   	nop

0805d2c0 <decode_rm_1_l>:
#endif

/* used by shift instructions */
make_helper(concat(decode_rm_1_, SUFFIX)) {
 805d2c0:	83 ec 0c             	sub    $0xc,%esp

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805d2c3:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
 805d2c8:	b9 08 ae 8f 14       	mov    $0x148fae08,%ecx
 805d2cd:	8b 44 24 10          	mov    0x10(%esp),%eax
 805d2d1:	e8 3a f5 ff ff       	call   805c810 <decode_rm_l_internal>
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_IMM;
	op_src->imm = 1;
	op_src->val = 1;
#ifdef DEBUG
	sprintf(op_src->str, "$1");
 805d2d6:	ba 24 31 00 00       	mov    $0x3124,%edx
#endif

/* used by shift instructions */
make_helper(concat(decode_rm_1_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_IMM;
 805d2db:	c7 05 08 ae 8f 14 02 	movl   $0x2,0x148fae08
 805d2e2:	00 00 00 
	op_src->imm = 1;
 805d2e5:	c7 05 10 ae 8f 14 01 	movl   $0x1,0x148fae10
 805d2ec:	00 00 00 
	op_src->val = 1;
 805d2ef:	c7 05 14 ae 8f 14 01 	movl   $0x1,0x148fae14
 805d2f6:	00 00 00 
#ifdef DEBUG
	sprintf(op_src->str, "$1");
 805d2f9:	66 89 15 18 ae 8f 14 	mov    %dx,0x148fae18
 805d300:	c6 05 1a ae 8f 14 00 	movb   $0x0,0x148fae1a
#endif
	return len;
}
 805d307:	83 c4 0c             	add    $0xc,%esp
 805d30a:	c3                   	ret    
 805d30b:	90                   	nop
 805d30c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805d310 <decode_rm_cl_l>:

make_helper(concat(decode_rm_cl_, SUFFIX)) {
 805d310:	53                   	push   %ebx

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805d311:	b9 08 ae 8f 14       	mov    $0x148fae08,%ecx
 805d316:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
	sprintf(op_src->str, "$1");
#endif
	return len;
}

make_helper(concat(decode_rm_cl_, SUFFIX)) {
 805d31b:	83 ec 08             	sub    $0x8,%esp

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805d31e:	8b 44 24 10          	mov    0x10(%esp),%eax
 805d322:	e8 e9 f4 ff ff       	call   805c810 <decode_rm_l_internal>
 805d327:	89 c3                	mov    %eax,%ebx

make_helper(concat(decode_rm_cl_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_REG;
	op_src->reg = R_CL;
	op_src->val = reg_b(R_CL);
 805d329:	0f b6 05 c4 ae 8f 14 	movzbl 0x148faec4,%eax
#ifdef DEBUG
	sprintf(op_src->str, "%%cl");
 805d330:	83 ec 08             	sub    $0x8,%esp
 805d333:	68 b4 5e 06 08       	push   $0x8065eb4
 805d338:	68 18 ae 8f 14       	push   $0x148fae18
	return len;
}

make_helper(concat(decode_rm_cl_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_REG;
 805d33d:	c7 05 08 ae 8f 14 00 	movl   $0x0,0x148fae08
 805d344:	00 00 00 
	op_src->reg = R_CL;
 805d347:	c7 05 10 ae 8f 14 01 	movl   $0x1,0x148fae10
 805d34e:	00 00 00 
	op_src->val = reg_b(R_CL);
 805d351:	a3 14 ae 8f 14       	mov    %eax,0x148fae14
#ifdef DEBUG
	sprintf(op_src->str, "%%cl");
 805d356:	e8 35 b8 fe ff       	call   8048b90 <sprintf@plt>
#endif
	return len;
}
 805d35b:	83 c4 18             	add    $0x18,%esp
 805d35e:	89 d8                	mov    %ebx,%eax
 805d360:	5b                   	pop    %ebx
 805d361:	c3                   	ret    
 805d362:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805d369:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805d370 <decode_rm_imm_l>:

make_helper(concat(decode_rm_imm_, SUFFIX)) {
 805d370:	56                   	push   %esi
 805d371:	53                   	push   %ebx

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805d372:	b9 08 ae 8f 14       	mov    $0x148fae08,%ecx
 805d377:	ba 40 ae 8f 14       	mov    $0x148fae40,%edx
	sprintf(op_src->str, "%%cl");
#endif
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
 805d37c:	83 ec 04             	sub    $0x4,%esp
 805d37f:	8b 74 24 10          	mov    0x10(%esp),%esi

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805d383:	89 f0                	mov    %esi,%eax
 805d385:	e8 86 f4 ff ff       	call   805c810 <decode_rm_l_internal>
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805d38a:	83 ec 0c             	sub    $0xc,%esp
 805d38d:	01 c6                	add    %eax,%esi

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805d38f:	89 c3                	mov    %eax,%ebx
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805d391:	56                   	push   %esi
 805d392:	e8 a9 f5 ff ff       	call   805c940 <decode_i_b>
	return len;
}
 805d397:	83 c4 14             	add    $0x14,%esp
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805d39a:	01 d8                	add    %ebx,%eax
	return len;
}
 805d39c:	5b                   	pop    %ebx
 805d39d:	5e                   	pop    %esi
 805d39e:	c3                   	ret    
 805d39f:	90                   	nop

0805d3a0 <write_operand_l>:

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
 805d3a0:	83 ec 0c             	sub    $0xc,%esp
 805d3a3:	8b 44 24 10          	mov    0x10(%esp),%eax
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
 805d3a7:	8b 10                	mov    (%eax),%edx
 805d3a9:	85 d2                	test   %edx,%edx
 805d3ab:	75 1b                	jne    805d3c8 <write_operand_l+0x28>
 805d3ad:	8b 40 08             	mov    0x8(%eax),%eax
 805d3b0:	83 f8 07             	cmp    $0x7,%eax
 805d3b3:	77 31                	ja     805d3e6 <write_operand_l+0x46>
 805d3b5:	8b 4c 24 14          	mov    0x14(%esp),%ecx
 805d3b9:	89 0c 85 c0 ae 8f 14 	mov    %ecx,0x148faec0(,%eax,4)
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
	else { assert(0); }
}
 805d3c0:	83 c4 0c             	add    $0xc,%esp
 805d3c3:	c3                   	ret    
 805d3c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return len;
}

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
 805d3c8:	83 fa 01             	cmp    $0x1,%edx
 805d3cb:	75 1e                	jne    805d3eb <write_operand_l+0x4b>
 805d3cd:	83 ec 04             	sub    $0x4,%esp
 805d3d0:	ff 74 24 18          	pushl  0x18(%esp)
 805d3d4:	ff 70 04             	pushl  0x4(%eax)
 805d3d7:	ff 70 08             	pushl  0x8(%eax)
 805d3da:	e8 d1 db fe ff       	call   804afb0 <swaddr_write>
 805d3df:	83 c4 10             	add    $0x10,%esp
	else { assert(0); }
}
 805d3e2:	83 c4 0c             	add    $0xc,%esp
 805d3e5:	c3                   	ret    
 805d3e6:	e8 20 b8 fe ff       	call   8048c0b <check_reg_index.part.0>
}

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
	else { assert(0); }
 805d3eb:	68 e2 5e 06 08       	push   $0x8065ee2
 805d3f0:	68 cd 00 00 00       	push   $0xcd
 805d3f5:	68 bc 5e 06 08       	push   $0x8065ebc
 805d3fa:	68 20 ef 05 08       	push   $0x805ef20
 805d3ff:	e8 ac b7 fe ff       	call   8048bb0 <__assert_fail@plt>
 805d404:	66 90                	xchg   %ax,%ax
 805d406:	66 90                	xchg   %ax,%ax
 805d408:	66 90                	xchg   %ax,%ax
 805d40a:	66 90                	xchg   %ax,%ax
 805d40c:	66 90                	xchg   %ax,%ax
 805d40e:	66 90                	xchg   %ax,%ax

0805d410 <load_addr>:
#include "cpu/decode/modrm.h"
#include "cpu/helper.h"

int load_addr(swaddr_t eip, ModR_M *m, Operand *rm) {
 805d410:	55                   	push   %ebp
 805d411:	57                   	push   %edi
 805d412:	56                   	push   %esi
 805d413:	53                   	push   %ebx
 805d414:	83 ec 3c             	sub    $0x3c,%esp
 805d417:	8b 7c 24 54          	mov    0x54(%esp),%edi
	assert(m->mod != 3);
 805d41b:	0f b6 1f             	movzbl (%edi),%ebx
 805d41e:	89 d8                	mov    %ebx,%eax
 805d420:	83 e0 c0             	and    $0xffffffc0,%eax
 805d423:	3c c0                	cmp    $0xc0,%al
 805d425:	0f 84 4a 02 00 00    	je     805d675 <load_addr+0x265>
	int32_t disp;
	int instr_len, disp_offset, disp_size = 4;
	int base_reg = -1, index_reg = -1, scale = 0;
	swaddr_t addr = 0;

	if(m->R_M == R_ESP) {
 805d42b:	83 e3 07             	and    $0x7,%ebx
 805d42e:	80 fb 04             	cmp    $0x4,%bl
 805d431:	0f 84 f1 01 00 00    	je     805d628 <load_addr+0x218>

		if(s.index != R_ESP) { index_reg = s.index; }
	}
	else {
		/* no SIB */
		base_reg = m->R_M;
 805d437:	0f b6 db             	movzbl %bl,%ebx
int load_addr(swaddr_t eip, ModR_M *m, Operand *rm) {
	assert(m->mod != 3);

	int32_t disp;
	int instr_len, disp_offset, disp_size = 4;
	int base_reg = -1, index_reg = -1, scale = 0;
 805d43a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 805d441:	00 
 805d442:	be ff ff ff ff       	mov    $0xffffffff,%esi
		if(s.index != R_ESP) { index_reg = s.index; }
	}
	else {
		/* no SIB */
		base_reg = m->R_M;
		disp_offset = 1;
 805d447:	bf 01 00 00 00       	mov    $0x1,%edi
	}

	if(m->mod == 0) {
 805d44c:	84 c0                	test   %al,%al
 805d44e:	0f 85 ec 00 00 00    	jne    805d540 <load_addr+0x130>
		if(base_reg == R_EBP) { base_reg = -1; }
 805d454:	83 fb 05             	cmp    $0x5,%ebx
 805d457:	0f 84 bb 01 00 00    	je     805d618 <load_addr+0x208>
		else { disp_size = 0; }
 805d45d:	31 c0                	xor    %eax,%eax
	assert(m->mod != 3);

	int32_t disp;
	int instr_len, disp_offset, disp_size = 4;
	int base_reg = -1, index_reg = -1, scale = 0;
	swaddr_t addr = 0;
 805d45f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 805d466:	00 
		instr_len += disp_size;
		addr += disp;
	}

	if(base_reg != -1) {
		addr += reg_l(base_reg);
 805d467:	8b 14 9d c0 ae 8f 14 	mov    0x148faec0(,%ebx,4),%edx
 805d46e:	01 54 24 08          	add    %edx,0x8(%esp)
 805d472:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}

	if(index_reg != -1) {
 805d478:	83 fe ff             	cmp    $0xffffffff,%esi
 805d47b:	74 13                	je     805d490 <load_addr+0x80>
		addr += reg_l(index_reg) << scale;
 805d47d:	0f b6 4c 24 0c       	movzbl 0xc(%esp),%ecx
 805d482:	8b 14 b5 c0 ae 8f 14 	mov    0x148faec0(,%esi,4),%edx
 805d489:	d3 e2                	shl    %cl,%edx
 805d48b:	01 54 24 08          	add    %edx,0x8(%esp)
 805d48f:	90                   	nop
#ifdef DEBUG
	char disp_buf[16];
	char base_buf[8];
	char index_buf[8];

	if(disp_size != 0) {
 805d490:	85 c0                	test   %eax,%eax
 805d492:	0f 84 20 01 00 00    	je     805d5b8 <load_addr+0x1a8>
		/* has disp */
		sprintf(disp_buf, "%s%#x", (disp < 0 ? "-" : ""), (disp < 0 ? -disp : disp));
 805d498:	89 ea                	mov    %ebp,%edx
 805d49a:	c1 fa 1f             	sar    $0x1f,%edx
 805d49d:	89 d0                	mov    %edx,%eax
 805d49f:	31 e8                	xor    %ebp,%eax
 805d4a1:	29 d0                	sub    %edx,%eax
 805d4a3:	85 ed                	test   %ebp,%ebp
 805d4a5:	ba 26 f4 05 08       	mov    $0x805f426,%edx
 805d4aa:	78 05                	js     805d4b1 <load_addr+0xa1>
 805d4ac:	ba 10 f1 05 08       	mov    $0x805f110,%edx
 805d4b1:	50                   	push   %eax
 805d4b2:	52                   	push   %edx
 805d4b3:	68 4a 5f 06 08       	push   $0x8065f4a
 805d4b8:	8d 6c 24 2c          	lea    0x2c(%esp),%ebp
 805d4bc:	55                   	push   %ebp
 805d4bd:	e8 ce b6 fe ff       	call   8048b90 <sprintf@plt>
 805d4c2:	83 c4 10             	add    $0x10,%esp
	}
	else { disp_buf[0] = '\0'; }

	if(base_reg == -1) { base_buf[0] = '\0'; }
 805d4c5:	83 fb ff             	cmp    $0xffffffff,%ebx
 805d4c8:	0f 85 b2 00 00 00    	jne    805d580 <load_addr+0x170>
	else { 
		sprintf(base_buf, "%%%s", regsl[base_reg]); 
	}

	if(index_reg == -1) { index_buf[0] = '\0'; }
 805d4ce:	83 fe ff             	cmp    $0xffffffff,%esi
		/* has disp */
		sprintf(disp_buf, "%s%#x", (disp < 0 ? "-" : ""), (disp < 0 ? -disp : disp));
	}
	else { disp_buf[0] = '\0'; }

	if(base_reg == -1) { base_buf[0] = '\0'; }
 805d4d1:	c6 44 24 10 00       	movb   $0x0,0x10(%esp)
 805d4d6:	8d 5c 24 10          	lea    0x10(%esp),%ebx
	else { 
		sprintf(base_buf, "%%%s", regsl[base_reg]); 
	}

	if(index_reg == -1) { index_buf[0] = '\0'; }
 805d4da:	0f 84 f0 00 00 00    	je     805d5d0 <load_addr+0x1c0>
	else { 
		sprintf(index_buf, ",%%%s,%d", regsl[index_reg], 1 << scale); 
 805d4e0:	0f b6 4c 24 0c       	movzbl 0xc(%esp),%ecx
 805d4e5:	b8 01 00 00 00       	mov    $0x1,%eax
 805d4ea:	d3 e0                	shl    %cl,%eax
 805d4ec:	50                   	push   %eax
 805d4ed:	ff 34 b5 c0 5b 07 08 	pushl  0x8075bc0(,%esi,4)
 805d4f4:	68 50 5f 06 08       	push   $0x8065f50
 805d4f9:	8d 74 24 24          	lea    0x24(%esp),%esi
 805d4fd:	56                   	push   %esi
 805d4fe:	e8 8d b6 fe ff       	call   8048b90 <sprintf@plt>
 805d503:	83 c4 10             	add    $0x10,%esp

	if(base_reg == -1 && index_reg == -1) {
		sprintf(rm->str, "%s", disp_buf);
	}
	else {
		sprintf(rm->str, "%s(%s%s)", disp_buf, base_buf, index_buf);
 805d506:	83 ec 0c             	sub    $0xc,%esp
 805d509:	56                   	push   %esi
 805d50a:	53                   	push   %ebx
 805d50b:	55                   	push   %ebp
 805d50c:	68 59 5f 06 08       	push   $0x8065f59
 805d511:	8b 44 24 74          	mov    0x74(%esp),%eax
 805d515:	83 c0 10             	add    $0x10,%eax
 805d518:	50                   	push   %eax
 805d519:	e8 72 b6 fe ff       	call   8048b90 <sprintf@plt>
 805d51e:	83 c4 20             	add    $0x20,%esp
	}
#endif

	rm->type = OP_TYPE_MEM;
 805d521:	8b 44 24 58          	mov    0x58(%esp),%eax
	rm->addr = addr;
 805d525:	8b 4c 24 08          	mov    0x8(%esp),%ecx
	else {
		sprintf(rm->str, "%s(%s%s)", disp_buf, base_buf, index_buf);
	}
#endif

	rm->type = OP_TYPE_MEM;
 805d529:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	rm->addr = addr;
 805d52f:	89 48 08             	mov    %ecx,0x8(%eax)

	return instr_len;
}
 805d532:	83 c4 3c             	add    $0x3c,%esp
 805d535:	5b                   	pop    %ebx
 805d536:	89 f8                	mov    %edi,%eax
 805d538:	5e                   	pop    %esi
 805d539:	5f                   	pop    %edi
 805d53a:	5d                   	pop    %ebp
 805d53b:	c3                   	ret    
 805d53c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	if(m->mod == 0) {
		if(base_reg == R_EBP) { base_reg = -1; }
		else { disp_size = 0; }
	}
	else if(m->mod == 1) { disp_size = 1; }
 805d540:	3c 40                	cmp    $0x40,%al
 805d542:	0f 84 a8 00 00 00    	je     805d5f0 <load_addr+0x1e0>
 805d548:	83 ec 08             	sub    $0x8,%esp
 805d54b:	6a 04                	push   $0x4

	instr_len = disp_offset;
	if(disp_size != 0) {
		/* has disp */
		disp = instr_fetch(eip + disp_offset, disp_size);
 805d54d:	8b 44 24 5c          	mov    0x5c(%esp),%eax
 805d551:	01 f8                	add    %edi,%eax
 805d553:	50                   	push   %eax
 805d554:	e8 07 da fe ff       	call   804af60 <swaddr_read>
 805d559:	83 c4 10             	add    $0x10,%esp
 805d55c:	89 c5                	mov    %eax,%ebp
 805d55e:	b8 04 00 00 00       	mov    $0x4,%eax
		if(disp_size == 1) { disp = (int8_t)disp; }

		instr_len += disp_size;
 805d563:	01 c7                	add    %eax,%edi
		addr += disp;
	}

	if(base_reg != -1) {
 805d565:	83 fb ff             	cmp    $0xffffffff,%ebx
		/* has disp */
		disp = instr_fetch(eip + disp_offset, disp_size);
		if(disp_size == 1) { disp = (int8_t)disp; }

		instr_len += disp_size;
		addr += disp;
 805d568:	89 6c 24 08          	mov    %ebp,0x8(%esp)
	}

	if(base_reg != -1) {
 805d56c:	0f 85 f5 fe ff ff    	jne    805d467 <load_addr+0x57>
 805d572:	e9 01 ff ff ff       	jmp    805d478 <load_addr+0x68>
 805d577:	89 f6                	mov    %esi,%esi
 805d579:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	}
	else { disp_buf[0] = '\0'; }

	if(base_reg == -1) { base_buf[0] = '\0'; }
	else { 
		sprintf(base_buf, "%%%s", regsl[base_reg]); 
 805d580:	83 ec 04             	sub    $0x4,%esp
 805d583:	ff 34 9d c0 5b 07 08 	pushl  0x8075bc0(,%ebx,4)
 805d58a:	68 1a 2e 06 08       	push   $0x8062e1a
 805d58f:	8d 5c 24 1c          	lea    0x1c(%esp),%ebx
 805d593:	53                   	push   %ebx
 805d594:	e8 f7 b5 fe ff       	call   8048b90 <sprintf@plt>
	}

	if(index_reg == -1) { index_buf[0] = '\0'; }
 805d599:	83 c4 10             	add    $0x10,%esp
 805d59c:	83 fe ff             	cmp    $0xffffffff,%esi
 805d59f:	0f 85 3b ff ff ff    	jne    805d4e0 <load_addr+0xd0>
 805d5a5:	c6 44 24 18 00       	movb   $0x0,0x18(%esp)
 805d5aa:	8d 74 24 18          	lea    0x18(%esp),%esi
 805d5ae:	e9 53 ff ff ff       	jmp    805d506 <load_addr+0xf6>
 805d5b3:	90                   	nop
 805d5b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	if(disp_size != 0) {
		/* has disp */
		sprintf(disp_buf, "%s%#x", (disp < 0 ? "-" : ""), (disp < 0 ? -disp : disp));
	}
	else { disp_buf[0] = '\0'; }
 805d5b8:	c6 44 24 20 00       	movb   $0x0,0x20(%esp)
 805d5bd:	8d 6c 24 20          	lea    0x20(%esp),%ebp
 805d5c1:	e9 ff fe ff ff       	jmp    805d4c5 <load_addr+0xb5>
 805d5c6:	8d 76 00             	lea    0x0(%esi),%esi
 805d5c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	else { 
		sprintf(index_buf, ",%%%s,%d", regsl[index_reg], 1 << scale); 
	}

	if(base_reg == -1 && index_reg == -1) {
		sprintf(rm->str, "%s", disp_buf);
 805d5d0:	83 ec 08             	sub    $0x8,%esp
 805d5d3:	55                   	push   %ebp
 805d5d4:	8b 44 24 64          	mov    0x64(%esp),%eax
 805d5d8:	83 c0 10             	add    $0x10,%eax
 805d5db:	50                   	push   %eax
 805d5dc:	e8 5f b4 fe ff       	call   8048a40 <strcpy@plt>
 805d5e1:	83 c4 10             	add    $0x10,%esp
 805d5e4:	e9 38 ff ff ff       	jmp    805d521 <load_addr+0x111>
 805d5e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805d5f0:	83 ec 08             	sub    $0x8,%esp
 805d5f3:	6a 01                	push   $0x1
	else if(m->mod == 1) { disp_size = 1; }

	instr_len = disp_offset;
	if(disp_size != 0) {
		/* has disp */
		disp = instr_fetch(eip + disp_offset, disp_size);
 805d5f5:	8b 44 24 5c          	mov    0x5c(%esp),%eax
 805d5f9:	01 f8                	add    %edi,%eax
 805d5fb:	50                   	push   %eax
 805d5fc:	e8 5f d9 fe ff       	call   804af60 <swaddr_read>
		if(disp_size == 1) { disp = (int8_t)disp; }
 805d601:	83 c4 10             	add    $0x10,%esp
 805d604:	0f be e8             	movsbl %al,%ebp

	if(m->mod == 0) {
		if(base_reg == R_EBP) { base_reg = -1; }
		else { disp_size = 0; }
	}
	else if(m->mod == 1) { disp_size = 1; }
 805d607:	b8 01 00 00 00       	mov    $0x1,%eax
 805d60c:	e9 52 ff ff ff       	jmp    805d563 <load_addr+0x153>
 805d611:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		base_reg = m->R_M;
		disp_offset = 1;
	}

	if(m->mod == 0) {
		if(base_reg == R_EBP) { base_reg = -1; }
 805d618:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
 805d61d:	e9 26 ff ff ff       	jmp    805d548 <load_addr+0x138>
 805d622:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805d628:	83 ec 08             	sub    $0x8,%esp
int load_addr(swaddr_t eip, ModR_M *m, Operand *rm) {
	assert(m->mod != 3);

	int32_t disp;
	int instr_len, disp_offset, disp_size = 4;
	int base_reg = -1, index_reg = -1, scale = 0;
 805d62b:	be ff ff ff ff       	mov    $0xffffffff,%esi
 805d630:	6a 01                	push   $0x1
	swaddr_t addr = 0;

	if(m->R_M == R_ESP) {
		SIB s;
		s.val = instr_fetch(eip + 1, 1);
 805d632:	8b 44 24 5c          	mov    0x5c(%esp),%eax
 805d636:	83 c0 01             	add    $0x1,%eax
 805d639:	50                   	push   %eax
 805d63a:	e8 21 d9 fe ff       	call   804af60 <swaddr_read>
		base_reg = s.base;
		disp_offset = 2;
		scale = s.ss;
 805d63f:	89 c2                	mov    %eax,%edx
	swaddr_t addr = 0;

	if(m->R_M == R_ESP) {
		SIB s;
		s.val = instr_fetch(eip + 1, 1);
		base_reg = s.base;
 805d641:	89 c3                	mov    %eax,%ebx
		disp_offset = 2;
		scale = s.ss;
 805d643:	c0 ea 06             	shr    $0x6,%dl
	swaddr_t addr = 0;

	if(m->R_M == R_ESP) {
		SIB s;
		s.val = instr_fetch(eip + 1, 1);
		base_reg = s.base;
 805d646:	83 e3 07             	and    $0x7,%ebx
		disp_offset = 2;
		scale = s.ss;
 805d649:	0f b6 ca             	movzbl %dl,%ecx

		if(s.index != R_ESP) { index_reg = s.index; }
 805d64c:	89 c2                	mov    %eax,%edx
 805d64e:	83 e2 38             	and    $0x38,%edx
	if(m->R_M == R_ESP) {
		SIB s;
		s.val = instr_fetch(eip + 1, 1);
		base_reg = s.base;
		disp_offset = 2;
		scale = s.ss;
 805d651:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)

		if(s.index != R_ESP) { index_reg = s.index; }
 805d655:	83 c4 10             	add    $0x10,%esp
 805d658:	80 fa 20             	cmp    $0x20,%dl
 805d65b:	74 08                	je     805d665 <load_addr+0x255>
 805d65d:	c0 e8 03             	shr    $0x3,%al
 805d660:	89 c6                	mov    %eax,%esi
 805d662:	83 e6 07             	and    $0x7,%esi
 805d665:	0f b6 07             	movzbl (%edi),%eax

	if(m->R_M == R_ESP) {
		SIB s;
		s.val = instr_fetch(eip + 1, 1);
		base_reg = s.base;
		disp_offset = 2;
 805d668:	bf 02 00 00 00       	mov    $0x2,%edi
 805d66d:	83 e0 c0             	and    $0xffffffc0,%eax
 805d670:	e9 d7 fd ff ff       	jmp    805d44c <load_addr+0x3c>
#include "cpu/decode/modrm.h"
#include "cpu/helper.h"

int load_addr(swaddr_t eip, ModR_M *m, Operand *rm) {
	assert(m->mod != 3);
 805d675:	68 7e 5f 06 08       	push   $0x8065f7e
 805d67a:	6a 05                	push   $0x5
 805d67c:	68 22 5f 06 08       	push   $0x8065f22
 805d681:	68 3e 5f 06 08       	push   $0x8065f3e
 805d686:	e8 25 b5 fe ff       	call   8048bb0 <__assert_fail@plt>
 805d68b:	90                   	nop
 805d68c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805d690 <read_ModR_M>:
	rm->addr = addr;

	return instr_len;
}

int read_ModR_M(swaddr_t eip, Operand *rm, Operand *reg) {
 805d690:	57                   	push   %edi
 805d691:	56                   	push   %esi
 805d692:	53                   	push   %ebx
 805d693:	83 ec 18             	sub    $0x18,%esp
 805d696:	8b 7c 24 28          	mov    0x28(%esp),%edi
 805d69a:	8b 74 24 30          	mov    0x30(%esp),%esi
 805d69e:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 805d6a2:	6a 01                	push   $0x1
 805d6a4:	57                   	push   %edi
 805d6a5:	e8 b6 d8 fe ff       	call   804af60 <swaddr_read>
	ModR_M m;
	m.val = instr_fetch(eip, 1);
	reg->type = OP_TYPE_REG;
	reg->reg = m.reg;
 805d6aa:	89 c2                	mov    %eax,%edx
	return instr_len;
}

int read_ModR_M(swaddr_t eip, Operand *rm, Operand *reg) {
	ModR_M m;
	m.val = instr_fetch(eip, 1);
 805d6ac:	88 44 24 1f          	mov    %al,0x1f(%esp)
	reg->type = OP_TYPE_REG;
	reg->reg = m.reg;

	if(m.mod == 3) {
 805d6b0:	83 c4 10             	add    $0x10,%esp

int read_ModR_M(swaddr_t eip, Operand *rm, Operand *reg) {
	ModR_M m;
	m.val = instr_fetch(eip, 1);
	reg->type = OP_TYPE_REG;
	reg->reg = m.reg;
 805d6b3:	c0 ea 03             	shr    $0x3,%dl
}

int read_ModR_M(swaddr_t eip, Operand *rm, Operand *reg) {
	ModR_M m;
	m.val = instr_fetch(eip, 1);
	reg->type = OP_TYPE_REG;
 805d6b6:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	reg->reg = m.reg;
 805d6bc:	83 e2 07             	and    $0x7,%edx
 805d6bf:	89 56 08             	mov    %edx,0x8(%esi)

	if(m.mod == 3) {
 805d6c2:	89 c2                	mov    %eax,%edx
 805d6c4:	83 e2 c0             	and    $0xffffffc0,%edx
 805d6c7:	80 fa c0             	cmp    $0xc0,%dl
 805d6ca:	74 34                	je     805d700 <read_ModR_M+0x70>
		}
#endif
		return 1;
	}
	else {
		int instr_len = load_addr(eip, &m, rm);
 805d6cc:	83 ec 04             	sub    $0x4,%esp
 805d6cf:	53                   	push   %ebx
 805d6d0:	8d 44 24 17          	lea    0x17(%esp),%eax
 805d6d4:	50                   	push   %eax
 805d6d5:	57                   	push   %edi
 805d6d6:	e8 35 fd ff ff       	call   805d410 <load_addr>
 805d6db:	89 c6                	mov    %eax,%esi
		rm->val = swaddr_read(rm->addr, rm->size);
 805d6dd:	58                   	pop    %eax
 805d6de:	5a                   	pop    %edx
 805d6df:	ff 73 04             	pushl  0x4(%ebx)
 805d6e2:	ff 73 08             	pushl  0x8(%ebx)
 805d6e5:	e8 76 d8 fe ff       	call   804af60 <swaddr_read>
		return instr_len;
 805d6ea:	83 c4 10             	add    $0x10,%esp
#endif
		return 1;
	}
	else {
		int instr_len = load_addr(eip, &m, rm);
		rm->val = swaddr_read(rm->addr, rm->size);
 805d6ed:	89 43 0c             	mov    %eax,0xc(%ebx)
		return instr_len;
 805d6f0:	89 f0                	mov    %esi,%eax
	}
}
 805d6f2:	83 c4 10             	add    $0x10,%esp
 805d6f5:	5b                   	pop    %ebx
 805d6f6:	5e                   	pop    %esi
 805d6f7:	5f                   	pop    %edi
 805d6f8:	c3                   	ret    
 805d6f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	reg->reg = m.reg;

	if(m.mod == 3) {
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
		switch(rm->size) {
 805d700:	8b 4b 04             	mov    0x4(%ebx),%ecx
	reg->type = OP_TYPE_REG;
	reg->reg = m.reg;

	if(m.mod == 3) {
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
 805d703:	89 c2                	mov    %eax,%edx
	m.val = instr_fetch(eip, 1);
	reg->type = OP_TYPE_REG;
	reg->reg = m.reg;

	if(m.mod == 3) {
		rm->type = OP_TYPE_REG;
 805d705:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		rm->reg = m.R_M;
 805d70b:	83 e2 07             	and    $0x7,%edx
 805d70e:	89 53 08             	mov    %edx,0x8(%ebx)
		switch(rm->size) {
 805d711:	83 f9 02             	cmp    $0x2,%ecx
 805d714:	0f 84 86 00 00 00    	je     805d7a0 <read_ModR_M+0x110>
 805d71a:	83 f9 04             	cmp    $0x4,%ecx
 805d71d:	74 61                	je     805d780 <read_ModR_M+0xf0>
 805d71f:	83 f9 01             	cmp    $0x1,%ecx
 805d722:	74 1c                	je     805d740 <read_ModR_M+0xb0>
			case 1: rm->val = reg_b(m.R_M); break;
			case 2: rm->val = reg_w(m.R_M); break;
			case 4: rm->val = reg_l(m.R_M); break;
			default: assert(0);
 805d724:	68 62 5f 06 08       	push   $0x8065f62
 805d729:	6a 63                	push   $0x63
 805d72b:	68 22 5f 06 08       	push   $0x8065f22
 805d730:	68 20 ef 05 08       	push   $0x805ef20
 805d735:	e8 76 b4 fe ff       	call   8048bb0 <__assert_fail@plt>
 805d73a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	if(m.mod == 3) {
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
		switch(rm->size) {
			case 1: rm->val = reg_b(m.R_M); break;
 805d740:	89 d1                	mov    %edx,%ecx
 805d742:	83 e0 03             	and    $0x3,%eax
			case 4: rm->val = reg_l(m.R_M); break;
			default: assert(0);
		}
#ifdef DEBUG
		switch(rm->size) {
			case 1: sprintf(rm->str, "%%%s", regsb[m.R_M]); break;
 805d745:	83 ec 04             	sub    $0x4,%esp

	if(m.mod == 3) {
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
		switch(rm->size) {
			case 1: rm->val = reg_b(m.R_M); break;
 805d748:	c1 f9 02             	sar    $0x2,%ecx
 805d74b:	0f b6 84 81 c0 ae 8f 	movzbl 0x148faec0(%ecx,%eax,4),%eax
 805d752:	14 
 805d753:	89 43 0c             	mov    %eax,0xc(%ebx)
			case 4: rm->val = reg_l(m.R_M); break;
			default: assert(0);
		}
#ifdef DEBUG
		switch(rm->size) {
			case 1: sprintf(rm->str, "%%%s", regsb[m.R_M]); break;
 805d756:	ff 34 95 80 5b 07 08 	pushl  0x8075b80(,%edx,4)
			case 2: sprintf(rm->str, "%%%s", regsw[m.R_M]); break;
			case 4: sprintf(rm->str, "%%%s", regsl[m.R_M]); break;
 805d75d:	83 c3 10             	add    $0x10,%ebx
 805d760:	68 1a 2e 06 08       	push   $0x8062e1a
 805d765:	53                   	push   %ebx
 805d766:	e8 25 b4 fe ff       	call   8048b90 <sprintf@plt>
 805d76b:	83 c4 10             	add    $0x10,%esp
		}
#endif
		return 1;
 805d76e:	b8 01 00 00 00       	mov    $0x1,%eax
	else {
		int instr_len = load_addr(eip, &m, rm);
		rm->val = swaddr_read(rm->addr, rm->size);
		return instr_len;
	}
}
 805d773:	83 c4 10             	add    $0x10,%esp
 805d776:	5b                   	pop    %ebx
 805d777:	5e                   	pop    %esi
 805d778:	5f                   	pop    %edi
 805d779:	c3                   	ret    
 805d77a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
		switch(rm->size) {
			case 1: rm->val = reg_b(m.R_M); break;
			case 2: rm->val = reg_w(m.R_M); break;
			case 4: rm->val = reg_l(m.R_M); break;
 805d780:	8b 04 95 c0 ae 8f 14 	mov    0x148faec0(,%edx,4),%eax
		}
#ifdef DEBUG
		switch(rm->size) {
			case 1: sprintf(rm->str, "%%%s", regsb[m.R_M]); break;
			case 2: sprintf(rm->str, "%%%s", regsw[m.R_M]); break;
			case 4: sprintf(rm->str, "%%%s", regsl[m.R_M]); break;
 805d787:	83 ec 04             	sub    $0x4,%esp
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
		switch(rm->size) {
			case 1: rm->val = reg_b(m.R_M); break;
			case 2: rm->val = reg_w(m.R_M); break;
			case 4: rm->val = reg_l(m.R_M); break;
 805d78a:	89 43 0c             	mov    %eax,0xc(%ebx)
		}
#ifdef DEBUG
		switch(rm->size) {
			case 1: sprintf(rm->str, "%%%s", regsb[m.R_M]); break;
			case 2: sprintf(rm->str, "%%%s", regsw[m.R_M]); break;
			case 4: sprintf(rm->str, "%%%s", regsl[m.R_M]); break;
 805d78d:	ff 34 95 c0 5b 07 08 	pushl  0x8075bc0(,%edx,4)
 805d794:	eb c7                	jmp    805d75d <read_ModR_M+0xcd>
 805d796:	8d 76 00             	lea    0x0(%esi),%esi
 805d799:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	if(m.mod == 3) {
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
		switch(rm->size) {
			case 1: rm->val = reg_b(m.R_M); break;
			case 2: rm->val = reg_w(m.R_M); break;
 805d7a0:	0f b7 04 95 c0 ae 8f 	movzwl 0x148faec0(,%edx,4),%eax
 805d7a7:	14 
			default: assert(0);
		}
#ifdef DEBUG
		switch(rm->size) {
			case 1: sprintf(rm->str, "%%%s", regsb[m.R_M]); break;
			case 2: sprintf(rm->str, "%%%s", regsw[m.R_M]); break;
 805d7a8:	83 ec 04             	sub    $0x4,%esp
	if(m.mod == 3) {
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
		switch(rm->size) {
			case 1: rm->val = reg_b(m.R_M); break;
			case 2: rm->val = reg_w(m.R_M); break;
 805d7ab:	89 43 0c             	mov    %eax,0xc(%ebx)
			default: assert(0);
		}
#ifdef DEBUG
		switch(rm->size) {
			case 1: sprintf(rm->str, "%%%s", regsb[m.R_M]); break;
			case 2: sprintf(rm->str, "%%%s", regsw[m.R_M]); break;
 805d7ae:	ff 34 95 a0 5b 07 08 	pushl  0x8075ba0(,%edx,4)
 805d7b5:	eb a6                	jmp    805d75d <read_ModR_M+0xcd>
 805d7b7:	66 90                	xchg   %ax,%ax
 805d7b9:	66 90                	xchg   %ax,%ax
 805d7bb:	66 90                	xchg   %ax,%ax
 805d7bd:	66 90                	xchg   %ax,%ax
 805d7bf:	90                   	nop

0805d7c0 <reg_test>:

const char *regsl[] = {"eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"};
const char *regsw[] = {"ax", "cx", "dx", "bx", "sp", "bp", "si", "di"};
const char *regsb[] = {"al", "cl", "dl", "bl", "ah", "ch", "dh", "bh"};

void reg_test() {
 805d7c0:	55                   	push   %ebp
 805d7c1:	57                   	push   %edi
 805d7c2:	56                   	push   %esi
 805d7c3:	53                   	push   %ebx
	uint32_t sample[8];
	uint32_t eip_sample = rand();
	cpu.eip = eip_sample;

	int i;
	for(i = R_EAX; i <= R_EDI; i ++) {
 805d7c4:	31 db                	xor    %ebx,%ebx

const char *regsl[] = {"eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"};
const char *regsw[] = {"ax", "cx", "dx", "bx", "sp", "bp", "si", "di"};
const char *regsb[] = {"al", "cl", "dl", "bl", "ah", "ch", "dh", "bh"};

void reg_test() {
 805d7c6:	83 ec 38             	sub    $0x38,%esp
	srand(time(0));
 805d7c9:	6a 00                	push   $0x0
 805d7cb:	e8 f0 b1 fe ff       	call   80489c0 <time@plt>
 805d7d0:	89 04 24             	mov    %eax,(%esp)
 805d7d3:	e8 b8 b2 fe ff       	call   8048a90 <srand@plt>
	uint32_t sample[8];
	uint32_t eip_sample = rand();
 805d7d8:	e8 73 b3 fe ff       	call   8048b50 <rand@plt>
	cpu.eip = eip_sample;
 805d7dd:	83 c4 10             	add    $0x10,%esp
const char *regsb[] = {"al", "cl", "dl", "bl", "ah", "ch", "dh", "bh"};

void reg_test() {
	srand(time(0));
	uint32_t sample[8];
	uint32_t eip_sample = rand();
 805d7e0:	89 c6                	mov    %eax,%esi
	cpu.eip = eip_sample;
 805d7e2:	a3 e0 ae 8f 14       	mov    %eax,0x148faee0

	int i;
	for(i = R_EAX; i <= R_EDI; i ++) {
		sample[i] = rand();
 805d7e7:	e8 64 b3 fe ff       	call   8048b50 <rand@plt>
 805d7ec:	89 04 9c             	mov    %eax,(%esp,%ebx,4)
		reg_l(i) = sample[i];
 805d7ef:	89 04 9d c0 ae 8f 14 	mov    %eax,0x148faec0(,%ebx,4)
	uint32_t sample[8];
	uint32_t eip_sample = rand();
	cpu.eip = eip_sample;

	int i;
	for(i = R_EAX; i <= R_EDI; i ++) {
 805d7f6:	83 c3 01             	add    $0x1,%ebx
 805d7f9:	83 fb 08             	cmp    $0x8,%ebx
 805d7fc:	75 e9                	jne    805d7e7 <reg_test+0x27>
		sample[i] = rand();
		reg_l(i) = sample[i];
		assert(reg_w(i) == (sample[i] & 0xffff));
	}

	assert(reg_b(R_AL) == (sample[R_EAX] & 0xff));
 805d7fe:	8b 14 24             	mov    (%esp),%edx
 805d801:	38 15 c0 ae 8f 14    	cmp    %dl,0x148faec0
 805d807:	0f 85 f8 00 00 00    	jne    805d905 <reg_test+0x145>
	assert(reg_b(R_AH) == ((sample[R_EAX] >> 8) & 0xff));
 805d80d:	89 d0                	mov    %edx,%eax
 805d80f:	c1 e8 08             	shr    $0x8,%eax
 805d812:	3a 05 c1 ae 8f 14    	cmp    0x148faec1,%al
 805d818:	0f 85 fd 00 00 00    	jne    805d91b <reg_test+0x15b>
	assert(reg_b(R_BL) == (sample[R_EBX] & 0xff));
 805d81e:	8b 44 24 0c          	mov    0xc(%esp),%eax
 805d822:	38 05 cc ae 8f 14    	cmp    %al,0x148faecc
 805d828:	0f 85 03 01 00 00    	jne    805d931 <reg_test+0x171>
	assert(reg_b(R_BH) == ((sample[R_EBX] >> 8) & 0xff));
 805d82e:	89 c1                	mov    %eax,%ecx
 805d830:	c1 e9 08             	shr    $0x8,%ecx
 805d833:	3a 0d cd ae 8f 14    	cmp    0x148faecd,%cl
 805d839:	0f 85 08 01 00 00    	jne    805d947 <reg_test+0x187>
	assert(reg_b(R_CL) == (sample[R_ECX] & 0xff));
 805d83f:	8b 5c 24 04          	mov    0x4(%esp),%ebx
 805d843:	38 1d c4 ae 8f 14    	cmp    %bl,0x148faec4
 805d849:	0f 85 0e 01 00 00    	jne    805d95d <reg_test+0x19d>
	assert(reg_b(R_CH) == ((sample[R_ECX] >> 8) & 0xff));
 805d84f:	89 d9                	mov    %ebx,%ecx
 805d851:	c1 e9 08             	shr    $0x8,%ecx
 805d854:	3a 0d c5 ae 8f 14    	cmp    0x148faec5,%cl
 805d85a:	0f 85 13 01 00 00    	jne    805d973 <reg_test+0x1b3>
	assert(reg_b(R_DL) == (sample[R_EDX] & 0xff));
 805d860:	8b 6c 24 08          	mov    0x8(%esp),%ebp
 805d864:	89 e9                	mov    %ebp,%ecx
 805d866:	38 0d c8 ae 8f 14    	cmp    %cl,0x148faec8
 805d86c:	0f 85 17 01 00 00    	jne    805d989 <reg_test+0x1c9>
	assert(reg_b(R_DH) == ((sample[R_EDX] >> 8) & 0xff));
 805d872:	89 ef                	mov    %ebp,%edi
 805d874:	c1 ef 08             	shr    $0x8,%edi
 805d877:	89 f9                	mov    %edi,%ecx
 805d879:	3a 0d c9 ae 8f 14    	cmp    0x148faec9,%cl
 805d87f:	0f 85 1a 01 00 00    	jne    805d99f <reg_test+0x1df>

	assert(sample[R_EAX] == cpu.eax);
 805d885:	3b 15 c0 ae 8f 14    	cmp    0x148faec0,%edx
 805d88b:	0f 85 24 01 00 00    	jne    805d9b5 <reg_test+0x1f5>
	assert(sample[R_ECX] == cpu.ecx);
 805d891:	3b 1d c4 ae 8f 14    	cmp    0x148faec4,%ebx
 805d897:	0f 85 2e 01 00 00    	jne    805d9cb <reg_test+0x20b>
	assert(sample[R_EDX] == cpu.edx);
 805d89d:	3b 2d c8 ae 8f 14    	cmp    0x148faec8,%ebp
 805d8a3:	0f 85 38 01 00 00    	jne    805d9e1 <reg_test+0x221>
	assert(sample[R_EBX] == cpu.ebx);
 805d8a9:	3b 05 cc ae 8f 14    	cmp    0x148faecc,%eax
 805d8af:	0f 85 42 01 00 00    	jne    805d9f7 <reg_test+0x237>
	assert(sample[R_ESP] == cpu.esp);
 805d8b5:	a1 d0 ae 8f 14       	mov    0x148faed0,%eax
 805d8ba:	39 44 24 10          	cmp    %eax,0x10(%esp)
 805d8be:	0f 85 49 01 00 00    	jne    805da0d <reg_test+0x24d>
	assert(sample[R_EBP] == cpu.ebp);
 805d8c4:	a1 d4 ae 8f 14       	mov    0x148faed4,%eax
 805d8c9:	39 44 24 14          	cmp    %eax,0x14(%esp)
 805d8cd:	0f 85 50 01 00 00    	jne    805da23 <reg_test+0x263>
	assert(sample[R_ESI] == cpu.esi);
 805d8d3:	a1 d8 ae 8f 14       	mov    0x148faed8,%eax
 805d8d8:	39 44 24 18          	cmp    %eax,0x18(%esp)
 805d8dc:	0f 85 57 01 00 00    	jne    805da39 <reg_test+0x279>
	assert(sample[R_EDI] == cpu.edi);
 805d8e2:	a1 dc ae 8f 14       	mov    0x148faedc,%eax
 805d8e7:	39 44 24 1c          	cmp    %eax,0x1c(%esp)
 805d8eb:	0f 85 5e 01 00 00    	jne    805da4f <reg_test+0x28f>

	assert(eip_sample == cpu.eip);
 805d8f1:	39 35 e0 ae 8f 14    	cmp    %esi,0x148faee0
 805d8f7:	0f 85 68 01 00 00    	jne    805da65 <reg_test+0x2a5>
}
 805d8fd:	83 c4 2c             	add    $0x2c,%esp
 805d900:	5b                   	pop    %ebx
 805d901:	5e                   	pop    %esi
 805d902:	5f                   	pop    %edi
 805d903:	5d                   	pop    %ebp
 805d904:	c3                   	ret    
		sample[i] = rand();
		reg_l(i) = sample[i];
		assert(reg_w(i) == (sample[i] & 0xffff));
	}

	assert(reg_b(R_AL) == (sample[R_EAX] & 0xff));
 805d905:	68 6a 63 06 08       	push   $0x806636a
 805d90a:	6a 18                	push   $0x18
 805d90c:	68 88 5f 06 08       	push   $0x8065f88
 805d911:	68 cc 60 06 08       	push   $0x80660cc
 805d916:	e8 95 b2 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(reg_b(R_AH) == ((sample[R_EAX] >> 8) & 0xff));
 805d91b:	68 6a 63 06 08       	push   $0x806636a
 805d920:	6a 19                	push   $0x19
 805d922:	68 88 5f 06 08       	push   $0x8065f88
 805d927:	68 1c 61 06 08       	push   $0x806611c
 805d92c:	e8 7f b2 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(reg_b(R_BL) == (sample[R_EBX] & 0xff));
 805d931:	68 6a 63 06 08       	push   $0x806636a
 805d936:	6a 1a                	push   $0x1a
 805d938:	68 88 5f 06 08       	push   $0x8065f88
 805d93d:	68 74 61 06 08       	push   $0x8066174
 805d942:	e8 69 b2 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(reg_b(R_BH) == ((sample[R_EBX] >> 8) & 0xff));
 805d947:	68 6a 63 06 08       	push   $0x806636a
 805d94c:	6a 1b                	push   $0x1b
 805d94e:	68 88 5f 06 08       	push   $0x8065f88
 805d953:	68 c4 61 06 08       	push   $0x80661c4
 805d958:	e8 53 b2 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(reg_b(R_CL) == (sample[R_ECX] & 0xff));
 805d95d:	68 6a 63 06 08       	push   $0x806636a
 805d962:	6a 1c                	push   $0x1c
 805d964:	68 88 5f 06 08       	push   $0x8065f88
 805d969:	68 1c 62 06 08       	push   $0x806621c
 805d96e:	e8 3d b2 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(reg_b(R_CH) == ((sample[R_ECX] >> 8) & 0xff));
 805d973:	68 6a 63 06 08       	push   $0x806636a
 805d978:	6a 1d                	push   $0x1d
 805d97a:	68 88 5f 06 08       	push   $0x8065f88
 805d97f:	68 6c 62 06 08       	push   $0x806626c
 805d984:	e8 27 b2 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(reg_b(R_DL) == (sample[R_EDX] & 0xff));
 805d989:	68 6a 63 06 08       	push   $0x806636a
 805d98e:	6a 1e                	push   $0x1e
 805d990:	68 88 5f 06 08       	push   $0x8065f88
 805d995:	68 c4 62 06 08       	push   $0x80662c4
 805d99a:	e8 11 b2 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(reg_b(R_DH) == ((sample[R_EDX] >> 8) & 0xff));
 805d99f:	68 6a 63 06 08       	push   $0x806636a
 805d9a4:	6a 1f                	push   $0x1f
 805d9a6:	68 88 5f 06 08       	push   $0x8065f88
 805d9ab:	68 14 63 06 08       	push   $0x8066314
 805d9b0:	e8 fb b1 fe ff       	call   8048bb0 <__assert_fail@plt>

	assert(sample[R_EAX] == cpu.eax);
 805d9b5:	68 6a 63 06 08       	push   $0x806636a
 805d9ba:	6a 21                	push   $0x21
 805d9bc:	68 88 5f 06 08       	push   $0x8065f88
 805d9c1:	68 9b 5f 06 08       	push   $0x8065f9b
 805d9c6:	e8 e5 b1 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(sample[R_ECX] == cpu.ecx);
 805d9cb:	68 6a 63 06 08       	push   $0x806636a
 805d9d0:	6a 22                	push   $0x22
 805d9d2:	68 88 5f 06 08       	push   $0x8065f88
 805d9d7:	68 b4 5f 06 08       	push   $0x8065fb4
 805d9dc:	e8 cf b1 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(sample[R_EDX] == cpu.edx);
 805d9e1:	68 6a 63 06 08       	push   $0x806636a
 805d9e6:	6a 23                	push   $0x23
 805d9e8:	68 88 5f 06 08       	push   $0x8065f88
 805d9ed:	68 cd 5f 06 08       	push   $0x8065fcd
 805d9f2:	e8 b9 b1 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(sample[R_EBX] == cpu.ebx);
 805d9f7:	68 6a 63 06 08       	push   $0x806636a
 805d9fc:	6a 24                	push   $0x24
 805d9fe:	68 88 5f 06 08       	push   $0x8065f88
 805da03:	68 e6 5f 06 08       	push   $0x8065fe6
 805da08:	e8 a3 b1 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(sample[R_ESP] == cpu.esp);
 805da0d:	68 6a 63 06 08       	push   $0x806636a
 805da12:	6a 25                	push   $0x25
 805da14:	68 88 5f 06 08       	push   $0x8065f88
 805da19:	68 ff 5f 06 08       	push   $0x8065fff
 805da1e:	e8 8d b1 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(sample[R_EBP] == cpu.ebp);
 805da23:	68 6a 63 06 08       	push   $0x806636a
 805da28:	6a 26                	push   $0x26
 805da2a:	68 88 5f 06 08       	push   $0x8065f88
 805da2f:	68 18 60 06 08       	push   $0x8066018
 805da34:	e8 77 b1 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(sample[R_ESI] == cpu.esi);
 805da39:	68 6a 63 06 08       	push   $0x806636a
 805da3e:	6a 27                	push   $0x27
 805da40:	68 88 5f 06 08       	push   $0x8065f88
 805da45:	68 31 60 06 08       	push   $0x8066031
 805da4a:	e8 61 b1 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(sample[R_EDI] == cpu.edi);
 805da4f:	68 6a 63 06 08       	push   $0x806636a
 805da54:	6a 28                	push   $0x28
 805da56:	68 88 5f 06 08       	push   $0x8065f88
 805da5b:	68 4a 60 06 08       	push   $0x806604a
 805da60:	e8 4b b1 fe ff       	call   8048bb0 <__assert_fail@plt>

	assert(eip_sample == cpu.eip);
 805da65:	68 6a 63 06 08       	push   $0x806636a
 805da6a:	6a 2a                	push   $0x2a
 805da6c:	68 88 5f 06 08       	push   $0x8065f88
 805da71:	68 63 60 06 08       	push   $0x8066063
 805da76:	e8 35 b1 fe ff       	call   8048bb0 <__assert_fail@plt>
 805da7b:	66 90                	xchg   %ax,%ax
 805da7d:	66 90                	xchg   %ax,%ax
 805da7f:	90                   	nop

0805da80 <add_mmio_map>:

static MMIO_t maps[NR_MAP];
static int nr_map = 0;

/* device interface */
void* add_mmio_map(hwaddr_t addr, size_t len, mmio_callback_t callback) {
 805da80:	55                   	push   %ebp
 805da81:	57                   	push   %edi
 805da82:	56                   	push   %esi
 805da83:	53                   	push   %ebx
 805da84:	83 ec 0c             	sub    $0xc,%esp
	assert(nr_map < NR_MAP);
 805da87:	8b 15 c0 81 07 08    	mov    0x80781c0,%edx

static MMIO_t maps[NR_MAP];
static int nr_map = 0;

/* device interface */
void* add_mmio_map(hwaddr_t addr, size_t len, mmio_callback_t callback) {
 805da8d:	8b 74 24 20          	mov    0x20(%esp),%esi
 805da91:	8b 5c 24 24          	mov    0x24(%esp),%ebx
	assert(nr_map < NR_MAP);
 805da95:	83 fa 07             	cmp    $0x7,%edx
 805da98:	7f 51                	jg     805daeb <add_mmio_map+0x6b>
	assert(mmio_space_free_index + len <= MMIO_SPACE_MAX);
 805da9a:	a1 80 82 07 08       	mov    0x8078280,%eax
 805da9f:	8d 3c 03             	lea    (%ebx,%eax,1),%edi
 805daa2:	81 ff 00 00 04 00    	cmp    $0x40000,%edi
 805daa8:	77 57                	ja     805db01 <add_mmio_map+0x81>

	uint8_t *space_base = &mmio_space_pool[mmio_space_free_index];
	maps[nr_map].low = addr;
	maps[nr_map].high = addr + len - 1;
 805daaa:	8d 5c 1e ff          	lea    -0x1(%esi,%ebx,1),%ebx
void* add_mmio_map(hwaddr_t addr, size_t len, mmio_callback_t callback) {
	assert(nr_map < NR_MAP);
	assert(mmio_space_free_index + len <= MMIO_SPACE_MAX);

	uint8_t *space_base = &mmio_space_pool[mmio_space_free_index];
	maps[nr_map].low = addr;
 805daae:	89 d5                	mov    %edx,%ebp
/* device interface */
void* add_mmio_map(hwaddr_t addr, size_t len, mmio_callback_t callback) {
	assert(nr_map < NR_MAP);
	assert(mmio_space_free_index + len <= MMIO_SPACE_MAX);

	uint8_t *space_base = &mmio_space_pool[mmio_space_free_index];
 805dab0:	05 c0 82 07 08       	add    $0x80782c0,%eax
	maps[nr_map].low = addr;
 805dab5:	c1 e5 04             	shl    $0x4,%ebp
	maps[nr_map].high = addr + len - 1;
	maps[nr_map].mmio_space = space_base;
	maps[nr_map].callback = callback;
	nr_map ++;
 805dab8:	83 c2 01             	add    $0x1,%edx
	mmio_space_free_index += len;
 805dabb:	89 3d 80 82 07 08    	mov    %edi,0x8078280
	assert(nr_map < NR_MAP);
	assert(mmio_space_free_index + len <= MMIO_SPACE_MAX);

	uint8_t *space_base = &mmio_space_pool[mmio_space_free_index];
	maps[nr_map].low = addr;
	maps[nr_map].high = addr + len - 1;
 805dac1:	89 9d 04 82 07 08    	mov    %ebx,0x8078204(%ebp)
	maps[nr_map].mmio_space = space_base;
	maps[nr_map].callback = callback;
 805dac7:	8b 5c 24 28          	mov    0x28(%esp),%ebx
void* add_mmio_map(hwaddr_t addr, size_t len, mmio_callback_t callback) {
	assert(nr_map < NR_MAP);
	assert(mmio_space_free_index + len <= MMIO_SPACE_MAX);

	uint8_t *space_base = &mmio_space_pool[mmio_space_free_index];
	maps[nr_map].low = addr;
 805dacb:	89 b5 00 82 07 08    	mov    %esi,0x8078200(%ebp)
	maps[nr_map].high = addr + len - 1;
	maps[nr_map].mmio_space = space_base;
 805dad1:	89 85 08 82 07 08    	mov    %eax,0x8078208(%ebp)
	maps[nr_map].callback = callback;
	nr_map ++;
 805dad7:	89 15 c0 81 07 08    	mov    %edx,0x80781c0

	uint8_t *space_base = &mmio_space_pool[mmio_space_free_index];
	maps[nr_map].low = addr;
	maps[nr_map].high = addr + len - 1;
	maps[nr_map].mmio_space = space_base;
	maps[nr_map].callback = callback;
 805dadd:	89 9d 0c 82 07 08    	mov    %ebx,0x807820c(%ebp)
	nr_map ++;
	mmio_space_free_index += len;
	return space_base;
}
 805dae3:	83 c4 0c             	add    $0xc,%esp
 805dae6:	5b                   	pop    %ebx
 805dae7:	5e                   	pop    %esi
 805dae8:	5f                   	pop    %edi
 805dae9:	5d                   	pop    %ebp
 805daea:	c3                   	ret    
static MMIO_t maps[NR_MAP];
static int nr_map = 0;

/* device interface */
void* add_mmio_map(hwaddr_t addr, size_t len, mmio_callback_t callback) {
	assert(nr_map < NR_MAP);
 805daeb:	68 d9 63 06 08       	push   $0x80663d9
 805daf0:	6a 17                	push   $0x17
 805daf2:	68 73 63 06 08       	push   $0x8066373
 805daf7:	68 8d 63 06 08       	push   $0x806638d
 805dafc:	e8 af b0 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(mmio_space_free_index + len <= MMIO_SPACE_MAX);
 805db01:	68 d9 63 06 08       	push   $0x80663d9
 805db06:	6a 18                	push   $0x18
 805db08:	68 73 63 06 08       	push   $0x8066373
 805db0d:	68 98 63 06 08       	push   $0x8066398
 805db12:	e8 99 b0 fe ff       	call   8048bb0 <__assert_fail@plt>
 805db17:	89 f6                	mov    %esi,%esi
 805db19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805db20 <is_mmio>:
	mmio_space_free_index += len;
	return space_base;
}

/* bus interface */
int is_mmio(hwaddr_t addr) {
 805db20:	53                   	push   %ebx
	int i;
	for(i = 0; i < nr_map; i ++) {
 805db21:	8b 1d c0 81 07 08    	mov    0x80781c0,%ebx
	mmio_space_free_index += len;
	return space_base;
}

/* bus interface */
int is_mmio(hwaddr_t addr) {
 805db27:	8b 4c 24 08          	mov    0x8(%esp),%ecx
	int i;
	for(i = 0; i < nr_map; i ++) {
 805db2b:	85 db                	test   %ebx,%ebx
 805db2d:	7e 24                	jle    805db53 <is_mmio+0x33>
 805db2f:	ba 00 82 07 08       	mov    $0x8078200,%edx
 805db34:	31 c0                	xor    %eax,%eax
 805db36:	8d 76 00             	lea    0x0(%esi),%esi
 805db39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		if(addr >= maps[i].low && addr <= maps[i].high) {
 805db40:	39 0a                	cmp    %ecx,(%edx)
 805db42:	77 05                	ja     805db49 <is_mmio+0x29>
 805db44:	3b 4a 04             	cmp    0x4(%edx),%ecx
 805db47:	76 0f                	jbe    805db58 <is_mmio+0x38>
}

/* bus interface */
int is_mmio(hwaddr_t addr) {
	int i;
	for(i = 0; i < nr_map; i ++) {
 805db49:	83 c0 01             	add    $0x1,%eax
 805db4c:	83 c2 10             	add    $0x10,%edx
 805db4f:	39 d8                	cmp    %ebx,%eax
 805db51:	75 ed                	jne    805db40 <is_mmio+0x20>
		if(addr >= maps[i].low && addr <= maps[i].high) {
			return i;
		}
	}
	return -1;
 805db53:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
 805db58:	5b                   	pop    %ebx
 805db59:	c3                   	ret    
 805db5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0805db60 <mmio_read>:

uint32_t mmio_read(hwaddr_t addr, size_t len, int map_NO) {
 805db60:	57                   	push   %edi
 805db61:	56                   	push   %esi
 805db62:	53                   	push   %ebx
 805db63:	8b 44 24 14          	mov    0x14(%esp),%eax
 805db67:	8b 54 24 10          	mov    0x10(%esp),%edx
	assert(len == 1 || len == 2 || len == 4);
 805db6b:	8d 48 ff             	lea    -0x1(%eax),%ecx
 805db6e:	83 f9 01             	cmp    $0x1,%ecx
 805db71:	76 05                	jbe    805db78 <mmio_read+0x18>
 805db73:	83 f8 04             	cmp    $0x4,%eax
 805db76:	75 41                	jne    805dbb9 <mmio_read+0x59>
	MMIO_t *map = &maps[map_NO];
	uint32_t data = *(uint32_t *)(map->mmio_space + (addr - map->low)) 
		& (~0u >> ((4 - len) << 3));
 805db78:	b9 04 00 00 00       	mov    $0x4,%ecx
 805db7d:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
}

uint32_t mmio_read(hwaddr_t addr, size_t len, int map_NO) {
	assert(len == 1 || len == 2 || len == 4);
	MMIO_t *map = &maps[map_NO];
	uint32_t data = *(uint32_t *)(map->mmio_space + (addr - map->low)) 
 805db82:	89 d7                	mov    %edx,%edi
		& (~0u >> ((4 - len) << 3));
 805db84:	29 c1                	sub    %eax,%ecx
	map->callback(addr, len, false);
 805db86:	83 ec 04             	sub    $0x4,%esp

uint32_t mmio_read(hwaddr_t addr, size_t len, int map_NO) {
	assert(len == 1 || len == 2 || len == 4);
	MMIO_t *map = &maps[map_NO];
	uint32_t data = *(uint32_t *)(map->mmio_space + (addr - map->low)) 
		& (~0u >> ((4 - len) << 3));
 805db89:	c1 e1 03             	shl    $0x3,%ecx
 805db8c:	d3 eb                	shr    %cl,%ebx
}

uint32_t mmio_read(hwaddr_t addr, size_t len, int map_NO) {
	assert(len == 1 || len == 2 || len == 4);
	MMIO_t *map = &maps[map_NO];
	uint32_t data = *(uint32_t *)(map->mmio_space + (addr - map->low)) 
 805db8e:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
 805db92:	c1 e1 04             	shl    $0x4,%ecx
 805db95:	2b b9 00 82 07 08    	sub    0x8078200(%ecx),%edi
 805db9b:	8d b1 00 82 07 08    	lea    0x8078200(%ecx),%esi
 805dba1:	89 f9                	mov    %edi,%ecx
 805dba3:	8b 7e 08             	mov    0x8(%esi),%edi
 805dba6:	23 1c 0f             	and    (%edi,%ecx,1),%ebx
		& (~0u >> ((4 - len) << 3));
	map->callback(addr, len, false);
 805dba9:	6a 00                	push   $0x0
 805dbab:	50                   	push   %eax
 805dbac:	52                   	push   %edx
 805dbad:	ff 56 0c             	call   *0xc(%esi)
	return data;
 805dbb0:	83 c4 10             	add    $0x10,%esp
}
 805dbb3:	89 d8                	mov    %ebx,%eax
 805dbb5:	5b                   	pop    %ebx
 805dbb6:	5e                   	pop    %esi
 805dbb7:	5f                   	pop    %edi
 805dbb8:	c3                   	ret    
	}
	return -1;
}

uint32_t mmio_read(hwaddr_t addr, size_t len, int map_NO) {
	assert(len == 1 || len == 2 || len == 4);
 805dbb9:	68 cf 63 06 08       	push   $0x80663cf
 805dbbe:	6a 30                	push   $0x30
 805dbc0:	68 73 63 06 08       	push   $0x8066373
 805dbc5:	68 40 f7 05 08       	push   $0x805f740
 805dbca:	e8 e1 af fe ff       	call   8048bb0 <__assert_fail@plt>
 805dbcf:	90                   	nop

0805dbd0 <mmio_write>:
		& (~0u >> ((4 - len) << 3));
	map->callback(addr, len, false);
	return data;
}

void mmio_write(hwaddr_t addr, size_t len, uint32_t data, int map_NO) {
 805dbd0:	57                   	push   %edi
 805dbd1:	56                   	push   %esi
 805dbd2:	53                   	push   %ebx
 805dbd3:	83 ec 10             	sub    $0x10,%esp
 805dbd6:	8b 54 24 24          	mov    0x24(%esp),%edx
 805dbda:	8b 7c 24 20          	mov    0x20(%esp),%edi
 805dbde:	8b 74 24 2c          	mov    0x2c(%esp),%esi
	assert(len == 1 || len == 2 || len == 4);
 805dbe2:	8d 42 ff             	lea    -0x1(%edx),%eax
 805dbe5:	83 f8 01             	cmp    $0x1,%eax
 805dbe8:	76 05                	jbe    805dbef <mmio_write+0x1f>
 805dbea:	83 fa 04             	cmp    $0x4,%edx
 805dbed:	75 61                	jne    805dc50 <mmio_write+0x80>
	MMIO_t *map = &maps[map_NO];
	uint32_t mask = (~0u >> ((4 - len) << 3));
 805dbef:	b9 04 00 00 00       	mov    $0x4,%ecx
 805dbf4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 805dbf9:	29 d1                	sub    %edx,%ecx
 805dbfb:	c1 e1 03             	shl    $0x3,%ecx
 805dbfe:	d3 e8                	shr    %cl,%eax
	memcpy_with_mask(map->mmio_space + (addr - map->low), &data, len, (void *)&mask);
 805dc00:	89 f9                	mov    %edi,%ecx
}

void mmio_write(hwaddr_t addr, size_t len, uint32_t data, int map_NO) {
	assert(len == 1 || len == 2 || len == 4);
	MMIO_t *map = &maps[map_NO];
	uint32_t mask = (~0u >> ((4 - len) << 3));
 805dc02:	89 44 24 0c          	mov    %eax,0xc(%esp)
	memcpy_with_mask(map->mmio_space + (addr - map->low), &data, len, (void *)&mask);
 805dc06:	89 f0                	mov    %esi,%eax
 805dc08:	c1 e0 04             	shl    $0x4,%eax
 805dc0b:	2b 88 00 82 07 08    	sub    0x8078200(%eax),%ecx
 805dc11:	8b 98 08 82 07 08    	mov    0x8078208(%eax),%ebx
 805dc17:	31 c0                	xor    %eax,%eax
 805dc19:	01 cb                	add    %ecx,%ebx
 805dc1b:	85 d2                	test   %edx,%edx
 805dc1d:	74 17                	je     805dc36 <mmio_write+0x66>
 805dc1f:	90                   	nop
		if(mask[i]) {
 805dc20:	80 7c 04 0c 00       	cmpb   $0x0,0xc(%esp,%eax,1)
 805dc25:	74 08                	je     805dc2f <mmio_write+0x5f>
			((uint8_t *)dest)[i] = ((uint8_t *)src)[i];
 805dc27:	0f b6 4c 04 28       	movzbl 0x28(%esp,%eax,1),%ecx
 805dc2c:	88 0c 03             	mov    %cl,(%ebx,%eax,1)

#include "common.h"

inline static void memcpy_with_mask(void *dest, const void *src, size_t len, uint8_t *mask) {
	int i;
	for(i = 0; i < len; i ++) {
 805dc2f:	83 c0 01             	add    $0x1,%eax
 805dc32:	39 d0                	cmp    %edx,%eax
 805dc34:	75 ea                	jne    805dc20 <mmio_write+0x50>
	maps[map_NO].callback(addr, len, true);
 805dc36:	83 ec 04             	sub    $0x4,%esp
 805dc39:	c1 e6 04             	shl    $0x4,%esi
 805dc3c:	6a 01                	push   $0x1
 805dc3e:	52                   	push   %edx
 805dc3f:	57                   	push   %edi
 805dc40:	ff 96 0c 82 07 08    	call   *0x807820c(%esi)
}
 805dc46:	83 c4 10             	add    $0x10,%esp
 805dc49:	83 c4 10             	add    $0x10,%esp
 805dc4c:	5b                   	pop    %ebx
 805dc4d:	5e                   	pop    %esi
 805dc4e:	5f                   	pop    %edi
 805dc4f:	c3                   	ret    
	map->callback(addr, len, false);
	return data;
}

void mmio_write(hwaddr_t addr, size_t len, uint32_t data, int map_NO) {
	assert(len == 1 || len == 2 || len == 4);
 805dc50:	68 c4 63 06 08       	push   $0x80663c4
 805dc55:	6a 39                	push   $0x39
 805dc57:	68 73 63 06 08       	push   $0x8066373
 805dc5c:	68 40 f7 05 08       	push   $0x805f740
 805dc61:	e8 4a af fe ff       	call   8048bb0 <__assert_fail@plt>
 805dc66:	66 90                	xchg   %ax,%ax
 805dc68:	66 90                	xchg   %ax,%ax
 805dc6a:	66 90                	xchg   %ax,%ax
 805dc6c:	66 90                	xchg   %ax,%ax
 805dc6e:	66 90                	xchg   %ax,%ax

0805dc70 <pio_callback>:
} PIO_t;

static PIO_t maps[NR_MAP];
static int nr_map = 0;

static void pio_callback(ioaddr_t addr, size_t len, bool is_write) {
 805dc70:	55                   	push   %ebp
 805dc71:	57                   	push   %edi
 805dc72:	56                   	push   %esi
 805dc73:	53                   	push   %ebx
 805dc74:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	for(i = 0; i < nr_map; i ++) {
 805dc77:	8b 1d c0 82 0b 08    	mov    0x80b82c0,%ebx
} PIO_t;

static PIO_t maps[NR_MAP];
static int nr_map = 0;

static void pio_callback(ioaddr_t addr, size_t len, bool is_write) {
 805dc7d:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
	int i;
	for(i = 0; i < nr_map; i ++) {
 805dc81:	85 db                	test   %ebx,%ebx
 805dc83:	7e 28                	jle    805dcad <pio_callback+0x3d>
		if(addr >= maps[i].low && addr + len - 1 <= maps[i].high) {
 805dc85:	0f b7 e8             	movzwl %ax,%ebp
static PIO_t maps[NR_MAP];
static int nr_map = 0;

static void pio_callback(ioaddr_t addr, size_t len, bool is_write) {
	int i;
	for(i = 0; i < nr_map; i ++) {
 805dc88:	31 c9                	xor    %ecx,%ecx
		if(addr >= maps[i].low && addr + len - 1 <= maps[i].high) {
 805dc8a:	8d 7c 2a ff          	lea    -0x1(%edx,%ebp,1),%edi
 805dc8e:	66 90                	xchg   %ax,%ax
 805dc90:	66 39 04 cd 00 83 0b 	cmp    %ax,0x80b8300(,%ecx,8)
 805dc97:	08 
 805dc98:	77 0c                	ja     805dca6 <pio_callback+0x36>
 805dc9a:	0f b7 34 cd 02 83 0b 	movzwl 0x80b8302(,%ecx,8),%esi
 805dca1:	08 
 805dca2:	39 f7                	cmp    %esi,%edi
 805dca4:	76 12                	jbe    805dcb8 <pio_callback+0x48>
static PIO_t maps[NR_MAP];
static int nr_map = 0;

static void pio_callback(ioaddr_t addr, size_t len, bool is_write) {
	int i;
	for(i = 0; i < nr_map; i ++) {
 805dca6:	83 c1 01             	add    $0x1,%ecx
 805dca9:	39 d9                	cmp    %ebx,%ecx
 805dcab:	75 e3                	jne    805dc90 <pio_callback+0x20>
		if(addr >= maps[i].low && addr + len - 1 <= maps[i].high) {
			maps[i].callback(addr, len, is_write);
			return;
		}
	}
}
 805dcad:	83 c4 1c             	add    $0x1c,%esp
 805dcb0:	5b                   	pop    %ebx
 805dcb1:	5e                   	pop    %esi
 805dcb2:	5f                   	pop    %edi
 805dcb3:	5d                   	pop    %ebp
 805dcb4:	c3                   	ret    
 805dcb5:	8d 76 00             	lea    0x0(%esi),%esi

static void pio_callback(ioaddr_t addr, size_t len, bool is_write) {
	int i;
	for(i = 0; i < nr_map; i ++) {
		if(addr >= maps[i].low && addr + len - 1 <= maps[i].high) {
			maps[i].callback(addr, len, is_write);
 805dcb8:	83 ec 04             	sub    $0x4,%esp
 805dcbb:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
 805dcc0:	50                   	push   %eax
 805dcc1:	52                   	push   %edx
 805dcc2:	55                   	push   %ebp
 805dcc3:	ff 14 cd 04 83 0b 08 	call   *0x80b8304(,%ecx,8)
			return;
 805dcca:	83 c4 10             	add    $0x10,%esp
		}
	}
}
 805dccd:	83 c4 1c             	add    $0x1c,%esp
 805dcd0:	5b                   	pop    %ebx
 805dcd1:	5e                   	pop    %esi
 805dcd2:	5f                   	pop    %edi
 805dcd3:	5d                   	pop    %ebp
 805dcd4:	c3                   	ret    
 805dcd5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805dcd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805dce0 <add_pio_map>:

/* device interface */
void* add_pio_map(ioaddr_t addr, size_t len, pio_callback_t callback) {
 805dce0:	56                   	push   %esi
 805dce1:	53                   	push   %ebx
 805dce2:	83 ec 04             	sub    $0x4,%esp
	assert(nr_map < NR_MAP);
 805dce5:	8b 15 c0 82 0b 08    	mov    0x80b82c0,%edx
		}
	}
}

/* device interface */
void* add_pio_map(ioaddr_t addr, size_t len, pio_callback_t callback) {
 805dceb:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 805dcef:	8b 5c 24 14          	mov    0x14(%esp),%ebx
	assert(nr_map < NR_MAP);
 805dcf3:	83 fa 07             	cmp    $0x7,%edx
 805dcf6:	7f 41                	jg     805dd39 <add_pio_map+0x59>
	assert(addr + len <= PORT_IO_SPACE_MAX);
 805dcf8:	0f b7 c1             	movzwl %cx,%eax
 805dcfb:	8d 34 18             	lea    (%eax,%ebx,1),%esi
 805dcfe:	81 fe 00 00 01 00    	cmp    $0x10000,%esi
 805dd04:	77 49                	ja     805dd4f <add_pio_map+0x6f>
	maps[nr_map].low = addr;
 805dd06:	66 89 0c d5 00 83 0b 	mov    %cx,0x80b8300(,%edx,8)
 805dd0d:	08 
	maps[nr_map].high = addr + len - 1;
 805dd0e:	8d 4c 19 ff          	lea    -0x1(%ecx,%ebx,1),%ecx
	maps[nr_map].callback = callback;
	nr_map ++;
	return pio_space + addr;
 805dd12:	05 40 83 0b 08       	add    $0x80b8340,%eax
/* device interface */
void* add_pio_map(ioaddr_t addr, size_t len, pio_callback_t callback) {
	assert(nr_map < NR_MAP);
	assert(addr + len <= PORT_IO_SPACE_MAX);
	maps[nr_map].low = addr;
	maps[nr_map].high = addr + len - 1;
 805dd17:	66 89 0c d5 02 83 0b 	mov    %cx,0x80b8302(,%edx,8)
 805dd1e:	08 
	maps[nr_map].callback = callback;
 805dd1f:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 805dd23:	89 0c d5 04 83 0b 08 	mov    %ecx,0x80b8304(,%edx,8)
	nr_map ++;
 805dd2a:	83 c2 01             	add    $0x1,%edx
 805dd2d:	89 15 c0 82 0b 08    	mov    %edx,0x80b82c0
	return pio_space + addr;
}
 805dd33:	83 c4 04             	add    $0x4,%esp
 805dd36:	5b                   	pop    %ebx
 805dd37:	5e                   	pop    %esi
 805dd38:	c3                   	ret    
	}
}

/* device interface */
void* add_pio_map(ioaddr_t addr, size_t len, pio_callback_t callback) {
	assert(nr_map < NR_MAP);
 805dd39:	68 41 64 06 08       	push   $0x8066441
 805dd3e:	6a 1f                	push   $0x1f
 805dd40:	68 e6 63 06 08       	push   $0x80663e6
 805dd45:	68 8d 63 06 08       	push   $0x806638d
 805dd4a:	e8 61 ae fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(addr + len <= PORT_IO_SPACE_MAX);
 805dd4f:	68 41 64 06 08       	push   $0x8066441
 805dd54:	6a 20                	push   $0x20
 805dd56:	68 e6 63 06 08       	push   $0x80663e6
 805dd5b:	68 03 64 06 08       	push   $0x8066403
 805dd60:	e8 4b ae fe ff       	call   8048bb0 <__assert_fail@plt>
 805dd65:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805dd69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805dd70 <pio_read>:
	return pio_space + addr;
}


/* CPU interface */
uint32_t pio_read(ioaddr_t addr, size_t len) {
 805dd70:	56                   	push   %esi
 805dd71:	53                   	push   %ebx
 805dd72:	83 ec 04             	sub    $0x4,%esp
 805dd75:	8b 74 24 14          	mov    0x14(%esp),%esi
 805dd79:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	assert(len == 1 || len == 2 || len == 4);
 805dd7d:	8d 46 ff             	lea    -0x1(%esi),%eax
 805dd80:	83 f8 01             	cmp    $0x1,%eax
 805dd83:	76 05                	jbe    805dd8a <pio_read+0x1a>
 805dd85:	83 fe 04             	cmp    $0x4,%esi
 805dd88:	75 36                	jne    805ddc0 <pio_read+0x50>
	assert(addr + len - 1 < PORT_IO_SPACE_MAX);
 805dd8a:	0f b7 db             	movzwl %bx,%ebx
 805dd8d:	8d 44 33 ff          	lea    -0x1(%ebx,%esi,1),%eax
 805dd91:	3d ff ff 00 00       	cmp    $0xffff,%eax
 805dd96:	77 3e                	ja     805ddd6 <pio_read+0x66>
	pio_callback(addr, len, false);		// prepare data to read
 805dd98:	89 d8                	mov    %ebx,%eax
 805dd9a:	31 c9                	xor    %ecx,%ecx
 805dd9c:	89 f2                	mov    %esi,%edx
 805dd9e:	e8 cd fe ff ff       	call   805dc70 <pio_callback>
	uint32_t data = *(uint32_t *)(pio_space + addr) & (~0u >> ((4 - len) << 3));
 805dda3:	b9 04 00 00 00       	mov    $0x4,%ecx
 805dda8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 805ddad:	29 f1                	sub    %esi,%ecx
 805ddaf:	c1 e1 03             	shl    $0x3,%ecx
 805ddb2:	d3 e8                	shr    %cl,%eax
 805ddb4:	23 83 40 83 0b 08    	and    0x80b8340(%ebx),%eax
	return data;
}
 805ddba:	83 c4 04             	add    $0x4,%esp
 805ddbd:	5b                   	pop    %ebx
 805ddbe:	5e                   	pop    %esi
 805ddbf:	c3                   	ret    
}


/* CPU interface */
uint32_t pio_read(ioaddr_t addr, size_t len) {
	assert(len == 1 || len == 2 || len == 4);
 805ddc0:	68 38 64 06 08       	push   $0x8066438
 805ddc5:	6a 2b                	push   $0x2b
 805ddc7:	68 e6 63 06 08       	push   $0x80663e6
 805ddcc:	68 40 f7 05 08       	push   $0x805f740
 805ddd1:	e8 da ad fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(addr + len - 1 < PORT_IO_SPACE_MAX);
 805ddd6:	68 38 64 06 08       	push   $0x8066438
 805dddb:	6a 2c                	push   $0x2c
 805dddd:	68 e6 63 06 08       	push   $0x80663e6
 805dde2:	68 17 64 06 08       	push   $0x8066417
 805dde7:	e8 c4 ad fe ff       	call   8048bb0 <__assert_fail@plt>
 805ddec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805ddf0 <pio_write>:
	pio_callback(addr, len, false);		// prepare data to read
	uint32_t data = *(uint32_t *)(pio_space + addr) & (~0u >> ((4 - len) << 3));
	return data;
}

void pio_write(ioaddr_t addr, size_t len, uint32_t data) {
 805ddf0:	56                   	push   %esi
 805ddf1:	53                   	push   %ebx
 805ddf2:	83 ec 04             	sub    $0x4,%esp
 805ddf5:	8b 74 24 14          	mov    0x14(%esp),%esi
 805ddf9:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	assert(len == 1 || len == 2 || len == 4);
 805ddfd:	8d 46 ff             	lea    -0x1(%esi),%eax
 805de00:	83 f8 01             	cmp    $0x1,%eax
 805de03:	76 05                	jbe    805de0a <pio_write+0x1a>
 805de05:	83 fe 04             	cmp    $0x4,%esi
 805de08:	75 37                	jne    805de41 <pio_write+0x51>
	assert(addr + len - 1 < PORT_IO_SPACE_MAX);
 805de0a:	0f b7 db             	movzwl %bx,%ebx
 805de0d:	8d 44 33 ff          	lea    -0x1(%ebx,%esi,1),%eax
 805de11:	3d ff ff 00 00       	cmp    $0xffff,%eax
 805de16:	77 3f                	ja     805de57 <pio_write+0x67>
	memcpy(pio_space + addr, &data, len);
 805de18:	8d 54 24 18          	lea    0x18(%esp),%edx
 805de1c:	8d 83 40 83 0b 08    	lea    0x80b8340(%ebx),%eax
 805de22:	83 ec 04             	sub    $0x4,%esp
 805de25:	56                   	push   %esi
 805de26:	52                   	push   %edx
 805de27:	50                   	push   %eax
 805de28:	e8 73 ab fe ff       	call   80489a0 <memcpy@plt>
	pio_callback(addr, len, true);
 805de2d:	89 f2                	mov    %esi,%edx
 805de2f:	89 d8                	mov    %ebx,%eax
 805de31:	b9 01 00 00 00       	mov    $0x1,%ecx
 805de36:	e8 35 fe ff ff       	call   805dc70 <pio_callback>
}
 805de3b:	83 c4 14             	add    $0x14,%esp
 805de3e:	5b                   	pop    %ebx
 805de3f:	5e                   	pop    %esi
 805de40:	c3                   	ret    
	uint32_t data = *(uint32_t *)(pio_space + addr) & (~0u >> ((4 - len) << 3));
	return data;
}

void pio_write(ioaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
 805de41:	68 2e 64 06 08       	push   $0x806642e
 805de46:	6a 33                	push   $0x33
 805de48:	68 e6 63 06 08       	push   $0x80663e6
 805de4d:	68 40 f7 05 08       	push   $0x805f740
 805de52:	e8 59 ad fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(addr + len - 1 < PORT_IO_SPACE_MAX);
 805de57:	68 2e 64 06 08       	push   $0x806642e
 805de5c:	6a 34                	push   $0x34
 805de5e:	68 e6 63 06 08       	push   $0x80663e6
 805de63:	68 17 64 06 08       	push   $0x8066417
 805de68:	e8 43 ad fe ff       	call   8048bb0 <__assert_fail@plt>
 805de6d:	66 90                	xchg   %ax,%ax
 805de6f:	90                   	nop

0805de70 <timer_intr>:
#include "monitor/monitor.h"

#define TIMER_IRQ 0

void timer_intr() {
	if(nemu_state == RUNNING) {
 805de70:	83 3d 80 81 07 08 01 	cmpl   $0x1,0x8078180
 805de77:	74 07                	je     805de80 <timer_intr+0x10>
		i8259_raise_intr(TIMER_IRQ);
	}
}
 805de79:	c3                   	ret    
 805de7a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#include "device/i8259.h"
#include "monitor/monitor.h"

#define TIMER_IRQ 0

void timer_intr() {
 805de80:	83 ec 18             	sub    $0x18,%esp
	if(nemu_state == RUNNING) {
		i8259_raise_intr(TIMER_IRQ);
 805de83:	6a 00                	push   $0x0
 805de85:	e8 26 01 00 00       	call   805dfb0 <i8259_raise_intr>
	}
}
 805de8a:	83 c4 1c             	add    $0x1c,%esp
 805de8d:	c3                   	ret    
 805de8e:	66 90                	xchg   %ax,%ax

0805de90 <init_timer>:

void init_timer() {
 805de90:	f3 c3                	repz ret 
 805de92:	66 90                	xchg   %ax,%ax
 805de94:	66 90                	xchg   %ax,%ax
 805de96:	66 90                	xchg   %ax,%ax
 805de98:	66 90                	xchg   %ax,%ax
 805de9a:	66 90                	xchg   %ax,%ax
 805de9c:	66 90                	xchg   %ax,%ax
 805de9e:	66 90                	xchg   %ax,%ax

0805dea0 <do_i8259>:
	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
};

/* i8259 internal */
static void do_i8259() {
 805dea0:	83 ec 0c             	sub    $0xc,%esp
	int8_t master_irq = master.highest_irq;
 805dea3:	0f b6 05 4b 83 0c 08 	movzbl 0x80c834b,%eax
	if(master_irq == NO_INTR) {
 805deaa:	3c ff                	cmp    $0xff,%al
 805deac:	0f 84 97 00 00 00    	je     805df49 <do_i8259+0xa9>
		 */
		// cpu.INTR = false;
		panic("uncomment the line above");
		return;
	}
	else if(master_irq == 2) {
 805deb2:	3c 02                	cmp    $0x2,%al
 805deb4:	74 6e                	je     805df24 <do_i8259+0x84>
	intr_NO = master_irq + IRQ_BASE;
	/* TODO: Uncomment the following line after the ``INTR'' member
	 * is added to the CPU_state structure.
	 */
	// cpu.INTR = true;
	panic("uncomment the line above");
 805deb6:	83 ec 0c             	sub    $0xc,%esp
 805deb9:	ff 35 20 5c 07 08    	pushl  0x8075c20
	else if(master_irq == 2) {
		assert(slave.highest_irq != NO_INTR);
		master_irq = 8 + slave.highest_irq;
	}

	intr_NO = master_irq + IRQ_BASE;
 805debf:	83 c0 20             	add    $0x20,%eax
 805dec2:	a2 43 83 0c 08       	mov    %al,0x80c8343
	/* TODO: Uncomment the following line after the ``INTR'' member
	 * is added to the CPU_state structure.
	 */
	// cpu.INTR = true;
	panic("uncomment the line above");
 805dec7:	e8 94 aa fe ff       	call   8048960 <fflush@plt>
 805decc:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805ded2:	6a 07                	push   $0x7
 805ded4:	6a 01                	push   $0x1
 805ded6:	68 92 ed 05 08       	push   $0x805ed92
 805dedb:	e8 30 ab fe ff       	call   8048a10 <fwrite@plt>
 805dee0:	83 c4 20             	add    $0x20,%esp
 805dee3:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805dee9:	6a 18                	push   $0x18
 805deeb:	6a 01                	push   $0x1
 805deed:	68 4d 64 06 08       	push   $0x806644d
 805def2:	e8 19 ab fe ff       	call   8048a10 <fwrite@plt>
 805def7:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805defd:	6a 05                	push   $0x5
 805deff:	6a 01                	push   $0x1
 805df01:	68 b1 ed 05 08       	push   $0x805edb1
 805df06:	e8 05 ab fe ff       	call   8048a10 <fwrite@plt>
 805df0b:	83 c4 20             	add    $0x20,%esp
 805df0e:	68 c0 64 06 08       	push   $0x80664c0
 805df13:	6a 3b                	push   $0x3b
 805df15:	68 66 64 06 08       	push   $0x8066466
 805df1a:	68 20 ef 05 08       	push   $0x805ef20
 805df1f:	e8 8c ac fe ff       	call   8048bb0 <__assert_fail@plt>
		// cpu.INTR = false;
		panic("uncomment the line above");
		return;
	}
	else if(master_irq == 2) {
		assert(slave.highest_irq != NO_INTR);
 805df24:	0f b6 15 47 83 0c 08 	movzbl 0x80c8347,%edx
		master_irq = 8 + slave.highest_irq;
 805df2b:	8d 42 08             	lea    0x8(%edx),%eax
		// cpu.INTR = false;
		panic("uncomment the line above");
		return;
	}
	else if(master_irq == 2) {
		assert(slave.highest_irq != NO_INTR);
 805df2e:	80 c2 01             	add    $0x1,%dl
 805df31:	75 83                	jne    805deb6 <do_i8259+0x16>
 805df33:	68 c0 64 06 08       	push   $0x80664c0
 805df38:	6a 32                	push   $0x32
 805df3a:	68 66 64 06 08       	push   $0x8066466
 805df3f:	68 7e 64 06 08       	push   $0x806647e
 805df44:	e8 67 ac fe ff       	call   8048bb0 <__assert_fail@plt>
	if(master_irq == NO_INTR) {
		/* TODO: Uncomment the following line after the ``INTR'' member
		 * is added to the CPU_state structure.
		 */
		// cpu.INTR = false;
		panic("uncomment the line above");
 805df49:	83 ec 0c             	sub    $0xc,%esp
 805df4c:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805df52:	e8 09 aa fe ff       	call   8048960 <fflush@plt>
 805df57:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805df5d:	6a 07                	push   $0x7
 805df5f:	6a 01                	push   $0x1
 805df61:	68 92 ed 05 08       	push   $0x805ed92
 805df66:	e8 a5 aa fe ff       	call   8048a10 <fwrite@plt>
 805df6b:	83 c4 20             	add    $0x20,%esp
 805df6e:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805df74:	6a 18                	push   $0x18
 805df76:	6a 01                	push   $0x1
 805df78:	68 4d 64 06 08       	push   $0x806644d
 805df7d:	e8 8e aa fe ff       	call   8048a10 <fwrite@plt>
 805df82:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805df88:	6a 05                	push   $0x5
 805df8a:	6a 01                	push   $0x1
 805df8c:	68 b1 ed 05 08       	push   $0x805edb1
 805df91:	e8 7a aa fe ff       	call   8048a10 <fwrite@plt>
 805df96:	83 c4 20             	add    $0x20,%esp
 805df99:	68 c0 64 06 08       	push   $0x80664c0
 805df9e:	6a 2e                	push   $0x2e
 805dfa0:	68 66 64 06 08       	push   $0x8066466
 805dfa5:	68 20 ef 05 08       	push   $0x805ef20
 805dfaa:	e8 01 ac fe ff       	call   8048bb0 <__assert_fail@plt>
 805dfaf:	90                   	nop

0805dfb0 <i8259_raise_intr>:
	// cpu.INTR = true;
	panic("uncomment the line above");
}

/* device interface */
void i8259_raise_intr(int n) {
 805dfb0:	83 ec 0c             	sub    $0xc,%esp
 805dfb3:	8b 4c 24 10          	mov    0x10(%esp),%ecx
	assert(n >= 0 && n < 16);
 805dfb7:	83 f9 0f             	cmp    $0xf,%ecx
 805dfba:	77 6d                	ja     805e029 <i8259_raise_intr+0x79>
	if(n < 8) {
 805dfbc:	83 f9 07             	cmp    $0x7,%ecx
 805dfbf:	7e 59                	jle    805e01a <i8259_raise_intr+0x6a>
		master.IRR |= MASK(n);
	}
	else {
		n -= 8;
 805dfc1:	83 e9 08             	sub    $0x8,%ecx
		slave.IRR |= MASK(n);
 805dfc4:	b8 01 00 00 00       	mov    $0x1,%eax
		master.IRR |= MASK(2);

		slave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];
 805dfc9:	0f b6 15 46 83 0c 08 	movzbl 0x80c8346,%edx
	if(n < 8) {
		master.IRR |= MASK(n);
	}
	else {
		n -= 8;
		slave.IRR |= MASK(n);
 805dfd0:	d3 e0                	shl    %cl,%eax
 805dfd2:	0a 05 44 83 0c 08    	or     0x80c8344,%al
		master.IRR |= MASK(2);
 805dfd8:	80 0d 48 83 0c 08 04 	orb    $0x4,0x80c8348

		slave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];
 805dfdf:	f7 d2                	not    %edx
	if(n < 8) {
		master.IRR |= MASK(n);
	}
	else {
		n -= 8;
		slave.IRR |= MASK(n);
 805dfe1:	a2 44 83 0c 08       	mov    %al,0x80c8344
		master.IRR |= MASK(2);

		slave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];
 805dfe6:	0f b6 c0             	movzbl %al,%eax
 805dfe9:	21 d0                	and    %edx,%eax
 805dfeb:	0f b6 80 00 65 06 08 	movzbl 0x8066500(%eax),%eax
 805dff2:	a2 47 83 0c 08       	mov    %al,0x80c8347
	}

	master.highest_irq = ffo_table[master.IRR & ~master.IMR];
 805dff7:	0f b6 05 4a 83 0c 08 	movzbl 0x80c834a,%eax
 805dffe:	0f b6 15 48 83 0c 08 	movzbl 0x80c8348,%edx
 805e005:	f7 d0                	not    %eax
 805e007:	21 d0                	and    %edx,%eax
 805e009:	0f b6 80 00 65 06 08 	movzbl 0x8066500(%eax),%eax
 805e010:	a2 4b 83 0c 08       	mov    %al,0x80c834b

	do_i8259();
 805e015:	e8 86 fe ff ff       	call   805dea0 <do_i8259>

/* device interface */
void i8259_raise_intr(int n) {
	assert(n >= 0 && n < 16);
	if(n < 8) {
		master.IRR |= MASK(n);
 805e01a:	b8 01 00 00 00       	mov    $0x1,%eax
 805e01f:	d3 e0                	shl    %cl,%eax
 805e021:	08 05 48 83 0c 08    	or     %al,0x80c8348
 805e027:	eb ce                	jmp    805dff7 <i8259_raise_intr+0x47>
	panic("uncomment the line above");
}

/* device interface */
void i8259_raise_intr(int n) {
	assert(n >= 0 && n < 16);
 805e029:	68 c9 64 06 08       	push   $0x80664c9
 805e02e:	6a 40                	push   $0x40
 805e030:	68 66 64 06 08       	push   $0x8066466
 805e035:	68 96 64 06 08       	push   $0x8066496
 805e03a:	e8 71 ab fe ff       	call   8048bb0 <__assert_fail@plt>
 805e03f:	90                   	nop

0805e040 <i8259_query_intr>:
}

/* CPU interface */
uint8_t i8259_query_intr() {
	return intr_NO;
}
 805e040:	0f b6 05 43 83 0c 08 	movzbl 0x80c8343,%eax
 805e047:	c3                   	ret    
 805e048:	90                   	nop
 805e049:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0805e050 <i8259_ack_intr>:

void i8259_ack_intr() {
 805e050:	83 ec 0c             	sub    $0xc,%esp
	if(intr_NO == NO_INTR) {
		return;
	}

	int n = intr_NO - IRQ_BASE;
 805e053:	0f b6 05 43 83 0c 08 	movzbl 0x80c8343,%eax
 805e05a:	8d 48 e0             	lea    -0x20(%eax),%ecx
	if(n < 8) {
 805e05d:	83 f9 07             	cmp    $0x7,%ecx
 805e060:	7f 30                	jg     805e092 <i8259_ack_intr+0x42>
		master.IRR &= ~MASK(n);
 805e062:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 805e067:	d3 c0                	rol    %cl,%eax
 805e069:	20 05 48 83 0c 08    	and    %al,0x80c8348
		master.IRR &= ~MASK(2);

		slave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];
	}

	master.highest_irq = ffo_table[master.IRR & ~master.IMR];
 805e06f:	0f b6 05 4a 83 0c 08 	movzbl 0x80c834a,%eax
 805e076:	0f b6 15 48 83 0c 08 	movzbl 0x80c8348,%edx
 805e07d:	f7 d0                	not    %eax
 805e07f:	21 d0                	and    %edx,%eax
 805e081:	0f b6 80 00 65 06 08 	movzbl 0x8066500(%eax),%eax
 805e088:	a2 4b 83 0c 08       	mov    %al,0x80c834b

	do_i8259();
 805e08d:	e8 0e fe ff ff       	call   805dea0 <do_i8259>
	int n = intr_NO - IRQ_BASE;
	if(n < 8) {
		master.IRR &= ~MASK(n);
	}
	else {
		n -= 8;
 805e092:	8d 48 d8             	lea    -0x28(%eax),%ecx
		slave.IRR &= ~MASK(n);
 805e095:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		master.IRR &= ~MASK(2);

		slave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];
 805e09a:	0f b6 15 46 83 0c 08 	movzbl 0x80c8346,%edx
		master.IRR &= ~MASK(n);
	}
	else {
		n -= 8;
		slave.IRR &= ~MASK(n);
		master.IRR &= ~MASK(2);
 805e0a1:	80 25 48 83 0c 08 fb 	andb   $0xfb,0x80c8348
	if(n < 8) {
		master.IRR &= ~MASK(n);
	}
	else {
		n -= 8;
		slave.IRR &= ~MASK(n);
 805e0a8:	d3 c0                	rol    %cl,%eax
 805e0aa:	22 05 44 83 0c 08    	and    0x80c8344,%al
		master.IRR &= ~MASK(2);

		slave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];
 805e0b0:	f7 d2                	not    %edx
	if(n < 8) {
		master.IRR &= ~MASK(n);
	}
	else {
		n -= 8;
		slave.IRR &= ~MASK(n);
 805e0b2:	a2 44 83 0c 08       	mov    %al,0x80c8344
		master.IRR &= ~MASK(2);

		slave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];
 805e0b7:	0f b6 c0             	movzbl %al,%eax
 805e0ba:	21 d0                	and    %edx,%eax
 805e0bc:	0f b6 80 00 65 06 08 	movzbl 0x8066500(%eax),%eax
 805e0c3:	a2 47 83 0c 08       	mov    %al,0x80c8347
 805e0c8:	eb a5                	jmp    805e06f <i8259_ack_intr+0x1f>
 805e0ca:	66 90                	xchg   %ax,%ax
 805e0cc:	66 90                	xchg   %ax,%ax
 805e0ce:	66 90                	xchg   %ax,%ax

0805e0d0 <i8042_io_handler>:
		newkey = true;
	}
}

void i8042_io_handler(ioaddr_t addr, size_t len, bool is_write) {
	if(!is_write) {
 805e0d0:	80 7c 24 0c 00       	cmpb   $0x0,0xc(%esp)
 805e0d5:	75 07                	jne    805e0de <i8042_io_handler+0xe>
		newkey = false;
 805e0d7:	c6 05 4c 83 0c 08 00 	movb   $0x0,0x80c834c
 805e0de:	f3 c3                	repz ret 

0805e0e0 <keyboard_intr>:
#define KEYBOARD_IRQ 1

static uint8_t *i8042_data_port_base;
static bool newkey;

void keyboard_intr(uint8_t scancode) {
 805e0e0:	83 ec 0c             	sub    $0xc,%esp
	if(nemu_state == RUNNING && newkey == false) {
 805e0e3:	83 3d 80 81 07 08 01 	cmpl   $0x1,0x8078180
#define KEYBOARD_IRQ 1

static uint8_t *i8042_data_port_base;
static bool newkey;

void keyboard_intr(uint8_t scancode) {
 805e0ea:	8b 44 24 10          	mov    0x10(%esp),%eax
	if(nemu_state == RUNNING && newkey == false) {
 805e0ee:	74 08                	je     805e0f8 <keyboard_intr+0x18>
		i8042_data_port_base[0] = scancode;
		i8259_raise_intr(KEYBOARD_IRQ);
		newkey = true;
	}
}
 805e0f0:	83 c4 0c             	add    $0xc,%esp
 805e0f3:	c3                   	ret    
 805e0f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static uint8_t *i8042_data_port_base;
static bool newkey;

void keyboard_intr(uint8_t scancode) {
	if(nemu_state == RUNNING && newkey == false) {
 805e0f8:	80 3d 4c 83 0c 08 00 	cmpb   $0x0,0x80c834c
 805e0ff:	75 ef                	jne    805e0f0 <keyboard_intr+0x10>
		i8042_data_port_base[0] = scancode;
 805e101:	8b 15 50 83 0c 08    	mov    0x80c8350,%edx
		i8259_raise_intr(KEYBOARD_IRQ);
 805e107:	83 ec 0c             	sub    $0xc,%esp
static uint8_t *i8042_data_port_base;
static bool newkey;

void keyboard_intr(uint8_t scancode) {
	if(nemu_state == RUNNING && newkey == false) {
		i8042_data_port_base[0] = scancode;
 805e10a:	88 02                	mov    %al,(%edx)
		i8259_raise_intr(KEYBOARD_IRQ);
 805e10c:	6a 01                	push   $0x1
 805e10e:	e8 9d fe ff ff       	call   805dfb0 <i8259_raise_intr>
		newkey = true;
 805e113:	83 c4 10             	add    $0x10,%esp
 805e116:	c6 05 4c 83 0c 08 01 	movb   $0x1,0x80c834c
	}
}
 805e11d:	83 c4 0c             	add    $0xc,%esp
 805e120:	c3                   	ret    
 805e121:	eb 0d                	jmp    805e130 <init_i8042>
 805e123:	90                   	nop
 805e124:	90                   	nop
 805e125:	90                   	nop
 805e126:	90                   	nop
 805e127:	90                   	nop
 805e128:	90                   	nop
 805e129:	90                   	nop
 805e12a:	90                   	nop
 805e12b:	90                   	nop
 805e12c:	90                   	nop
 805e12d:	90                   	nop
 805e12e:	90                   	nop
 805e12f:	90                   	nop

0805e130 <init_i8042>:
	if(!is_write) {
		newkey = false;
	}
}

void init_i8042() {
 805e130:	83 ec 10             	sub    $0x10,%esp
	i8042_data_port_base = add_pio_map(I8042_DATA_PORT, 1, i8042_io_handler);
 805e133:	68 d0 e0 05 08       	push   $0x805e0d0
 805e138:	6a 01                	push   $0x1
 805e13a:	6a 60                	push   $0x60
 805e13c:	e8 9f fb ff ff       	call   805dce0 <add_pio_map>
	newkey = false;
 805e141:	c6 05 4c 83 0c 08 00 	movb   $0x0,0x80c834c
		newkey = false;
	}
}

void init_i8042() {
	i8042_data_port_base = add_pio_map(I8042_DATA_PORT, 1, i8042_io_handler);
 805e148:	a3 50 83 0c 08       	mov    %eax,0x80c8350
	newkey = false;
}
 805e14d:	83 c4 1c             	add    $0x1c,%esp
 805e150:	c3                   	ret    
 805e151:	66 90                	xchg   %ax,%ax
 805e153:	66 90                	xchg   %ax,%ax
 805e155:	66 90                	xchg   %ax,%ax
 805e157:	66 90                	xchg   %ax,%ax
 805e159:	66 90                	xchg   %ax,%ax
 805e15b:	66 90                	xchg   %ax,%ax
 805e15d:	66 90                	xchg   %ax,%ax
 805e15f:	90                   	nop

0805e160 <serial_io_handler>:
#define CH_OFFSET 0
#define LSR_OFFSET 5		/* line status register */

static uint8_t *serial_port_base;

void serial_io_handler(ioaddr_t addr, size_t len, bool is_write) {
 805e160:	53                   	push   %ebx
 805e161:	83 ec 08             	sub    $0x8,%esp
	if(is_write) {
 805e164:	80 7c 24 18 00       	cmpb   $0x0,0x18(%esp)
#define CH_OFFSET 0
#define LSR_OFFSET 5		/* line status register */

static uint8_t *serial_port_base;

void serial_io_handler(ioaddr_t addr, size_t len, bool is_write) {
 805e169:	8b 54 24 10          	mov    0x10(%esp),%edx
 805e16d:	8b 44 24 14          	mov    0x14(%esp),%eax
	if(is_write) {
 805e171:	74 0c                	je     805e17f <serial_io_handler+0x1f>
		assert(len == 1);
 805e173:	83 f8 01             	cmp    $0x1,%eax
 805e176:	75 43                	jne    805e1bb <serial_io_handler+0x5b>
		if(addr == SERIAL_PORT + CH_OFFSET) {
 805e178:	66 81 fa f8 03       	cmp    $0x3f8,%dx
 805e17d:	74 09                	je     805e188 <serial_io_handler+0x28>
			if(c == '\n') {
				fflush(stdout);
			}
		}
	}
}
 805e17f:	83 c4 08             	add    $0x8,%esp
 805e182:	5b                   	pop    %ebx
 805e183:	c3                   	ret    
 805e184:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

void serial_io_handler(ioaddr_t addr, size_t len, bool is_write) {
	if(is_write) {
		assert(len == 1);
		if(addr == SERIAL_PORT + CH_OFFSET) {
			char c = serial_port_base[CH_OFFSET];
 805e188:	a1 54 83 0c 08       	mov    0x80c8354,%eax
			/* We bind the serial port with the host stdout in NEMU. */
			putc(c, stdout);
 805e18d:	83 ec 08             	sub    $0x8,%esp

void serial_io_handler(ioaddr_t addr, size_t len, bool is_write) {
	if(is_write) {
		assert(len == 1);
		if(addr == SERIAL_PORT + CH_OFFSET) {
			char c = serial_port_base[CH_OFFSET];
 805e190:	0f be 00             	movsbl (%eax),%eax
			/* We bind the serial port with the host stdout in NEMU. */
			putc(c, stdout);
 805e193:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805e199:	50                   	push   %eax

void serial_io_handler(ioaddr_t addr, size_t len, bool is_write) {
	if(is_write) {
		assert(len == 1);
		if(addr == SERIAL_PORT + CH_OFFSET) {
			char c = serial_port_base[CH_OFFSET];
 805e19a:	89 c3                	mov    %eax,%ebx
			/* We bind the serial port with the host stdout in NEMU. */
			putc(c, stdout);
 805e19c:	e8 3f a8 fe ff       	call   80489e0 <_IO_putc@plt>
			if(c == '\n') {
 805e1a1:	83 c4 10             	add    $0x10,%esp
 805e1a4:	80 fb 0a             	cmp    $0xa,%bl
 805e1a7:	75 d6                	jne    805e17f <serial_io_handler+0x1f>
				fflush(stdout);
 805e1a9:	a1 20 5c 07 08       	mov    0x8075c20,%eax
 805e1ae:	89 44 24 10          	mov    %eax,0x10(%esp)
			}
		}
	}
}
 805e1b2:	83 c4 08             	add    $0x8,%esp
 805e1b5:	5b                   	pop    %ebx
		if(addr == SERIAL_PORT + CH_OFFSET) {
			char c = serial_port_base[CH_OFFSET];
			/* We bind the serial port with the host stdout in NEMU. */
			putc(c, stdout);
			if(c == '\n') {
				fflush(stdout);
 805e1b6:	e9 a5 a7 fe ff       	jmp    8048960 <fflush@plt>

static uint8_t *serial_port_base;

void serial_io_handler(ioaddr_t addr, size_t len, bool is_write) {
	if(is_write) {
		assert(len == 1);
 805e1bb:	68 22 66 06 08       	push   $0x8066622
 805e1c0:	6a 0e                	push   $0xe
 805e1c2:	68 00 66 06 08       	push   $0x8066600
 805e1c7:	68 19 66 06 08       	push   $0x8066619
 805e1cc:	e8 df a9 fe ff       	call   8048bb0 <__assert_fail@plt>
 805e1d1:	eb 0d                	jmp    805e1e0 <init_serial>
 805e1d3:	90                   	nop
 805e1d4:	90                   	nop
 805e1d5:	90                   	nop
 805e1d6:	90                   	nop
 805e1d7:	90                   	nop
 805e1d8:	90                   	nop
 805e1d9:	90                   	nop
 805e1da:	90                   	nop
 805e1db:	90                   	nop
 805e1dc:	90                   	nop
 805e1dd:	90                   	nop
 805e1de:	90                   	nop
 805e1df:	90                   	nop

0805e1e0 <init_serial>:
			}
		}
	}
}

void init_serial() {
 805e1e0:	83 ec 10             	sub    $0x10,%esp
	serial_port_base = add_pio_map(SERIAL_PORT, 8, serial_io_handler);
 805e1e3:	68 60 e1 05 08       	push   $0x805e160
 805e1e8:	6a 08                	push   $0x8
 805e1ea:	68 f8 03 00 00       	push   $0x3f8
 805e1ef:	e8 ec fa ff ff       	call   805dce0 <add_pio_map>
 805e1f4:	a3 54 83 0c 08       	mov    %eax,0x80c8354
	serial_port_base[LSR_OFFSET] = 0x20; /* the status is always free */
 805e1f9:	c6 40 05 20          	movb   $0x20,0x5(%eax)
}
 805e1fd:	83 c4 1c             	add    $0x1c,%esp
 805e200:	c3                   	ret    
 805e201:	66 90                	xchg   %ax,%ax
 805e203:	66 90                	xchg   %ax,%ax
 805e205:	66 90                	xchg   %ax,%ax
 805e207:	66 90                	xchg   %ax,%ax
 805e209:	66 90                	xchg   %ax,%ax
 805e20b:	66 90                	xchg   %ax,%ax
 805e20d:	66 90                	xchg   %ax,%ax
 805e20f:	90                   	nop

0805e210 <ide_io_handler>:
static uint32_t sector, disk_idx;
static uint32_t byte_cnt;
static bool ide_write;
static FILE *disk_fp;

void ide_io_handler(ioaddr_t addr, size_t len, bool is_write) {
 805e210:	83 ec 0c             	sub    $0xc,%esp
	assert(byte_cnt <= 512);
 805e213:	81 3d 60 83 0c 08 00 	cmpl   $0x200,0x80c8360
 805e21a:	02 00 00 
static uint32_t sector, disk_idx;
static uint32_t byte_cnt;
static bool ide_write;
static FILE *disk_fp;

void ide_io_handler(ioaddr_t addr, size_t len, bool is_write) {
 805e21d:	8b 44 24 10          	mov    0x10(%esp),%eax
 805e221:	8b 4c 24 14          	mov    0x14(%esp),%ecx
 805e225:	8b 54 24 18          	mov    0x18(%esp),%edx
	assert(byte_cnt <= 512);
 805e229:	0f 87 92 01 00 00    	ja     805e3c1 <ide_io_handler+0x1b1>
	int ret;
	if(is_write) {
 805e22f:	84 d2                	test   %dl,%dl
 805e231:	74 6d                	je     805e2a0 <ide_io_handler+0x90>
		if(addr - IDE_PORT == 0 && len == 4) {
 805e233:	66 3d f0 01          	cmp    $0x1f0,%ax
 805e237:	0f 85 c3 00 00 00    	jne    805e300 <ide_io_handler+0xf0>
 805e23d:	83 f9 04             	cmp    $0x4,%ecx
 805e240:	0f 85 ba 00 00 00    	jne    805e300 <ide_io_handler+0xf0>
			/* write 4 bytes data to disk */
			assert(ide_write);
 805e246:	80 3d 5c 83 0c 08 00 	cmpb   $0x0,0x80c835c
 805e24d:	0f 84 9a 01 00 00    	je     805e3ed <ide_io_handler+0x1dd>
			ret = fwrite(ide_port_base, 4, 1, disk_fp);
 805e253:	ff 35 58 83 0c 08    	pushl  0x80c8358
 805e259:	6a 01                	push   $0x1
 805e25b:	6a 04                	push   $0x4
 805e25d:	ff 35 70 83 0c 08    	pushl  0x80c8370
 805e263:	e8 a8 a7 fe ff       	call   8048a10 <fwrite@plt>
			assert(ret == 1);
 805e268:	83 c4 10             	add    $0x10,%esp
 805e26b:	83 f8 01             	cmp    $0x1,%eax
 805e26e:	0f 85 8f 01 00 00    	jne    805e403 <ide_io_handler+0x1f3>
			/* read 4 bytes data from disk */
			assert(!ide_write);
			ret = fread(ide_port_base, 4, 1, disk_fp);
			assert(ret == 1 || feof(disk_fp));

			byte_cnt += 4;
 805e274:	a1 60 83 0c 08       	mov    0x80c8360,%eax
 805e279:	83 c0 04             	add    $0x4,%eax
			if(byte_cnt == 512) {
 805e27c:	3d 00 02 00 00       	cmp    $0x200,%eax
			/* read 4 bytes data from disk */
			assert(!ide_write);
			ret = fread(ide_port_base, 4, 1, disk_fp);
			assert(ret == 1 || feof(disk_fp));

			byte_cnt += 4;
 805e281:	a3 60 83 0c 08       	mov    %eax,0x80c8360
			if(byte_cnt == 512) {
 805e286:	75 10                	jne    805e298 <ide_io_handler+0x88>
				/* finish */
				ide_port_base[7] = 0x40;
 805e288:	a1 70 83 0c 08       	mov    0x80c8370,%eax
 805e28d:	c6 40 07 40          	movb   $0x40,0x7(%eax)
 805e291:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			}
		}
	}
}
 805e298:	83 c4 0c             	add    $0xc,%esp
 805e29b:	c3                   	ret    
 805e29c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				assert(0);
			}
		}
	}
	else {
		if(addr - IDE_PORT == 0 && len == 4) {
 805e2a0:	66 3d f0 01          	cmp    $0x1f0,%ax
 805e2a4:	75 f2                	jne    805e298 <ide_io_handler+0x88>
 805e2a6:	83 f9 04             	cmp    $0x4,%ecx
 805e2a9:	75 ed                	jne    805e298 <ide_io_handler+0x88>
			/* read 4 bytes data from disk */
			assert(!ide_write);
 805e2ab:	80 3d 5c 83 0c 08 00 	cmpb   $0x0,0x80c835c
 805e2b2:	0f 85 1f 01 00 00    	jne    805e3d7 <ide_io_handler+0x1c7>
			ret = fread(ide_port_base, 4, 1, disk_fp);
 805e2b8:	ff 35 58 83 0c 08    	pushl  0x80c8358
 805e2be:	6a 01                	push   $0x1
 805e2c0:	6a 04                	push   $0x4
 805e2c2:	ff 35 70 83 0c 08    	pushl  0x80c8370
 805e2c8:	e8 63 a7 fe ff       	call   8048a30 <fread@plt>
			assert(ret == 1 || feof(disk_fp));
 805e2cd:	83 c4 10             	add    $0x10,%esp
 805e2d0:	83 f8 01             	cmp    $0x1,%eax
 805e2d3:	74 9f                	je     805e274 <ide_io_handler+0x64>
 805e2d5:	83 ec 0c             	sub    $0xc,%esp
 805e2d8:	ff 35 58 83 0c 08    	pushl  0x80c8358
 805e2de:	e8 9d a7 fe ff       	call   8048a80 <feof@plt>
 805e2e3:	83 c4 10             	add    $0x10,%esp
 805e2e6:	85 c0                	test   %eax,%eax
 805e2e8:	75 8a                	jne    805e274 <ide_io_handler+0x64>
 805e2ea:	68 b8 66 06 08       	push   $0x80666b8
 805e2ef:	6a 4a                	push   $0x4a
 805e2f1:	68 34 66 06 08       	push   $0x8066634
 805e2f6:	68 65 66 06 08       	push   $0x8066665
 805e2fb:	e8 b0 a8 fe ff       	call   8048bb0 <__assert_fail@plt>
			if(byte_cnt == 512) {
				/* finish */
				ide_port_base[7] = 0x40;
			}
		}
		else if(addr - IDE_PORT == 7) {
 805e300:	66 3d f7 01          	cmp    $0x1f7,%ax
 805e304:	75 92                	jne    805e298 <ide_io_handler+0x88>
			if(ide_port_base[7] == 0x20 || ide_port_base[7] == 0x30) {
 805e306:	8b 15 70 83 0c 08    	mov    0x80c8370,%edx
 805e30c:	0f b6 42 07          	movzbl 0x7(%edx),%eax
 805e310:	89 c1                	mov    %eax,%ecx
 805e312:	83 e1 ef             	and    $0xffffffef,%ecx
 805e315:	80 f9 20             	cmp    $0x20,%cl
 805e318:	74 26                	je     805e340 <ide_io_handler+0x130>
				else {
					/* command: write to disk */
					ide_write = true;
				}
			}
			else if (ide_port_base[7] == 0xc8) {
 805e31a:	3c c8                	cmp    $0xc8,%al
 805e31c:	0f 84 76 ff ff ff    	je     805e298 <ide_io_handler+0x88>
				/* Nothing to do here. The actual read operation is
				 * issued by write commands to the bus master register. */
			}
			else {
				/* not implemented command */
				assert(0);
 805e322:	68 b8 66 06 08       	push   $0x80666b8
 805e327:	6a 41                	push   $0x41
 805e329:	68 34 66 06 08       	push   $0x8066634
 805e32e:	68 20 ef 05 08       	push   $0x805ef20
 805e333:	e8 78 a8 fe ff       	call   8048bb0 <__assert_fail@plt>
 805e338:	90                   	nop
 805e339:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			}
		}
		else if(addr - IDE_PORT == 7) {
			if(ide_port_base[7] == 0x20 || ide_port_base[7] == 0x30) {
				/* command: read/write */
				sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805e340:	0f b6 42 05          	movzbl 0x5(%edx),%eax
					| ide_port_base[4] << 8 | ide_port_base[3];
				disk_idx = sector << 9;
				fseek(disk_fp, disk_idx, SEEK_SET);
 805e344:	83 ec 04             	sub    $0x4,%esp
			}
		}
		else if(addr - IDE_PORT == 7) {
			if(ide_port_base[7] == 0x20 || ide_port_base[7] == 0x30) {
				/* command: read/write */
				sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805e347:	c1 e0 10             	shl    $0x10,%eax
 805e34a:	89 c1                	mov    %eax,%ecx
					| ide_port_base[4] << 8 | ide_port_base[3];
 805e34c:	0f b6 42 04          	movzbl 0x4(%edx),%eax
 805e350:	c1 e0 08             	shl    $0x8,%eax
 805e353:	09 c8                	or     %ecx,%eax
 805e355:	0f b6 4a 03          	movzbl 0x3(%edx),%ecx
			}
		}
		else if(addr - IDE_PORT == 7) {
			if(ide_port_base[7] == 0x20 || ide_port_base[7] == 0x30) {
				/* command: read/write */
				sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805e359:	0f b6 52 06          	movzbl 0x6(%edx),%edx
					| ide_port_base[4] << 8 | ide_port_base[3];
				disk_idx = sector << 9;
				fseek(disk_fp, disk_idx, SEEK_SET);
 805e35d:	6a 00                	push   $0x0
			}
		}
		else if(addr - IDE_PORT == 7) {
			if(ide_port_base[7] == 0x20 || ide_port_base[7] == 0x30) {
				/* command: read/write */
				sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805e35f:	83 e2 1f             	and    $0x1f,%edx
 805e362:	09 c8                	or     %ecx,%eax
 805e364:	c1 e2 18             	shl    $0x18,%edx
					| ide_port_base[4] << 8 | ide_port_base[3];
 805e367:	09 d0                	or     %edx,%eax
			}
		}
		else if(addr - IDE_PORT == 7) {
			if(ide_port_base[7] == 0x20 || ide_port_base[7] == 0x30) {
				/* command: read/write */
				sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805e369:	a3 68 83 0c 08       	mov    %eax,0x80c8368
					| ide_port_base[4] << 8 | ide_port_base[3];
				disk_idx = sector << 9;
 805e36e:	c1 e0 09             	shl    $0x9,%eax
				fseek(disk_fp, disk_idx, SEEK_SET);
 805e371:	50                   	push   %eax
 805e372:	ff 35 58 83 0c 08    	pushl  0x80c8358
		else if(addr - IDE_PORT == 7) {
			if(ide_port_base[7] == 0x20 || ide_port_base[7] == 0x30) {
				/* command: read/write */
				sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
					| ide_port_base[4] << 8 | ide_port_base[3];
				disk_idx = sector << 9;
 805e378:	a3 64 83 0c 08       	mov    %eax,0x80c8364
				fseek(disk_fp, disk_idx, SEEK_SET);
 805e37d:	e8 6e a6 fe ff       	call   80489f0 <fseek@plt>

				byte_cnt = 0;

				if(ide_port_base[7] == 0x20) {
 805e382:	a1 70 83 0c 08       	mov    0x80c8370,%eax
 805e387:	83 c4 10             	add    $0x10,%esp
				sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
					| ide_port_base[4] << 8 | ide_port_base[3];
				disk_idx = sector << 9;
				fseek(disk_fp, disk_idx, SEEK_SET);

				byte_cnt = 0;
 805e38a:	c7 05 60 83 0c 08 00 	movl   $0x0,0x80c8360
 805e391:	00 00 00 

				if(ide_port_base[7] == 0x20) {
 805e394:	80 78 07 20          	cmpb   $0x20,0x7(%eax)
 805e398:	74 0c                	je     805e3a6 <ide_io_handler+0x196>
					ide_port_base[7] = 0x40;
					i8259_raise_intr(IDE_IRQ);
				}
				else {
					/* command: write to disk */
					ide_write = true;
 805e39a:	c6 05 5c 83 0c 08 01 	movb   $0x1,0x80c835c
 805e3a1:	e9 f2 fe ff ff       	jmp    805e298 <ide_io_handler+0x88>
				byte_cnt = 0;

				if(ide_port_base[7] == 0x20) {
					/* command: read from disk */
					ide_write = false;
					ide_port_base[7] = 0x40;
 805e3a6:	c6 40 07 40          	movb   $0x40,0x7(%eax)

				byte_cnt = 0;

				if(ide_port_base[7] == 0x20) {
					/* command: read from disk */
					ide_write = false;
 805e3aa:	c6 05 5c 83 0c 08 00 	movb   $0x0,0x80c835c
					ide_port_base[7] = 0x40;
					i8259_raise_intr(IDE_IRQ);
 805e3b1:	c7 44 24 10 0e 00 00 	movl   $0xe,0x10(%esp)
 805e3b8:	00 
				/* finish */
				ide_port_base[7] = 0x40;
			}
		}
	}
}
 805e3b9:	83 c4 0c             	add    $0xc,%esp

				if(ide_port_base[7] == 0x20) {
					/* command: read from disk */
					ide_write = false;
					ide_port_base[7] = 0x40;
					i8259_raise_intr(IDE_IRQ);
 805e3bc:	e9 ef fb ff ff       	jmp    805dfb0 <i8259_raise_intr>
static uint32_t byte_cnt;
static bool ide_write;
static FILE *disk_fp;

void ide_io_handler(ioaddr_t addr, size_t len, bool is_write) {
	assert(byte_cnt <= 512);
 805e3c1:	68 b8 66 06 08       	push   $0x80666b8
 805e3c6:	6a 15                	push   $0x15
 805e3c8:	68 34 66 06 08       	push   $0x8066634
 805e3cd:	68 4a 66 06 08       	push   $0x806664a
 805e3d2:	e8 d9 a7 fe ff       	call   8048bb0 <__assert_fail@plt>
		}
	}
	else {
		if(addr - IDE_PORT == 0 && len == 4) {
			/* read 4 bytes data from disk */
			assert(!ide_write);
 805e3d7:	68 b8 66 06 08       	push   $0x80666b8
 805e3dc:	6a 48                	push   $0x48
 805e3de:	68 34 66 06 08       	push   $0x8066634
 805e3e3:	68 5a 66 06 08       	push   $0x806665a
 805e3e8:	e8 c3 a7 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(byte_cnt <= 512);
	int ret;
	if(is_write) {
		if(addr - IDE_PORT == 0 && len == 4) {
			/* write 4 bytes data to disk */
			assert(ide_write);
 805e3ed:	68 b8 66 06 08       	push   $0x80666b8
 805e3f2:	6a 1a                	push   $0x1a
 805e3f4:	68 34 66 06 08       	push   $0x8066634
 805e3f9:	68 5b 66 06 08       	push   $0x806665b
 805e3fe:	e8 ad a7 fe ff       	call   8048bb0 <__assert_fail@plt>
			ret = fwrite(ide_port_base, 4, 1, disk_fp);
			assert(ret == 1);
 805e403:	68 b8 66 06 08       	push   $0x80666b8
 805e408:	6a 1c                	push   $0x1c
 805e40a:	68 34 66 06 08       	push   $0x8066634
 805e40f:	68 ee ed 05 08       	push   $0x805edee
 805e414:	e8 97 a7 fe ff       	call   8048bb0 <__assert_fail@plt>
 805e419:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0805e420 <bmr_io_handler>:
			}
		}
	}
}

void bmr_io_handler(ioaddr_t addr, size_t len, bool is_write) {
 805e420:	56                   	push   %esi
 805e421:	53                   	push   %ebx
 805e422:	83 ec 04             	sub    $0x4,%esp
	int ret;
	if(is_write) {
		if(addr - BMR_PORT == 0) {
 805e425:	80 7c 24 18 00       	cmpb   $0x0,0x18(%esp)
			}
		}
	}
}

void bmr_io_handler(ioaddr_t addr, size_t len, bool is_write) {
 805e42a:	8b 44 24 10          	mov    0x10(%esp),%eax
	int ret;
	if(is_write) {
		if(addr - BMR_PORT == 0) {
 805e42e:	0f 84 e4 00 00 00    	je     805e518 <bmr_io_handler+0xf8>
 805e434:	66 3d 40 c0          	cmp    $0xc040,%ax
 805e438:	0f 85 da 00 00 00    	jne    805e518 <bmr_io_handler+0xf8>
			if(bmr_base[0] & 0x1) {
 805e43e:	a1 6c 83 0c 08       	mov    0x80c836c,%eax
 805e443:	0f b6 10             	movzbl (%eax),%edx
 805e446:	f6 c2 01             	test   $0x1,%dl
 805e449:	0f 84 c9 00 00 00    	je     805e518 <bmr_io_handler+0xf8>
				/* DMA start command */
				if(bmr_base[0] & 0x8) {
 805e44f:	83 e2 08             	and    $0x8,%edx
 805e452:	0f 84 c6 00 00 00    	je     805e51e <bmr_io_handler+0xfe>
					/* DMA read */

					/* the address of Physical Region Descriptor Table */
					hwaddr_t prdt_addr = *(uint32_t *)(bmr_base + 4);
 805e458:	8b 58 04             	mov    0x4(%eax),%ebx

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
 805e45b:	83 ec 08             	sub    $0x8,%esp
 805e45e:	6a 04                	push   $0x4
 805e460:	53                   	push   %ebx
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
 805e461:	83 c3 04             	add    $0x4,%ebx
					/* DMA read */

					/* the address of Physical Region Descriptor Table */
					hwaddr_t prdt_addr = *(uint32_t *)(bmr_base + 4);

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
 805e464:	e8 77 ca fe ff       	call   804aee0 <hwaddr_read>
 805e469:	89 c6                	mov    %eax,%esi
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
 805e46b:	58                   	pop    %eax
 805e46c:	5a                   	pop    %edx
 805e46d:	6a 04                	push   $0x4
 805e46f:	53                   	push   %ebx
 805e470:	e8 6b ca fe ff       	call   804aee0 <hwaddr_read>
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805e475:	8b 0d 70 83 0c 08    	mov    0x80c8370,%ecx

					/* the address of Physical Region Descriptor Table */
					hwaddr_t prdt_addr = *(uint32_t *)(bmr_base + 4);

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
 805e47b:	89 c3                	mov    %eax,%ebx
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
						| ide_port_base[4] << 8 | ide_port_base[3];
					disk_idx = sector << 9;
					fseek(disk_fp, disk_idx, SEEK_SET);
 805e47d:	83 c4 0c             	add    $0xc,%esp

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805e480:	0f b6 51 05          	movzbl 0x5(%ecx),%edx
						| ide_port_base[4] << 8 | ide_port_base[3];
 805e484:	0f b6 41 04          	movzbl 0x4(%ecx),%eax

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805e488:	c1 e2 10             	shl    $0x10,%edx
						| ide_port_base[4] << 8 | ide_port_base[3];
 805e48b:	c1 e0 08             	shl    $0x8,%eax
 805e48e:	09 c2                	or     %eax,%edx
 805e490:	0f b6 41 03          	movzbl 0x3(%ecx),%eax

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805e494:	0f b6 49 06          	movzbl 0x6(%ecx),%ecx
						| ide_port_base[4] << 8 | ide_port_base[3];
					disk_idx = sector << 9;
					fseek(disk_fp, disk_idx, SEEK_SET);
 805e498:	6a 00                	push   $0x0

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805e49a:	83 e1 1f             	and    $0x1f,%ecx
 805e49d:	09 c2                	or     %eax,%edx
 805e49f:	c1 e1 18             	shl    $0x18,%ecx
						| ide_port_base[4] << 8 | ide_port_base[3];
 805e4a2:	09 ca                	or     %ecx,%edx

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805e4a4:	89 15 68 83 0c 08    	mov    %edx,0x80c8368
						| ide_port_base[4] << 8 | ide_port_base[3];
					disk_idx = sector << 9;
 805e4aa:	c1 e2 09             	shl    $0x9,%edx
					fseek(disk_fp, disk_idx, SEEK_SET);
 805e4ad:	52                   	push   %edx
 805e4ae:	ff 35 58 83 0c 08    	pushl  0x80c8358
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
						| ide_port_base[4] << 8 | ide_port_base[3];
					disk_idx = sector << 9;
 805e4b4:	89 15 64 83 0c 08    	mov    %edx,0x80c8364
					fseek(disk_fp, disk_idx, SEEK_SET);
 805e4ba:	e8 31 a5 fe ff       	call   80489f0 <fseek@plt>

					ret = fread((void *)hwa_to_va(addr), byte_cnt, 1, disk_fp);
 805e4bf:	03 35 c8 51 07 08    	add    0x80751c8,%esi
 805e4c5:	0f b7 c3             	movzwl %bx,%eax
 805e4c8:	ff 35 58 83 0c 08    	pushl  0x80c8358
 805e4ce:	6a 01                	push   $0x1
 805e4d0:	50                   	push   %eax
 805e4d1:	56                   	push   %esi
 805e4d2:	e8 59 a5 fe ff       	call   8048a30 <fread@plt>
					assert(ret == 1 || feof(disk_fp));
 805e4d7:	83 c4 20             	add    $0x20,%esp
 805e4da:	83 f8 01             	cmp    $0x1,%eax
 805e4dd:	74 15                	je     805e4f4 <bmr_io_handler+0xd4>
 805e4df:	83 ec 0c             	sub    $0xc,%esp
 805e4e2:	ff 35 58 83 0c 08    	pushl  0x80c8358
 805e4e8:	e8 93 a5 fe ff       	call   8048a80 <feof@plt>
 805e4ed:	83 c4 10             	add    $0x10,%esp
 805e4f0:	85 c0                	test   %eax,%eax
 805e4f2:	74 56                	je     805e54a <bmr_io_handler+0x12a>

					/* We only implement PRDT of single entry. */
					assert(hi_entry & 0x80000000);
 805e4f4:	85 db                	test   %ebx,%ebx
 805e4f6:	79 3c                	jns    805e534 <bmr_io_handler+0x114>

					/* finish */
					ide_port_base[7] = 0x40;
 805e4f8:	a1 70 83 0c 08       	mov    0x80c8370,%eax
 805e4fd:	c6 40 07 40          	movb   $0x40,0x7(%eax)
					i8259_raise_intr(IDE_IRQ);
 805e501:	c7 44 24 10 0e 00 00 	movl   $0xe,0x10(%esp)
 805e508:	00 
					assert(0);
				}
			}
		}
	}
}
 805e509:	83 c4 04             	add    $0x4,%esp
 805e50c:	5b                   	pop    %ebx
 805e50d:	5e                   	pop    %esi
					/* We only implement PRDT of single entry. */
					assert(hi_entry & 0x80000000);

					/* finish */
					ide_port_base[7] = 0x40;
					i8259_raise_intr(IDE_IRQ);
 805e50e:	e9 9d fa ff ff       	jmp    805dfb0 <i8259_raise_intr>
 805e513:	90                   	nop
 805e514:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					assert(0);
				}
			}
		}
	}
}
 805e518:	83 c4 04             	add    $0x4,%esp
 805e51b:	5b                   	pop    %ebx
 805e51c:	5e                   	pop    %esi
 805e51d:	c3                   	ret    
					ide_port_base[7] = 0x40;
					i8259_raise_intr(IDE_IRQ);
				}
				else {
					/* DMA write is not implemented */
					assert(0);
 805e51e:	68 a9 66 06 08       	push   $0x80666a9
 805e523:	6a 76                	push   $0x76
 805e525:	68 34 66 06 08       	push   $0x8066634
 805e52a:	68 20 ef 05 08       	push   $0x805ef20
 805e52f:	e8 7c a6 fe ff       	call   8048bb0 <__assert_fail@plt>

					ret = fread((void *)hwa_to_va(addr), byte_cnt, 1, disk_fp);
					assert(ret == 1 || feof(disk_fp));

					/* We only implement PRDT of single entry. */
					assert(hi_entry & 0x80000000);
 805e534:	68 a9 66 06 08       	push   $0x80666a9
 805e539:	6a 6e                	push   $0x6e
 805e53b:	68 34 66 06 08       	push   $0x8066634
 805e540:	68 7f 66 06 08       	push   $0x806667f
 805e545:	e8 66 a6 fe ff       	call   8048bb0 <__assert_fail@plt>
						| ide_port_base[4] << 8 | ide_port_base[3];
					disk_idx = sector << 9;
					fseek(disk_fp, disk_idx, SEEK_SET);

					ret = fread((void *)hwa_to_va(addr), byte_cnt, 1, disk_fp);
					assert(ret == 1 || feof(disk_fp));
 805e54a:	68 a9 66 06 08       	push   $0x80666a9
 805e54f:	6a 6b                	push   $0x6b
 805e551:	68 34 66 06 08       	push   $0x8066634
 805e556:	68 65 66 06 08       	push   $0x8066665
 805e55b:	e8 50 a6 fe ff       	call   8048bb0 <__assert_fail@plt>

0805e560 <init_ide>:
			}
		}
	}
}

void init_ide() {
 805e560:	83 ec 10             	sub    $0x10,%esp
	ide_port_base = add_pio_map(IDE_PORT, 8, ide_io_handler);
 805e563:	68 10 e2 05 08       	push   $0x805e210
 805e568:	6a 08                	push   $0x8
 805e56a:	68 f0 01 00 00       	push   $0x1f0
 805e56f:	e8 6c f7 ff ff       	call   805dce0 <add_pio_map>
	ide_port_base[7] = 0x40;

	bmr_base = add_pio_map(BMR_PORT, 8, bmr_io_handler);
 805e574:	83 c4 0c             	add    $0xc,%esp
	}
}

void init_ide() {
	ide_port_base = add_pio_map(IDE_PORT, 8, ide_io_handler);
	ide_port_base[7] = 0x40;
 805e577:	c6 40 07 40          	movb   $0x40,0x7(%eax)
		}
	}
}

void init_ide() {
	ide_port_base = add_pio_map(IDE_PORT, 8, ide_io_handler);
 805e57b:	a3 70 83 0c 08       	mov    %eax,0x80c8370
	ide_port_base[7] = 0x40;

	bmr_base = add_pio_map(BMR_PORT, 8, bmr_io_handler);
 805e580:	68 20 e4 05 08       	push   $0x805e420
 805e585:	6a 08                	push   $0x8
 805e587:	68 40 c0 00 00       	push   $0xc040
 805e58c:	e8 4f f7 ff ff       	call   805dce0 <add_pio_map>
	bmr_base[0] = 0;
 805e591:	c6 00 00             	movb   $0x0,(%eax)

void init_ide() {
	ide_port_base = add_pio_map(IDE_PORT, 8, ide_io_handler);
	ide_port_base[7] = 0x40;

	bmr_base = add_pio_map(BMR_PORT, 8, bmr_io_handler);
 805e594:	a3 6c 83 0c 08       	mov    %eax,0x80c836c
	bmr_base[0] = 0;

	extern char *exec_file;
	disk_fp = fopen(exec_file, "r+");
 805e599:	5a                   	pop    %edx
 805e59a:	59                   	pop    %ecx
 805e59b:	68 95 66 06 08       	push   $0x8066695
 805e5a0:	ff 35 2c 5c 07 08    	pushl  0x8075c2c
 805e5a6:	e8 35 a5 fe ff       	call   8048ae0 <fopen@plt>
	Assert(disk_fp, "Can not open '%s'", exec_file);
 805e5ab:	83 c4 10             	add    $0x10,%esp
 805e5ae:	85 c0                	test   %eax,%eax

	bmr_base = add_pio_map(BMR_PORT, 8, bmr_io_handler);
	bmr_base[0] = 0;

	extern char *exec_file;
	disk_fp = fopen(exec_file, "r+");
 805e5b0:	a3 58 83 0c 08       	mov    %eax,0x80c8358
	Assert(disk_fp, "Can not open '%s'", exec_file);
 805e5b5:	74 09                	je     805e5c0 <init_ide+0x60>
}
 805e5b7:	83 c4 0c             	add    $0xc,%esp
 805e5ba:	c3                   	ret    
 805e5bb:	90                   	nop
 805e5bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	bmr_base = add_pio_map(BMR_PORT, 8, bmr_io_handler);
	bmr_base[0] = 0;

	extern char *exec_file;
	disk_fp = fopen(exec_file, "r+");
	Assert(disk_fp, "Can not open '%s'", exec_file);
 805e5c0:	83 ec 0c             	sub    $0xc,%esp
 805e5c3:	ff 35 20 5c 07 08    	pushl  0x8075c20
 805e5c9:	e8 92 a3 fe ff       	call   8048960 <fflush@plt>
 805e5ce:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805e5d4:	6a 07                	push   $0x7
 805e5d6:	6a 01                	push   $0x1
 805e5d8:	68 92 ed 05 08       	push   $0x805ed92
 805e5dd:	e8 2e a4 fe ff       	call   8048a10 <fwrite@plt>
 805e5e2:	83 c4 1c             	add    $0x1c,%esp
 805e5e5:	ff 35 2c 5c 07 08    	pushl  0x8075c2c
 805e5eb:	68 dc ed 05 08       	push   $0x805eddc
 805e5f0:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805e5f6:	e8 c5 a4 fe ff       	call   8048ac0 <fprintf@plt>
 805e5fb:	ff 35 00 5c 07 08    	pushl  0x8075c00
 805e601:	6a 05                	push   $0x5
 805e603:	6a 01                	push   $0x1
 805e605:	68 b1 ed 05 08       	push   $0x805edb1
 805e60a:	e8 01 a4 fe ff       	call   8048a10 <fwrite@plt>
 805e60f:	a1 58 83 0c 08       	mov    0x80c8358,%eax
 805e614:	83 c4 20             	add    $0x20,%esp
 805e617:	85 c0                	test   %eax,%eax
 805e619:	75 9c                	jne    805e5b7 <init_ide+0x57>
 805e61b:	68 a0 66 06 08       	push   $0x80666a0
 805e620:	68 86 00 00 00       	push   $0x86
 805e625:	68 34 66 06 08       	push   $0x8066634
 805e62a:	68 98 66 06 08       	push   $0x8066698
 805e62f:	e8 7c a5 fe ff       	call   8048bb0 <__assert_fail@plt>
 805e634:	66 90                	xchg   %ax,%ax
 805e636:	66 90                	xchg   %ax,%ax
 805e638:	66 90                	xchg   %ax,%ax
 805e63a:	66 90                	xchg   %ax,%ax
 805e63c:	66 90                	xchg   %ax,%ax
 805e63e:	66 90                	xchg   %ax,%ax

0805e640 <__divdi3>:
 805e640:	55                   	push   %ebp
 805e641:	57                   	push   %edi
 805e642:	56                   	push   %esi
 805e643:	83 ec 20             	sub    $0x20,%esp
 805e646:	8b 44 24 34          	mov    0x34(%esp),%eax
 805e64a:	8b 6c 24 30          	mov    0x30(%esp),%ebp
 805e64e:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
 805e652:	8b 7c 24 38          	mov    0x38(%esp),%edi
 805e656:	89 6c 24 08          	mov    %ebp,0x8(%esp)
 805e65a:	31 ed                	xor    %ebp,%ebp
 805e65c:	85 c0                	test   %eax,%eax
 805e65e:	89 ce                	mov    %ecx,%esi
 805e660:	89 44 24 0c          	mov    %eax,0xc(%esp)
 805e664:	0f 88 f6 00 00 00    	js     805e760 <__divdi3+0x120>
 805e66a:	85 f6                	test   %esi,%esi
 805e66c:	89 f8                	mov    %edi,%eax
 805e66e:	89 ca                	mov    %ecx,%edx
 805e670:	0f 88 da 00 00 00    	js     805e750 <__divdi3+0x110>
 805e676:	8b 74 24 08          	mov    0x8(%esp),%esi
 805e67a:	8b 7c 24 0c          	mov    0xc(%esp),%edi
 805e67e:	85 d2                	test   %edx,%edx
 805e680:	89 44 24 18          	mov    %eax,0x18(%esp)
 805e684:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 805e688:	89 74 24 1c          	mov    %esi,0x1c(%esp)
 805e68c:	89 fe                	mov    %edi,%esi
 805e68e:	89 c7                	mov    %eax,%edi
 805e690:	75 1e                	jne    805e6b0 <__divdi3+0x70>
 805e692:	39 f0                	cmp    %esi,%eax
 805e694:	0f 86 86 00 00 00    	jbe    805e720 <__divdi3+0xe0>
 805e69a:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
 805e69e:	89 f2                	mov    %esi,%edx
 805e6a0:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 805e6a7:	00 
 805e6a8:	89 c8                	mov    %ecx,%eax
 805e6aa:	f7 f7                	div    %edi
 805e6ac:	89 c1                	mov    %eax,%ecx
 805e6ae:	eb 0e                	jmp    805e6be <__divdi3+0x7e>
 805e6b0:	39 f2                	cmp    %esi,%edx
 805e6b2:	76 44                	jbe    805e6f8 <__divdi3+0xb8>
 805e6b4:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 805e6bb:	00 
 805e6bc:	31 c9                	xor    %ecx,%ecx
 805e6be:	31 c0                	xor    %eax,%eax
 805e6c0:	85 ed                	test   %ebp,%ebp
 805e6c2:	0f 95 c0             	setne  %al
 805e6c5:	31 d2                	xor    %edx,%edx
 805e6c7:	89 c7                	mov    %eax,%edi
 805e6c9:	89 d5                	mov    %edx,%ebp
 805e6cb:	f7 df                	neg    %edi
 805e6cd:	83 d5 00             	adc    $0x0,%ebp
 805e6d0:	89 7c 24 08          	mov    %edi,0x8(%esp)
 805e6d4:	33 4c 24 08          	xor    0x8(%esp),%ecx
 805e6d8:	f7 dd                	neg    %ebp
 805e6da:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
 805e6de:	89 ce                	mov    %ecx,%esi
 805e6e0:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
 805e6e4:	33 4c 24 14          	xor    0x14(%esp),%ecx
 805e6e8:	01 f0                	add    %esi,%eax
 805e6ea:	11 ca                	adc    %ecx,%edx
 805e6ec:	83 c4 20             	add    $0x20,%esp
 805e6ef:	5e                   	pop    %esi
 805e6f0:	5f                   	pop    %edi
 805e6f1:	5d                   	pop    %ebp
 805e6f2:	c3                   	ret    
 805e6f3:	90                   	nop
 805e6f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805e6f8:	0f bd c2             	bsr    %edx,%eax
 805e6fb:	83 f0 1f             	xor    $0x1f,%eax
 805e6fe:	89 44 24 14          	mov    %eax,0x14(%esp)
 805e702:	75 7c                	jne    805e780 <__divdi3+0x140>
 805e704:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
 805e708:	39 7c 24 18          	cmp    %edi,0x18(%esp)
 805e70c:	76 06                	jbe    805e714 <__divdi3+0xd4>
 805e70e:	31 c9                	xor    %ecx,%ecx
 805e710:	39 f2                	cmp    %esi,%edx
 805e712:	73 aa                	jae    805e6be <__divdi3+0x7e>
 805e714:	b9 01 00 00 00       	mov    $0x1,%ecx
 805e719:	eb a3                	jmp    805e6be <__divdi3+0x7e>
 805e71b:	90                   	nop
 805e71c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805e720:	85 c0                	test   %eax,%eax
 805e722:	75 0b                	jne    805e72f <__divdi3+0xef>
 805e724:	b8 01 00 00 00       	mov    $0x1,%eax
 805e729:	31 d2                	xor    %edx,%edx
 805e72b:	f7 f7                	div    %edi
 805e72d:	89 c7                	mov    %eax,%edi
 805e72f:	89 f0                	mov    %esi,%eax
 805e731:	31 d2                	xor    %edx,%edx
 805e733:	f7 f7                	div    %edi
 805e735:	89 c6                	mov    %eax,%esi
 805e737:	89 c8                	mov    %ecx,%eax
 805e739:	89 74 24 14          	mov    %esi,0x14(%esp)
 805e73d:	f7 f7                	div    %edi
 805e73f:	89 c1                	mov    %eax,%ecx
 805e741:	e9 78 ff ff ff       	jmp    805e6be <__divdi3+0x7e>
 805e746:	8d 76 00             	lea    0x0(%esi),%esi
 805e749:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 805e750:	f7 d8                	neg    %eax
 805e752:	f7 d5                	not    %ebp
 805e754:	83 d2 00             	adc    $0x0,%edx
 805e757:	f7 da                	neg    %edx
 805e759:	e9 18 ff ff ff       	jmp    805e676 <__divdi3+0x36>
 805e75e:	66 90                	xchg   %ax,%ax
 805e760:	f7 5c 24 08          	negl   0x8(%esp)
 805e764:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
 805e769:	83 54 24 0c 00       	adcl   $0x0,0xc(%esp)
 805e76e:	f7 5c 24 0c          	negl   0xc(%esp)
 805e772:	e9 f3 fe ff ff       	jmp    805e66a <__divdi3+0x2a>
 805e777:	89 f6                	mov    %esi,%esi
 805e779:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 805e780:	89 d7                	mov    %edx,%edi
 805e782:	8b 54 24 14          	mov    0x14(%esp),%edx
 805e786:	b8 20 00 00 00       	mov    $0x20,%eax
 805e78b:	29 d0                	sub    %edx,%eax
 805e78d:	89 d1                	mov    %edx,%ecx
 805e78f:	8b 54 24 18          	mov    0x18(%esp),%edx
 805e793:	d3 e7                	shl    %cl,%edi
 805e795:	89 c1                	mov    %eax,%ecx
 805e797:	d3 ea                	shr    %cl,%edx
 805e799:	89 d1                	mov    %edx,%ecx
 805e79b:	8b 54 24 18          	mov    0x18(%esp),%edx
 805e79f:	09 f9                	or     %edi,%ecx
 805e7a1:	8b 7c 24 14          	mov    0x14(%esp),%edi
 805e7a5:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 805e7a9:	89 f9                	mov    %edi,%ecx
 805e7ab:	d3 e2                	shl    %cl,%edx
 805e7ad:	89 c1                	mov    %eax,%ecx
 805e7af:	89 54 24 18          	mov    %edx,0x18(%esp)
 805e7b3:	89 f2                	mov    %esi,%edx
 805e7b5:	d3 ea                	shr    %cl,%edx
 805e7b7:	89 f9                	mov    %edi,%ecx
 805e7b9:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
 805e7bd:	d3 e6                	shl    %cl,%esi
 805e7bf:	89 c1                	mov    %eax,%ecx
 805e7c1:	d3 ef                	shr    %cl,%edi
 805e7c3:	09 fe                	or     %edi,%esi
 805e7c5:	89 f0                	mov    %esi,%eax
 805e7c7:	f7 74 24 08          	divl   0x8(%esp)
 805e7cb:	89 d6                	mov    %edx,%esi
 805e7cd:	89 c7                	mov    %eax,%edi
 805e7cf:	f7 64 24 18          	mull   0x18(%esp)
 805e7d3:	39 d6                	cmp    %edx,%esi
 805e7d5:	89 54 24 08          	mov    %edx,0x8(%esp)
 805e7d9:	72 25                	jb     805e800 <__divdi3+0x1c0>
 805e7db:	0f b6 4c 24 14       	movzbl 0x14(%esp),%ecx
 805e7e0:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 805e7e4:	d3 e2                	shl    %cl,%edx
 805e7e6:	39 c2                	cmp    %eax,%edx
 805e7e8:	73 06                	jae    805e7f0 <__divdi3+0x1b0>
 805e7ea:	3b 74 24 08          	cmp    0x8(%esp),%esi
 805e7ee:	74 10                	je     805e800 <__divdi3+0x1c0>
 805e7f0:	89 f9                	mov    %edi,%ecx
 805e7f2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 805e7f9:	00 
 805e7fa:	e9 bf fe ff ff       	jmp    805e6be <__divdi3+0x7e>
 805e7ff:	90                   	nop
 805e800:	8d 4f ff             	lea    -0x1(%edi),%ecx
 805e803:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 805e80a:	00 
 805e80b:	e9 ae fe ff ff       	jmp    805e6be <__divdi3+0x7e>

0805e810 <__moddi3>:
 805e810:	55                   	push   %ebp
 805e811:	57                   	push   %edi
 805e812:	56                   	push   %esi
 805e813:	83 ec 30             	sub    $0x30,%esp
 805e816:	8b 54 24 44          	mov    0x44(%esp),%edx
 805e81a:	8b 44 24 40          	mov    0x40(%esp),%eax
 805e81e:	8b 6c 24 48          	mov    0x48(%esp),%ebp
 805e822:	8b 4c 24 4c          	mov    0x4c(%esp),%ecx
 805e826:	85 d2                	test   %edx,%edx
 805e828:	0f 88 12 01 00 00    	js     805e940 <__moddi3+0x130>
 805e82e:	89 44 24 08          	mov    %eax,0x8(%esp)
 805e832:	89 54 24 0c          	mov    %edx,0xc(%esp)
 805e836:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
 805e83d:	00 
 805e83e:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 805e845:	00 
 805e846:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
 805e84d:	00 
 805e84e:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
 805e855:	00 
 805e856:	89 c8                	mov    %ecx,%eax
 805e858:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 805e85f:	00 
 805e860:	99                   	cltd   
 805e861:	89 d0                	mov    %edx,%eax
 805e863:	8b 54 24 0c          	mov    0xc(%esp),%edx
 805e867:	c1 e8 1f             	shr    $0x1f,%eax
 805e86a:	89 04 24             	mov    %eax,(%esp)
 805e86d:	8b 44 24 08          	mov    0x8(%esp),%eax
 805e871:	89 54 24 14          	mov    %edx,0x14(%esp)
 805e875:	8b 54 24 04          	mov    0x4(%esp),%edx
 805e879:	89 44 24 28          	mov    %eax,0x28(%esp)
 805e87d:	8b 04 24             	mov    (%esp),%eax
 805e880:	f7 d8                	neg    %eax
 805e882:	83 d2 00             	adc    $0x0,%edx
 805e885:	31 c5                	xor    %eax,%ebp
 805e887:	f7 da                	neg    %edx
 805e889:	89 e8                	mov    %ebp,%eax
 805e88b:	89 d5                	mov    %edx,%ebp
 805e88d:	31 cd                	xor    %ecx,%ebp
 805e88f:	03 04 24             	add    (%esp),%eax
 805e892:	89 ea                	mov    %ebp,%edx
 805e894:	13 54 24 04          	adc    0x4(%esp),%edx
 805e898:	89 04 24             	mov    %eax,(%esp)
 805e89b:	89 c5                	mov    %eax,%ebp
 805e89d:	89 c7                	mov    %eax,%edi
 805e89f:	89 d1                	mov    %edx,%ecx
 805e8a1:	89 c2                	mov    %eax,%edx
 805e8a3:	8b 44 24 14          	mov    0x14(%esp),%eax
 805e8a7:	89 ce                	mov    %ecx,%esi
 805e8a9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 805e8ad:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 805e8b1:	85 f6                	test   %esi,%esi
 805e8b3:	75 1b                	jne    805e8d0 <__moddi3+0xc0>
 805e8b5:	39 c2                	cmp    %eax,%edx
 805e8b7:	76 67                	jbe    805e920 <__moddi3+0x110>
 805e8b9:	8b 44 24 28          	mov    0x28(%esp),%eax
 805e8bd:	8b 54 24 14          	mov    0x14(%esp),%edx
 805e8c1:	f7 34 24             	divl   (%esp)
 805e8c4:	31 c0                	xor    %eax,%eax
 805e8c6:	eb 16                	jmp    805e8de <__moddi3+0xce>
 805e8c8:	90                   	nop
 805e8c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805e8d0:	3b 74 24 14          	cmp    0x14(%esp),%esi
 805e8d4:	76 2a                	jbe    805e900 <__moddi3+0xf0>
 805e8d6:	8b 54 24 08          	mov    0x8(%esp),%edx
 805e8da:	8b 44 24 14          	mov    0x14(%esp),%eax
 805e8de:	8b 4c 24 20          	mov    0x20(%esp),%ecx
 805e8e2:	31 d1                	xor    %edx,%ecx
 805e8e4:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 805e8e8:	89 ce                	mov    %ecx,%esi
 805e8ea:	8b 4c 24 24          	mov    0x24(%esp),%ecx
 805e8ee:	31 c1                	xor    %eax,%ecx
 805e8f0:	8b 44 24 18          	mov    0x18(%esp),%eax
 805e8f4:	01 f0                	add    %esi,%eax
 805e8f6:	11 ca                	adc    %ecx,%edx
 805e8f8:	83 c4 30             	add    $0x30,%esp
 805e8fb:	5e                   	pop    %esi
 805e8fc:	5f                   	pop    %edi
 805e8fd:	5d                   	pop    %ebp
 805e8fe:	c3                   	ret    
 805e8ff:	90                   	nop
 805e900:	0f bd fe             	bsr    %esi,%edi
 805e903:	83 f7 1f             	xor    $0x1f,%edi
 805e906:	75 70                	jne    805e978 <__moddi3+0x168>
 805e908:	39 ca                	cmp    %ecx,%edx
 805e90a:	0f 86 00 01 00 00    	jbe    805ea10 <__moddi3+0x200>
 805e910:	3b 74 24 14          	cmp    0x14(%esp),%esi
 805e914:	0f 82 f6 00 00 00    	jb     805ea10 <__moddi3+0x200>
 805e91a:	89 ca                	mov    %ecx,%edx
 805e91c:	eb c0                	jmp    805e8de <__moddi3+0xce>
 805e91e:	66 90                	xchg   %ax,%ax
 805e920:	85 d2                	test   %edx,%edx
 805e922:	75 0b                	jne    805e92f <__moddi3+0x11f>
 805e924:	b8 01 00 00 00       	mov    $0x1,%eax
 805e929:	31 d2                	xor    %edx,%edx
 805e92b:	f7 f5                	div    %ebp
 805e92d:	89 c7                	mov    %eax,%edi
 805e92f:	8b 44 24 14          	mov    0x14(%esp),%eax
 805e933:	31 d2                	xor    %edx,%edx
 805e935:	f7 f7                	div    %edi
 805e937:	89 c8                	mov    %ecx,%eax
 805e939:	f7 f7                	div    %edi
 805e93b:	31 c0                	xor    %eax,%eax
 805e93d:	eb 9f                	jmp    805e8de <__moddi3+0xce>
 805e93f:	90                   	nop
 805e940:	f7 d8                	neg    %eax
 805e942:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
 805e949:	00 
 805e94a:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 805e951:	00 
 805e952:	83 d2 00             	adc    $0x0,%edx
 805e955:	89 44 24 08          	mov    %eax,0x8(%esp)
 805e959:	c7 44 24 20 ff ff ff 	movl   $0xffffffff,0x20(%esp)
 805e960:	ff 
 805e961:	f7 da                	neg    %edx
 805e963:	c7 44 24 24 ff ff ff 	movl   $0xffffffff,0x24(%esp)
 805e96a:	ff 
 805e96b:	89 54 24 0c          	mov    %edx,0xc(%esp)
 805e96f:	e9 e2 fe ff ff       	jmp    805e856 <__moddi3+0x46>
 805e974:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805e978:	b8 20 00 00 00       	mov    $0x20,%eax
 805e97d:	89 f9                	mov    %edi,%ecx
 805e97f:	29 f8                	sub    %edi,%eax
 805e981:	d3 e6                	shl    %cl,%esi
 805e983:	89 c2                	mov    %eax,%edx
 805e985:	89 44 24 2c          	mov    %eax,0x2c(%esp)
 805e989:	89 e8                	mov    %ebp,%eax
 805e98b:	89 d1                	mov    %edx,%ecx
 805e98d:	d3 e8                	shr    %cl,%eax
 805e98f:	89 f9                	mov    %edi,%ecx
 805e991:	09 f0                	or     %esi,%eax
 805e993:	d3 e5                	shl    %cl,%ebp
 805e995:	89 d1                	mov    %edx,%ecx
 805e997:	89 04 24             	mov    %eax,(%esp)
 805e99a:	8b 44 24 14          	mov    0x14(%esp),%eax
 805e99e:	89 6c 24 08          	mov    %ebp,0x8(%esp)
 805e9a2:	89 d5                	mov    %edx,%ebp
 805e9a4:	89 c6                	mov    %eax,%esi
 805e9a6:	89 c2                	mov    %eax,%edx
 805e9a8:	8b 44 24 28          	mov    0x28(%esp),%eax
 805e9ac:	d3 ee                	shr    %cl,%esi
 805e9ae:	89 f9                	mov    %edi,%ecx
 805e9b0:	d3 e2                	shl    %cl,%edx
 805e9b2:	89 e9                	mov    %ebp,%ecx
 805e9b4:	d3 e8                	shr    %cl,%eax
 805e9b6:	89 f9                	mov    %edi,%ecx
 805e9b8:	09 d0                	or     %edx,%eax
 805e9ba:	8b 54 24 28          	mov    0x28(%esp),%edx
 805e9be:	d3 e2                	shl    %cl,%edx
 805e9c0:	89 54 24 14          	mov    %edx,0x14(%esp)
 805e9c4:	89 f2                	mov    %esi,%edx
 805e9c6:	f7 34 24             	divl   (%esp)
 805e9c9:	89 d1                	mov    %edx,%ecx
 805e9cb:	f7 64 24 08          	mull   0x8(%esp)
 805e9cf:	39 d1                	cmp    %edx,%ecx
 805e9d1:	89 c5                	mov    %eax,%ebp
 805e9d3:	89 d6                	mov    %edx,%esi
 805e9d5:	72 0a                	jb     805e9e1 <__moddi3+0x1d1>
 805e9d7:	39 44 24 14          	cmp    %eax,0x14(%esp)
 805e9db:	73 0f                	jae    805e9ec <__moddi3+0x1dc>
 805e9dd:	39 d1                	cmp    %edx,%ecx
 805e9df:	75 0b                	jne    805e9ec <__moddi3+0x1dc>
 805e9e1:	89 d6                	mov    %edx,%esi
 805e9e3:	89 c5                	mov    %eax,%ebp
 805e9e5:	2b 6c 24 08          	sub    0x8(%esp),%ebp
 805e9e9:	1b 34 24             	sbb    (%esp),%esi
 805e9ec:	89 c8                	mov    %ecx,%eax
 805e9ee:	89 f9                	mov    %edi,%ecx
 805e9f0:	8b 54 24 14          	mov    0x14(%esp),%edx
 805e9f4:	29 ea                	sub    %ebp,%edx
 805e9f6:	19 f0                	sbb    %esi,%eax
 805e9f8:	d3 ea                	shr    %cl,%edx
 805e9fa:	0f b6 4c 24 2c       	movzbl 0x2c(%esp),%ecx
 805e9ff:	89 c6                	mov    %eax,%esi
 805ea01:	d3 e6                	shl    %cl,%esi
 805ea03:	89 f9                	mov    %edi,%ecx
 805ea05:	09 f2                	or     %esi,%edx
 805ea07:	d3 e8                	shr    %cl,%eax
 805ea09:	e9 d0 fe ff ff       	jmp    805e8de <__moddi3+0xce>
 805ea0e:	66 90                	xchg   %ax,%ax
 805ea10:	8b 44 24 14          	mov    0x14(%esp),%eax
 805ea14:	2b 0c 24             	sub    (%esp),%ecx
 805ea17:	1b 44 24 04          	sbb    0x4(%esp),%eax
 805ea1b:	89 ca                	mov    %ecx,%edx
 805ea1d:	e9 bc fe ff ff       	jmp    805e8de <__moddi3+0xce>
 805ea22:	66 90                	xchg   %ax,%ax
 805ea24:	66 90                	xchg   %ax,%ax
 805ea26:	66 90                	xchg   %ax,%ax
 805ea28:	66 90                	xchg   %ax,%ax
 805ea2a:	66 90                	xchg   %ax,%ax
 805ea2c:	66 90                	xchg   %ax,%ax
 805ea2e:	66 90                	xchg   %ax,%ax

0805ea30 <__udivdi3>:
 805ea30:	55                   	push   %ebp
 805ea31:	57                   	push   %edi
 805ea32:	56                   	push   %esi
 805ea33:	83 ec 10             	sub    $0x10,%esp
 805ea36:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 805ea3a:	8b 7c 24 20          	mov    0x20(%esp),%edi
 805ea3e:	8b 74 24 24          	mov    0x24(%esp),%esi
 805ea42:	8b 4c 24 28          	mov    0x28(%esp),%ecx
 805ea46:	85 d2                	test   %edx,%edx
 805ea48:	89 7c 24 04          	mov    %edi,0x4(%esp)
 805ea4c:	89 34 24             	mov    %esi,(%esp)
 805ea4f:	89 c8                	mov    %ecx,%eax
 805ea51:	75 35                	jne    805ea88 <__udivdi3+0x58>
 805ea53:	39 f1                	cmp    %esi,%ecx
 805ea55:	0f 87 bd 00 00 00    	ja     805eb18 <__udivdi3+0xe8>
 805ea5b:	85 c9                	test   %ecx,%ecx
 805ea5d:	89 cd                	mov    %ecx,%ebp
 805ea5f:	75 0b                	jne    805ea6c <__udivdi3+0x3c>
 805ea61:	b8 01 00 00 00       	mov    $0x1,%eax
 805ea66:	31 d2                	xor    %edx,%edx
 805ea68:	f7 f1                	div    %ecx
 805ea6a:	89 c5                	mov    %eax,%ebp
 805ea6c:	89 f0                	mov    %esi,%eax
 805ea6e:	31 d2                	xor    %edx,%edx
 805ea70:	f7 f5                	div    %ebp
 805ea72:	89 c6                	mov    %eax,%esi
 805ea74:	89 f8                	mov    %edi,%eax
 805ea76:	f7 f5                	div    %ebp
 805ea78:	89 f2                	mov    %esi,%edx
 805ea7a:	83 c4 10             	add    $0x10,%esp
 805ea7d:	5e                   	pop    %esi
 805ea7e:	5f                   	pop    %edi
 805ea7f:	5d                   	pop    %ebp
 805ea80:	c3                   	ret    
 805ea81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805ea88:	3b 14 24             	cmp    (%esp),%edx
 805ea8b:	77 7b                	ja     805eb08 <__udivdi3+0xd8>
 805ea8d:	0f bd f2             	bsr    %edx,%esi
 805ea90:	83 f6 1f             	xor    $0x1f,%esi
 805ea93:	0f 84 97 00 00 00    	je     805eb30 <__udivdi3+0x100>
 805ea99:	bd 20 00 00 00       	mov    $0x20,%ebp
 805ea9e:	89 d7                	mov    %edx,%edi
 805eaa0:	89 f1                	mov    %esi,%ecx
 805eaa2:	29 f5                	sub    %esi,%ebp
 805eaa4:	d3 e7                	shl    %cl,%edi
 805eaa6:	89 c2                	mov    %eax,%edx
 805eaa8:	89 e9                	mov    %ebp,%ecx
 805eaaa:	d3 ea                	shr    %cl,%edx
 805eaac:	89 f1                	mov    %esi,%ecx
 805eaae:	09 fa                	or     %edi,%edx
 805eab0:	8b 3c 24             	mov    (%esp),%edi
 805eab3:	d3 e0                	shl    %cl,%eax
 805eab5:	89 54 24 08          	mov    %edx,0x8(%esp)
 805eab9:	89 e9                	mov    %ebp,%ecx
 805eabb:	89 44 24 0c          	mov    %eax,0xc(%esp)
 805eabf:	8b 44 24 04          	mov    0x4(%esp),%eax
 805eac3:	89 fa                	mov    %edi,%edx
 805eac5:	d3 ea                	shr    %cl,%edx
 805eac7:	89 f1                	mov    %esi,%ecx
 805eac9:	d3 e7                	shl    %cl,%edi
 805eacb:	89 e9                	mov    %ebp,%ecx
 805eacd:	d3 e8                	shr    %cl,%eax
 805eacf:	09 c7                	or     %eax,%edi
 805ead1:	89 f8                	mov    %edi,%eax
 805ead3:	f7 74 24 08          	divl   0x8(%esp)
 805ead7:	89 d5                	mov    %edx,%ebp
 805ead9:	89 c7                	mov    %eax,%edi
 805eadb:	f7 64 24 0c          	mull   0xc(%esp)
 805eadf:	39 d5                	cmp    %edx,%ebp
 805eae1:	89 14 24             	mov    %edx,(%esp)
 805eae4:	72 11                	jb     805eaf7 <__udivdi3+0xc7>
 805eae6:	8b 54 24 04          	mov    0x4(%esp),%edx
 805eaea:	89 f1                	mov    %esi,%ecx
 805eaec:	d3 e2                	shl    %cl,%edx
 805eaee:	39 c2                	cmp    %eax,%edx
 805eaf0:	73 5e                	jae    805eb50 <__udivdi3+0x120>
 805eaf2:	3b 2c 24             	cmp    (%esp),%ebp
 805eaf5:	75 59                	jne    805eb50 <__udivdi3+0x120>
 805eaf7:	8d 47 ff             	lea    -0x1(%edi),%eax
 805eafa:	31 f6                	xor    %esi,%esi
 805eafc:	89 f2                	mov    %esi,%edx
 805eafe:	83 c4 10             	add    $0x10,%esp
 805eb01:	5e                   	pop    %esi
 805eb02:	5f                   	pop    %edi
 805eb03:	5d                   	pop    %ebp
 805eb04:	c3                   	ret    
 805eb05:	8d 76 00             	lea    0x0(%esi),%esi
 805eb08:	31 f6                	xor    %esi,%esi
 805eb0a:	31 c0                	xor    %eax,%eax
 805eb0c:	89 f2                	mov    %esi,%edx
 805eb0e:	83 c4 10             	add    $0x10,%esp
 805eb11:	5e                   	pop    %esi
 805eb12:	5f                   	pop    %edi
 805eb13:	5d                   	pop    %ebp
 805eb14:	c3                   	ret    
 805eb15:	8d 76 00             	lea    0x0(%esi),%esi
 805eb18:	89 f2                	mov    %esi,%edx
 805eb1a:	31 f6                	xor    %esi,%esi
 805eb1c:	89 f8                	mov    %edi,%eax
 805eb1e:	f7 f1                	div    %ecx
 805eb20:	89 f2                	mov    %esi,%edx
 805eb22:	83 c4 10             	add    $0x10,%esp
 805eb25:	5e                   	pop    %esi
 805eb26:	5f                   	pop    %edi
 805eb27:	5d                   	pop    %ebp
 805eb28:	c3                   	ret    
 805eb29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805eb30:	3b 4c 24 04          	cmp    0x4(%esp),%ecx
 805eb34:	76 0b                	jbe    805eb41 <__udivdi3+0x111>
 805eb36:	31 c0                	xor    %eax,%eax
 805eb38:	3b 14 24             	cmp    (%esp),%edx
 805eb3b:	0f 83 37 ff ff ff    	jae    805ea78 <__udivdi3+0x48>
 805eb41:	b8 01 00 00 00       	mov    $0x1,%eax
 805eb46:	e9 2d ff ff ff       	jmp    805ea78 <__udivdi3+0x48>
 805eb4b:	90                   	nop
 805eb4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805eb50:	89 f8                	mov    %edi,%eax
 805eb52:	31 f6                	xor    %esi,%esi
 805eb54:	e9 1f ff ff ff       	jmp    805ea78 <__udivdi3+0x48>
 805eb59:	66 90                	xchg   %ax,%ax
 805eb5b:	66 90                	xchg   %ax,%ax
 805eb5d:	66 90                	xchg   %ax,%ax
 805eb5f:	90                   	nop

0805eb60 <__umoddi3>:
 805eb60:	55                   	push   %ebp
 805eb61:	57                   	push   %edi
 805eb62:	56                   	push   %esi
 805eb63:	83 ec 20             	sub    $0x20,%esp
 805eb66:	8b 44 24 34          	mov    0x34(%esp),%eax
 805eb6a:	8b 4c 24 30          	mov    0x30(%esp),%ecx
 805eb6e:	8b 7c 24 38          	mov    0x38(%esp),%edi
 805eb72:	89 c6                	mov    %eax,%esi
 805eb74:	89 44 24 10          	mov    %eax,0x10(%esp)
 805eb78:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 805eb7c:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 805eb80:	89 7c 24 0c          	mov    %edi,0xc(%esp)
 805eb84:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 805eb88:	89 74 24 18          	mov    %esi,0x18(%esp)
 805eb8c:	85 c0                	test   %eax,%eax
 805eb8e:	89 c2                	mov    %eax,%edx
 805eb90:	75 1e                	jne    805ebb0 <__umoddi3+0x50>
 805eb92:	39 f7                	cmp    %esi,%edi
 805eb94:	76 52                	jbe    805ebe8 <__umoddi3+0x88>
 805eb96:	89 c8                	mov    %ecx,%eax
 805eb98:	89 f2                	mov    %esi,%edx
 805eb9a:	f7 f7                	div    %edi
 805eb9c:	89 d0                	mov    %edx,%eax
 805eb9e:	31 d2                	xor    %edx,%edx
 805eba0:	83 c4 20             	add    $0x20,%esp
 805eba3:	5e                   	pop    %esi
 805eba4:	5f                   	pop    %edi
 805eba5:	5d                   	pop    %ebp
 805eba6:	c3                   	ret    
 805eba7:	89 f6                	mov    %esi,%esi
 805eba9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 805ebb0:	39 f0                	cmp    %esi,%eax
 805ebb2:	77 5c                	ja     805ec10 <__umoddi3+0xb0>
 805ebb4:	0f bd e8             	bsr    %eax,%ebp
 805ebb7:	83 f5 1f             	xor    $0x1f,%ebp
 805ebba:	75 64                	jne    805ec20 <__umoddi3+0xc0>
 805ebbc:	8b 6c 24 14          	mov    0x14(%esp),%ebp
 805ebc0:	39 6c 24 0c          	cmp    %ebp,0xc(%esp)
 805ebc4:	0f 86 f6 00 00 00    	jbe    805ecc0 <__umoddi3+0x160>
 805ebca:	3b 44 24 18          	cmp    0x18(%esp),%eax
 805ebce:	0f 82 ec 00 00 00    	jb     805ecc0 <__umoddi3+0x160>
 805ebd4:	8b 44 24 14          	mov    0x14(%esp),%eax
 805ebd8:	8b 54 24 18          	mov    0x18(%esp),%edx
 805ebdc:	83 c4 20             	add    $0x20,%esp
 805ebdf:	5e                   	pop    %esi
 805ebe0:	5f                   	pop    %edi
 805ebe1:	5d                   	pop    %ebp
 805ebe2:	c3                   	ret    
 805ebe3:	90                   	nop
 805ebe4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805ebe8:	85 ff                	test   %edi,%edi
 805ebea:	89 fd                	mov    %edi,%ebp
 805ebec:	75 0b                	jne    805ebf9 <__umoddi3+0x99>
 805ebee:	b8 01 00 00 00       	mov    $0x1,%eax
 805ebf3:	31 d2                	xor    %edx,%edx
 805ebf5:	f7 f7                	div    %edi
 805ebf7:	89 c5                	mov    %eax,%ebp
 805ebf9:	8b 44 24 10          	mov    0x10(%esp),%eax
 805ebfd:	31 d2                	xor    %edx,%edx
 805ebff:	f7 f5                	div    %ebp
 805ec01:	89 c8                	mov    %ecx,%eax
 805ec03:	f7 f5                	div    %ebp
 805ec05:	eb 95                	jmp    805eb9c <__umoddi3+0x3c>
 805ec07:	89 f6                	mov    %esi,%esi
 805ec09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 805ec10:	89 c8                	mov    %ecx,%eax
 805ec12:	89 f2                	mov    %esi,%edx
 805ec14:	83 c4 20             	add    $0x20,%esp
 805ec17:	5e                   	pop    %esi
 805ec18:	5f                   	pop    %edi
 805ec19:	5d                   	pop    %ebp
 805ec1a:	c3                   	ret    
 805ec1b:	90                   	nop
 805ec1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805ec20:	b8 20 00 00 00       	mov    $0x20,%eax
 805ec25:	89 e9                	mov    %ebp,%ecx
 805ec27:	29 e8                	sub    %ebp,%eax
 805ec29:	d3 e2                	shl    %cl,%edx
 805ec2b:	89 c7                	mov    %eax,%edi
 805ec2d:	89 44 24 18          	mov    %eax,0x18(%esp)
 805ec31:	8b 44 24 0c          	mov    0xc(%esp),%eax
 805ec35:	89 f9                	mov    %edi,%ecx
 805ec37:	d3 e8                	shr    %cl,%eax
 805ec39:	89 c1                	mov    %eax,%ecx
 805ec3b:	8b 44 24 0c          	mov    0xc(%esp),%eax
 805ec3f:	09 d1                	or     %edx,%ecx
 805ec41:	89 fa                	mov    %edi,%edx
 805ec43:	89 4c 24 10          	mov    %ecx,0x10(%esp)
 805ec47:	89 e9                	mov    %ebp,%ecx
 805ec49:	d3 e0                	shl    %cl,%eax
 805ec4b:	89 f9                	mov    %edi,%ecx
 805ec4d:	89 44 24 0c          	mov    %eax,0xc(%esp)
 805ec51:	89 f0                	mov    %esi,%eax
 805ec53:	d3 e8                	shr    %cl,%eax
 805ec55:	89 e9                	mov    %ebp,%ecx
 805ec57:	89 c7                	mov    %eax,%edi
 805ec59:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805ec5d:	d3 e6                	shl    %cl,%esi
 805ec5f:	89 d1                	mov    %edx,%ecx
 805ec61:	89 fa                	mov    %edi,%edx
 805ec63:	d3 e8                	shr    %cl,%eax
 805ec65:	89 e9                	mov    %ebp,%ecx
 805ec67:	09 f0                	or     %esi,%eax
 805ec69:	8b 74 24 1c          	mov    0x1c(%esp),%esi
 805ec6d:	f7 74 24 10          	divl   0x10(%esp)
 805ec71:	d3 e6                	shl    %cl,%esi
 805ec73:	89 d1                	mov    %edx,%ecx
 805ec75:	f7 64 24 0c          	mull   0xc(%esp)
 805ec79:	39 d1                	cmp    %edx,%ecx
 805ec7b:	89 74 24 14          	mov    %esi,0x14(%esp)
 805ec7f:	89 d7                	mov    %edx,%edi
 805ec81:	89 c6                	mov    %eax,%esi
 805ec83:	72 0a                	jb     805ec8f <__umoddi3+0x12f>
 805ec85:	39 44 24 14          	cmp    %eax,0x14(%esp)
 805ec89:	73 10                	jae    805ec9b <__umoddi3+0x13b>
 805ec8b:	39 d1                	cmp    %edx,%ecx
 805ec8d:	75 0c                	jne    805ec9b <__umoddi3+0x13b>
 805ec8f:	89 d7                	mov    %edx,%edi
 805ec91:	89 c6                	mov    %eax,%esi
 805ec93:	2b 74 24 0c          	sub    0xc(%esp),%esi
 805ec97:	1b 7c 24 10          	sbb    0x10(%esp),%edi
 805ec9b:	89 ca                	mov    %ecx,%edx
 805ec9d:	89 e9                	mov    %ebp,%ecx
 805ec9f:	8b 44 24 14          	mov    0x14(%esp),%eax
 805eca3:	29 f0                	sub    %esi,%eax
 805eca5:	19 fa                	sbb    %edi,%edx
 805eca7:	d3 e8                	shr    %cl,%eax
 805eca9:	0f b6 4c 24 18       	movzbl 0x18(%esp),%ecx
 805ecae:	89 d7                	mov    %edx,%edi
 805ecb0:	d3 e7                	shl    %cl,%edi
 805ecb2:	89 e9                	mov    %ebp,%ecx
 805ecb4:	09 f8                	or     %edi,%eax
 805ecb6:	d3 ea                	shr    %cl,%edx
 805ecb8:	83 c4 20             	add    $0x20,%esp
 805ecbb:	5e                   	pop    %esi
 805ecbc:	5f                   	pop    %edi
 805ecbd:	5d                   	pop    %ebp
 805ecbe:	c3                   	ret    
 805ecbf:	90                   	nop
 805ecc0:	8b 74 24 10          	mov    0x10(%esp),%esi
 805ecc4:	29 f9                	sub    %edi,%ecx
 805ecc6:	19 c6                	sbb    %eax,%esi
 805ecc8:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 805eccc:	89 74 24 18          	mov    %esi,0x18(%esp)
 805ecd0:	e9 ff fe ff ff       	jmp    805ebd4 <__umoddi3+0x74>
 805ecd5:	66 90                	xchg   %ax,%ax
 805ecd7:	66 90                	xchg   %ax,%ax
 805ecd9:	66 90                	xchg   %ax,%ax
 805ecdb:	66 90                	xchg   %ax,%ax
 805ecdd:	66 90                	xchg   %ax,%ax
 805ecdf:	90                   	nop

0805ece0 <__libc_csu_init>:
 805ece0:	55                   	push   %ebp
 805ece1:	57                   	push   %edi
 805ece2:	31 ff                	xor    %edi,%edi
 805ece4:	56                   	push   %esi
 805ece5:	53                   	push   %ebx
 805ece6:	e8 b5 9f fe ff       	call   8048ca0 <__x86.get_pc_thunk.bx>
 805eceb:	81 c3 15 64 01 00    	add    $0x16415,%ebx
 805ecf1:	83 ec 1c             	sub    $0x1c,%esp
 805ecf4:	8b 6c 24 30          	mov    0x30(%esp),%ebp
 805ecf8:	8d b3 04 ff ff ff    	lea    -0xfc(%ebx),%esi
 805ecfe:	e8 01 9c fe ff       	call   8048904 <_init>
 805ed03:	8d 83 00 ff ff ff    	lea    -0x100(%ebx),%eax
 805ed09:	29 c6                	sub    %eax,%esi
 805ed0b:	c1 fe 02             	sar    $0x2,%esi
 805ed0e:	85 f6                	test   %esi,%esi
 805ed10:	74 27                	je     805ed39 <__libc_csu_init+0x59>
 805ed12:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805ed18:	8b 44 24 38          	mov    0x38(%esp),%eax
 805ed1c:	89 2c 24             	mov    %ebp,(%esp)
 805ed1f:	89 44 24 08          	mov    %eax,0x8(%esp)
 805ed23:	8b 44 24 34          	mov    0x34(%esp),%eax
 805ed27:	89 44 24 04          	mov    %eax,0x4(%esp)
 805ed2b:	ff 94 bb 00 ff ff ff 	call   *-0x100(%ebx,%edi,4)
 805ed32:	83 c7 01             	add    $0x1,%edi
 805ed35:	39 f7                	cmp    %esi,%edi
 805ed37:	75 df                	jne    805ed18 <__libc_csu_init+0x38>
 805ed39:	83 c4 1c             	add    $0x1c,%esp
 805ed3c:	5b                   	pop    %ebx
 805ed3d:	5e                   	pop    %esi
 805ed3e:	5f                   	pop    %edi
 805ed3f:	5d                   	pop    %ebp
 805ed40:	c3                   	ret    
 805ed41:	eb 0d                	jmp    805ed50 <__libc_csu_fini>
 805ed43:	90                   	nop
 805ed44:	90                   	nop
 805ed45:	90                   	nop
 805ed46:	90                   	nop
 805ed47:	90                   	nop
 805ed48:	90                   	nop
 805ed49:	90                   	nop
 805ed4a:	90                   	nop
 805ed4b:	90                   	nop
 805ed4c:	90                   	nop
 805ed4d:	90                   	nop
 805ed4e:	90                   	nop
 805ed4f:	90                   	nop

0805ed50 <__libc_csu_fini>:
 805ed50:	f3 c3                	repz ret 

Disassembly of section .fini:

0805ed54 <_fini>:
 805ed54:	53                   	push   %ebx
 805ed55:	83 ec 08             	sub    $0x8,%esp
 805ed58:	e8 43 9f fe ff       	call   8048ca0 <__x86.get_pc_thunk.bx>
 805ed5d:	81 c3 a3 63 01 00    	add    $0x163a3,%ebx
 805ed63:	83 c4 08             	add    $0x8,%esp
 805ed66:	5b                   	pop    %ebx
 805ed67:	c3                   	ret    
