
nemu:     file format elf32-i386


Disassembly of section .init:

08048904 <_init>:
 8048904:	53                   	push   %ebx
 8048905:	83 ec 08             	sub    $0x8,%esp
 8048908:	e8 93 03 00 00       	call   8048ca0 <__x86.get_pc_thunk.bx>
 804890d:	81 c3 eb c8 02 00    	add    $0x2c8eb,%ebx
 8048913:	8b 83 fc ff ff ff    	mov    -0x4(%ebx),%eax
 8048919:	85 c0                	test   %eax,%eax
 804891b:	74 05                	je     8048922 <_init+0x1e>
 804891d:	e8 4e 01 00 00       	call   8048a70 <__gmon_start__@plt>
 8048922:	83 c4 08             	add    $0x8,%esp
 8048925:	5b                   	pop    %ebx
 8048926:	c3                   	ret    

Disassembly of section .plt:

08048930 <strcmp@plt-0x10>:
 8048930:	ff 35 fc 51 07 08    	pushl  0x80751fc
 8048936:	ff 25 00 52 07 08    	jmp    *0x8075200
 804893c:	00 00                	add    %al,(%eax)
	...

08048940 <strcmp@plt>:
 8048940:	ff 25 04 52 07 08    	jmp    *0x8075204
 8048946:	68 00 00 00 00       	push   $0x0
 804894b:	e9 e0 ff ff ff       	jmp    8048930 <_init+0x2c>

08048950 <printf@plt>:
 8048950:	ff 25 08 52 07 08    	jmp    *0x8075208
 8048956:	68 08 00 00 00       	push   $0x8
 804895b:	e9 d0 ff ff ff       	jmp    8048930 <_init+0x2c>

08048960 <fflush@plt>:
 8048960:	ff 25 0c 52 07 08    	jmp    *0x807520c
 8048966:	68 10 00 00 00       	push   $0x10
 804896b:	e9 c0 ff ff ff       	jmp    8048930 <_init+0x2c>

08048970 <_setjmp@plt>:
 8048970:	ff 25 10 52 07 08    	jmp    *0x8075210
 8048976:	68 18 00 00 00       	push   $0x18
 804897b:	e9 b0 ff ff ff       	jmp    8048930 <_init+0x2c>

08048980 <free@plt>:
 8048980:	ff 25 14 52 07 08    	jmp    *0x8075214
 8048986:	68 20 00 00 00       	push   $0x20
 804898b:	e9 a0 ff ff ff       	jmp    8048930 <_init+0x2c>

08048990 <add_history@plt>:
 8048990:	ff 25 18 52 07 08    	jmp    *0x8075218
 8048996:	68 28 00 00 00       	push   $0x28
 804899b:	e9 90 ff ff ff       	jmp    8048930 <_init+0x2c>

080489a0 <memcpy@plt>:
 80489a0:	ff 25 1c 52 07 08    	jmp    *0x807521c
 80489a6:	68 30 00 00 00       	push   $0x30
 80489ab:	e9 80 ff ff ff       	jmp    8048930 <_init+0x2c>

080489b0 <fclose@plt>:
 80489b0:	ff 25 20 52 07 08    	jmp    *0x8075220
 80489b6:	68 38 00 00 00       	push   $0x38
 80489bb:	e9 70 ff ff ff       	jmp    8048930 <_init+0x2c>

080489c0 <time@plt>:
 80489c0:	ff 25 24 52 07 08    	jmp    *0x8075224
 80489c6:	68 40 00 00 00       	push   $0x40
 80489cb:	e9 60 ff ff ff       	jmp    8048930 <_init+0x2c>

080489d0 <memcmp@plt>:
 80489d0:	ff 25 28 52 07 08    	jmp    *0x8075228
 80489d6:	68 48 00 00 00       	push   $0x48
 80489db:	e9 50 ff ff ff       	jmp    8048930 <_init+0x2c>

080489e0 <_IO_putc@plt>:
 80489e0:	ff 25 2c 52 07 08    	jmp    *0x807522c
 80489e6:	68 50 00 00 00       	push   $0x50
 80489eb:	e9 40 ff ff ff       	jmp    8048930 <_init+0x2c>

080489f0 <fseek@plt>:
 80489f0:	ff 25 30 52 07 08    	jmp    *0x8075230
 80489f6:	68 58 00 00 00       	push   $0x58
 80489fb:	e9 30 ff ff ff       	jmp    8048930 <_init+0x2c>

08048a00 <readline@plt>:
 8048a00:	ff 25 34 52 07 08    	jmp    *0x8075234
 8048a06:	68 60 00 00 00       	push   $0x60
 8048a0b:	e9 20 ff ff ff       	jmp    8048930 <_init+0x2c>

08048a10 <fwrite@plt>:
 8048a10:	ff 25 38 52 07 08    	jmp    *0x8075238
 8048a16:	68 68 00 00 00       	push   $0x68
 8048a1b:	e9 10 ff ff ff       	jmp    8048930 <_init+0x2c>

08048a20 <strcat@plt>:
 8048a20:	ff 25 3c 52 07 08    	jmp    *0x807523c
 8048a26:	68 70 00 00 00       	push   $0x70
 8048a2b:	e9 00 ff ff ff       	jmp    8048930 <_init+0x2c>

08048a30 <fread@plt>:
 8048a30:	ff 25 40 52 07 08    	jmp    *0x8075240
 8048a36:	68 78 00 00 00       	push   $0x78
 8048a3b:	e9 f0 fe ff ff       	jmp    8048930 <_init+0x2c>

08048a40 <strcpy@plt>:
 8048a40:	ff 25 44 52 07 08    	jmp    *0x8075244
 8048a46:	68 80 00 00 00       	push   $0x80
 8048a4b:	e9 e0 fe ff ff       	jmp    8048930 <_init+0x2c>

08048a50 <malloc@plt>:
 8048a50:	ff 25 48 52 07 08    	jmp    *0x8075248
 8048a56:	68 88 00 00 00       	push   $0x88
 8048a5b:	e9 d0 fe ff ff       	jmp    8048930 <_init+0x2c>

08048a60 <puts@plt>:
 8048a60:	ff 25 4c 52 07 08    	jmp    *0x807524c
 8048a66:	68 90 00 00 00       	push   $0x90
 8048a6b:	e9 c0 fe ff ff       	jmp    8048930 <_init+0x2c>

08048a70 <__gmon_start__@plt>:
 8048a70:	ff 25 50 52 07 08    	jmp    *0x8075250
 8048a76:	68 98 00 00 00       	push   $0x98
 8048a7b:	e9 b0 fe ff ff       	jmp    8048930 <_init+0x2c>

08048a80 <feof@plt>:
 8048a80:	ff 25 54 52 07 08    	jmp    *0x8075254
 8048a86:	68 a0 00 00 00       	push   $0xa0
 8048a8b:	e9 a0 fe ff ff       	jmp    8048930 <_init+0x2c>

08048a90 <srand@plt>:
 8048a90:	ff 25 58 52 07 08    	jmp    *0x8075258
 8048a96:	68 a8 00 00 00       	push   $0xa8
 8048a9b:	e9 90 fe ff ff       	jmp    8048930 <_init+0x2c>

08048aa0 <strlen@plt>:
 8048aa0:	ff 25 5c 52 07 08    	jmp    *0x807525c
 8048aa6:	68 b0 00 00 00       	push   $0xb0
 8048aab:	e9 80 fe ff ff       	jmp    8048930 <_init+0x2c>

08048ab0 <__libc_start_main@plt>:
 8048ab0:	ff 25 60 52 07 08    	jmp    *0x8075260
 8048ab6:	68 b8 00 00 00       	push   $0xb8
 8048abb:	e9 70 fe ff ff       	jmp    8048930 <_init+0x2c>

08048ac0 <fprintf@plt>:
 8048ac0:	ff 25 64 52 07 08    	jmp    *0x8075264
 8048ac6:	68 c0 00 00 00       	push   $0xc0
 8048acb:	e9 60 fe ff ff       	jmp    8048930 <_init+0x2c>

08048ad0 <ftell@plt>:
 8048ad0:	ff 25 68 52 07 08    	jmp    *0x8075268
 8048ad6:	68 c8 00 00 00       	push   $0xc8
 8048adb:	e9 50 fe ff ff       	jmp    8048930 <_init+0x2c>

08048ae0 <fopen@plt>:
 8048ae0:	ff 25 6c 52 07 08    	jmp    *0x807526c
 8048ae6:	68 d0 00 00 00       	push   $0xd0
 8048aeb:	e9 40 fe ff ff       	jmp    8048930 <_init+0x2c>

08048af0 <memset@plt>:
 8048af0:	ff 25 70 52 07 08    	jmp    *0x8075270
 8048af6:	68 d8 00 00 00       	push   $0xd8
 8048afb:	e9 30 fe ff ff       	jmp    8048930 <_init+0x2c>

08048b00 <snprintf@plt>:
 8048b00:	ff 25 74 52 07 08    	jmp    *0x8075274
 8048b06:	68 e0 00 00 00       	push   $0xe0
 8048b0b:	e9 20 fe ff ff       	jmp    8048930 <_init+0x2c>

08048b10 <putchar@plt>:
 8048b10:	ff 25 78 52 07 08    	jmp    *0x8075278
 8048b16:	68 e8 00 00 00       	push   $0xe8
 8048b1b:	e9 10 fe ff ff       	jmp    8048930 <_init+0x2c>

08048b20 <regerror@plt>:
 8048b20:	ff 25 7c 52 07 08    	jmp    *0x807527c
 8048b26:	68 f0 00 00 00       	push   $0xf0
 8048b2b:	e9 00 fe ff ff       	jmp    8048930 <_init+0x2c>

08048b30 <strncpy@plt>:
 8048b30:	ff 25 80 52 07 08    	jmp    *0x8075280
 8048b36:	68 f8 00 00 00       	push   $0xf8
 8048b3b:	e9 f0 fd ff ff       	jmp    8048930 <_init+0x2c>

08048b40 <regexec@plt>:
 8048b40:	ff 25 84 52 07 08    	jmp    *0x8075284
 8048b46:	68 00 01 00 00       	push   $0x100
 8048b4b:	e9 e0 fd ff ff       	jmp    8048930 <_init+0x2c>

08048b50 <rand@plt>:
 8048b50:	ff 25 88 52 07 08    	jmp    *0x8075288
 8048b56:	68 08 01 00 00       	push   $0x108
 8048b5b:	e9 d0 fd ff ff       	jmp    8048930 <_init+0x2c>

08048b60 <strtok@plt>:
 8048b60:	ff 25 8c 52 07 08    	jmp    *0x807528c
 8048b66:	68 10 01 00 00       	push   $0x110
 8048b6b:	e9 c0 fd ff ff       	jmp    8048930 <_init+0x2c>

08048b70 <fputc@plt>:
 8048b70:	ff 25 90 52 07 08    	jmp    *0x8075290
 8048b76:	68 18 01 00 00       	push   $0x118
 8048b7b:	e9 b0 fd ff ff       	jmp    8048930 <_init+0x2c>

08048b80 <regcomp@plt>:
 8048b80:	ff 25 94 52 07 08    	jmp    *0x8075294
 8048b86:	68 20 01 00 00       	push   $0x120
 8048b8b:	e9 a0 fd ff ff       	jmp    8048930 <_init+0x2c>

08048b90 <sprintf@plt>:
 8048b90:	ff 25 98 52 07 08    	jmp    *0x8075298
 8048b96:	68 28 01 00 00       	push   $0x128
 8048b9b:	e9 90 fd ff ff       	jmp    8048930 <_init+0x2c>

08048ba0 <strtol@plt>:
 8048ba0:	ff 25 9c 52 07 08    	jmp    *0x807529c
 8048ba6:	68 30 01 00 00       	push   $0x130
 8048bab:	e9 80 fd ff ff       	jmp    8048930 <_init+0x2c>

08048bb0 <__assert_fail@plt>:
 8048bb0:	ff 25 a0 52 07 08    	jmp    *0x80752a0
 8048bb6:	68 38 01 00 00       	push   $0x138
 8048bbb:	e9 70 fd ff ff       	jmp    8048930 <_init+0x2c>

Disassembly of section .text:

08048bc0 <check_reg_index.part.0>:

} CPU_state;

extern CPU_state cpu;

static inline int check_reg_index(int index) {
 8048bc0:	83 ec 0c             	sub    $0xc,%esp
	assert(index >= 0 && index < 8);
 8048bc3:	68 8b f0 05 08       	push   $0x805f08b
 8048bc8:	6a 3e                	push   $0x3e
 8048bca:	68 1b ee 05 08       	push   $0x805ee1b
 8048bcf:	68 32 ee 05 08       	push   $0x805ee32
 8048bd4:	e8 d7 ff ff ff       	call   8048bb0 <__assert_fail@plt>

08048bd9 <check_reg_index.part.0>:

} CPU_state;

extern CPU_state cpu;

static inline int check_reg_index(int index) {
 8048bd9:	83 ec 0c             	sub    $0xc,%esp
	assert(index >= 0 && index < 8);
 8048bdc:	68 39 06 06 08       	push   $0x8060639
 8048be1:	6a 3e                	push   $0x3e
 8048be3:	68 1b ee 05 08       	push   $0x805ee1b
 8048be8:	68 32 ee 05 08       	push   $0x805ee32
 8048bed:	e8 be ff ff ff       	call   8048bb0 <__assert_fail@plt>

08048bf2 <check_reg_index.part.0>:

} CPU_state;

extern CPU_state cpu;

static inline int check_reg_index(int index) {
 8048bf2:	83 ec 0c             	sub    $0xc,%esp
	assert(index >= 0 && index < 8);
 8048bf5:	68 c9 0a 06 08       	push   $0x8060ac9
 8048bfa:	6a 3e                	push   $0x3e
 8048bfc:	68 1b ee 05 08       	push   $0x805ee1b
 8048c01:	68 32 ee 05 08       	push   $0x805ee32
 8048c06:	e8 a5 ff ff ff       	call   8048bb0 <__assert_fail@plt>

08048c0b <check_reg_index.part.0>:

} CPU_state;

extern CPU_state cpu;

static inline int check_reg_index(int index) {
 8048c0b:	83 ec 0c             	sub    $0xc,%esp
	assert(index >= 0 && index < 8);
 8048c0e:	68 32 5a 06 08       	push   $0x8065a32
 8048c13:	6a 3e                	push   $0x3e
 8048c15:	68 1b ee 05 08       	push   $0x805ee1b
 8048c1a:	68 32 ee 05 08       	push   $0x805ee32
 8048c1f:	e8 8c ff ff ff       	call   8048bb0 <__assert_fail@plt>

08048c24 <check_reg_index.part.0>:

} CPU_state;

extern CPU_state cpu;

static inline int check_reg_index(int index) {
 8048c24:	83 ec 0c             	sub    $0xc,%esp
	assert(index >= 0 && index < 8);
 8048c27:	68 8e 5a 06 08       	push   $0x8065a8e
 8048c2c:	6a 3e                	push   $0x3e
 8048c2e:	68 1b ee 05 08       	push   $0x805ee1b
 8048c33:	68 32 ee 05 08       	push   $0x805ee32
 8048c38:	e8 73 ff ff ff       	call   8048bb0 <__assert_fail@plt>
 8048c3d:	66 90                	xchg   %ax,%ax
 8048c3f:	90                   	nop

08048c40 <main>:
void init_monitor(int, char *[]);
void reg_test();
void restart();
void ui_mainloop();

int main(int argc, char *argv[]) {
 8048c40:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 8048c44:	83 e4 f0             	and    $0xfffffff0,%esp
 8048c47:	ff 71 fc             	pushl  -0x4(%ecx)
 8048c4a:	55                   	push   %ebp
 8048c4b:	89 e5                	mov    %esp,%ebp
 8048c4d:	51                   	push   %ecx
 8048c4e:	83 ec 0c             	sub    $0xc,%esp

	/* Initialize the monitor. */
	init_monitor(argc, argv);
 8048c51:	ff 71 04             	pushl  0x4(%ecx)
 8048c54:	ff 31                	pushl  (%ecx)
 8048c56:	e8 15 01 00 00       	call   8048d70 <init_monitor>

	/* Test the implementation of the ``CPU_state'' structure. */
	reg_test();
 8048c5b:	e8 60 46 01 00       	call   805d2c0 <reg_test>

	/* Initialize the virtual computer system. */
	restart();
 8048c60:	e8 eb 01 00 00       	call   8048e50 <restart>

	/* Receive commands from user. */
	ui_mainloop();
 8048c65:	e8 c6 0f 00 00       	call   8049c30 <ui_mainloop>

	return 0;
}
 8048c6a:	8b 4d fc             	mov    -0x4(%ebp),%ecx
	restart();

	/* Receive commands from user. */
	ui_mainloop();

	return 0;
 8048c6d:	83 c4 10             	add    $0x10,%esp
}
 8048c70:	31 c0                	xor    %eax,%eax
 8048c72:	c9                   	leave  
 8048c73:	8d 61 fc             	lea    -0x4(%ecx),%esp
 8048c76:	c3                   	ret    

08048c77 <_start>:
 8048c77:	31 ed                	xor    %ebp,%ebp
 8048c79:	5e                   	pop    %esi
 8048c7a:	89 e1                	mov    %esp,%ecx
 8048c7c:	83 e4 f0             	and    $0xfffffff0,%esp
 8048c7f:	50                   	push   %eax
 8048c80:	54                   	push   %esp
 8048c81:	52                   	push   %edx
 8048c82:	68 50 e8 05 08       	push   $0x805e850
 8048c87:	68 e0 e7 05 08       	push   $0x805e7e0
 8048c8c:	51                   	push   %ecx
 8048c8d:	56                   	push   %esi
 8048c8e:	68 40 8c 04 08       	push   $0x8048c40
 8048c93:	e8 18 fe ff ff       	call   8048ab0 <__libc_start_main@plt>
 8048c98:	f4                   	hlt    
 8048c99:	66 90                	xchg   %ax,%ax
 8048c9b:	66 90                	xchg   %ax,%ax
 8048c9d:	66 90                	xchg   %ax,%ax
 8048c9f:	90                   	nop

08048ca0 <__x86.get_pc_thunk.bx>:
 8048ca0:	8b 1c 24             	mov    (%esp),%ebx
 8048ca3:	c3                   	ret    
 8048ca4:	66 90                	xchg   %ax,%ax
 8048ca6:	66 90                	xchg   %ax,%ax
 8048ca8:	66 90                	xchg   %ax,%ax
 8048caa:	66 90                	xchg   %ax,%ax
 8048cac:	66 90                	xchg   %ax,%ax
 8048cae:	66 90                	xchg   %ax,%ax

08048cb0 <deregister_tm_clones>:
 8048cb0:	b8 e3 5c 07 08       	mov    $0x8075ce3,%eax
 8048cb5:	2d e0 5c 07 08       	sub    $0x8075ce0,%eax
 8048cba:	83 f8 06             	cmp    $0x6,%eax
 8048cbd:	76 1a                	jbe    8048cd9 <deregister_tm_clones+0x29>
 8048cbf:	b8 00 00 00 00       	mov    $0x0,%eax
 8048cc4:	85 c0                	test   %eax,%eax
 8048cc6:	74 11                	je     8048cd9 <deregister_tm_clones+0x29>
 8048cc8:	55                   	push   %ebp
 8048cc9:	89 e5                	mov    %esp,%ebp
 8048ccb:	83 ec 14             	sub    $0x14,%esp
 8048cce:	68 e0 5c 07 08       	push   $0x8075ce0
 8048cd3:	ff d0                	call   *%eax
 8048cd5:	83 c4 10             	add    $0x10,%esp
 8048cd8:	c9                   	leave  
 8048cd9:	f3 c3                	repz ret 
 8048cdb:	90                   	nop
 8048cdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08048ce0 <register_tm_clones>:
 8048ce0:	b8 e0 5c 07 08       	mov    $0x8075ce0,%eax
 8048ce5:	2d e0 5c 07 08       	sub    $0x8075ce0,%eax
 8048cea:	c1 f8 02             	sar    $0x2,%eax
 8048ced:	89 c2                	mov    %eax,%edx
 8048cef:	c1 ea 1f             	shr    $0x1f,%edx
 8048cf2:	01 d0                	add    %edx,%eax
 8048cf4:	d1 f8                	sar    %eax
 8048cf6:	74 1b                	je     8048d13 <register_tm_clones+0x33>
 8048cf8:	ba 00 00 00 00       	mov    $0x0,%edx
 8048cfd:	85 d2                	test   %edx,%edx
 8048cff:	74 12                	je     8048d13 <register_tm_clones+0x33>
 8048d01:	55                   	push   %ebp
 8048d02:	89 e5                	mov    %esp,%ebp
 8048d04:	83 ec 10             	sub    $0x10,%esp
 8048d07:	50                   	push   %eax
 8048d08:	68 e0 5c 07 08       	push   $0x8075ce0
 8048d0d:	ff d2                	call   *%edx
 8048d0f:	83 c4 10             	add    $0x10,%esp
 8048d12:	c9                   	leave  
 8048d13:	f3 c3                	repz ret 
 8048d15:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8048d19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08048d20 <__do_global_dtors_aux>:
 8048d20:	80 3d 24 5d 07 08 00 	cmpb   $0x0,0x8075d24
 8048d27:	75 13                	jne    8048d3c <__do_global_dtors_aux+0x1c>
 8048d29:	55                   	push   %ebp
 8048d2a:	89 e5                	mov    %esp,%ebp
 8048d2c:	83 ec 08             	sub    $0x8,%esp
 8048d2f:	e8 7c ff ff ff       	call   8048cb0 <deregister_tm_clones>
 8048d34:	c6 05 24 5d 07 08 01 	movb   $0x1,0x8075d24
 8048d3b:	c9                   	leave  
 8048d3c:	f3 c3                	repz ret 
 8048d3e:	66 90                	xchg   %ax,%ax

08048d40 <frame_dummy>:
 8048d40:	b8 00 51 07 08       	mov    $0x8075100,%eax
 8048d45:	8b 10                	mov    (%eax),%edx
 8048d47:	85 d2                	test   %edx,%edx
 8048d49:	75 05                	jne    8048d50 <frame_dummy+0x10>
 8048d4b:	eb 93                	jmp    8048ce0 <register_tm_clones>
 8048d4d:	8d 76 00             	lea    0x0(%esi),%esi
 8048d50:	ba 00 00 00 00       	mov    $0x0,%edx
 8048d55:	85 d2                	test   %edx,%edx
 8048d57:	74 f2                	je     8048d4b <frame_dummy+0xb>
 8048d59:	55                   	push   %ebp
 8048d5a:	89 e5                	mov    %esp,%ebp
 8048d5c:	83 ec 14             	sub    $0x14,%esp
 8048d5f:	50                   	push   %eax
 8048d60:	ff d2                	call   *%edx
 8048d62:	83 c4 10             	add    $0x10,%esp
 8048d65:	c9                   	leave  
 8048d66:	e9 75 ff ff ff       	jmp    8048ce0 <register_tm_clones>
 8048d6b:	66 90                	xchg   %ax,%ax
 8048d6d:	66 90                	xchg   %ax,%ax
 8048d6f:	90                   	nop

08048d70 <init_monitor>:
static void welcome() {
	printf("Welcome to NEMU!\nThe executable is %s.\nFor help, type \"help\"\n",
			exec_file);
}

void init_monitor(int argc, char *argv[]) {
 8048d70:	56                   	push   %esi
 8048d71:	53                   	push   %ebx
 8048d72:	83 ec 0c             	sub    $0xc,%esp
 8048d75:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 8048d79:	8b 74 24 1c          	mov    0x1c(%esp),%esi
void init_l1cache();

FILE *log_fp = NULL;

static void init_log() {
	log_fp = fopen("log.txt", "w");
 8048d7d:	68 88 e8 05 08       	push   $0x805e888
 8048d82:	68 8a e8 05 08       	push   $0x805e88a
 8048d87:	e8 54 fd ff ff       	call   8048ae0 <fopen@plt>
	Assert(log_fp, "Can not open 'log.txt'");
 8048d8c:	83 c4 10             	add    $0x10,%esp
 8048d8f:	85 c0                	test   %eax,%eax
void init_l1cache();

FILE *log_fp = NULL;

static void init_log() {
	log_fp = fopen("log.txt", "w");
 8048d91:	a3 28 5d 07 08       	mov    %eax,0x8075d28
	Assert(log_fp, "Can not open 'log.txt'");
 8048d96:	74 38                	je     8048dd0 <init_monitor+0x60>

	/* Open the log file. */
	init_log();

	/* Load the string table and symbol table from the ELF file for future use. */
	load_elf_tables(argc, argv);
 8048d98:	83 ec 08             	sub    $0x8,%esp
 8048d9b:	56                   	push   %esi
 8048d9c:	53                   	push   %ebx
 8048d9d:	e8 1e 03 00 00       	call   80490c0 <load_elf_tables>

	/* Compile the regular expressions. */
	init_regex();
 8048da2:	e8 19 12 00 00       	call   8049fc0 <init_regex>

	/* Initialize the watchpoint link list. */
	init_wp_list();
 8048da7:	e8 44 0f 00 00       	call   8049cf0 <init_wp_list>
	log_fp = fopen("log.txt", "w");
	Assert(log_fp, "Can not open 'log.txt'");
}

static void welcome() {
	printf("Welcome to NEMU!\nThe executable is %s.\nFor help, type \"help\"\n",
 8048dac:	a1 2c 5d 07 08       	mov    0x8075d2c,%eax
 8048db1:	c7 44 24 20 44 e9 05 	movl   $0x805e944,0x20(%esp)
 8048db8:	08 
 8048db9:	89 44 24 24          	mov    %eax,0x24(%esp)
	/* Initialize the watchpoint link list. */
	init_wp_list();

	/* Display welcome message. */
	welcome();
}
 8048dbd:	83 c4 14             	add    $0x14,%esp
 8048dc0:	5b                   	pop    %ebx
 8048dc1:	5e                   	pop    %esi
	log_fp = fopen("log.txt", "w");
	Assert(log_fp, "Can not open 'log.txt'");
}

static void welcome() {
	printf("Welcome to NEMU!\nThe executable is %s.\nFor help, type \"help\"\n",
 8048dc2:	e9 89 fb ff ff       	jmp    8048950 <printf@plt>
 8048dc7:	89 f6                	mov    %esi,%esi
 8048dc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

FILE *log_fp = NULL;

static void init_log() {
	log_fp = fopen("log.txt", "w");
	Assert(log_fp, "Can not open 'log.txt'");
 8048dd0:	83 ec 0c             	sub    $0xc,%esp
 8048dd3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8048dd9:	e8 82 fb ff ff       	call   8048960 <fflush@plt>
 8048dde:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8048de4:	6a 07                	push   $0x7
 8048de6:	6a 01                	push   $0x1
 8048de8:	68 92 e8 05 08       	push   $0x805e892
 8048ded:	e8 1e fc ff ff       	call   8048a10 <fwrite@plt>
 8048df2:	83 c4 20             	add    $0x20,%esp
 8048df5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8048dfb:	6a 16                	push   $0x16
 8048dfd:	6a 01                	push   $0x1
 8048dff:	68 9a e8 05 08       	push   $0x805e89a
 8048e04:	e8 07 fc ff ff       	call   8048a10 <fwrite@plt>
 8048e09:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8048e0f:	6a 05                	push   $0x5
 8048e11:	6a 01                	push   $0x1
 8048e13:	68 42 f3 05 08       	push   $0x805f342
 8048e18:	e8 f3 fb ff ff       	call   8048a10 <fwrite@plt>
 8048e1d:	a1 28 5d 07 08       	mov    0x8075d28,%eax
 8048e22:	83 c4 20             	add    $0x20,%esp
 8048e25:	85 c0                	test   %eax,%eax
 8048e27:	0f 85 6b ff ff ff    	jne    8048d98 <init_monitor+0x28>
 8048e2d:	68 9a e9 05 08       	push   $0x805e99a
 8048e32:	6a 13                	push   $0x13
 8048e34:	68 b1 e8 05 08       	push   $0x805e8b1
 8048e39:	68 cc e8 05 08       	push   $0x805e8cc
 8048e3e:	e8 6d fd ff ff       	call   8048bb0 <__assert_fail@plt>
 8048e43:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8048e49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08048e50 <restart>:
	ret = fread(hwa_to_va(ENTRY_START), file_size, 1, fp);
	assert(ret == 1);
	fclose(fp);
}

void restart() {
 8048e50:	56                   	push   %esi
 8048e51:	53                   	push   %ebx
 8048e52:	83 ec 0c             	sub    $0xc,%esp

#ifdef USE_RAMDISK
static void init_ramdisk() {
	int ret;
	const int ramdisk_max_size = 0xa0000;
	FILE *fp = fopen(exec_file, "rb");
 8048e55:	68 d3 e8 05 08       	push   $0x805e8d3
 8048e5a:	ff 35 2c 5d 07 08    	pushl  0x8075d2c
 8048e60:	e8 7b fc ff ff       	call   8048ae0 <fopen@plt>
	Assert(fp, "Can not open '%s'", exec_file);
 8048e65:	83 c4 10             	add    $0x10,%esp
 8048e68:	85 c0                	test   %eax,%eax

#ifdef USE_RAMDISK
static void init_ramdisk() {
	int ret;
	const int ramdisk_max_size = 0xa0000;
	FILE *fp = fopen(exec_file, "rb");
 8048e6a:	89 c3                	mov    %eax,%ebx
	Assert(fp, "Can not open '%s'", exec_file);
 8048e6c:	0f 84 46 01 00 00    	je     8048fb8 <restart+0x168>

	fseek(fp, 0, SEEK_END);
 8048e72:	83 ec 04             	sub    $0x4,%esp
 8048e75:	6a 02                	push   $0x2
 8048e77:	6a 00                	push   $0x0
 8048e79:	50                   	push   %eax
 8048e7a:	e8 71 fb ff ff       	call   80489f0 <fseek@plt>
	size_t file_size = ftell(fp);
 8048e7f:	89 1c 24             	mov    %ebx,(%esp)
 8048e82:	e8 49 fc ff ff       	call   8048ad0 <ftell@plt>
	Assert(file_size < ramdisk_max_size, "file size(%zd) too large", file_size);
 8048e87:	83 c4 10             	add    $0x10,%esp
 8048e8a:	3d ff ff 09 00       	cmp    $0x9ffff,%eax
	const int ramdisk_max_size = 0xa0000;
	FILE *fp = fopen(exec_file, "rb");
	Assert(fp, "Can not open '%s'", exec_file);

	fseek(fp, 0, SEEK_END);
	size_t file_size = ftell(fp);
 8048e8f:	89 c6                	mov    %eax,%esi
	Assert(file_size < ramdisk_max_size, "file size(%zd) too large", file_size);
 8048e91:	76 6d                	jbe    8048f00 <restart+0xb0>
 8048e93:	83 ec 0c             	sub    $0xc,%esp
 8048e96:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8048e9c:	e8 bf fa ff ff       	call   8048960 <fflush@plt>
 8048ea1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8048ea7:	6a 07                	push   $0x7
 8048ea9:	6a 01                	push   $0x1
 8048eab:	68 92 e8 05 08       	push   $0x805e892
 8048eb0:	e8 5b fb ff ff       	call   8048a10 <fwrite@plt>
 8048eb5:	83 c4 1c             	add    $0x1c,%esp
 8048eb8:	56                   	push   %esi
 8048eb9:	68 0c e9 05 08       	push   $0x805e90c
 8048ebe:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8048ec4:	e8 f7 fb ff ff       	call   8048ac0 <fprintf@plt>
 8048ec9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8048ecf:	6a 05                	push   $0x5
 8048ed1:	6a 01                	push   $0x1
 8048ed3:	68 42 f3 05 08       	push   $0x805f342
 8048ed8:	e8 33 fb ff ff       	call   8048a10 <fwrite@plt>
 8048edd:	83 c4 20             	add    $0x20,%esp
 8048ee0:	68 8d e9 05 08       	push   $0x805e98d
 8048ee5:	6a 37                	push   $0x37
 8048ee7:	68 b1 e8 05 08       	push   $0x805e8b1
 8048eec:	68 25 e9 05 08       	push   $0x805e925
 8048ef1:	e8 ba fc ff ff       	call   8048bb0 <__assert_fail@plt>
 8048ef6:	8d 76 00             	lea    0x0(%esi),%esi
 8048ef9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

	fseek(fp, 0, SEEK_SET);
 8048f00:	83 ec 04             	sub    $0x4,%esp
 8048f03:	6a 00                	push   $0x0
 8048f05:	6a 00                	push   $0x0
 8048f07:	53                   	push   %ebx
 8048f08:	e8 e3 fa ff ff       	call   80489f0 <fseek@plt>
	ret = fread(hwa_to_va(0), file_size, 1, fp);
 8048f0d:	53                   	push   %ebx
 8048f0e:	6a 01                	push   $0x1
 8048f10:	56                   	push   %esi
 8048f11:	ff 35 c8 52 07 08    	pushl  0x80752c8
 8048f17:	e8 14 fb ff ff       	call   8048a30 <fread@plt>
	assert(ret == 1);
 8048f1c:	83 c4 20             	add    $0x20,%esp
 8048f1f:	83 f8 01             	cmp    $0x1,%eax
 8048f22:	0f 85 5e 01 00 00    	jne    8049086 <restart+0x236>
	fclose(fp);
 8048f28:	83 ec 0c             	sub    $0xc,%esp
 8048f2b:	53                   	push   %ebx
 8048f2c:	e8 7f fa ff ff       	call   80489b0 <fclose@plt>
}
#endif

static void load_entry() {
	int ret;
	FILE *fp = fopen("entry", "rb");
 8048f31:	58                   	pop    %eax
 8048f32:	5a                   	pop    %edx
 8048f33:	68 d3 e8 05 08       	push   $0x805e8d3
 8048f38:	68 f1 e8 05 08       	push   $0x805e8f1
 8048f3d:	e8 9e fb ff ff       	call   8048ae0 <fopen@plt>
	Assert(fp, "Can not open 'entry'");
 8048f42:	83 c4 10             	add    $0x10,%esp
 8048f45:	85 c0                	test   %eax,%eax
}
#endif

static void load_entry() {
	int ret;
	FILE *fp = fopen("entry", "rb");
 8048f47:	89 c3                	mov    %eax,%ebx
	Assert(fp, "Can not open 'entry'");
 8048f49:	0f 84 d1 00 00 00    	je     8049020 <restart+0x1d0>

	fseek(fp, 0, SEEK_END);
 8048f4f:	83 ec 04             	sub    $0x4,%esp
 8048f52:	6a 02                	push   $0x2
 8048f54:	6a 00                	push   $0x0
 8048f56:	50                   	push   %eax
 8048f57:	e8 94 fa ff ff       	call   80489f0 <fseek@plt>
	size_t file_size = ftell(fp);
 8048f5c:	89 1c 24             	mov    %ebx,(%esp)
 8048f5f:	e8 6c fb ff ff       	call   8048ad0 <ftell@plt>

	fseek(fp, 0, SEEK_SET);
 8048f64:	83 c4 0c             	add    $0xc,%esp
	int ret;
	FILE *fp = fopen("entry", "rb");
	Assert(fp, "Can not open 'entry'");

	fseek(fp, 0, SEEK_END);
	size_t file_size = ftell(fp);
 8048f67:	89 c6                	mov    %eax,%esi

	fseek(fp, 0, SEEK_SET);
 8048f69:	6a 00                	push   $0x0
 8048f6b:	6a 00                	push   $0x0
 8048f6d:	53                   	push   %ebx
 8048f6e:	e8 7d fa ff ff       	call   80489f0 <fseek@plt>
	ret = fread(hwa_to_va(ENTRY_START), file_size, 1, fp);
 8048f73:	a1 c8 52 07 08       	mov    0x80752c8,%eax
 8048f78:	53                   	push   %ebx
 8048f79:	6a 01                	push   $0x1
 8048f7b:	56                   	push   %esi
 8048f7c:	05 00 00 10 00       	add    $0x100000,%eax
 8048f81:	50                   	push   %eax
 8048f82:	e8 a9 fa ff ff       	call   8048a30 <fread@plt>
	assert(ret == 1);
 8048f87:	83 c4 20             	add    $0x20,%esp
 8048f8a:	83 f8 01             	cmp    $0x1,%eax
 8048f8d:	0f 85 09 01 00 00    	jne    804909c <restart+0x24c>
	fclose(fp);
 8048f93:	83 ec 0c             	sub    $0xc,%esp
 8048f96:	53                   	push   %ebx
 8048f97:	e8 14 fa ff ff       	call   80489b0 <fclose@plt>

	/* Read the entry code into memory. */
	load_entry();

	/* Set the initial instruction pointer. */
	cpu.eip = ENTRY_START;
 8048f9c:	c7 05 e0 af 0f 10 00 	movl   $0x100000,0x100fafe0
 8048fa3:	00 10 00 

	/* Initialize DRAM. */
	init_ddr3();
 8048fa6:	e8 55 23 00 00       	call   804b300 <init_ddr3>
	init_l1cache();
}
 8048fab:	83 c4 14             	add    $0x14,%esp
 8048fae:	5b                   	pop    %ebx
 8048faf:	5e                   	pop    %esi
	/* Set the initial instruction pointer. */
	cpu.eip = ENTRY_START;

	/* Initialize DRAM. */
	init_ddr3();
	init_l1cache();
 8048fb0:	e9 4b 24 00 00       	jmp    804b400 <init_l1cache>
 8048fb5:	8d 76 00             	lea    0x0(%esi),%esi
#ifdef USE_RAMDISK
static void init_ramdisk() {
	int ret;
	const int ramdisk_max_size = 0xa0000;
	FILE *fp = fopen(exec_file, "rb");
	Assert(fp, "Can not open '%s'", exec_file);
 8048fb8:	83 ec 0c             	sub    $0xc,%esp
 8048fbb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8048fc1:	e8 9a f9 ff ff       	call   8048960 <fflush@plt>
 8048fc6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8048fcc:	6a 07                	push   $0x7
 8048fce:	6a 01                	push   $0x1
 8048fd0:	68 92 e8 05 08       	push   $0x805e892
 8048fd5:	e8 36 fa ff ff       	call   8048a10 <fwrite@plt>
 8048fda:	83 c4 1c             	add    $0x1c,%esp
 8048fdd:	ff 35 2c 5d 07 08    	pushl  0x8075d2c
 8048fe3:	68 d6 e8 05 08       	push   $0x805e8d6
 8048fe8:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8048fee:	e8 cd fa ff ff       	call   8048ac0 <fprintf@plt>
 8048ff3:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8048ff9:	6a 05                	push   $0x5
 8048ffb:	6a 01                	push   $0x1
 8048ffd:	68 42 f3 05 08       	push   $0x805f342
 8049002:	e8 09 fa ff ff       	call   8048a10 <fwrite@plt>
 8049007:	83 c4 20             	add    $0x20,%esp
 804900a:	68 8d e9 05 08       	push   $0x805e98d
 804900f:	6a 33                	push   $0x33
 8049011:	68 b1 e8 05 08       	push   $0x805e8b1
 8049016:	68 d0 e8 05 08       	push   $0x805e8d0
 804901b:	e8 90 fb ff ff       	call   8048bb0 <__assert_fail@plt>
#endif

static void load_entry() {
	int ret;
	FILE *fp = fopen("entry", "rb");
	Assert(fp, "Can not open 'entry'");
 8049020:	83 ec 0c             	sub    $0xc,%esp
 8049023:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8049029:	e8 32 f9 ff ff       	call   8048960 <fflush@plt>
 804902e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8049034:	6a 07                	push   $0x7
 8049036:	6a 01                	push   $0x1
 8049038:	68 92 e8 05 08       	push   $0x805e892
 804903d:	e8 ce f9 ff ff       	call   8048a10 <fwrite@plt>
 8049042:	83 c4 20             	add    $0x20,%esp
 8049045:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804904b:	6a 14                	push   $0x14
 804904d:	6a 01                	push   $0x1
 804904f:	68 f7 e8 05 08       	push   $0x805e8f7
 8049054:	e8 b7 f9 ff ff       	call   8048a10 <fwrite@plt>
 8049059:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804905f:	6a 05                	push   $0x5
 8049061:	6a 01                	push   $0x1
 8049063:	68 42 f3 05 08       	push   $0x805f342
 8049068:	e8 a3 f9 ff ff       	call   8048a10 <fwrite@plt>
 804906d:	83 c4 20             	add    $0x20,%esp
 8049070:	68 82 e9 05 08       	push   $0x805e982
 8049075:	6a 43                	push   $0x43
 8049077:	68 b1 e8 05 08       	push   $0x805e8b1
 804907c:	68 d0 e8 05 08       	push   $0x805e8d0
 8049081:	e8 2a fb ff ff       	call   8048bb0 <__assert_fail@plt>
	size_t file_size = ftell(fp);
	Assert(file_size < ramdisk_max_size, "file size(%zd) too large", file_size);

	fseek(fp, 0, SEEK_SET);
	ret = fread(hwa_to_va(0), file_size, 1, fp);
	assert(ret == 1);
 8049086:	68 8d e9 05 08       	push   $0x805e98d
 804908b:	6a 3b                	push   $0x3b
 804908d:	68 b1 e8 05 08       	push   $0x805e8b1
 8049092:	68 e8 e8 05 08       	push   $0x805e8e8
 8049097:	e8 14 fb ff ff       	call   8048bb0 <__assert_fail@plt>
	fseek(fp, 0, SEEK_END);
	size_t file_size = ftell(fp);

	fseek(fp, 0, SEEK_SET);
	ret = fread(hwa_to_va(ENTRY_START), file_size, 1, fp);
	assert(ret == 1);
 804909c:	68 82 e9 05 08       	push   $0x805e982
 80490a1:	6a 4a                	push   $0x4a
 80490a3:	68 b1 e8 05 08       	push   $0x805e8b1
 80490a8:	68 e8 e8 05 08       	push   $0x805e8e8
 80490ad:	e8 fe fa ff ff       	call   8048bb0 <__assert_fail@plt>
 80490b2:	66 90                	xchg   %ax,%ax
 80490b4:	66 90                	xchg   %ax,%ax
 80490b6:	66 90                	xchg   %ax,%ax
 80490b8:	66 90                	xchg   %ax,%ax
 80490ba:	66 90                	xchg   %ax,%ax
 80490bc:	66 90                	xchg   %ax,%ax
 80490be:	66 90                	xchg   %ax,%ax

080490c0 <load_elf_tables>:

static char *strtab = NULL;
static Elf32_Sym *symtab = NULL;
static int nr_symtab_entry;

void load_elf_tables(int argc, char *argv[]) {
 80490c0:	55                   	push   %ebp
 80490c1:	57                   	push   %edi
 80490c2:	56                   	push   %esi
 80490c3:	53                   	push   %ebx
 80490c4:	83 ec 5c             	sub    $0x5c,%esp
	int ret;
	Assert(argc == 2, "run NEMU with format 'nemu [program]'");
 80490c7:	83 7c 24 70 02       	cmpl   $0x2,0x70(%esp)
 80490cc:	74 66                	je     8049134 <load_elf_tables+0x74>
 80490ce:	83 ec 0c             	sub    $0xc,%esp
 80490d1:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80490d7:	e8 84 f8 ff ff       	call   8048960 <fflush@plt>
 80490dc:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80490e2:	6a 07                	push   $0x7
 80490e4:	6a 01                	push   $0x1
 80490e6:	68 92 e8 05 08       	push   $0x805e892
 80490eb:	e8 20 f9 ff ff       	call   8048a10 <fwrite@plt>
 80490f0:	83 c4 20             	add    $0x20,%esp
 80490f3:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80490f9:	6a 25                	push   $0x25
 80490fb:	6a 01                	push   $0x1
 80490fd:	68 68 ea 05 08       	push   $0x805ea68
 8049102:	e8 09 f9 ff ff       	call   8048a10 <fwrite@plt>
 8049107:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804910d:	6a 05                	push   $0x5
 804910f:	6a 01                	push   $0x1
 8049111:	68 42 f3 05 08       	push   $0x805f342
 8049116:	e8 f5 f8 ff ff       	call   8048a10 <fwrite@plt>
 804911b:	83 c4 20             	add    $0x20,%esp
 804911e:	68 13 eb 05 08       	push   $0x805eb13
 8049123:	6a 0d                	push   $0xd
 8049125:	68 a3 e9 05 08       	push   $0x805e9a3
 804912a:	68 c0 e9 05 08       	push   $0x805e9c0
 804912f:	e8 7c fa ff ff       	call   8048bb0 <__assert_fail@plt>
	exec_file = argv[1];
 8049134:	8b 44 24 74          	mov    0x74(%esp),%eax

	FILE *fp = fopen(exec_file, "rb");
 8049138:	83 ec 08             	sub    $0x8,%esp
static int nr_symtab_entry;

void load_elf_tables(int argc, char *argv[]) {
	int ret;
	Assert(argc == 2, "run NEMU with format 'nemu [program]'");
	exec_file = argv[1];
 804913b:	8b 40 04             	mov    0x4(%eax),%eax

	FILE *fp = fopen(exec_file, "rb");
 804913e:	68 d3 e8 05 08       	push   $0x805e8d3
 8049143:	50                   	push   %eax
static int nr_symtab_entry;

void load_elf_tables(int argc, char *argv[]) {
	int ret;
	Assert(argc == 2, "run NEMU with format 'nemu [program]'");
	exec_file = argv[1];
 8049144:	a3 2c 5d 07 08       	mov    %eax,0x8075d2c

	FILE *fp = fopen(exec_file, "rb");
 8049149:	e8 92 f9 ff ff       	call   8048ae0 <fopen@plt>
 804914e:	89 44 24 14          	mov    %eax,0x14(%esp)
	Assert(fp, "Can not open '%s'", exec_file);
 8049152:	83 c4 10             	add    $0x10,%esp
 8049155:	85 c0                	test   %eax,%eax
 8049157:	0f 84 c5 02 00 00    	je     8049422 <load_elf_tables+0x362>

	uint8_t buf[sizeof(Elf32_Ehdr)];
	ret = fread(buf, sizeof(Elf32_Ehdr), 1, fp);
 804915d:	ff 74 24 04          	pushl  0x4(%esp)
 8049161:	6a 01                	push   $0x1
 8049163:	6a 34                	push   $0x34
 8049165:	8d 5c 24 28          	lea    0x28(%esp),%ebx
 8049169:	53                   	push   %ebx
 804916a:	e8 c1 f8 ff ff       	call   8048a30 <fread@plt>
	assert(ret == 1);
 804916f:	83 c4 10             	add    $0x10,%esp
 8049172:	83 f8 01             	cmp    $0x1,%eax
 8049175:	0f 85 2d 04 00 00    	jne    80495a8 <load_elf_tables+0x4e8>

	/* The first several bytes contain the ELF header. */
	Elf32_Ehdr *elf = (void *)buf;
	char magic[] = {ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3};
 804917b:	c6 44 24 18 7f       	movb   $0x7f,0x18(%esp)
 8049180:	c6 44 24 19 45       	movb   $0x45,0x19(%esp)

	/* Check ELF header */
	assert(memcmp(elf->e_ident, magic, 4) == 0);		// magic number
 8049185:	83 ec 04             	sub    $0x4,%esp
	ret = fread(buf, sizeof(Elf32_Ehdr), 1, fp);
	assert(ret == 1);

	/* The first several bytes contain the ELF header. */
	Elf32_Ehdr *elf = (void *)buf;
	char magic[] = {ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3};
 8049188:	c6 44 24 1e 4c       	movb   $0x4c,0x1e(%esp)
 804918d:	c6 44 24 1f 46       	movb   $0x46,0x1f(%esp)

	/* Check ELF header */
	assert(memcmp(elf->e_ident, magic, 4) == 0);		// magic number
 8049192:	6a 04                	push   $0x4
 8049194:	8d 44 24 20          	lea    0x20(%esp),%eax
 8049198:	50                   	push   %eax
 8049199:	53                   	push   %ebx
 804919a:	e8 31 f8 ff ff       	call   80489d0 <memcmp@plt>
 804919f:	83 c4 10             	add    $0x10,%esp
 80491a2:	85 c0                	test   %eax,%eax
 80491a4:	0f 85 e8 03 00 00    	jne    8049592 <load_elf_tables+0x4d2>
	assert(elf->e_ident[EI_CLASS] == ELFCLASS32);		// 32-bit architecture
 80491aa:	80 7c 24 20 01       	cmpb   $0x1,0x20(%esp)
 80491af:	0f 85 c7 03 00 00    	jne    804957c <load_elf_tables+0x4bc>
	assert(elf->e_ident[EI_DATA] == ELFDATA2LSB);		// littel-endian
 80491b5:	80 7c 24 21 01       	cmpb   $0x1,0x21(%esp)
 80491ba:	0f 85 a6 03 00 00    	jne    8049566 <load_elf_tables+0x4a6>
	assert(elf->e_ident[EI_VERSION] == EV_CURRENT);		// current version
 80491c0:	80 7c 24 22 01       	cmpb   $0x1,0x22(%esp)
 80491c5:	0f 85 85 03 00 00    	jne    8049550 <load_elf_tables+0x490>
	assert(elf->e_ident[EI_OSABI] == ELFOSABI_SYSV || 	// UNIX System V ABI
 80491cb:	0f b6 44 24 23       	movzbl 0x23(%esp),%eax
 80491d0:	3c 03                	cmp    $0x3,%al
 80491d2:	74 08                	je     80491dc <load_elf_tables+0x11c>
 80491d4:	84 c0                	test   %al,%al
 80491d6:	0f 85 5e 03 00 00    	jne    804953a <load_elf_tables+0x47a>
			elf->e_ident[EI_OSABI] == ELFOSABI_LINUX); 	// UNIX - GNU
	assert(elf->e_ident[EI_ABIVERSION] == 0);			// should be 0
 80491dc:	80 7c 24 24 00       	cmpb   $0x0,0x24(%esp)
 80491e1:	0f 85 3d 03 00 00    	jne    8049524 <load_elf_tables+0x464>
	assert(elf->e_type == ET_EXEC);						// executable file
 80491e7:	66 83 7c 24 2c 02    	cmpw   $0x2,0x2c(%esp)
 80491ed:	0f 85 1b 03 00 00    	jne    804950e <load_elf_tables+0x44e>
	assert(elf->e_machine == EM_386);					// Intel 80386 architecture
 80491f3:	66 83 7c 24 2e 03    	cmpw   $0x3,0x2e(%esp)
 80491f9:	0f 85 f9 02 00 00    	jne    80494f8 <load_elf_tables+0x438>
	assert(elf->e_version == EV_CURRENT);				// current version
 80491ff:	83 7c 24 30 01       	cmpl   $0x1,0x30(%esp)
 8049204:	0f 85 d8 02 00 00    	jne    80494e2 <load_elf_tables+0x422>


	/* Load symbol table and string table for future use */

	/* Load section header table */
	uint32_t sh_size = elf->e_shentsize * elf->e_shnum;
 804920a:	0f b7 5c 24 4a       	movzwl 0x4a(%esp),%ebx
 804920f:	0f b7 44 24 4c       	movzwl 0x4c(%esp),%eax
	Elf32_Shdr *sh = malloc(sh_size);
 8049214:	83 ec 0c             	sub    $0xc,%esp


	/* Load symbol table and string table for future use */

	/* Load section header table */
	uint32_t sh_size = elf->e_shentsize * elf->e_shnum;
 8049217:	0f af d8             	imul   %eax,%ebx
	Elf32_Shdr *sh = malloc(sh_size);
 804921a:	53                   	push   %ebx
 804921b:	e8 30 f8 ff ff       	call   8048a50 <malloc@plt>
 8049220:	89 44 24 1c          	mov    %eax,0x1c(%esp)
	fseek(fp, elf->e_shoff, SEEK_SET);
 8049224:	83 c4 0c             	add    $0xc,%esp

	/* Load symbol table and string table for future use */

	/* Load section header table */
	uint32_t sh_size = elf->e_shentsize * elf->e_shnum;
	Elf32_Shdr *sh = malloc(sh_size);
 8049227:	89 c6                	mov    %eax,%esi
	fseek(fp, elf->e_shoff, SEEK_SET);
 8049229:	6a 00                	push   $0x0
 804922b:	ff 74 24 44          	pushl  0x44(%esp)
 804922f:	8b 7c 24 10          	mov    0x10(%esp),%edi
 8049233:	57                   	push   %edi
 8049234:	e8 b7 f7 ff ff       	call   80489f0 <fseek@plt>
	ret = fread(sh, sh_size, 1, fp);
 8049239:	57                   	push   %edi
 804923a:	6a 01                	push   $0x1
 804923c:	53                   	push   %ebx
 804923d:	56                   	push   %esi
 804923e:	e8 ed f7 ff ff       	call   8048a30 <fread@plt>
	assert(ret == 1);
 8049243:	83 c4 20             	add    $0x20,%esp
 8049246:	83 f8 01             	cmp    $0x1,%eax
 8049249:	0f 85 7d 02 00 00    	jne    80494cc <load_elf_tables+0x40c>

	/* Load section header string table */
	char *shstrtab = malloc(sh[elf->e_shstrndx].sh_size);
 804924f:	0f b7 44 24 4e       	movzwl 0x4e(%esp),%eax
 8049254:	8b 7c 24 0c          	mov    0xc(%esp),%edi
 8049258:	83 ec 0c             	sub    $0xc,%esp
 804925b:	8d 04 80             	lea    (%eax,%eax,4),%eax
 804925e:	8d 1c c7             	lea    (%edi,%eax,8),%ebx
 8049261:	ff 73 14             	pushl  0x14(%ebx)
 8049264:	e8 e7 f7 ff ff       	call   8048a50 <malloc@plt>
 8049269:	89 44 24 18          	mov    %eax,0x18(%esp)
	fseek(fp, sh[elf->e_shstrndx].sh_offset, SEEK_SET);
 804926d:	83 c4 0c             	add    $0xc,%esp
 8049270:	6a 00                	push   $0x0
 8049272:	ff 73 10             	pushl  0x10(%ebx)
 8049275:	8b 74 24 10          	mov    0x10(%esp),%esi
 8049279:	56                   	push   %esi
 804927a:	e8 71 f7 ff ff       	call   80489f0 <fseek@plt>
	ret = fread(shstrtab, sh[elf->e_shstrndx].sh_size, 1, fp);
 804927f:	56                   	push   %esi
 8049280:	6a 01                	push   $0x1
 8049282:	0f b7 44 24 66       	movzwl 0x66(%esp),%eax
 8049287:	8d 04 80             	lea    (%eax,%eax,4),%eax
 804928a:	ff 74 c7 14          	pushl  0x14(%edi,%eax,8)
 804928e:	8b 54 24 24          	mov    0x24(%esp),%edx
 8049292:	52                   	push   %edx
 8049293:	89 54 24 28          	mov    %edx,0x28(%esp)
 8049297:	e8 94 f7 ff ff       	call   8048a30 <fread@plt>
	assert(ret == 1);
 804929c:	83 c4 20             	add    $0x20,%esp
 804929f:	83 f8 01             	cmp    $0x1,%eax
 80492a2:	0f 85 0e 02 00 00    	jne    80494b6 <load_elf_tables+0x3f6>

	int i;
	for(i = 0; i < elf->e_shnum; i ++) {
 80492a8:	31 ed                	xor    %ebp,%ebp
 80492aa:	66 83 7c 24 4c 00    	cmpw   $0x0,0x4c(%esp)
 80492b0:	8d 5f 14             	lea    0x14(%edi),%ebx
 80492b3:	8b 54 24 08          	mov    0x8(%esp),%edx
 80492b7:	75 23                	jne    80492dc <load_elf_tables+0x21c>
 80492b9:	e9 9a 00 00 00       	jmp    8049358 <load_elf_tables+0x298>
 80492be:	66 90                	xchg   %ax,%ax
			fseek(fp, sh[i].sh_offset, SEEK_SET);
			ret = fread(symtab, sh[i].sh_size, 1, fp);
			assert(ret == 1);
			nr_symtab_entry = sh[i].sh_size / sizeof(symtab[0]);
		}
		else if(sh[i].sh_type == SHT_STRTAB && 
 80492c0:	83 f8 03             	cmp    $0x3,%eax
 80492c3:	0f 84 e7 00 00 00    	je     80493b0 <load_elf_tables+0x2f0>
	fseek(fp, sh[elf->e_shstrndx].sh_offset, SEEK_SET);
	ret = fread(shstrtab, sh[elf->e_shstrndx].sh_size, 1, fp);
	assert(ret == 1);

	int i;
	for(i = 0; i < elf->e_shnum; i ++) {
 80492c9:	0f b7 44 24 4c       	movzwl 0x4c(%esp),%eax
 80492ce:	83 c5 01             	add    $0x1,%ebp
 80492d1:	83 c3 28             	add    $0x28,%ebx
 80492d4:	39 e8                	cmp    %ebp,%eax
 80492d6:	0f 8e 7c 00 00 00    	jle    8049358 <load_elf_tables+0x298>
		if(sh[i].sh_type == SHT_SYMTAB && 
 80492dc:	8b 43 f0             	mov    -0x10(%ebx),%eax
 80492df:	83 f8 02             	cmp    $0x2,%eax
 80492e2:	75 dc                	jne    80492c0 <load_elf_tables+0x200>
				strcmp(shstrtab + sh[i].sh_name, ".symtab") == 0) {
 80492e4:	8b 73 ec             	mov    -0x14(%ebx),%esi
 80492e7:	bf 57 ea 05 08       	mov    $0x805ea57,%edi
 80492ec:	b9 08 00 00 00       	mov    $0x8,%ecx
 80492f1:	01 d6                	add    %edx,%esi
	ret = fread(shstrtab, sh[elf->e_shstrndx].sh_size, 1, fp);
	assert(ret == 1);

	int i;
	for(i = 0; i < elf->e_shnum; i ++) {
		if(sh[i].sh_type == SHT_SYMTAB && 
 80492f3:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
 80492f5:	75 d2                	jne    80492c9 <load_elf_tables+0x209>
 80492f7:	89 54 24 08          	mov    %edx,0x8(%esp)
				strcmp(shstrtab + sh[i].sh_name, ".symtab") == 0) {
			/* Load symbol table from exec_file */
			symtab = malloc(sh[i].sh_size);
 80492fb:	83 ec 0c             	sub    $0xc,%esp
 80492fe:	ff 33                	pushl  (%ebx)
 8049300:	e8 4b f7 ff ff       	call   8048a50 <malloc@plt>
			fseek(fp, sh[i].sh_offset, SEEK_SET);
 8049305:	83 c4 0c             	add    $0xc,%esp
	int i;
	for(i = 0; i < elf->e_shnum; i ++) {
		if(sh[i].sh_type == SHT_SYMTAB && 
				strcmp(shstrtab + sh[i].sh_name, ".symtab") == 0) {
			/* Load symbol table from exec_file */
			symtab = malloc(sh[i].sh_size);
 8049308:	a3 34 5d 07 08       	mov    %eax,0x8075d34
			fseek(fp, sh[i].sh_offset, SEEK_SET);
 804930d:	6a 00                	push   $0x0
 804930f:	ff 73 fc             	pushl  -0x4(%ebx)
 8049312:	8b 7c 24 10          	mov    0x10(%esp),%edi
 8049316:	57                   	push   %edi
 8049317:	e8 d4 f6 ff ff       	call   80489f0 <fseek@plt>
			ret = fread(symtab, sh[i].sh_size, 1, fp);
 804931c:	57                   	push   %edi
 804931d:	6a 01                	push   $0x1
 804931f:	ff 33                	pushl  (%ebx)
 8049321:	ff 35 34 5d 07 08    	pushl  0x8075d34
 8049327:	e8 04 f7 ff ff       	call   8048a30 <fread@plt>
			assert(ret == 1);
 804932c:	83 c4 20             	add    $0x20,%esp
 804932f:	83 f8 01             	cmp    $0x1,%eax
 8049332:	8b 54 24 08          	mov    0x8(%esp),%edx
 8049336:	0f 85 64 01 00 00    	jne    80494a0 <load_elf_tables+0x3e0>
			nr_symtab_entry = sh[i].sh_size / sizeof(symtab[0]);
 804933c:	8b 03                	mov    (%ebx),%eax
	fseek(fp, sh[elf->e_shstrndx].sh_offset, SEEK_SET);
	ret = fread(shstrtab, sh[elf->e_shstrndx].sh_size, 1, fp);
	assert(ret == 1);

	int i;
	for(i = 0; i < elf->e_shnum; i ++) {
 804933e:	83 c5 01             	add    $0x1,%ebp
 8049341:	83 c3 28             	add    $0x28,%ebx
			/* Load symbol table from exec_file */
			symtab = malloc(sh[i].sh_size);
			fseek(fp, sh[i].sh_offset, SEEK_SET);
			ret = fread(symtab, sh[i].sh_size, 1, fp);
			assert(ret == 1);
			nr_symtab_entry = sh[i].sh_size / sizeof(symtab[0]);
 8049344:	c1 e8 04             	shr    $0x4,%eax
 8049347:	a3 30 5d 07 08       	mov    %eax,0x8075d30
	fseek(fp, sh[elf->e_shstrndx].sh_offset, SEEK_SET);
	ret = fread(shstrtab, sh[elf->e_shstrndx].sh_size, 1, fp);
	assert(ret == 1);

	int i;
	for(i = 0; i < elf->e_shnum; i ++) {
 804934c:	0f b7 44 24 4c       	movzwl 0x4c(%esp),%eax
 8049351:	39 e8                	cmp    %ebp,%eax
 8049353:	7f 87                	jg     80492dc <load_elf_tables+0x21c>
 8049355:	8d 76 00             	lea    0x0(%esi),%esi
 8049358:	89 54 24 08          	mov    %edx,0x8(%esp)
			ret = fread(strtab, sh[i].sh_size, 1, fp);
			assert(ret == 1);
		}
	}

	free(sh);
 804935c:	83 ec 0c             	sub    $0xc,%esp
 804935f:	ff 74 24 18          	pushl  0x18(%esp)
 8049363:	e8 18 f6 ff ff       	call   8048980 <free@plt>
	free(shstrtab);
 8049368:	8b 54 24 18          	mov    0x18(%esp),%edx
 804936c:	89 14 24             	mov    %edx,(%esp)
 804936f:	e8 0c f6 ff ff       	call   8048980 <free@plt>

	assert(strtab != NULL && symtab != NULL);
 8049374:	8b 15 38 5d 07 08    	mov    0x8075d38,%edx
 804937a:	83 c4 10             	add    $0x10,%esp
 804937d:	85 d2                	test   %edx,%edx
 804937f:	0f 84 05 01 00 00    	je     804948a <load_elf_tables+0x3ca>
 8049385:	a1 34 5d 07 08       	mov    0x8075d34,%eax
 804938a:	85 c0                	test   %eax,%eax
 804938c:	0f 84 f8 00 00 00    	je     804948a <load_elf_tables+0x3ca>

	fclose(fp);
 8049392:	83 ec 0c             	sub    $0xc,%esp
 8049395:	ff 74 24 10          	pushl  0x10(%esp)
 8049399:	e8 12 f6 ff ff       	call   80489b0 <fclose@plt>
}
 804939e:	83 c4 10             	add    $0x10,%esp
 80493a1:	83 c4 5c             	add    $0x5c,%esp
 80493a4:	5b                   	pop    %ebx
 80493a5:	5e                   	pop    %esi
 80493a6:	5f                   	pop    %edi
 80493a7:	5d                   	pop    %ebp
 80493a8:	c3                   	ret    
 80493a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			ret = fread(symtab, sh[i].sh_size, 1, fp);
			assert(ret == 1);
			nr_symtab_entry = sh[i].sh_size / sizeof(symtab[0]);
		}
		else if(sh[i].sh_type == SHT_STRTAB && 
				strcmp(shstrtab + sh[i].sh_name, ".strtab") == 0) {
 80493b0:	8b 73 ec             	mov    -0x14(%ebx),%esi
 80493b3:	bf 5f ea 05 08       	mov    $0x805ea5f,%edi
 80493b8:	b9 08 00 00 00       	mov    $0x8,%ecx
 80493bd:	01 d6                	add    %edx,%esi
			fseek(fp, sh[i].sh_offset, SEEK_SET);
			ret = fread(symtab, sh[i].sh_size, 1, fp);
			assert(ret == 1);
			nr_symtab_entry = sh[i].sh_size / sizeof(symtab[0]);
		}
		else if(sh[i].sh_type == SHT_STRTAB && 
 80493bf:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
 80493c1:	0f 85 02 ff ff ff    	jne    80492c9 <load_elf_tables+0x209>
 80493c7:	89 54 24 08          	mov    %edx,0x8(%esp)
				strcmp(shstrtab + sh[i].sh_name, ".strtab") == 0) {
			/* Load string table from exec_file */
			strtab = malloc(sh[i].sh_size);
 80493cb:	83 ec 0c             	sub    $0xc,%esp
 80493ce:	ff 33                	pushl  (%ebx)
 80493d0:	e8 7b f6 ff ff       	call   8048a50 <malloc@plt>
			fseek(fp, sh[i].sh_offset, SEEK_SET);
 80493d5:	83 c4 0c             	add    $0xc,%esp
			nr_symtab_entry = sh[i].sh_size / sizeof(symtab[0]);
		}
		else if(sh[i].sh_type == SHT_STRTAB && 
				strcmp(shstrtab + sh[i].sh_name, ".strtab") == 0) {
			/* Load string table from exec_file */
			strtab = malloc(sh[i].sh_size);
 80493d8:	a3 38 5d 07 08       	mov    %eax,0x8075d38
			fseek(fp, sh[i].sh_offset, SEEK_SET);
 80493dd:	6a 00                	push   $0x0
 80493df:	ff 73 fc             	pushl  -0x4(%ebx)
 80493e2:	8b 7c 24 10          	mov    0x10(%esp),%edi
 80493e6:	57                   	push   %edi
 80493e7:	e8 04 f6 ff ff       	call   80489f0 <fseek@plt>
			ret = fread(strtab, sh[i].sh_size, 1, fp);
 80493ec:	57                   	push   %edi
 80493ed:	6a 01                	push   $0x1
 80493ef:	ff 33                	pushl  (%ebx)
 80493f1:	ff 35 38 5d 07 08    	pushl  0x8075d38
 80493f7:	e8 34 f6 ff ff       	call   8048a30 <fread@plt>
			assert(ret == 1);
 80493fc:	83 c4 20             	add    $0x20,%esp
 80493ff:	83 f8 01             	cmp    $0x1,%eax
 8049402:	8b 54 24 08          	mov    0x8(%esp),%edx
 8049406:	0f 84 bd fe ff ff    	je     80492c9 <load_elf_tables+0x209>
 804940c:	68 13 eb 05 08       	push   $0x805eb13
 8049411:	6a 48                	push   $0x48
 8049413:	68 a3 e9 05 08       	push   $0x805e9a3
 8049418:	68 e8 e8 05 08       	push   $0x805e8e8
 804941d:	e8 8e f7 ff ff       	call   8048bb0 <__assert_fail@plt>
	int ret;
	Assert(argc == 2, "run NEMU with format 'nemu [program]'");
	exec_file = argv[1];

	FILE *fp = fopen(exec_file, "rb");
	Assert(fp, "Can not open '%s'", exec_file);
 8049422:	83 ec 0c             	sub    $0xc,%esp
 8049425:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804942b:	e8 30 f5 ff ff       	call   8048960 <fflush@plt>
 8049430:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8049436:	6a 07                	push   $0x7
 8049438:	6a 01                	push   $0x1
 804943a:	68 92 e8 05 08       	push   $0x805e892
 804943f:	e8 cc f5 ff ff       	call   8048a10 <fwrite@plt>
 8049444:	83 c4 1c             	add    $0x1c,%esp
 8049447:	ff 35 2c 5d 07 08    	pushl  0x8075d2c
 804944d:	68 d6 e8 05 08       	push   $0x805e8d6
 8049452:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8049458:	e8 63 f6 ff ff       	call   8048ac0 <fprintf@plt>
 804945d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8049463:	6a 05                	push   $0x5
 8049465:	6a 01                	push   $0x1
 8049467:	68 42 f3 05 08       	push   $0x805f342
 804946c:	e8 9f f5 ff ff       	call   8048a10 <fwrite@plt>
 8049471:	83 c4 20             	add    $0x20,%esp
 8049474:	68 13 eb 05 08       	push   $0x805eb13
 8049479:	6a 11                	push   $0x11
 804947b:	68 a3 e9 05 08       	push   $0x805e9a3
 8049480:	68 d0 e8 05 08       	push   $0x805e8d0
 8049485:	e8 26 f7 ff ff       	call   8048bb0 <__assert_fail@plt>
	}

	free(sh);
	free(shstrtab);

	assert(strtab != NULL && symtab != NULL);
 804948a:	68 13 eb 05 08       	push   $0x805eb13
 804948f:	6a 4f                	push   $0x4f
 8049491:	68 a3 e9 05 08       	push   $0x805e9a3
 8049496:	68 e4 ea 05 08       	push   $0x805eae4
 804949b:	e8 10 f7 ff ff       	call   8048bb0 <__assert_fail@plt>
				strcmp(shstrtab + sh[i].sh_name, ".symtab") == 0) {
			/* Load symbol table from exec_file */
			symtab = malloc(sh[i].sh_size);
			fseek(fp, sh[i].sh_offset, SEEK_SET);
			ret = fread(symtab, sh[i].sh_size, 1, fp);
			assert(ret == 1);
 80494a0:	68 13 eb 05 08       	push   $0x805eb13
 80494a5:	6a 3f                	push   $0x3f
 80494a7:	68 a3 e9 05 08       	push   $0x805e9a3
 80494ac:	68 e8 e8 05 08       	push   $0x805e8e8
 80494b1:	e8 fa f6 ff ff       	call   8048bb0 <__assert_fail@plt>

	/* Load section header string table */
	char *shstrtab = malloc(sh[elf->e_shstrndx].sh_size);
	fseek(fp, sh[elf->e_shstrndx].sh_offset, SEEK_SET);
	ret = fread(shstrtab, sh[elf->e_shstrndx].sh_size, 1, fp);
	assert(ret == 1);
 80494b6:	68 13 eb 05 08       	push   $0x805eb13
 80494bb:	6a 35                	push   $0x35
 80494bd:	68 a3 e9 05 08       	push   $0x805e9a3
 80494c2:	68 e8 e8 05 08       	push   $0x805e8e8
 80494c7:	e8 e4 f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	/* Load section header table */
	uint32_t sh_size = elf->e_shentsize * elf->e_shnum;
	Elf32_Shdr *sh = malloc(sh_size);
	fseek(fp, elf->e_shoff, SEEK_SET);
	ret = fread(sh, sh_size, 1, fp);
	assert(ret == 1);
 80494cc:	68 13 eb 05 08       	push   $0x805eb13
 80494d1:	6a 2f                	push   $0x2f
 80494d3:	68 a3 e9 05 08       	push   $0x805e9a3
 80494d8:	68 e8 e8 05 08       	push   $0x805e8e8
 80494dd:	e8 ce f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	assert(elf->e_ident[EI_OSABI] == ELFOSABI_SYSV || 	// UNIX System V ABI
			elf->e_ident[EI_OSABI] == ELFOSABI_LINUX); 	// UNIX - GNU
	assert(elf->e_ident[EI_ABIVERSION] == 0);			// should be 0
	assert(elf->e_type == ET_EXEC);						// executable file
	assert(elf->e_machine == EM_386);					// Intel 80386 architecture
	assert(elf->e_version == EV_CURRENT);				// current version
 80494e2:	68 13 eb 05 08       	push   $0x805eb13
 80494e7:	6a 25                	push   $0x25
 80494e9:	68 a3 e9 05 08       	push   $0x805e9a3
 80494ee:	68 43 ea 05 08       	push   $0x805ea43
 80494f3:	e8 b8 f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	assert(elf->e_ident[EI_VERSION] == EV_CURRENT);		// current version
	assert(elf->e_ident[EI_OSABI] == ELFOSABI_SYSV || 	// UNIX System V ABI
			elf->e_ident[EI_OSABI] == ELFOSABI_LINUX); 	// UNIX - GNU
	assert(elf->e_ident[EI_ABIVERSION] == 0);			// should be 0
	assert(elf->e_type == ET_EXEC);						// executable file
	assert(elf->e_machine == EM_386);					// Intel 80386 architecture
 80494f8:	68 13 eb 05 08       	push   $0x805eb13
 80494fd:	6a 24                	push   $0x24
 80494ff:	68 a3 e9 05 08       	push   $0x805e9a3
 8049504:	68 2f ea 05 08       	push   $0x805ea2f
 8049509:	e8 a2 f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	assert(elf->e_ident[EI_DATA] == ELFDATA2LSB);		// littel-endian
	assert(elf->e_ident[EI_VERSION] == EV_CURRENT);		// current version
	assert(elf->e_ident[EI_OSABI] == ELFOSABI_SYSV || 	// UNIX System V ABI
			elf->e_ident[EI_OSABI] == ELFOSABI_LINUX); 	// UNIX - GNU
	assert(elf->e_ident[EI_ABIVERSION] == 0);			// should be 0
	assert(elf->e_type == ET_EXEC);						// executable file
 804950e:	68 13 eb 05 08       	push   $0x805eb13
 8049513:	6a 23                	push   $0x23
 8049515:	68 a3 e9 05 08       	push   $0x805e9a3
 804951a:	68 1e ea 05 08       	push   $0x805ea1e
 804951f:	e8 8c f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	assert(elf->e_ident[EI_CLASS] == ELFCLASS32);		// 32-bit architecture
	assert(elf->e_ident[EI_DATA] == ELFDATA2LSB);		// littel-endian
	assert(elf->e_ident[EI_VERSION] == EV_CURRENT);		// current version
	assert(elf->e_ident[EI_OSABI] == ELFOSABI_SYSV || 	// UNIX System V ABI
			elf->e_ident[EI_OSABI] == ELFOSABI_LINUX); 	// UNIX - GNU
	assert(elf->e_ident[EI_ABIVERSION] == 0);			// should be 0
 8049524:	68 13 eb 05 08       	push   $0x805eb13
 8049529:	6a 22                	push   $0x22
 804952b:	68 a3 e9 05 08       	push   $0x805e9a3
 8049530:	68 09 ea 05 08       	push   $0x805ea09
 8049535:	e8 76 f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	/* Check ELF header */
	assert(memcmp(elf->e_ident, magic, 4) == 0);		// magic number
	assert(elf->e_ident[EI_CLASS] == ELFCLASS32);		// 32-bit architecture
	assert(elf->e_ident[EI_DATA] == ELFDATA2LSB);		// littel-endian
	assert(elf->e_ident[EI_VERSION] == EV_CURRENT);		// current version
	assert(elf->e_ident[EI_OSABI] == ELFOSABI_SYSV || 	// UNIX System V ABI
 804953a:	68 13 eb 05 08       	push   $0x805eb13
 804953f:	6a 21                	push   $0x21
 8049541:	68 a3 e9 05 08       	push   $0x805e9a3
 8049546:	68 b4 ea 05 08       	push   $0x805eab4
 804954b:	e8 60 f6 ff ff       	call   8048bb0 <__assert_fail@plt>

	/* Check ELF header */
	assert(memcmp(elf->e_ident, magic, 4) == 0);		// magic number
	assert(elf->e_ident[EI_CLASS] == ELFCLASS32);		// 32-bit architecture
	assert(elf->e_ident[EI_DATA] == ELFDATA2LSB);		// littel-endian
	assert(elf->e_ident[EI_VERSION] == EV_CURRENT);		// current version
 8049550:	68 13 eb 05 08       	push   $0x805eb13
 8049555:	6a 1f                	push   $0x1f
 8049557:	68 a3 e9 05 08       	push   $0x805e9a3
 804955c:	68 f4 e9 05 08       	push   $0x805e9f4
 8049561:	e8 4a f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	char magic[] = {ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3};

	/* Check ELF header */
	assert(memcmp(elf->e_ident, magic, 4) == 0);		// magic number
	assert(elf->e_ident[EI_CLASS] == ELFCLASS32);		// 32-bit architecture
	assert(elf->e_ident[EI_DATA] == ELFDATA2LSB);		// littel-endian
 8049566:	68 13 eb 05 08       	push   $0x805eb13
 804956b:	6a 1e                	push   $0x1e
 804956d:	68 a3 e9 05 08       	push   $0x805e9a3
 8049572:	68 df e9 05 08       	push   $0x805e9df
 8049577:	e8 34 f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	Elf32_Ehdr *elf = (void *)buf;
	char magic[] = {ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3};

	/* Check ELF header */
	assert(memcmp(elf->e_ident, magic, 4) == 0);		// magic number
	assert(elf->e_ident[EI_CLASS] == ELFCLASS32);		// 32-bit architecture
 804957c:	68 13 eb 05 08       	push   $0x805eb13
 8049581:	6a 1d                	push   $0x1d
 8049583:	68 a3 e9 05 08       	push   $0x805e9a3
 8049588:	68 ca e9 05 08       	push   $0x805e9ca
 804958d:	e8 1e f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	/* The first several bytes contain the ELF header. */
	Elf32_Ehdr *elf = (void *)buf;
	char magic[] = {ELFMAG0, ELFMAG1, ELFMAG2, ELFMAG3};

	/* Check ELF header */
	assert(memcmp(elf->e_ident, magic, 4) == 0);		// magic number
 8049592:	68 13 eb 05 08       	push   $0x805eb13
 8049597:	6a 1c                	push   $0x1c
 8049599:	68 a3 e9 05 08       	push   $0x805e9a3
 804959e:	68 90 ea 05 08       	push   $0x805ea90
 80495a3:	e8 08 f6 ff ff       	call   8048bb0 <__assert_fail@plt>
	FILE *fp = fopen(exec_file, "rb");
	Assert(fp, "Can not open '%s'", exec_file);

	uint8_t buf[sizeof(Elf32_Ehdr)];
	ret = fread(buf, sizeof(Elf32_Ehdr), 1, fp);
	assert(ret == 1);
 80495a8:	68 13 eb 05 08       	push   $0x805eb13
 80495ad:	6a 15                	push   $0x15
 80495af:	68 a3 e9 05 08       	push   $0x805e9a3
 80495b4:	68 e8 e8 05 08       	push   $0x805e8e8
 80495b9:	e8 f2 f5 ff ff       	call   8048bb0 <__assert_fail@plt>
 80495be:	66 90                	xchg   %ax,%ax

080495c0 <read_sym>:
	assert(strtab != NULL && symtab != NULL);

	fclose(fp);
}

uint32_t read_sym(char * str) {
 80495c0:	55                   	push   %ebp
 80495c1:	57                   	push   %edi
 80495c2:	56                   	push   %esi
 80495c3:	53                   	push   %ebx
 80495c4:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 80495c7:	a1 30 5d 07 08       	mov    0x8075d30,%eax
	assert(strtab != NULL && symtab != NULL);

	fclose(fp);
}

uint32_t read_sym(char * str) {
 80495cc:	8b 7c 24 30          	mov    0x30(%esp),%edi
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 80495d0:	85 c0                	test   %eax,%eax
 80495d2:	89 44 24 0c          	mov    %eax,0xc(%esp)
 80495d6:	7e 48                	jle    8049620 <read_sym+0x60>
 80495d8:	8b 2d 38 5d 07 08    	mov    0x8075d38,%ebp
 80495de:	8b 1d 34 5d 07 08    	mov    0x8075d34,%ebx
 80495e4:	31 f6                	xor    %esi,%esi
 80495e6:	eb 14                	jmp    80495fc <read_sym+0x3c>
 80495e8:	90                   	nop
 80495e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 80495f0:	83 c6 01             	add    $0x1,%esi
 80495f3:	83 c3 10             	add    $0x10,%ebx
 80495f6:	3b 74 24 0c          	cmp    0xc(%esp),%esi
 80495fa:	74 24                	je     8049620 <read_sym+0x60>
		if(strcmp(strtab + symtab[i].st_name, str) == 0) {
 80495fc:	8b 03                	mov    (%ebx),%eax
 80495fe:	83 ec 08             	sub    $0x8,%esp
 8049601:	57                   	push   %edi
 8049602:	01 e8                	add    %ebp,%eax
 8049604:	50                   	push   %eax
 8049605:	e8 36 f3 ff ff       	call   8048940 <strcmp@plt>
 804960a:	83 c4 10             	add    $0x10,%esp
 804960d:	85 c0                	test   %eax,%eax
 804960f:	75 df                	jne    80495f0 <read_sym+0x30>
			return symtab[i].st_value;
 8049611:	8b 43 04             	mov    0x4(%ebx),%eax
		}
	}
	return 0;
}
 8049614:	83 c4 1c             	add    $0x1c,%esp
 8049617:	5b                   	pop    %ebx
 8049618:	5e                   	pop    %esi
 8049619:	5f                   	pop    %edi
 804961a:	5d                   	pop    %ebp
 804961b:	c3                   	ret    
 804961c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049620:	83 c4 1c             	add    $0x1c,%esp
	for(i = 0; i < nr_symtab_entry; i ++) {
		if(strcmp(strtab + symtab[i].st_name, str) == 0) {
			return symtab[i].st_value;
		}
	}
	return 0;
 8049623:	31 c0                	xor    %eax,%eax
}
 8049625:	5b                   	pop    %ebx
 8049626:	5e                   	pop    %esi
 8049627:	5f                   	pop    %edi
 8049628:	5d                   	pop    %ebp
 8049629:	c3                   	ret    
 804962a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

08049630 <get_func_name>:

void get_func_name(char * fun_name, swaddr_t addr, int * flag) {
 8049630:	55                   	push   %ebp
 8049631:	57                   	push   %edi
 8049632:	56                   	push   %esi
 8049633:	53                   	push   %ebx
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 8049634:	31 f6                	xor    %esi,%esi
		}
	}
	return 0;
}

void get_func_name(char * fun_name, swaddr_t addr, int * flag) {
 8049636:	83 ec 0c             	sub    $0xc,%esp
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 8049639:	8b 3d 30 5d 07 08    	mov    0x8075d30,%edi
 804963f:	a1 34 5d 07 08       	mov    0x8075d34,%eax
		}
	}
	return 0;
}

void get_func_name(char * fun_name, swaddr_t addr, int * flag) {
 8049644:	8b 6c 24 24          	mov    0x24(%esp),%ebp
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 8049648:	85 ff                	test   %edi,%edi
 804964a:	8d 58 0c             	lea    0xc(%eax),%ebx
 804964d:	7f 13                	jg     8049662 <get_func_name+0x32>
 804964f:	eb 5f                	jmp    80496b0 <get_func_name+0x80>
 8049651:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049658:	83 c6 01             	add    $0x1,%esi
 804965b:	83 c3 10             	add    $0x10,%ebx
 804965e:	39 fe                	cmp    %edi,%esi
 8049660:	74 4e                	je     80496b0 <get_func_name+0x80>
		if((symtab[i].st_info & 0xf) != STT_FUNC) continue;
 8049662:	0f b6 03             	movzbl (%ebx),%eax
 8049665:	83 e0 0f             	and    $0xf,%eax
 8049668:	3c 02                	cmp    $0x2,%al
 804966a:	75 ec                	jne    8049658 <get_func_name+0x28>
		if((symtab[i].st_value <= addr) && 
 804966c:	8b 43 f8             	mov    -0x8(%ebx),%eax
 804966f:	39 e8                	cmp    %ebp,%eax
 8049671:	77 e5                	ja     8049658 <get_func_name+0x28>
				(symtab[i].st_value + symtab[i].st_size >= addr)) {
 8049673:	03 43 fc             	add    -0x4(%ebx),%eax

void get_func_name(char * fun_name, swaddr_t addr, int * flag) {
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
		if((symtab[i].st_info & 0xf) != STT_FUNC) continue;
		if((symtab[i].st_value <= addr) && 
 8049676:	39 c5                	cmp    %eax,%ebp
 8049678:	77 de                	ja     8049658 <get_func_name+0x28>
				(symtab[i].st_value + symtab[i].st_size >= addr)) {
			strcpy(fun_name, strtab + symtab[i].st_name);
 804967a:	8b 43 f4             	mov    -0xc(%ebx),%eax
 804967d:	03 05 38 5d 07 08    	add    0x8075d38,%eax
 8049683:	83 ec 08             	sub    $0x8,%esp
	return 0;
}

void get_func_name(char * fun_name, swaddr_t addr, int * flag) {
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 8049686:	83 c6 01             	add    $0x1,%esi
 8049689:	83 c3 10             	add    $0x10,%ebx
		if((symtab[i].st_info & 0xf) != STT_FUNC) continue;
		if((symtab[i].st_value <= addr) && 
				(symtab[i].st_value + symtab[i].st_size >= addr)) {
			strcpy(fun_name, strtab + symtab[i].st_name);
 804968c:	50                   	push   %eax
 804968d:	ff 74 24 2c          	pushl  0x2c(%esp)
 8049691:	e8 aa f3 ff ff       	call   8048a40 <strcpy@plt>
			*flag = 1;
 8049696:	8b 44 24 38          	mov    0x38(%esp),%eax
 804969a:	83 c4 10             	add    $0x10,%esp
	return 0;
}

void get_func_name(char * fun_name, swaddr_t addr, int * flag) {
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 804969d:	39 fe                	cmp    %edi,%esi
		if((symtab[i].st_info & 0xf) != STT_FUNC) continue;
		if((symtab[i].st_value <= addr) && 
				(symtab[i].st_value + symtab[i].st_size >= addr)) {
			strcpy(fun_name, strtab + symtab[i].st_name);
			*flag = 1;
 804969f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	return 0;
}

void get_func_name(char * fun_name, swaddr_t addr, int * flag) {
	int i;
	for(i = 0; i < nr_symtab_entry; i ++) {
 80496a5:	75 bb                	jne    8049662 <get_func_name+0x32>
 80496a7:	89 f6                	mov    %esi,%esi
 80496a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
				(symtab[i].st_value + symtab[i].st_size >= addr)) {
			strcpy(fun_name, strtab + symtab[i].st_name);
			*flag = 1;
		}
	}
}
 80496b0:	83 c4 0c             	add    $0xc,%esp
 80496b3:	5b                   	pop    %ebx
 80496b4:	5e                   	pop    %esi
 80496b5:	5f                   	pop    %edi
 80496b6:	5d                   	pop    %ebp
 80496b7:	c3                   	ret    
 80496b8:	66 90                	xchg   %ax,%ax
 80496ba:	66 90                	xchg   %ax,%ax
 80496bc:	66 90                	xchg   %ax,%ax
 80496be:	66 90                	xchg   %ax,%ax

080496c0 <cmd_q>:
	return 0;
}

static int cmd_q(char *args) {
	return -1;
}
 80496c0:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 80496c5:	c3                   	ret    
 80496c6:	8d 76 00             	lea    0x0(%esi),%esi
 80496c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080496d0 <cmd_bt>:
	int no = atoi(args);
	delete_wp(no);
	return 0;
}

static int cmd_bt(char *args) {
 80496d0:	55                   	push   %ebp
 80496d1:	57                   	push   %edi
 80496d2:	56                   	push   %esi
 80496d3:	53                   	push   %ebx
	swaddr_t addr = cpu.eip;
	uint32_t ebp = cpu.ebp;
	char fun_name[32];
	int i, flag, cnt = 0;
	while(ebp) {
 80496d4:	31 f6                	xor    %esi,%esi
	int no = atoi(args);
	delete_wp(no);
	return 0;
}

static int cmd_bt(char *args) {
 80496d6:	83 ec 4c             	sub    $0x4c,%esp
	swaddr_t addr = cpu.eip;
	uint32_t ebp = cpu.ebp;
 80496d9:	8b 1d d4 af 0f 10    	mov    0x100fafd4,%ebx
	delete_wp(no);
	return 0;
}

static int cmd_bt(char *args) {
	swaddr_t addr = cpu.eip;
 80496df:	a1 e0 af 0f 10       	mov    0x100fafe0,%eax
 80496e4:	8d 6c 24 20          	lea    0x20(%esp),%ebp
	uint32_t ebp = cpu.ebp;
	char fun_name[32];
	int i, flag, cnt = 0;
	while(ebp) {
 80496e8:	85 db                	test   %ebx,%ebx
	delete_wp(no);
	return 0;
}

static int cmd_bt(char *args) {
	swaddr_t addr = cpu.eip;
 80496ea:	89 44 24 08          	mov    %eax,0x8(%esp)
	uint32_t ebp = cpu.ebp;
	char fun_name[32];
	int i, flag, cnt = 0;
	while(ebp) {
 80496ee:	0f 84 dc 00 00 00    	je     80497d0 <cmd_bt+0x100>
 80496f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		flag = 0;
 80496f8:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 80496ff:	00 
		get_func_name(fun_name, addr, &flag);
 8049700:	83 ec 04             	sub    $0x4,%esp
 8049703:	8d 44 24 20          	lea    0x20(%esp),%eax
 8049707:	50                   	push   %eax
 8049708:	ff 74 24 10          	pushl  0x10(%esp)
 804970c:	55                   	push   %ebp
 804970d:	e8 1e ff ff ff       	call   8049630 <get_func_name>
		if(!flag) {
 8049712:	83 c4 10             	add    $0x10,%esp
 8049715:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8049719:	85 c0                	test   %eax,%eax
 804971b:	0f 84 9f 00 00 00    	je     80497c0 <cmd_bt+0xf0>
			printf("the program haven't start yet.\n");
			return 0;
		}
		printf("#%d\t0x%x\tin %s()\n", cnt++, addr, fun_name);
 8049721:	8d 46 01             	lea    0x1(%esi),%eax
		if(strcmp(fun_name, "main") != 0) addr = swaddr_read(ebp + 4, 4);
 8049724:	bf b0 eb 05 08       	mov    $0x805ebb0,%edi
		get_func_name(fun_name, addr, &flag);
		if(!flag) {
			printf("the program haven't start yet.\n");
			return 0;
		}
		printf("#%d\t0x%x\tin %s()\n", cnt++, addr, fun_name);
 8049729:	89 44 24 0c          	mov    %eax,0xc(%esp)
 804972d:	55                   	push   %ebp
 804972e:	ff 74 24 0c          	pushl  0xc(%esp)
 8049732:	56                   	push   %esi
		if(strcmp(fun_name, "main") != 0) addr = swaddr_read(ebp + 4, 4);
 8049733:	89 ee                	mov    %ebp,%esi
		get_func_name(fun_name, addr, &flag);
		if(!flag) {
			printf("the program haven't start yet.\n");
			return 0;
		}
		printf("#%d\t0x%x\tin %s()\n", cnt++, addr, fun_name);
 8049735:	68 9e eb 05 08       	push   $0x805eb9e
 804973a:	e8 11 f2 ff ff       	call   8048950 <printf@plt>
		if(strcmp(fun_name, "main") != 0) addr = swaddr_read(ebp + 4, 4);
 804973f:	b9 05 00 00 00       	mov    $0x5,%ecx
 8049744:	f3 a6                	repz cmpsb %es:(%edi),%ds:(%esi)
 8049746:	0f 97 c2             	seta   %dl
 8049749:	0f 92 c0             	setb   %al
 804974c:	83 c4 10             	add    $0x10,%esp
 804974f:	38 c2                	cmp    %al,%dl
 8049751:	75 55                	jne    80497a8 <cmd_bt+0xd8>
		get_func_name(fun_name, addr, &flag);
		if(!flag) {
			printf("the program haven't start yet.\n");
			return 0;
		}
		printf("#%d\t0x%x\tin %s()\n", cnt++, addr, fun_name);
 8049753:	be 02 00 00 00       	mov    $0x2,%esi
		if(strcmp(fun_name, "main") != 0) addr = swaddr_read(ebp + 4, 4);
		for(i = 0; i < 4; i ++) {
			printf("\t0x%08x", swaddr_read(ebp + ((i + 2) << 2), 4));
 8049758:	8d 04 b3             	lea    (%ebx,%esi,4),%eax
 804975b:	83 ec 08             	sub    $0x8,%esp
 804975e:	83 c6 01             	add    $0x1,%esi
 8049761:	6a 04                	push   $0x4
 8049763:	50                   	push   %eax
 8049764:	e8 e7 17 00 00       	call   804af50 <swaddr_read>
 8049769:	59                   	pop    %ecx
 804976a:	5f                   	pop    %edi
 804976b:	50                   	push   %eax
 804976c:	68 b5 eb 05 08       	push   $0x805ebb5
 8049771:	e8 da f1 ff ff       	call   8048950 <printf@plt>
			printf("the program haven't start yet.\n");
			return 0;
		}
		printf("#%d\t0x%x\tin %s()\n", cnt++, addr, fun_name);
		if(strcmp(fun_name, "main") != 0) addr = swaddr_read(ebp + 4, 4);
		for(i = 0; i < 4; i ++) {
 8049776:	83 c4 10             	add    $0x10,%esp
 8049779:	83 fe 06             	cmp    $0x6,%esi
 804977c:	75 da                	jne    8049758 <cmd_bt+0x88>
			printf("\t0x%08x", swaddr_read(ebp + ((i + 2) << 2), 4));
		}
		printf("\n");
 804977e:	83 ec 0c             	sub    $0xc,%esp
 8049781:	6a 0a                	push   $0xa
 8049783:	e8 88 f3 ff ff       	call   8048b10 <putchar@plt>
		ebp = swaddr_read(ebp, 4);
 8049788:	58                   	pop    %eax
 8049789:	5a                   	pop    %edx
 804978a:	6a 04                	push   $0x4
 804978c:	53                   	push   %ebx
 804978d:	e8 be 17 00 00       	call   804af50 <swaddr_read>
static int cmd_bt(char *args) {
	swaddr_t addr = cpu.eip;
	uint32_t ebp = cpu.ebp;
	char fun_name[32];
	int i, flag, cnt = 0;
	while(ebp) {
 8049792:	83 c4 10             	add    $0x10,%esp
 8049795:	85 c0                	test   %eax,%eax
		if(strcmp(fun_name, "main") != 0) addr = swaddr_read(ebp + 4, 4);
		for(i = 0; i < 4; i ++) {
			printf("\t0x%08x", swaddr_read(ebp + ((i + 2) << 2), 4));
		}
		printf("\n");
		ebp = swaddr_read(ebp, 4);
 8049797:	89 c3                	mov    %eax,%ebx
static int cmd_bt(char *args) {
	swaddr_t addr = cpu.eip;
	uint32_t ebp = cpu.ebp;
	char fun_name[32];
	int i, flag, cnt = 0;
	while(ebp) {
 8049799:	74 35                	je     80497d0 <cmd_bt+0x100>
		get_func_name(fun_name, addr, &flag);
		if(!flag) {
			printf("the program haven't start yet.\n");
			return 0;
		}
		printf("#%d\t0x%x\tin %s()\n", cnt++, addr, fun_name);
 804979b:	8b 74 24 0c          	mov    0xc(%esp),%esi
 804979f:	e9 54 ff ff ff       	jmp    80496f8 <cmd_bt+0x28>
 80497a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if(strcmp(fun_name, "main") != 0) addr = swaddr_read(ebp + 4, 4);
 80497a8:	8d 43 04             	lea    0x4(%ebx),%eax
 80497ab:	83 ec 08             	sub    $0x8,%esp
 80497ae:	6a 04                	push   $0x4
 80497b0:	50                   	push   %eax
 80497b1:	e8 9a 17 00 00       	call   804af50 <swaddr_read>
 80497b6:	89 44 24 18          	mov    %eax,0x18(%esp)
 80497ba:	83 c4 10             	add    $0x10,%esp
 80497bd:	eb 94                	jmp    8049753 <cmd_bt+0x83>
 80497bf:	90                   	nop
	int i, flag, cnt = 0;
	while(ebp) {
		flag = 0;
		get_func_name(fun_name, addr, &flag);
		if(!flag) {
			printf("the program haven't start yet.\n");
 80497c0:	83 ec 0c             	sub    $0xc,%esp
 80497c3:	68 24 eb 05 08       	push   $0x805eb24
 80497c8:	e8 93 f2 ff ff       	call   8048a60 <puts@plt>
			return 0;
 80497cd:	83 c4 10             	add    $0x10,%esp
		}
		printf("\n");
		ebp = swaddr_read(ebp, 4);
	}
	return 0;
}
 80497d0:	83 c4 4c             	add    $0x4c,%esp
 80497d3:	31 c0                	xor    %eax,%eax
 80497d5:	5b                   	pop    %ebx
 80497d6:	5e                   	pop    %esi
 80497d7:	5f                   	pop    %edi
 80497d8:	5d                   	pop    %ebp
 80497d9:	c3                   	ret    
 80497da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

080497e0 <cmd_d>:
static int cmd_w(char *args) {
	add_wp(args);
	return 0;
}

static int cmd_d(char *args) {
 80497e0:	83 ec 0c             	sub    $0xc,%esp
 80497e3:	8b 44 24 10          	mov    0x10(%esp),%eax
	if(args == 0) {
 80497e7:	85 c0                	test   %eax,%eax
 80497e9:	74 25                	je     8049810 <cmd_d+0x30>
#ifdef __USE_EXTERN_INLINES
__BEGIN_NAMESPACE_STD
__extern_inline int
__NTH (atoi (const char *__nptr))
{
  return (int) strtol (__nptr, (char **) NULL, 10);
 80497eb:	83 ec 04             	sub    $0x4,%esp
 80497ee:	6a 0a                	push   $0xa
 80497f0:	6a 00                	push   $0x0
 80497f2:	50                   	push   %eax
 80497f3:	e8 a8 f3 ff ff       	call   8048ba0 <strtol@plt>
		delete_all_wp();
		return 0;
	}
	int no = atoi(args);
	delete_wp(no);
 80497f8:	89 04 24             	mov    %eax,(%esp)
 80497fb:	e8 e0 06 00 00       	call   8049ee0 <delete_wp>
	return 0;
 8049800:	83 c4 10             	add    $0x10,%esp
}
 8049803:	31 c0                	xor    %eax,%eax
 8049805:	83 c4 0c             	add    $0xc,%esp
 8049808:	c3                   	ret    
 8049809:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	return 0;
}

static int cmd_d(char *args) {
	if(args == 0) {
		delete_all_wp();
 8049810:	e8 7b 07 00 00       	call   8049f90 <delete_all_wp>
		return 0;
	}
	int no = atoi(args);
	delete_wp(no);
	return 0;
}
 8049815:	31 c0                	xor    %eax,%eax
 8049817:	83 c4 0c             	add    $0xc,%esp
 804981a:	c3                   	ret    
 804981b:	90                   	nop
 804981c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08049820 <cmd_w>:
		return 0;
	}
	return 0;
}

static int cmd_w(char *args) {
 8049820:	83 ec 18             	sub    $0x18,%esp
	add_wp(args);
 8049823:	ff 74 24 1c          	pushl  0x1c(%esp)
 8049827:	e8 64 06 00 00       	call   8049e90 <add_wp>
	return 0;
}
 804982c:	31 c0                	xor    %eax,%eax
 804982e:	83 c4 1c             	add    $0x1c,%esp
 8049831:	c3                   	ret    
 8049832:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049839:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049840 <cmd_p>:
	}
	printf("\n");
	return 0;
}

static int cmd_p(char *args) {
 8049840:	83 ec 24             	sub    $0x24,%esp
	bool flag = true;
	int n = expr(args, &flag);
 8049843:	8d 44 24 17          	lea    0x17(%esp),%eax
	printf("\n");
	return 0;
}

static int cmd_p(char *args) {
	bool flag = true;
 8049847:	c6 44 24 17 01       	movb   $0x1,0x17(%esp)
	int n = expr(args, &flag);
 804984c:	50                   	push   %eax
 804984d:	ff 74 24 2c          	pushl  0x2c(%esp)
 8049851:	e8 7a 12 00 00       	call   804aad0 <expr>
	if(flag) printf("0x%x\n", n);
 8049856:	83 c4 10             	add    $0x10,%esp
 8049859:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
 804985e:	75 20                	jne    8049880 <cmd_p+0x40>
	else {
		printf("not a correct expression.\n");
 8049860:	83 ec 0c             	sub    $0xc,%esp
 8049863:	68 c3 eb 05 08       	push   $0x805ebc3
 8049868:	e8 f3 f1 ff ff       	call   8048a60 <puts@plt>
		return 0;
 804986d:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
}
 8049870:	31 c0                	xor    %eax,%eax
 8049872:	83 c4 1c             	add    $0x1c,%esp
 8049875:	c3                   	ret    
 8049876:	8d 76 00             	lea    0x0(%esi),%esi
 8049879:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
}

static int cmd_p(char *args) {
	bool flag = true;
	int n = expr(args, &flag);
	if(flag) printf("0x%x\n", n);
 8049880:	83 ec 08             	sub    $0x8,%esp
 8049883:	50                   	push   %eax
 8049884:	68 bd eb 05 08       	push   $0x805ebbd
 8049889:	e8 c2 f0 ff ff       	call   8048950 <printf@plt>
	else {
		printf("not a correct expression.\n");
		return 0;
	}
	return 0;
 804988e:	83 c4 10             	add    $0x10,%esp
}
 8049891:	31 c0                	xor    %eax,%eax
 8049893:	83 c4 1c             	add    $0x1c,%esp
 8049896:	c3                   	ret    
 8049897:	89 f6                	mov    %esi,%esi
 8049899:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080498a0 <cmd_x>:
		print_wp_info();
	}
	return 0;
}

static int cmd_x(char *args) {
 80498a0:	57                   	push   %edi
 80498a1:	56                   	push   %esi
 80498a2:	53                   	push   %ebx
 80498a3:	83 ec 10             	sub    $0x10,%esp
 80498a6:	8b 74 24 20          	mov    0x20(%esp),%esi
	int i;
	int j = 0, n = 0, m = 0;
	bool flag = true;
 80498aa:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
	while(args[j]!=' ') {
 80498af:	80 3e 20             	cmpb   $0x20,(%esi)
 80498b2:	0f 84 c1 00 00 00    	je     8049979 <cmd_x+0xd9>
 80498b8:	31 c0                	xor    %eax,%eax
 80498ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		j++;
 80498c0:	83 c0 01             	add    $0x1,%eax

static int cmd_x(char *args) {
	int i;
	int j = 0, n = 0, m = 0;
	bool flag = true;
	while(args[j]!=' ') {
 80498c3:	80 3c 06 20          	cmpb   $0x20,(%esi,%eax,1)
 80498c7:	75 f7                	jne    80498c0 <cmd_x+0x20>
 80498c9:	8d 58 01             	lea    0x1(%eax),%ebx
 80498cc:	83 ec 04             	sub    $0x4,%esp
 80498cf:	6a 0a                	push   $0xa
 80498d1:	6a 00                	push   $0x0
 80498d3:	56                   	push   %esi
 80498d4:	e8 c7 f2 ff ff       	call   8048ba0 <strtol@plt>
 80498d9:	89 c7                	mov    %eax,%edi
		j++;
	}
	n = atoi(args);
	m = expr(args + j + 1, &flag);
 80498db:	58                   	pop    %eax
 80498dc:	5a                   	pop    %edx
 80498dd:	8d 14 1e             	lea    (%esi,%ebx,1),%edx
 80498e0:	8d 44 24 17          	lea    0x17(%esp),%eax
 80498e4:	50                   	push   %eax
 80498e5:	52                   	push   %edx
 80498e6:	e8 e5 11 00 00       	call   804aad0 <expr>
	if(!flag) {
 80498eb:	83 c4 10             	add    $0x10,%esp
 80498ee:	80 7c 24 0f 00       	cmpb   $0x0,0xf(%esp)
 80498f3:	74 6b                	je     8049960 <cmd_x+0xc0>
		printf("not a correct expression.\n");
		return 0;
	}
	for(i = 0; i < 4 * n; i += 4) {
 80498f5:	c1 e7 02             	shl    $0x2,%edi
 80498f8:	31 db                	xor    %ebx,%ebx
 80498fa:	89 c6                	mov    %eax,%esi
 80498fc:	85 ff                	test   %edi,%edi
 80498fe:	7f 2d                	jg     804992d <cmd_x+0x8d>
 8049900:	eb 46                	jmp    8049948 <cmd_x+0xa8>
 8049902:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		if((i & 15) == 0) printf("\n0x%08x:", m + i);
		printf(" 0x%08x", hwaddr_read(m + i, 4));
 8049908:	83 ec 08             	sub    $0x8,%esp
	m = expr(args + j + 1, &flag);
	if(!flag) {
		printf("not a correct expression.\n");
		return 0;
	}
	for(i = 0; i < 4 * n; i += 4) {
 804990b:	83 c3 04             	add    $0x4,%ebx
		if((i & 15) == 0) printf("\n0x%08x:", m + i);
		printf(" 0x%08x", hwaddr_read(m + i, 4));
 804990e:	6a 04                	push   $0x4
 8049910:	56                   	push   %esi
 8049911:	83 c6 04             	add    $0x4,%esi
 8049914:	e8 b7 15 00 00       	call   804aed0 <hwaddr_read>
 8049919:	5a                   	pop    %edx
 804991a:	59                   	pop    %ecx
 804991b:	50                   	push   %eax
 804991c:	68 e6 eb 05 08       	push   $0x805ebe6
 8049921:	e8 2a f0 ff ff       	call   8048950 <printf@plt>
	m = expr(args + j + 1, &flag);
	if(!flag) {
		printf("not a correct expression.\n");
		return 0;
	}
	for(i = 0; i < 4 * n; i += 4) {
 8049926:	83 c4 10             	add    $0x10,%esp
 8049929:	39 fb                	cmp    %edi,%ebx
 804992b:	7d 1b                	jge    8049948 <cmd_x+0xa8>
		if((i & 15) == 0) printf("\n0x%08x:", m + i);
 804992d:	f6 c3 0f             	test   $0xf,%bl
 8049930:	75 d6                	jne    8049908 <cmd_x+0x68>
 8049932:	83 ec 08             	sub    $0x8,%esp
 8049935:	56                   	push   %esi
 8049936:	68 dd eb 05 08       	push   $0x805ebdd
 804993b:	e8 10 f0 ff ff       	call   8048950 <printf@plt>
 8049940:	83 c4 10             	add    $0x10,%esp
 8049943:	eb c3                	jmp    8049908 <cmd_x+0x68>
 8049945:	8d 76 00             	lea    0x0(%esi),%esi
		printf(" 0x%08x", hwaddr_read(m + i, 4));
	}
	printf("\n");
 8049948:	83 ec 0c             	sub    $0xc,%esp
 804994b:	6a 0a                	push   $0xa
 804994d:	e8 be f1 ff ff       	call   8048b10 <putchar@plt>
	return 0;
 8049952:	83 c4 10             	add    $0x10,%esp
}
 8049955:	31 c0                	xor    %eax,%eax
 8049957:	83 c4 10             	add    $0x10,%esp
 804995a:	5b                   	pop    %ebx
 804995b:	5e                   	pop    %esi
 804995c:	5f                   	pop    %edi
 804995d:	c3                   	ret    
 804995e:	66 90                	xchg   %ax,%ax
		j++;
	}
	n = atoi(args);
	m = expr(args + j + 1, &flag);
	if(!flag) {
		printf("not a correct expression.\n");
 8049960:	83 ec 0c             	sub    $0xc,%esp
 8049963:	68 c3 eb 05 08       	push   $0x805ebc3
 8049968:	e8 f3 f0 ff ff       	call   8048a60 <puts@plt>
		return 0;
 804996d:	83 c4 10             	add    $0x10,%esp
		if((i & 15) == 0) printf("\n0x%08x:", m + i);
		printf(" 0x%08x", hwaddr_read(m + i, 4));
	}
	printf("\n");
	return 0;
}
 8049970:	31 c0                	xor    %eax,%eax
 8049972:	83 c4 10             	add    $0x10,%esp
 8049975:	5b                   	pop    %ebx
 8049976:	5e                   	pop    %esi
 8049977:	5f                   	pop    %edi
 8049978:	c3                   	ret    

static int cmd_x(char *args) {
	int i;
	int j = 0, n = 0, m = 0;
	bool flag = true;
	while(args[j]!=' ') {
 8049979:	bb 01 00 00 00       	mov    $0x1,%ebx
 804997e:	e9 49 ff ff ff       	jmp    80498cc <cmd_x+0x2c>
 8049983:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8049989:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049990 <cmd_si>:

static int cmd_q(char *args) {
	return -1;
}

static int cmd_si(char *args) {
 8049990:	83 ec 0c             	sub    $0xc,%esp
 8049993:	8b 44 24 10          	mov    0x10(%esp),%eax
	if(args == NULL)cpu_exec(1);
 8049997:	85 c0                	test   %eax,%eax
 8049999:	74 25                	je     80499c0 <cmd_si+0x30>
 804999b:	83 ec 04             	sub    $0x4,%esp
 804999e:	6a 0a                	push   $0xa
 80499a0:	6a 00                	push   $0x0
 80499a2:	50                   	push   %eax
 80499a3:	e8 f8 f1 ff ff       	call   8048ba0 <strtol@plt>
	else cpu_exec(atoi(args));
 80499a8:	89 04 24             	mov    %eax,(%esp)
 80499ab:	e8 90 13 00 00       	call   804ad40 <cpu_exec>
 80499b0:	83 c4 10             	add    $0x10,%esp
	return 0;
}
 80499b3:	31 c0                	xor    %eax,%eax
 80499b5:	83 c4 0c             	add    $0xc,%esp
 80499b8:	c3                   	ret    
 80499b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
static int cmd_q(char *args) {
	return -1;
}

static int cmd_si(char *args) {
	if(args == NULL)cpu_exec(1);
 80499c0:	83 ec 0c             	sub    $0xc,%esp
 80499c3:	6a 01                	push   $0x1
 80499c5:	e8 76 13 00 00       	call   804ad40 <cpu_exec>
 80499ca:	83 c4 10             	add    $0x10,%esp
	else cpu_exec(atoi(args));
	return 0;
}
 80499cd:	31 c0                	xor    %eax,%eax
 80499cf:	83 c4 0c             	add    $0xc,%esp
 80499d2:	c3                   	ret    
 80499d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80499d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080499e0 <cmd_c>:
	}

	return line_read;
}

static int cmd_c(char *args) {
 80499e0:	83 ec 18             	sub    $0x18,%esp
	cpu_exec(-1);
 80499e3:	6a ff                	push   $0xffffffff
 80499e5:	e8 56 13 00 00       	call   804ad40 <cpu_exec>
	return 0;
}
 80499ea:	31 c0                	xor    %eax,%eax
 80499ec:	83 c4 1c             	add    $0x1c,%esp
 80499ef:	c3                   	ret    

080499f0 <cmd_help>:

};

#define NR_CMD (sizeof(cmd_table) / sizeof(cmd_table[0]))

static int cmd_help(char *args) {
 80499f0:	55                   	push   %ebp
 80499f1:	57                   	push   %edi
 80499f2:	56                   	push   %esi
 80499f3:	53                   	push   %ebx
	/* extract the first argument */
	char *arg = strtok(NULL, " ");
	int i;

	if(arg == NULL) {
 80499f4:	31 db                	xor    %ebx,%ebx
 80499f6:	be 00 ed 05 08       	mov    $0x805ed00,%esi

};

#define NR_CMD (sizeof(cmd_table) / sizeof(cmd_table[0]))

static int cmd_help(char *args) {
 80499fb:	83 ec 14             	sub    $0x14,%esp
	/* extract the first argument */
	char *arg = strtok(NULL, " ");
 80499fe:	68 a6 f1 05 08       	push   $0x805f1a6
 8049a03:	6a 00                	push   $0x0
 8049a05:	e8 56 f1 ff ff       	call   8048b60 <strtok@plt>
	int i;

	if(arg == NULL) {
 8049a0a:	83 c4 10             	add    $0x10,%esp
 8049a0d:	85 c0                	test   %eax,%eax

#define NR_CMD (sizeof(cmd_table) / sizeof(cmd_table[0]))

static int cmd_help(char *args) {
	/* extract the first argument */
	char *arg = strtok(NULL, " ");
 8049a0f:	89 c5                	mov    %eax,%ebp
	int i;

	if(arg == NULL) {
 8049a11:	74 6d                	je     8049a80 <cmd_help+0x90>
 8049a13:	90                   	nop
 8049a14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			printf("%s - %s\n", cmd_table[i].name, cmd_table[i].description);
		}
	}
	else {
		for(i = 0; i < NR_CMD; i ++) {
			if(strcmp(arg, cmd_table[i].name) == 0) {
 8049a18:	8b 3e                	mov    (%esi),%edi
 8049a1a:	83 ec 08             	sub    $0x8,%esp
 8049a1d:	57                   	push   %edi
 8049a1e:	55                   	push   %ebp
 8049a1f:	e8 1c ef ff ff       	call   8048940 <strcmp@plt>
 8049a24:	83 c4 10             	add    $0x10,%esp
 8049a27:	85 c0                	test   %eax,%eax
 8049a29:	74 2d                	je     8049a58 <cmd_help+0x68>
		for(i = 0; i < NR_CMD; i ++) {
			printf("%s - %s\n", cmd_table[i].name, cmd_table[i].description);
		}
	}
	else {
		for(i = 0; i < NR_CMD; i ++) {
 8049a2b:	83 c3 01             	add    $0x1,%ebx
 8049a2e:	83 c6 0c             	add    $0xc,%esi
 8049a31:	83 fb 0a             	cmp    $0xa,%ebx
 8049a34:	75 e2                	jne    8049a18 <cmd_help+0x28>
			if(strcmp(arg, cmd_table[i].name) == 0) {
				printf("%s - %s\n", cmd_table[i].name, cmd_table[i].description);
				return 0;
			}
		}
		printf("Unknown command '%s'\n", arg);
 8049a36:	83 ec 08             	sub    $0x8,%esp
 8049a39:	55                   	push   %ebp
 8049a3a:	68 f7 eb 05 08       	push   $0x805ebf7
 8049a3f:	e8 0c ef ff ff       	call   8048950 <printf@plt>
 8049a44:	83 c4 10             	add    $0x10,%esp
	}
	return 0;
}
 8049a47:	31 c0                	xor    %eax,%eax
 8049a49:	83 c4 0c             	add    $0xc,%esp
 8049a4c:	5b                   	pop    %ebx
 8049a4d:	5e                   	pop    %esi
 8049a4e:	5f                   	pop    %edi
 8049a4f:	5d                   	pop    %ebp
 8049a50:	c3                   	ret    
 8049a51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		}
	}
	else {
		for(i = 0; i < NR_CMD; i ++) {
			if(strcmp(arg, cmd_table[i].name) == 0) {
				printf("%s - %s\n", cmd_table[i].name, cmd_table[i].description);
 8049a58:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
 8049a5b:	83 ec 04             	sub    $0x4,%esp
 8049a5e:	ff 34 85 04 ed 05 08 	pushl  0x805ed04(,%eax,4)
 8049a65:	57                   	push   %edi
 8049a66:	68 ee eb 05 08       	push   $0x805ebee
 8049a6b:	e8 e0 ee ff ff       	call   8048950 <printf@plt>
				return 0;
 8049a70:	83 c4 10             	add    $0x10,%esp
			}
		}
		printf("Unknown command '%s'\n", arg);
	}
	return 0;
}
 8049a73:	31 c0                	xor    %eax,%eax
 8049a75:	83 c4 0c             	add    $0xc,%esp
 8049a78:	5b                   	pop    %ebx
 8049a79:	5e                   	pop    %esi
 8049a7a:	5f                   	pop    %edi
 8049a7b:	5d                   	pop    %ebp
 8049a7c:	c3                   	ret    
 8049a7d:	8d 76 00             	lea    0x0(%esi),%esi
 8049a80:	bb 04 ed 05 08       	mov    $0x805ed04,%ebx
 8049a85:	8d 76 00             	lea    0x0(%esi),%esi
	int i;

	if(arg == NULL) {
		/* no argument given */
		for(i = 0; i < NR_CMD; i ++) {
			printf("%s - %s\n", cmd_table[i].name, cmd_table[i].description);
 8049a88:	83 ec 04             	sub    $0x4,%esp
 8049a8b:	ff 33                	pushl  (%ebx)
 8049a8d:	ff 73 fc             	pushl  -0x4(%ebx)
 8049a90:	68 ee eb 05 08       	push   $0x805ebee
 8049a95:	83 c3 0c             	add    $0xc,%ebx
 8049a98:	e8 b3 ee ff ff       	call   8048950 <printf@plt>
	char *arg = strtok(NULL, " ");
	int i;

	if(arg == NULL) {
		/* no argument given */
		for(i = 0; i < NR_CMD; i ++) {
 8049a9d:	83 c4 10             	add    $0x10,%esp
 8049aa0:	81 fb 7c ed 05 08    	cmp    $0x805ed7c,%ebx
 8049aa6:	75 e0                	jne    8049a88 <cmd_help+0x98>
			}
		}
		printf("Unknown command '%s'\n", arg);
	}
	return 0;
}
 8049aa8:	83 c4 0c             	add    $0xc,%esp
 8049aab:	31 c0                	xor    %eax,%eax
 8049aad:	5b                   	pop    %ebx
 8049aae:	5e                   	pop    %esi
 8049aaf:	5f                   	pop    %edi
 8049ab0:	5d                   	pop    %ebp
 8049ab1:	c3                   	ret    
 8049ab2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049ab9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049ac0 <cmd_info>:
	if(args == NULL)cpu_exec(1);
	else cpu_exec(atoi(args));
	return 0;
}

static int cmd_info(char *args) {
 8049ac0:	53                   	push   %ebx
 8049ac1:	83 ec 08             	sub    $0x8,%esp
 8049ac4:	8b 44 24 10          	mov    0x10(%esp),%eax
	int i;
	if(args == NULL) {
 8049ac8:	85 c0                	test   %eax,%eax
 8049aca:	0f 84 e8 00 00 00    	je     8049bb8 <cmd_info+0xf8>
		printf("no input!");
		return 0;
	}
	if(args[0] == 'r') {
 8049ad0:	0f b6 00             	movzbl (%eax),%eax
 8049ad3:	3c 72                	cmp    $0x72,%al
 8049ad5:	74 19                	je     8049af0 <cmd_info+0x30>
		printf("OF = %d\n", cpu.OF);
		printf("CF = %d\n", cpu.CF);
		printf("SF = %d\n", cpu.SF);
		printf("ZF = %d\n", cpu.ZF);
	}
	else if(args[0] == 'w') {
 8049ad7:	3c 77                	cmp    $0x77,%al
 8049ad9:	0f 84 c9 00 00 00    	je     8049ba8 <cmd_info+0xe8>
		print_wp_info();
	}
	return 0;
}
 8049adf:	83 c4 08             	add    $0x8,%esp
 8049ae2:	31 c0                	xor    %eax,%eax
 8049ae4:	5b                   	pop    %ebx
 8049ae5:	c3                   	ret    
 8049ae6:	8d 76 00             	lea    0x0(%esi),%esi
 8049ae9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 8049af0:	31 db                	xor    %ebx,%ebx
		printf("no input!");
		return 0;
	}
	if(args[0] == 'r') {
		for(i = R_EAX; i <= R_EDI; i ++) {
			printf("%s = 0x%08x\n", regsl[i], reg_l(i));
 8049af2:	83 ec 04             	sub    $0x4,%esp
 8049af5:	ff 34 9d c0 af 0f 10 	pushl  0x100fafc0(,%ebx,4)
 8049afc:	ff 34 9d c0 5c 07 08 	pushl  0x8075cc0(,%ebx,4)
 8049b03:	68 17 ec 05 08       	push   $0x805ec17
	if(args == NULL) {
		printf("no input!");
		return 0;
	}
	if(args[0] == 'r') {
		for(i = R_EAX; i <= R_EDI; i ++) {
 8049b08:	83 c3 01             	add    $0x1,%ebx
			printf("%s = 0x%08x\n", regsl[i], reg_l(i));
 8049b0b:	e8 40 ee ff ff       	call   8048950 <printf@plt>
	if(args == NULL) {
		printf("no input!");
		return 0;
	}
	if(args[0] == 'r') {
		for(i = R_EAX; i <= R_EDI; i ++) {
 8049b10:	83 c4 10             	add    $0x10,%esp
 8049b13:	83 fb 08             	cmp    $0x8,%ebx
 8049b16:	75 da                	jne    8049af2 <cmd_info+0x32>
			printf("%s = 0x%04x\n", regsw[i], reg_w(i));
		}
		for(i = R_AL; i <= R_BH; i ++) {
			printf("%s = 0x%02x\n", regsb[i], reg_b(i));
		}*/
		printf("PF = %d\n", cpu.PF);
 8049b18:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 8049b1f:	83 ec 08             	sub    $0x8,%esp
 8049b22:	c0 e8 02             	shr    $0x2,%al
 8049b25:	83 e0 01             	and    $0x1,%eax
 8049b28:	50                   	push   %eax
 8049b29:	68 24 ec 05 08       	push   $0x805ec24
 8049b2e:	e8 1d ee ff ff       	call   8048950 <printf@plt>
		printf("OF = %d\n", cpu.OF);
 8049b33:	58                   	pop    %eax
 8049b34:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
 8049b3b:	5a                   	pop    %edx
 8049b3c:	c0 e8 03             	shr    $0x3,%al
 8049b3f:	83 e0 01             	and    $0x1,%eax
 8049b42:	50                   	push   %eax
 8049b43:	68 2d ec 05 08       	push   $0x805ec2d
 8049b48:	e8 03 ee ff ff       	call   8048950 <printf@plt>
		printf("CF = %d\n", cpu.CF);
 8049b4d:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 8049b54:	59                   	pop    %ecx
 8049b55:	5b                   	pop    %ebx
 8049b56:	83 e0 01             	and    $0x1,%eax
 8049b59:	50                   	push   %eax
 8049b5a:	68 36 ec 05 08       	push   $0x805ec36
 8049b5f:	e8 ec ed ff ff       	call   8048950 <printf@plt>
		printf("SF = %d\n", cpu.SF);
 8049b64:	58                   	pop    %eax
 8049b65:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 8049b6c:	5a                   	pop    %edx
 8049b6d:	c0 e8 07             	shr    $0x7,%al
 8049b70:	0f b6 c0             	movzbl %al,%eax
 8049b73:	50                   	push   %eax
 8049b74:	68 3f ec 05 08       	push   $0x805ec3f
 8049b79:	e8 d2 ed ff ff       	call   8048950 <printf@plt>
		printf("ZF = %d\n", cpu.ZF);
 8049b7e:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 8049b85:	59                   	pop    %ecx
 8049b86:	5b                   	pop    %ebx
 8049b87:	c0 e8 06             	shr    $0x6,%al
 8049b8a:	83 e0 01             	and    $0x1,%eax
 8049b8d:	50                   	push   %eax
 8049b8e:	68 48 ec 05 08       	push   $0x805ec48
 8049b93:	e8 b8 ed ff ff       	call   8048950 <printf@plt>
 8049b98:	83 c4 10             	add    $0x10,%esp
	}
	else if(args[0] == 'w') {
		print_wp_info();
	}
	return 0;
}
 8049b9b:	31 c0                	xor    %eax,%eax
 8049b9d:	83 c4 08             	add    $0x8,%esp
 8049ba0:	5b                   	pop    %ebx
 8049ba1:	c3                   	ret    
 8049ba2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		printf("CF = %d\n", cpu.CF);
		printf("SF = %d\n", cpu.SF);
		printf("ZF = %d\n", cpu.ZF);
	}
	else if(args[0] == 'w') {
		print_wp_info();
 8049ba8:	e8 93 02 00 00       	call   8049e40 <print_wp_info>
	}
	return 0;
}
 8049bad:	83 c4 08             	add    $0x8,%esp
 8049bb0:	31 c0                	xor    %eax,%eax
 8049bb2:	5b                   	pop    %ebx
 8049bb3:	c3                   	ret    
 8049bb4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
}

static int cmd_info(char *args) {
	int i;
	if(args == NULL) {
		printf("no input!");
 8049bb8:	83 ec 0c             	sub    $0xc,%esp
 8049bbb:	68 0d ec 05 08       	push   $0x805ec0d
 8049bc0:	e8 8b ed ff ff       	call   8048950 <printf@plt>
		return 0;
 8049bc5:	83 c4 10             	add    $0x10,%esp
 8049bc8:	e9 12 ff ff ff       	jmp    8049adf <cmd_info+0x1f>
 8049bcd:	8d 76 00             	lea    0x0(%esi),%esi

08049bd0 <rl_gets>:
void get_func_name(char *, swaddr_t, int *);

void cpu_exec(uint32_t);

/* We use the ``readline'' library to provide more flexibility to read from stdin. */
char* rl_gets() {
 8049bd0:	83 ec 0c             	sub    $0xc,%esp
	static char *line_read = NULL;

	if (line_read) {
 8049bd3:	a1 3c 5d 07 08       	mov    0x8075d3c,%eax
 8049bd8:	85 c0                	test   %eax,%eax
 8049bda:	74 16                	je     8049bf2 <rl_gets+0x22>
		free(line_read);
 8049bdc:	83 ec 0c             	sub    $0xc,%esp
 8049bdf:	50                   	push   %eax
 8049be0:	e8 9b ed ff ff       	call   8048980 <free@plt>
		line_read = NULL;
 8049be5:	c7 05 3c 5d 07 08 00 	movl   $0x0,0x8075d3c
 8049bec:	00 00 00 
 8049bef:	83 c4 10             	add    $0x10,%esp
	}

	line_read = readline("(nemu) ");
 8049bf2:	83 ec 0c             	sub    $0xc,%esp
 8049bf5:	68 51 ec 05 08       	push   $0x805ec51
 8049bfa:	e8 01 ee ff ff       	call   8048a00 <readline@plt>

	if (line_read && *line_read) {
 8049bff:	83 c4 10             	add    $0x10,%esp
 8049c02:	85 c0                	test   %eax,%eax
	if (line_read) {
		free(line_read);
		line_read = NULL;
	}

	line_read = readline("(nemu) ");
 8049c04:	a3 3c 5d 07 08       	mov    %eax,0x8075d3c

	if (line_read && *line_read) {
 8049c09:	74 16                	je     8049c21 <rl_gets+0x51>
 8049c0b:	80 38 00             	cmpb   $0x0,(%eax)
 8049c0e:	74 11                	je     8049c21 <rl_gets+0x51>
		add_history(line_read);
 8049c10:	83 ec 0c             	sub    $0xc,%esp
 8049c13:	50                   	push   %eax
 8049c14:	e8 77 ed ff ff       	call   8048990 <add_history@plt>
 8049c19:	a1 3c 5d 07 08       	mov    0x8075d3c,%eax
 8049c1e:	83 c4 10             	add    $0x10,%esp
	}

	return line_read;
}
 8049c21:	83 c4 0c             	add    $0xc,%esp
 8049c24:	c3                   	ret    
 8049c25:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049c29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049c30 <ui_mainloop>:
		printf("Unknown command '%s'\n", arg);
	}
	return 0;
}

void ui_mainloop() {
 8049c30:	55                   	push   %ebp
 8049c31:	57                   	push   %edi
 8049c32:	56                   	push   %esi
 8049c33:	53                   	push   %ebx
 8049c34:	83 ec 0c             	sub    $0xc,%esp
 8049c37:	89 f6                	mov    %esi,%esi
 8049c39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	while(1) {
		char *str = rl_gets();
 8049c40:	e8 8b ff ff ff       	call   8049bd0 <rl_gets>
		char *str_end = str + strlen(str);
 8049c45:	83 ec 0c             	sub    $0xc,%esp
	return 0;
}

void ui_mainloop() {
	while(1) {
		char *str = rl_gets();
 8049c48:	89 c3                	mov    %eax,%ebx
		char *str_end = str + strlen(str);
 8049c4a:	50                   	push   %eax
 8049c4b:	e8 50 ee ff ff       	call   8048aa0 <strlen@plt>
 8049c50:	5a                   	pop    %edx
 8049c51:	59                   	pop    %ecx

		/* extract the first token as the command */
		char *cmd = strtok(str, " ");
 8049c52:	68 a6 f1 05 08       	push   $0x805f1a6
 8049c57:	53                   	push   %ebx
}

void ui_mainloop() {
	while(1) {
		char *str = rl_gets();
		char *str_end = str + strlen(str);
 8049c58:	89 c6                	mov    %eax,%esi

		/* extract the first token as the command */
		char *cmd = strtok(str, " ");
 8049c5a:	e8 01 ef ff ff       	call   8048b60 <strtok@plt>
		if(cmd == NULL) { continue; }
 8049c5f:	83 c4 10             	add    $0x10,%esp
 8049c62:	85 c0                	test   %eax,%eax
	while(1) {
		char *str = rl_gets();
		char *str_end = str + strlen(str);

		/* extract the first token as the command */
		char *cmd = strtok(str, " ");
 8049c64:	89 c7                	mov    %eax,%edi
		if(cmd == NULL) { continue; }
 8049c66:	74 d8                	je     8049c40 <ui_mainloop+0x10>

		/* treat the remaining string as the arguments,
		 * which may need further parsing
		 */
		char *args = cmd + strlen(cmd) + 1;
 8049c68:	83 ec 0c             	sub    $0xc,%esp
}

void ui_mainloop() {
	while(1) {
		char *str = rl_gets();
		char *str_end = str + strlen(str);
 8049c6b:	01 f3                	add    %esi,%ebx
 8049c6d:	be 00 ed 05 08       	mov    $0x805ed00,%esi
		if(cmd == NULL) { continue; }

		/* treat the remaining string as the arguments,
		 * which may need further parsing
		 */
		char *args = cmd + strlen(cmd) + 1;
 8049c72:	50                   	push   %eax
 8049c73:	e8 28 ee ff ff       	call   8048aa0 <strlen@plt>
 8049c78:	8d 6c 07 01          	lea    0x1(%edi,%eax,1),%ebp
 8049c7c:	83 c4 10             	add    $0x10,%esp
		if(args >= str_end) {
			args = NULL;
 8049c7f:	39 dd                	cmp    %ebx,%ebp
 8049c81:	19 c0                	sbb    %eax,%eax
 8049c83:	31 db                	xor    %ebx,%ebx
 8049c85:	21 c5                	and    %eax,%ebp
 8049c87:	89 f6                	mov    %esi,%esi
 8049c89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		sdl_clear_event_queue();
#endif

		int i;
		for(i = 0; i < NR_CMD; i ++) {
			if(strcmp(cmd, cmd_table[i].name) == 0) {
 8049c90:	83 ec 08             	sub    $0x8,%esp
 8049c93:	ff 36                	pushl  (%esi)
 8049c95:	57                   	push   %edi
 8049c96:	e8 a5 ec ff ff       	call   8048940 <strcmp@plt>
 8049c9b:	83 c4 10             	add    $0x10,%esp
 8049c9e:	85 c0                	test   %eax,%eax
 8049ca0:	74 1e                	je     8049cc0 <ui_mainloop+0x90>
		extern void sdl_clear_event_queue(void);
		sdl_clear_event_queue();
#endif

		int i;
		for(i = 0; i < NR_CMD; i ++) {
 8049ca2:	83 c3 01             	add    $0x1,%ebx
 8049ca5:	83 c6 0c             	add    $0xc,%esi
 8049ca8:	83 fb 0a             	cmp    $0xa,%ebx
 8049cab:	75 e3                	jne    8049c90 <ui_mainloop+0x60>
				if(cmd_table[i].handler(args) < 0) { return; }
				break;
			}
		}

		if(i == NR_CMD) { printf("Unknown command '%s'\n", cmd); }
 8049cad:	83 ec 08             	sub    $0x8,%esp
 8049cb0:	57                   	push   %edi
 8049cb1:	68 f7 eb 05 08       	push   $0x805ebf7
 8049cb6:	e8 95 ec ff ff       	call   8048950 <printf@plt>
 8049cbb:	83 c4 10             	add    $0x10,%esp
 8049cbe:	eb 80                	jmp    8049c40 <ui_mainloop+0x10>
#endif

		int i;
		for(i = 0; i < NR_CMD; i ++) {
			if(strcmp(cmd, cmd_table[i].name) == 0) {
				if(cmd_table[i].handler(args) < 0) { return; }
 8049cc0:	83 ec 0c             	sub    $0xc,%esp
 8049cc3:	8d 04 5b             	lea    (%ebx,%ebx,2),%eax
 8049cc6:	55                   	push   %ebp
 8049cc7:	ff 14 85 08 ed 05 08 	call   *0x805ed08(,%eax,4)
 8049cce:	83 c4 10             	add    $0x10,%esp
 8049cd1:	85 c0                	test   %eax,%eax
 8049cd3:	0f 89 67 ff ff ff    	jns    8049c40 <ui_mainloop+0x10>
			}
		}

		if(i == NR_CMD) { printf("Unknown command '%s'\n", cmd); }
	}
}
 8049cd9:	83 c4 0c             	add    $0xc,%esp
 8049cdc:	5b                   	pop    %ebx
 8049cdd:	5e                   	pop    %esi
 8049cde:	5f                   	pop    %edi
 8049cdf:	5d                   	pop    %ebp
 8049ce0:	c3                   	ret    
 8049ce1:	66 90                	xchg   %ax,%ax
 8049ce3:	66 90                	xchg   %ax,%ax
 8049ce5:	66 90                	xchg   %ax,%ax
 8049ce7:	66 90                	xchg   %ax,%ax
 8049ce9:	66 90                	xchg   %ax,%ax
 8049ceb:	66 90                	xchg   %ax,%ax
 8049ced:	66 90                	xchg   %ax,%ax
 8049cef:	90                   	nop

08049cf0 <init_wp_list>:

static WP wp_list[NR_WP];
static WP *head, *free_;
static int wp_num = 0;

void init_wp_list() {
 8049cf0:	b8 8c 5e 07 08       	mov    $0x8075e8c,%eax
	int i;
	for(i = 0; i < NR_WP; i ++) {
 8049cf5:	31 d2                	xor    %edx,%edx
 8049cf7:	89 f6                	mov    %esi,%esi
 8049cf9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		wp_list[i].NO = i;
 8049d00:	89 90 f4 fe ff ff    	mov    %edx,-0x10c(%eax)
		wp_list[i].next = &wp_list[i + 1];
 8049d06:	83 c2 01             	add    $0x1,%edx
 8049d09:	89 80 f8 fe ff ff    	mov    %eax,-0x108(%eax)
 8049d0f:	05 0c 01 00 00       	add    $0x10c,%eax
static WP *head, *free_;
static int wp_num = 0;

void init_wp_list() {
	int i;
	for(i = 0; i < NR_WP; i ++) {
 8049d14:	83 fa 20             	cmp    $0x20,%edx
 8049d17:	75 e7                	jne    8049d00 <init_wp_list+0x10>
		wp_list[i].NO = i;
		wp_list[i].next = &wp_list[i + 1];
	}
	wp_list[NR_WP - 1].next = NULL;
 8049d19:	c7 05 f8 7d 07 08 00 	movl   $0x0,0x8077df8
 8049d20:	00 00 00 

	head = NULL;
 8049d23:	c7 05 48 5d 07 08 00 	movl   $0x0,0x8075d48
 8049d2a:	00 00 00 
	free_ = wp_list;
 8049d2d:	c7 05 44 5d 07 08 80 	movl   $0x8075d80,0x8075d44
 8049d34:	5d 07 08 
 8049d37:	c3                   	ret    
 8049d38:	90                   	nop
 8049d39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08049d40 <new_wp>:
}

WP* new_wp() {
	WP *now = free_;
 8049d40:	a1 44 5d 07 08       	mov    0x8075d44,%eax
	
	if(free_ == NULL) {
 8049d45:	85 c0                	test   %eax,%eax
 8049d47:	74 18                	je     8049d61 <new_wp+0x21>
		printf("no more points!\n");
		assert(0);	
	}	

	free_ = (*free_).next;
 8049d49:	8b 50 04             	mov    0x4(%eax),%edx
 8049d4c:	89 15 44 5d 07 08    	mov    %edx,0x8075d44
	(*now).next = head;
 8049d52:	8b 15 48 5d 07 08    	mov    0x8075d48,%edx
	head = now;
 8049d58:	a3 48 5d 07 08       	mov    %eax,0x8075d48
		printf("no more points!\n");
		assert(0);	
	}	

	free_ = (*free_).next;
	(*now).next = head;
 8049d5d:	89 50 04             	mov    %edx,0x4(%eax)
	head = now;

	return now;
}
 8049d60:	c3                   	ret    

	head = NULL;
	free_ = wp_list;
}

WP* new_wp() {
 8049d61:	83 ec 18             	sub    $0x18,%esp
	WP *now = free_;
	
	if(free_ == NULL) {
		printf("no more points!\n");
 8049d64:	68 78 ed 05 08       	push   $0x805ed78
 8049d69:	e8 f2 ec ff ff       	call   8048a60 <puts@plt>
		assert(0);	
 8049d6e:	68 14 ee 05 08       	push   $0x805ee14
 8049d73:	6a 1b                	push   $0x1b
 8049d75:	68 e8 ed 05 08       	push   $0x805ede8
 8049d7a:	68 1c ea 05 08       	push   $0x805ea1c
 8049d7f:	e8 2c ee ff ff       	call   8048bb0 <__assert_fail@plt>
 8049d84:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8049d8a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08049d90 <free_wp>:
	head = now;

	return now;
}

void free_wp(WP *wp) {
 8049d90:	83 ec 0c             	sub    $0xc,%esp
 8049d93:	8b 4c 24 10          	mov    0x10(%esp),%ecx
	if(wp == NULL) {
 8049d97:	85 c9                	test   %ecx,%ecx
 8049d99:	74 77                	je     8049e12 <free_wp+0x82>
		printf("free a null ponit!\n");
		assert(0);
	}

	WP *now = head;
 8049d9b:	8b 15 48 5d 07 08    	mov    0x8075d48,%edx

	if(wp == head) {
 8049da1:	39 d1                	cmp    %edx,%ecx
 8049da3:	75 11                	jne    8049db6 <free_wp+0x26>
 8049da5:	eb 51                	jmp    8049df8 <free_wp+0x68>
 8049da7:	89 f6                	mov    %esi,%esi
 8049da9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		free_ = wp;
		return;
	}

	while((*now).next != NULL) {
		if((*now).next == wp) {
 8049db0:	39 c1                	cmp    %eax,%ecx
 8049db2:	74 2c                	je     8049de0 <free_wp+0x50>
 8049db4:	89 c2                	mov    %eax,%edx
		(*wp).next = free_;
		free_ = wp;
		return;
	}

	while((*now).next != NULL) {
 8049db6:	8b 42 04             	mov    0x4(%edx),%eax
 8049db9:	85 c0                	test   %eax,%eax
 8049dbb:	75 f3                	jne    8049db0 <free_wp+0x20>
		}
		now = (*now).next;
	}

	if((*now).next == NULL) {
		printf("no this point\n");
 8049dbd:	83 ec 0c             	sub    $0xc,%esp
 8049dc0:	68 9b ed 05 08       	push   $0x805ed9b
 8049dc5:	e8 96 ec ff ff       	call   8048a60 <puts@plt>
		assert(0);
 8049dca:	68 0c ee 05 08       	push   $0x805ee0c
 8049dcf:	6a 40                	push   $0x40
 8049dd1:	68 e8 ed 05 08       	push   $0x805ede8
 8049dd6:	68 1c ea 05 08       	push   $0x805ea1c
 8049ddb:	e8 d0 ed ff ff       	call   8048bb0 <__assert_fail@plt>
		return;
	}

	while((*now).next != NULL) {
		if((*now).next == wp) {
			(*now).next = (*wp).next;
 8049de0:	8b 41 04             	mov    0x4(%ecx),%eax
 8049de3:	89 42 04             	mov    %eax,0x4(%edx)
			(*wp).next = free_;
 8049de6:	a1 44 5d 07 08       	mov    0x8075d44,%eax
			free_ = wp;
 8049deb:	89 0d 44 5d 07 08    	mov    %ecx,0x8075d44
	}

	while((*now).next != NULL) {
		if((*now).next == wp) {
			(*now).next = (*wp).next;
			(*wp).next = free_;
 8049df1:	89 41 04             	mov    %eax,0x4(%ecx)

	if((*now).next == NULL) {
		printf("no this point\n");
		assert(0);
	}
}
 8049df4:	83 c4 0c             	add    $0xc,%esp
 8049df7:	c3                   	ret    
	}

	WP *now = head;

	if(wp == head) {
		head = (*head).next;
 8049df8:	8b 41 04             	mov    0x4(%ecx),%eax
 8049dfb:	a3 48 5d 07 08       	mov    %eax,0x8075d48
		(*wp).next = free_;
 8049e00:	a1 44 5d 07 08       	mov    0x8075d44,%eax
		free_ = wp;
 8049e05:	89 0d 44 5d 07 08    	mov    %ecx,0x8075d44

	WP *now = head;

	if(wp == head) {
		head = (*head).next;
		(*wp).next = free_;
 8049e0b:	89 41 04             	mov    %eax,0x4(%ecx)

	if((*now).next == NULL) {
		printf("no this point\n");
		assert(0);
	}
}
 8049e0e:	83 c4 0c             	add    $0xc,%esp
 8049e11:	c3                   	ret    
	return now;
}

void free_wp(WP *wp) {
	if(wp == NULL) {
		printf("free a null ponit!\n");
 8049e12:	83 ec 0c             	sub    $0xc,%esp
 8049e15:	68 88 ed 05 08       	push   $0x805ed88
 8049e1a:	e8 41 ec ff ff       	call   8048a60 <puts@plt>
		assert(0);
 8049e1f:	68 0c ee 05 08       	push   $0x805ee0c
 8049e24:	6a 28                	push   $0x28
 8049e26:	68 e8 ed 05 08       	push   $0x805ede8
 8049e2b:	68 1c ea 05 08       	push   $0x805ea1c
 8049e30:	e8 7b ed ff ff       	call   8048bb0 <__assert_fail@plt>
 8049e35:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049e39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049e40 <print_wp_info>:
		printf("no this point\n");
		assert(0);
	}
}

void print_wp_info() {
 8049e40:	53                   	push   %ebx
 8049e41:	83 ec 14             	sub    $0x14,%esp
	WP* now = head;
 8049e44:	8b 1d 48 5d 07 08    	mov    0x8075d48,%ebx
	printf("Num\tValue\tExpr\n");
 8049e4a:	68 a9 ed 05 08       	push   $0x805eda9
 8049e4f:	e8 0c ec ff ff       	call   8048a60 <puts@plt>
	while(now != NULL) {
 8049e54:	83 c4 10             	add    $0x10,%esp
 8049e57:	85 db                	test   %ebx,%ebx
 8049e59:	74 22                	je     8049e7d <print_wp_info+0x3d>
 8049e5b:	90                   	nop
 8049e5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		printf("%d\t%d\t%s\n", (*now).NO, (*now).v, (*now).expr);
 8049e60:	8d 43 0c             	lea    0xc(%ebx),%eax
 8049e63:	50                   	push   %eax
 8049e64:	ff 73 08             	pushl  0x8(%ebx)
 8049e67:	ff 33                	pushl  (%ebx)
 8049e69:	68 b8 ed 05 08       	push   $0x805edb8
 8049e6e:	e8 dd ea ff ff       	call   8048950 <printf@plt>
		now = (*now).next;
 8049e73:	8b 5b 04             	mov    0x4(%ebx),%ebx
}

void print_wp_info() {
	WP* now = head;
	printf("Num\tValue\tExpr\n");
	while(now != NULL) {
 8049e76:	83 c4 10             	add    $0x10,%esp
 8049e79:	85 db                	test   %ebx,%ebx
 8049e7b:	75 e3                	jne    8049e60 <print_wp_info+0x20>
		printf("%d\t%d\t%s\n", (*now).NO, (*now).v, (*now).expr);
		now = (*now).next;
	}
}
 8049e7d:	83 c4 08             	add    $0x8,%esp
 8049e80:	5b                   	pop    %ebx
 8049e81:	c3                   	ret    
 8049e82:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8049e89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049e90 <add_wp>:

void add_wp(char *args) {
 8049e90:	56                   	push   %esi
 8049e91:	53                   	push   %ebx
 8049e92:	83 ec 14             	sub    $0x14,%esp
	bool flag = true;
 8049e95:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
	WP *now = new_wp();
 8049e9a:	e8 a1 fe ff ff       	call   8049d40 <new_wp>
 8049e9f:	89 c3                	mov    %eax,%ebx
	(*now).NO = wp_num ++;
 8049ea1:	a1 40 5d 07 08       	mov    0x8075d40,%eax
	strcpy((*now).expr, args);
 8049ea6:	83 ec 08             	sub    $0x8,%esp
 8049ea9:	8d 73 0c             	lea    0xc(%ebx),%esi
}

void add_wp(char *args) {
	bool flag = true;
	WP *now = new_wp();
	(*now).NO = wp_num ++;
 8049eac:	89 03                	mov    %eax,(%ebx)
 8049eae:	8d 50 01             	lea    0x1(%eax),%edx
	strcpy((*now).expr, args);
 8049eb1:	ff 74 24 28          	pushl  0x28(%esp)
 8049eb5:	56                   	push   %esi
}

void add_wp(char *args) {
	bool flag = true;
	WP *now = new_wp();
	(*now).NO = wp_num ++;
 8049eb6:	89 15 40 5d 07 08    	mov    %edx,0x8075d40
	strcpy((*now).expr, args);
 8049ebc:	e8 7f eb ff ff       	call   8048a40 <strcpy@plt>
	(*now).v = expr((*now).expr, &flag);
 8049ec1:	58                   	pop    %eax
 8049ec2:	5a                   	pop    %edx
 8049ec3:	8d 44 24 17          	lea    0x17(%esp),%eax
 8049ec7:	50                   	push   %eax
 8049ec8:	56                   	push   %esi
 8049ec9:	e8 02 0c 00 00       	call   804aad0 <expr>
 8049ece:	89 43 08             	mov    %eax,0x8(%ebx)
}
 8049ed1:	83 c4 24             	add    $0x24,%esp
 8049ed4:	5b                   	pop    %ebx
 8049ed5:	5e                   	pop    %esi
 8049ed6:	c3                   	ret    
 8049ed7:	89 f6                	mov    %esi,%esi
 8049ed9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049ee0 <delete_wp>:

void delete_wp(int no) {
	WP *now = head;
 8049ee0:	a1 48 5d 07 08       	mov    0x8075d48,%eax
	(*now).NO = wp_num ++;
	strcpy((*now).expr, args);
	(*now).v = expr((*now).expr, &flag);
}

void delete_wp(int no) {
 8049ee5:	8b 54 24 04          	mov    0x4(%esp),%edx
	WP *now = head;
	while(now != NULL) {
 8049ee9:	85 c0                	test   %eax,%eax
 8049eeb:	75 0a                	jne    8049ef7 <delete_wp+0x17>
 8049eed:	eb 19                	jmp    8049f08 <delete_wp+0x28>
 8049eef:	90                   	nop
		if((*now).NO == no) {
			free_wp(now);
			return;
		}
		now = (*now).next;
 8049ef0:	8b 40 04             	mov    0x4(%eax),%eax
	(*now).v = expr((*now).expr, &flag);
}

void delete_wp(int no) {
	WP *now = head;
	while(now != NULL) {
 8049ef3:	85 c0                	test   %eax,%eax
 8049ef5:	74 11                	je     8049f08 <delete_wp+0x28>
		if((*now).NO == no) {
 8049ef7:	39 10                	cmp    %edx,(%eax)
 8049ef9:	75 f5                	jne    8049ef0 <delete_wp+0x10>
			free_wp(now);
 8049efb:	89 44 24 04          	mov    %eax,0x4(%esp)
 8049eff:	e9 8c fe ff ff       	jmp    8049d90 <free_wp>
 8049f04:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			return;
		}
		now = (*now).next;
	}
	printf("no this number's point\n");
 8049f08:	c7 44 24 04 c2 ed 05 	movl   $0x805edc2,0x4(%esp)
 8049f0f:	08 
 8049f10:	e9 4b eb ff ff       	jmp    8048a60 <puts@plt>
 8049f15:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8049f19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049f20 <check_wp>:
}

void check_wp(bool *fl) {
 8049f20:	57                   	push   %edi
 8049f21:	56                   	push   %esi
 8049f22:	53                   	push   %ebx
 8049f23:	83 ec 10             	sub    $0x10,%esp
	WP *now = head;
 8049f26:	8b 1d 48 5d 07 08    	mov    0x8075d48,%ebx
 8049f2c:	8d 7c 24 0f          	lea    0xf(%esp),%edi
	while(now != NULL) {
 8049f30:	85 db                	test   %ebx,%ebx
 8049f32:	75 13                	jne    8049f47 <check_wp+0x27>
 8049f34:	eb 46                	jmp    8049f7c <check_wp+0x5c>
 8049f36:	8d 76 00             	lea    0x0(%esi),%esi
 8049f39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			*fl = false;
			(*now).v = t;
			printf("%d: %s = %d\n", (*now).NO, (*now).expr, t);
			break;
		}
		now = (*now).next;
 8049f40:	8b 5b 04             	mov    0x4(%ebx),%ebx
	printf("no this number's point\n");
}

void check_wp(bool *fl) {
	WP *now = head;
	while(now != NULL) {
 8049f43:	85 db                	test   %ebx,%ebx
 8049f45:	74 35                	je     8049f7c <check_wp+0x5c>
		bool flag =true;
		uint32_t t = expr((*now).expr, &flag);
 8049f47:	8d 73 0c             	lea    0xc(%ebx),%esi
}

void check_wp(bool *fl) {
	WP *now = head;
	while(now != NULL) {
		bool flag =true;
 8049f4a:	c6 44 24 0f 01       	movb   $0x1,0xf(%esp)
		uint32_t t = expr((*now).expr, &flag);
 8049f4f:	83 ec 08             	sub    $0x8,%esp
 8049f52:	57                   	push   %edi
 8049f53:	56                   	push   %esi
 8049f54:	e8 77 0b 00 00       	call   804aad0 <expr>
		if(t != (*now).v) {
 8049f59:	83 c4 10             	add    $0x10,%esp
 8049f5c:	39 43 08             	cmp    %eax,0x8(%ebx)
 8049f5f:	74 df                	je     8049f40 <check_wp+0x20>
			*fl = false;
 8049f61:	8b 54 24 20          	mov    0x20(%esp),%edx
 8049f65:	c6 02 00             	movb   $0x0,(%edx)
			(*now).v = t;
 8049f68:	89 43 08             	mov    %eax,0x8(%ebx)
			printf("%d: %s = %d\n", (*now).NO, (*now).expr, t);
 8049f6b:	50                   	push   %eax
 8049f6c:	56                   	push   %esi
 8049f6d:	ff 33                	pushl  (%ebx)
 8049f6f:	68 d9 ed 05 08       	push   $0x805edd9
 8049f74:	e8 d7 e9 ff ff       	call   8048950 <printf@plt>
			break;
 8049f79:	83 c4 10             	add    $0x10,%esp
		}
		now = (*now).next;
	}
}
 8049f7c:	83 c4 10             	add    $0x10,%esp
 8049f7f:	5b                   	pop    %ebx
 8049f80:	5e                   	pop    %esi
 8049f81:	5f                   	pop    %edi
 8049f82:	c3                   	ret    
 8049f83:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8049f89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08049f90 <delete_all_wp>:

void delete_all_wp() {
	while(head != NULL) {
 8049f90:	a1 48 5d 07 08       	mov    0x8075d48,%eax
 8049f95:	85 c0                	test   %eax,%eax
 8049f97:	74 1f                	je     8049fb8 <delete_all_wp+0x28>
		}
		now = (*now).next;
	}
}

void delete_all_wp() {
 8049f99:	83 ec 0c             	sub    $0xc,%esp
 8049f9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	while(head != NULL) {
		free_wp(head);
 8049fa0:	83 ec 0c             	sub    $0xc,%esp
 8049fa3:	50                   	push   %eax
 8049fa4:	e8 e7 fd ff ff       	call   8049d90 <free_wp>
		now = (*now).next;
	}
}

void delete_all_wp() {
	while(head != NULL) {
 8049fa9:	a1 48 5d 07 08       	mov    0x8075d48,%eax
 8049fae:	83 c4 10             	add    $0x10,%esp
 8049fb1:	85 c0                	test   %eax,%eax
 8049fb3:	75 eb                	jne    8049fa0 <delete_all_wp+0x10>
		free_wp(head);
	}
}
 8049fb5:	83 c4 0c             	add    $0xc,%esp
 8049fb8:	f3 c3                	repz ret 
 8049fba:	66 90                	xchg   %ax,%ax
 8049fbc:	66 90                	xchg   %ax,%ax
 8049fbe:	66 90                	xchg   %ax,%ax

08049fc0 <init_regex>:
static regex_t re[NR_REGEX];

/* Rules are used for many times.
 * Therefore we compile them only once before any usage.
 */
void init_regex() {
 8049fc0:	57                   	push   %edi
 8049fc1:	56                   	push   %esi
 8049fc2:	be 00 7f 07 08       	mov    $0x8077f00,%esi
 8049fc7:	53                   	push   %ebx
 8049fc8:	31 db                	xor    %ebx,%ebx
 8049fca:	83 c4 80             	add    $0xffffff80,%esp
 8049fcd:	eb 10                	jmp    8049fdf <init_regex+0x1f>
 8049fcf:	90                   	nop
	int i;
	char error_msg[128];
	int ret;

	for(i = 0; i < NR_REGEX; i ++) {
 8049fd0:	83 c3 01             	add    $0x1,%ebx
 8049fd3:	83 c6 20             	add    $0x20,%esi
 8049fd6:	83 fb 1c             	cmp    $0x1c,%ebx
 8049fd9:	0f 84 91 00 00 00    	je     804a070 <init_regex+0xb0>
		ret = regcomp(&re[i], rules[i].regex, REG_EXTENDED);
 8049fdf:	8b 3c dd c0 f0 05 08 	mov    0x805f0c0(,%ebx,8),%edi
 8049fe6:	83 ec 04             	sub    $0x4,%esp
 8049fe9:	6a 01                	push   $0x1
 8049feb:	57                   	push   %edi
 8049fec:	56                   	push   %esi
 8049fed:	e8 8e eb ff ff       	call   8048b80 <regcomp@plt>
		if(ret != 0) {
 8049ff2:	83 c4 10             	add    $0x10,%esp
 8049ff5:	85 c0                	test   %eax,%eax
 8049ff7:	74 d7                	je     8049fd0 <init_regex+0x10>
			regerror(ret, &re[i], error_msg, 128);
 8049ff9:	68 80 00 00 00       	push   $0x80
 8049ffe:	8d 5c 24 04          	lea    0x4(%esp),%ebx
 804a002:	53                   	push   %ebx
 804a003:	56                   	push   %esi
 804a004:	50                   	push   %eax
 804a005:	e8 16 eb ff ff       	call   8048b20 <regerror@plt>
			Assert(ret == 0, "regex compilation failed: %s\n%s", error_msg, rules[i].regex);
 804a00a:	58                   	pop    %eax
 804a00b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804a011:	e8 4a e9 ff ff       	call   8048960 <fflush@plt>
 804a016:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804a01c:	6a 07                	push   $0x7
 804a01e:	6a 01                	push   $0x1
 804a020:	68 92 e8 05 08       	push   $0x805e892
 804a025:	e8 e6 e9 ff ff       	call   8048a10 <fwrite@plt>
 804a02a:	83 c4 20             	add    $0x20,%esp
 804a02d:	57                   	push   %edi
 804a02e:	53                   	push   %ebx
 804a02f:	68 4c ef 05 08       	push   $0x805ef4c
 804a034:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804a03a:	e8 81 ea ff ff       	call   8048ac0 <fprintf@plt>
 804a03f:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804a045:	6a 05                	push   $0x5
 804a047:	6a 01                	push   $0x1
 804a049:	68 42 f3 05 08       	push   $0x805f342
 804a04e:	e8 bd e9 ff ff       	call   8048a10 <fwrite@plt>
 804a053:	83 c4 20             	add    $0x20,%esp
 804a056:	68 ad f0 05 08       	push   $0x805f0ad
 804a05b:	6a 4a                	push   $0x4a
 804a05d:	68 4a ee 05 08       	push   $0x805ee4a
 804a062:	68 68 ee 05 08       	push   $0x805ee68
 804a067:	e8 44 eb ff ff       	call   8048bb0 <__assert_fail@plt>
 804a06c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		}
	}
}
 804a070:	83 ec 80             	sub    $0xffffff80,%esp
 804a073:	5b                   	pop    %ebx
 804a074:	5e                   	pop    %esi
 804a075:	5f                   	pop    %edi
 804a076:	c3                   	ret    
 804a077:	89 f6                	mov    %esi,%esi
 804a079:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804a080 <not_a_num>:
} Token;

Token tokens[32];
int nr_token;

bool not_a_num(uint32_t p) {
 804a080:	8b 44 24 04          	mov    0x4(%esp),%eax
		if(tokens[p].type != NUM && tokens[p].type != ONUM && tokens[p].type != HNUM && tokens[p].type != '$' && tokens[p].type != VAR) {
 804a084:	8d 04 c0             	lea    (%eax,%eax,8),%eax
 804a087:	8b 14 85 c0 84 0c 08 	mov    0x80c84c0(,%eax,4),%edx
 804a08e:	81 fa 0d 01 00 00    	cmp    $0x10d,%edx
 804a094:	0f 95 c1             	setne  %cl
 804a097:	83 fa 24             	cmp    $0x24,%edx
 804a09a:	0f 95 c0             	setne  %al
 804a09d:	81 ea 02 01 00 00    	sub    $0x102,%edx
 804a0a3:	21 c8                	and    %ecx,%eax
 804a0a5:	83 fa 02             	cmp    $0x2,%edx
 804a0a8:	0f 97 c2             	seta   %dl
 804a0ab:	21 d0                	and    %edx,%eax
			return true;
		}
		else return false;
}
 804a0ad:	c3                   	ret    
 804a0ae:	66 90                	xchg   %ax,%ax

0804a0b0 <check_parentheses>:
	}

	return true; 
}

bool check_parentheses(uint32_t p, uint32_t q, bool *success) {
 804a0b0:	56                   	push   %esi
 804a0b1:	53                   	push   %ebx
 804a0b2:	83 ec 04             	sub    $0x4,%esp
 804a0b5:	8b 54 24 10          	mov    0x10(%esp),%edx
 804a0b9:	8b 4c 24 14          	mov    0x14(%esp),%ecx
	int i = 0, j = 0;
	bool flag = true;
	if(p >= q) {
 804a0bd:	39 ca                	cmp    %ecx,%edx
 804a0bf:	0f 83 aa 00 00 00    	jae    804a16f <check_parentheses+0xbf>
		printf("there are something goes wrong\n");
		assert(0);
	}
	if(tokens[p].type != '(' || tokens[q].type != ')')return false;
 804a0c5:	8d 1c d2             	lea    (%edx,%edx,8),%ebx
 804a0c8:	31 c0                	xor    %eax,%eax
 804a0ca:	83 3c 9d c0 84 0c 08 	cmpl   $0x28,0x80c84c0(,%ebx,4)
 804a0d1:	28 
 804a0d2:	74 0c                	je     804a0e0 <check_parentheses+0x30>
		printf("brackets not match!\n");
		*success = false;
		return true;
	}
	return flag;
}
 804a0d4:	83 c4 04             	add    $0x4,%esp
 804a0d7:	5b                   	pop    %ebx
 804a0d8:	5e                   	pop    %esi
 804a0d9:	c3                   	ret    
 804a0da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	bool flag = true;
	if(p >= q) {
		printf("there are something goes wrong\n");
		assert(0);
	}
	if(tokens[p].type != '(' || tokens[q].type != ')')return false;
 804a0e0:	8d 1c c9             	lea    (%ecx,%ecx,8),%ebx
 804a0e3:	c1 e3 02             	shl    $0x2,%ebx
 804a0e6:	83 bb c0 84 0c 08 29 	cmpl   $0x29,0x80c84c0(%ebx)
 804a0ed:	75 e5                	jne    804a0d4 <check_parentheses+0x24>
	for(i = p + 1; i < q; i++) {
 804a0ef:	83 c2 01             	add    $0x1,%edx
 804a0f2:	39 d1                	cmp    %edx,%ecx
 804a0f4:	76 6f                	jbe    804a165 <check_parentheses+0xb5>
 804a0f6:	8d 04 d2             	lea    (%edx,%edx,8),%eax
 804a0f9:	81 c3 c0 84 0c 08    	add    $0x80c84c0,%ebx
 804a0ff:	31 f6                	xor    %esi,%esi
 804a101:	8d 14 85 c0 84 0c 08 	lea    0x80c84c0(,%eax,4),%edx
 804a108:	b8 01 00 00 00       	mov    $0x1,%eax
 804a10d:	eb 0d                	jmp    804a11c <check_parentheses+0x6c>
 804a10f:	90                   	nop
		if(tokens[i].type == '(') {
			j++;
		}
		else if(tokens[i].type == ')') {
 804a110:	83 f9 29             	cmp    $0x29,%ecx
 804a113:	74 3b                	je     804a150 <check_parentheses+0xa0>
 804a115:	83 c2 24             	add    $0x24,%edx
	if(p >= q) {
		printf("there are something goes wrong\n");
		assert(0);
	}
	if(tokens[p].type != '(' || tokens[q].type != ')')return false;
	for(i = p + 1; i < q; i++) {
 804a118:	39 da                	cmp    %ebx,%edx
 804a11a:	74 11                	je     804a12d <check_parentheses+0x7d>
		if(tokens[i].type == '(') {
 804a11c:	8b 0a                	mov    (%edx),%ecx
 804a11e:	83 f9 28             	cmp    $0x28,%ecx
 804a121:	75 ed                	jne    804a110 <check_parentheses+0x60>
 804a123:	83 c2 24             	add    $0x24,%edx
			j++;
 804a126:	83 c6 01             	add    $0x1,%esi
	if(p >= q) {
		printf("there are something goes wrong\n");
		assert(0);
	}
	if(tokens[p].type != '(' || tokens[q].type != ')')return false;
	for(i = p + 1; i < q; i++) {
 804a129:	39 da                	cmp    %ebx,%edx
 804a12b:	75 ef                	jne    804a11c <check_parentheses+0x6c>
			j--;
			if(j < 0) flag = false;
			if(j < -1) *success = false;
		}
	}
	if(j != 0) {
 804a12d:	85 f6                	test   %esi,%esi
 804a12f:	74 a3                	je     804a0d4 <check_parentheses+0x24>
		printf("brackets not match!\n");
 804a131:	83 ec 0c             	sub    $0xc,%esp
 804a134:	68 71 ee 05 08       	push   $0x805ee71
 804a139:	e8 22 e9 ff ff       	call   8048a60 <puts@plt>
		*success = false;
 804a13e:	8b 44 24 28          	mov    0x28(%esp),%eax
		return true;
 804a142:	83 c4 10             	add    $0x10,%esp
			if(j < -1) *success = false;
		}
	}
	if(j != 0) {
		printf("brackets not match!\n");
		*success = false;
 804a145:	c6 00 00             	movb   $0x0,(%eax)
		return true;
 804a148:	b8 01 00 00 00       	mov    $0x1,%eax
 804a14d:	eb 85                	jmp    804a0d4 <check_parentheses+0x24>
 804a14f:	90                   	nop
		if(tokens[i].type == '(') {
			j++;
		}
		else if(tokens[i].type == ')') {
			j--;
			if(j < 0) flag = false;
 804a150:	83 ee 01             	sub    $0x1,%esi
 804a153:	79 c0                	jns    804a115 <check_parentheses+0x65>
			if(j < -1) *success = false;
 804a155:	83 fe ff             	cmp    $0xffffffff,%esi
 804a158:	74 3b                	je     804a195 <check_parentheses+0xe5>
 804a15a:	8b 44 24 18          	mov    0x18(%esp),%eax
 804a15e:	c6 00 00             	movb   $0x0,(%eax)
		if(tokens[i].type == '(') {
			j++;
		}
		else if(tokens[i].type == ')') {
			j--;
			if(j < 0) flag = false;
 804a161:	31 c0                	xor    %eax,%eax
 804a163:	eb b0                	jmp    804a115 <check_parentheses+0x65>
	return true; 
}

bool check_parentheses(uint32_t p, uint32_t q, bool *success) {
	int i = 0, j = 0;
	bool flag = true;
 804a165:	b8 01 00 00 00       	mov    $0x1,%eax
	if(j != 0) {
		printf("brackets not match!\n");
		*success = false;
		return true;
	}
	return flag;
 804a16a:	e9 65 ff ff ff       	jmp    804a0d4 <check_parentheses+0x24>

bool check_parentheses(uint32_t p, uint32_t q, bool *success) {
	int i = 0, j = 0;
	bool flag = true;
	if(p >= q) {
		printf("there are something goes wrong\n");
 804a16f:	83 ec 0c             	sub    $0xc,%esp
 804a172:	68 6c ef 05 08       	push   $0x805ef6c
 804a177:	e8 e4 e8 ff ff       	call   8048a60 <puts@plt>
		assert(0);
 804a17c:	68 9b f0 05 08       	push   $0x805f09b
 804a181:	68 90 00 00 00       	push   $0x90
 804a186:	68 4a ee 05 08       	push   $0x805ee4a
 804a18b:	68 1c ea 05 08       	push   $0x805ea1c
 804a190:	e8 1b ea ff ff       	call   8048bb0 <__assert_fail@plt>
		if(tokens[i].type == '(') {
			j++;
		}
		else if(tokens[i].type == ')') {
			j--;
			if(j < 0) flag = false;
 804a195:	31 c0                	xor    %eax,%eax
 804a197:	e9 79 ff ff ff       	jmp    804a115 <check_parentheses+0x65>
 804a19c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804a1a0 <relax>:
		return true;
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
 804a1a0:	53                   	push   %ebx
 804a1a1:	8b 44 24 14          	mov    0x14(%esp),%eax
 804a1a5:	8b 54 24 0c          	mov    0xc(%esp),%edx
	if(v >= *pr) {
 804a1a9:	39 10                	cmp    %edx,(%eax)
 804a1ab:	77 0c                	ja     804a1b9 <relax+0x19>
		*la = i;
 804a1ad:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 804a1b1:	8b 5c 24 08          	mov    0x8(%esp),%ebx
 804a1b5:	89 19                	mov    %ebx,(%ecx)
		*pr = v;
 804a1b7:	89 10                	mov    %edx,(%eax)
	}
	return 0;
}
 804a1b9:	31 c0                	xor    %eax,%eax
 804a1bb:	5b                   	pop    %ebx
 804a1bc:	c3                   	ret    
 804a1bd:	8d 76 00             	lea    0x0(%esi),%esi

0804a1c0 <relax1>:

uint32_t relax1(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
 804a1c0:	53                   	push   %ebx
 804a1c1:	8b 44 24 14          	mov    0x14(%esp),%eax
 804a1c5:	8b 54 24 0c          	mov    0xc(%esp),%edx
	if(v > *pr) {
 804a1c9:	39 10                	cmp    %edx,(%eax)
 804a1cb:	73 0c                	jae    804a1d9 <relax1+0x19>
		*la = i;
 804a1cd:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 804a1d1:	8b 5c 24 08          	mov    0x8(%esp),%ebx
 804a1d5:	89 19                	mov    %ebx,(%ecx)
		*pr = v;
 804a1d7:	89 10                	mov    %edx,(%eax)
	}
	return 0;
}
 804a1d9:	31 c0                	xor    %eax,%eax
 804a1db:	5b                   	pop    %ebx
 804a1dc:	c3                   	ret    
 804a1dd:	8d 76 00             	lea    0x0(%esi),%esi

0804a1e0 <find_the_last_operator>:

uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
 804a1e0:	55                   	push   %ebp
 804a1e1:	57                   	push   %edi
 804a1e2:	56                   	push   %esi
 804a1e3:	53                   	push   %ebx
 804a1e4:	83 ec 08             	sub    $0x8,%esp
 804a1e7:	8b 74 24 20          	mov    0x20(%esp),%esi
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a1eb:	39 74 24 1c          	cmp    %esi,0x1c(%esp)
 804a1ef:	0f 87 6e 03 00 00    	ja     804a563 <find_the_last_operator+0x383>
 804a1f5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804a1f9:	31 ff                	xor    %edi,%edi
 804a1fb:	31 ed                	xor    %ebp,%ebp
 804a1fd:	31 c9                	xor    %ecx,%ecx
 804a1ff:	8d 04 c0             	lea    (%eax,%eax,8),%eax
 804a202:	8d 14 85 9c 84 0c 08 	lea    0x80c849c(,%eax,4),%edx
 804a209:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804a20d:	8d 76 00             	lea    0x0(%esi),%esi
		if(tokens[i].type == '(') j++;
 804a210:	8b 5a 24             	mov    0x24(%edx),%ebx
 804a213:	83 fb 28             	cmp    $0x28,%ebx
 804a216:	74 68                	je     804a280 <find_the_last_operator+0xa0>
		else if(tokens[i].type == ')') j--;
 804a218:	83 fb 29             	cmp    $0x29,%ebx
 804a21b:	74 73                	je     804a290 <find_the_last_operator+0xb0>
		else if(j == 0) {
 804a21d:	85 c9                	test   %ecx,%ecx
 804a21f:	75 47                	jne    804a268 <find_the_last_operator+0x88>
			switch(tokens[i].type) {
 804a221:	83 fb 7c             	cmp    $0x7c,%ebx
 804a224:	0f 84 16 03 00 00    	je     804a540 <find_the_last_operator+0x360>
 804a22a:	7f 7c                	jg     804a2a8 <find_the_last_operator+0xc8>
 804a22c:	83 fb 2d             	cmp    $0x2d,%ebx
 804a22f:	0f 84 bb 02 00 00    	je     804a4f0 <find_the_last_operator+0x310>
 804a235:	0f 8f 2d 01 00 00    	jg     804a368 <find_the_last_operator+0x188>
 804a23b:	83 fb 26             	cmp    $0x26,%ebx
 804a23e:	0f 84 84 02 00 00    	je     804a4c8 <find_the_last_operator+0x2e8>
 804a244:	0f 8e de 01 00 00    	jle    804a428 <find_the_last_operator+0x248>
 804a24a:	83 fb 2a             	cmp    $0x2a,%ebx
 804a24d:	0f 84 5d 01 00 00    	je     804a3b0 <find_the_last_operator+0x1d0>
 804a253:	83 fb 2b             	cmp    $0x2b,%ebx
 804a256:	75 10                	jne    804a268 <find_the_last_operator+0x88>
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a258:	83 ff 04             	cmp    $0x4,%edi
 804a25b:	77 0b                	ja     804a268 <find_the_last_operator+0x88>
 804a25d:	89 c5                	mov    %eax,%ebp
		*la = i;
		*pr = v;
 804a25f:	bf 04 00 00 00       	mov    $0x4,%edi
 804a264:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a268:	83 c0 01             	add    $0x1,%eax
 804a26b:	83 c2 24             	add    $0x24,%edx
 804a26e:	39 c6                	cmp    %eax,%esi
 804a270:	73 9e                	jae    804a210 <find_the_last_operator+0x30>
					break;
			}
		}
	}
	return *la;
}
 804a272:	83 c4 08             	add    $0x8,%esp
 804a275:	89 e8                	mov    %ebp,%eax
 804a277:	5b                   	pop    %ebx
 804a278:	5e                   	pop    %esi
 804a279:	5f                   	pop    %edi
 804a27a:	5d                   	pop    %ebp
 804a27b:	c3                   	ret    
 804a27c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a280:	83 c0 01             	add    $0x1,%eax
		if(tokens[i].type == '(') j++;
 804a283:	83 c1 01             	add    $0x1,%ecx
 804a286:	83 c2 24             	add    $0x24,%edx
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a289:	39 c6                	cmp    %eax,%esi
 804a28b:	73 83                	jae    804a210 <find_the_last_operator+0x30>
 804a28d:	eb e3                	jmp    804a272 <find_the_last_operator+0x92>
 804a28f:	90                   	nop
 804a290:	83 c0 01             	add    $0x1,%eax
		if(tokens[i].type == '(') j++;
		else if(tokens[i].type == ')') j--;
 804a293:	83 e9 01             	sub    $0x1,%ecx
 804a296:	83 c2 24             	add    $0x24,%edx
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a299:	39 c6                	cmp    %eax,%esi
 804a29b:	0f 83 6f ff ff ff    	jae    804a210 <find_the_last_operator+0x30>
 804a2a1:	eb cf                	jmp    804a272 <find_the_last_operator+0x92>
 804a2a3:	90                   	nop
 804a2a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if(tokens[i].type == '(') j++;
		else if(tokens[i].type == ')') j--;
		else if(j == 0) {
			switch(tokens[i].type) {
 804a2a8:	81 fb 07 01 00 00    	cmp    $0x107,%ebx
 804a2ae:	74 20                	je     804a2d0 <find_the_last_operator+0xf0>
 804a2b0:	7f 66                	jg     804a318 <find_the_last_operator+0x138>
 804a2b2:	81 fb 01 01 00 00    	cmp    $0x101,%ebx
 804a2b8:	74 36                	je     804a2f0 <find_the_last_operator+0x110>
 804a2ba:	0f 8e a8 01 00 00    	jle    804a468 <find_the_last_operator+0x288>
 804a2c0:	81 fb 05 01 00 00    	cmp    $0x105,%ebx
 804a2c6:	74 28                	je     804a2f0 <find_the_last_operator+0x110>
 804a2c8:	81 fb 06 01 00 00    	cmp    $0x106,%ebx
 804a2ce:	75 98                	jne    804a268 <find_the_last_operator+0x88>
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a2d0:	83 ff 06             	cmp    $0x6,%edi
 804a2d3:	77 93                	ja     804a268 <find_the_last_operator+0x88>
 804a2d5:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a2d7:	83 c0 01             	add    $0x1,%eax
 804a2da:	83 c2 24             	add    $0x24,%edx
 804a2dd:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a2df:	bf 06 00 00 00       	mov    $0x6,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a2e4:	0f 83 26 ff ff ff    	jae    804a210 <find_the_last_operator+0x30>
 804a2ea:	eb 86                	jmp    804a272 <find_the_last_operator+0x92>
 804a2ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a2f0:	83 ff 07             	cmp    $0x7,%edi
 804a2f3:	0f 87 6f ff ff ff    	ja     804a268 <find_the_last_operator+0x88>
 804a2f9:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a2fb:	83 c0 01             	add    $0x1,%eax
 804a2fe:	83 c2 24             	add    $0x24,%edx
 804a301:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a303:	bf 07 00 00 00       	mov    $0x7,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a308:	0f 83 02 ff ff ff    	jae    804a210 <find_the_last_operator+0x30>
 804a30e:	e9 5f ff ff ff       	jmp    804a272 <find_the_last_operator+0x92>
 804a313:	90                   	nop
 804a314:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if(tokens[i].type == '(') j++;
		else if(tokens[i].type == ')') j--;
		else if(j == 0) {
			switch(tokens[i].type) {
 804a318:	81 fb 09 01 00 00    	cmp    $0x109,%ebx
 804a31e:	0f 84 7c 01 00 00    	je     804a4a0 <find_the_last_operator+0x2c0>
 804a324:	0f 8c 4e 01 00 00    	jl     804a478 <find_the_last_operator+0x298>
 804a32a:	81 fb 0b 01 00 00    	cmp    $0x10b,%ebx
 804a330:	74 0c                	je     804a33e <find_the_last_operator+0x15e>
 804a332:	81 fb 0c 01 00 00    	cmp    $0x10c,%ebx
 804a338:	0f 85 2a ff ff ff    	jne    804a268 <find_the_last_operator+0x88>
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a33e:	83 ff 05             	cmp    $0x5,%edi
 804a341:	0f 87 21 ff ff ff    	ja     804a268 <find_the_last_operator+0x88>
 804a347:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a349:	83 c0 01             	add    $0x1,%eax
 804a34c:	83 c2 24             	add    $0x24,%edx
 804a34f:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a351:	bf 05 00 00 00       	mov    $0x5,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a356:	0f 83 b4 fe ff ff    	jae    804a210 <find_the_last_operator+0x30>
 804a35c:	e9 11 ff ff ff       	jmp    804a272 <find_the_last_operator+0x92>
 804a361:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if(tokens[i].type == '(') j++;
		else if(tokens[i].type == ')') j--;
		else if(j == 0) {
			switch(tokens[i].type) {
 804a368:	83 fb 3c             	cmp    $0x3c,%ebx
 804a36b:	0f 84 5f ff ff ff    	je     804a2d0 <find_the_last_operator+0xf0>
 804a371:	0f 8e c1 00 00 00    	jle    804a438 <find_the_last_operator+0x258>
 804a377:	83 fb 3e             	cmp    $0x3e,%ebx
 804a37a:	0f 84 50 ff ff ff    	je     804a2d0 <find_the_last_operator+0xf0>
 804a380:	83 fb 5e             	cmp    $0x5e,%ebx
 804a383:	0f 85 df fe ff ff    	jne    804a268 <find_the_last_operator+0x88>
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a389:	83 ff 09             	cmp    $0x9,%edi
 804a38c:	0f 87 d6 fe ff ff    	ja     804a268 <find_the_last_operator+0x88>
 804a392:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a394:	83 c0 01             	add    $0x1,%eax
 804a397:	83 c2 24             	add    $0x24,%edx
 804a39a:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a39c:	bf 09 00 00 00       	mov    $0x9,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a3a1:	0f 83 69 fe ff ff    	jae    804a210 <find_the_last_operator+0x30>
 804a3a7:	e9 c6 fe ff ff       	jmp    804a272 <find_the_last_operator+0x92>
 804a3ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					break;
				case '/':
					relax(i, 3, la, pr);
					break;
				case '*':
					if(i != p && (!not_a_num(i-1) || tokens[i-1].type == ')')) relax(i, 4, la, pr);
 804a3b0:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
 804a3b4:	74 4b                	je     804a401 <find_the_last_operator+0x221>

Token tokens[32];
int nr_token;

bool not_a_num(uint32_t p) {
		if(tokens[p].type != NUM && tokens[p].type != ONUM && tokens[p].type != HNUM && tokens[p].type != '$' && tokens[p].type != VAR) {
 804a3b6:	8b 1a                	mov    (%edx),%ebx
					break;
				case '/':
					relax(i, 3, la, pr);
					break;
				case '*':
					if(i != p && (!not_a_num(i-1) || tokens[i-1].type == ')')) relax(i, 4, la, pr);
 804a3b8:	83 fb 29             	cmp    $0x29,%ebx
 804a3bb:	89 1c 24             	mov    %ebx,(%esp)
 804a3be:	0f 94 44 24 06       	sete   0x6(%esp)

Token tokens[32];
int nr_token;

bool not_a_num(uint32_t p) {
		if(tokens[p].type != NUM && tokens[p].type != ONUM && tokens[p].type != HNUM && tokens[p].type != '$' && tokens[p].type != VAR) {
 804a3c3:	81 fb 0d 01 00 00    	cmp    $0x10d,%ebx
 804a3c9:	0f 95 44 24 07       	setne  0x7(%esp)
 804a3ce:	83 3c 24 24          	cmpl   $0x24,(%esp)
 804a3d2:	0f b6 5c 24 07       	movzbl 0x7(%esp),%ebx
 804a3d7:	0f 95 44 24 07       	setne  0x7(%esp)
 804a3dc:	22 5c 24 07          	and    0x7(%esp),%bl
 804a3e0:	88 5c 24 07          	mov    %bl,0x7(%esp)
 804a3e4:	8b 1c 24             	mov    (%esp),%ebx
 804a3e7:	81 eb 02 01 00 00    	sub    $0x102,%ebx
 804a3ed:	83 fb 02             	cmp    $0x2,%ebx
 804a3f0:	0f 97 c3             	seta   %bl
 804a3f3:	22 5c 24 07          	and    0x7(%esp),%bl
					break;
				case '/':
					relax(i, 3, la, pr);
					break;
				case '*':
					if(i != p && (!not_a_num(i-1) || tokens[i-1].type == ')')) relax(i, 4, la, pr);
 804a3f7:	38 5c 24 06          	cmp    %bl,0x6(%esp)
 804a3fb:	0f 83 57 fe ff ff    	jae    804a258 <find_the_last_operator+0x78>
	}
	return 0;
}

uint32_t relax1(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v > *pr) {
 804a401:	83 ff 01             	cmp    $0x1,%edi
 804a404:	0f 87 5e fe ff ff    	ja     804a268 <find_the_last_operator+0x88>
 804a40a:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a40c:	83 c0 01             	add    $0x1,%eax
 804a40f:	83 c2 24             	add    $0x24,%edx
 804a412:	39 c6                	cmp    %eax,%esi
}

uint32_t relax1(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v > *pr) {
		*la = i;
		*pr = v;
 804a414:	bf 02 00 00 00       	mov    $0x2,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a419:	0f 83 f1 fd ff ff    	jae    804a210 <find_the_last_operator+0x30>
 804a41f:	e9 4e fe ff ff       	jmp    804a272 <find_the_last_operator+0x92>
 804a424:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if(tokens[i].type == '(') j++;
		else if(tokens[i].type == ')') j--;
		else if(j == 0) {
			switch(tokens[i].type) {
 804a428:	83 fb 21             	cmp    $0x21,%ebx
 804a42b:	74 d4                	je     804a401 <find_the_last_operator+0x221>
 804a42d:	e9 36 fe ff ff       	jmp    804a268 <find_the_last_operator+0x88>
 804a432:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804a438:	83 fb 2f             	cmp    $0x2f,%ebx
 804a43b:	0f 85 27 fe ff ff    	jne    804a268 <find_the_last_operator+0x88>
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a441:	83 ff 03             	cmp    $0x3,%edi
 804a444:	0f 87 1e fe ff ff    	ja     804a268 <find_the_last_operator+0x88>
 804a44a:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a44c:	83 c0 01             	add    $0x1,%eax
 804a44f:	83 c2 24             	add    $0x24,%edx
 804a452:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a454:	bf 03 00 00 00       	mov    $0x3,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a459:	0f 83 b1 fd ff ff    	jae    804a210 <find_the_last_operator+0x30>
 804a45f:	e9 0e fe ff ff       	jmp    804a272 <find_the_last_operator+0x92>
 804a464:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		if(tokens[i].type == '(') j++;
		else if(tokens[i].type == ')') j--;
		else if(j == 0) {
			switch(tokens[i].type) {
 804a468:	83 fb 7e             	cmp    $0x7e,%ebx
 804a46b:	74 94                	je     804a401 <find_the_last_operator+0x221>
 804a46d:	e9 f6 fd ff ff       	jmp    804a268 <find_the_last_operator+0x88>
 804a472:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a478:	83 ff 0b             	cmp    $0xb,%edi
 804a47b:	0f 87 e7 fd ff ff    	ja     804a268 <find_the_last_operator+0x88>
 804a481:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a483:	83 c0 01             	add    $0x1,%eax
 804a486:	83 c2 24             	add    $0x24,%edx
 804a489:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a48b:	bf 0b 00 00 00       	mov    $0xb,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a490:	0f 83 7a fd ff ff    	jae    804a210 <find_the_last_operator+0x30>
 804a496:	e9 d7 fd ff ff       	jmp    804a272 <find_the_last_operator+0x92>
 804a49b:	90                   	nop
 804a49c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a4a0:	83 ff 0c             	cmp    $0xc,%edi
 804a4a3:	0f 87 bf fd ff ff    	ja     804a268 <find_the_last_operator+0x88>
 804a4a9:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a4ab:	83 c0 01             	add    $0x1,%eax
 804a4ae:	83 c2 24             	add    $0x24,%edx
 804a4b1:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a4b3:	bf 0c 00 00 00       	mov    $0xc,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a4b8:	0f 83 52 fd ff ff    	jae    804a210 <find_the_last_operator+0x30>
 804a4be:	e9 af fd ff ff       	jmp    804a272 <find_the_last_operator+0x92>
 804a4c3:	90                   	nop
 804a4c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a4c8:	83 ff 08             	cmp    $0x8,%edi
 804a4cb:	0f 87 97 fd ff ff    	ja     804a268 <find_the_last_operator+0x88>
 804a4d1:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a4d3:	83 c0 01             	add    $0x1,%eax
 804a4d6:	83 c2 24             	add    $0x24,%edx
 804a4d9:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a4db:	bf 08 00 00 00       	mov    $0x8,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a4e0:	0f 83 2a fd ff ff    	jae    804a210 <find_the_last_operator+0x30>
 804a4e6:	e9 87 fd ff ff       	jmp    804a272 <find_the_last_operator+0x92>
 804a4eb:	90                   	nop
 804a4ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					break;
				case '+':
					relax(i, 4, la, pr);
					break;
				case '-':
					if(i != p && (!not_a_num(i-1) || tokens[i-1].type == ')')) relax(i, 4, la, pr);
 804a4f0:	3b 44 24 1c          	cmp    0x1c(%esp),%eax
 804a4f4:	0f 84 07 ff ff ff    	je     804a401 <find_the_last_operator+0x221>

Token tokens[32];
int nr_token;

bool not_a_num(uint32_t p) {
		if(tokens[p].type != NUM && tokens[p].type != ONUM && tokens[p].type != HNUM && tokens[p].type != '$' && tokens[p].type != VAR) {
 804a4fa:	81 3a 0d 01 00 00    	cmpl   $0x10d,(%edx)
 804a500:	0f 95 04 24          	setne  (%esp)
 804a504:	83 3a 24             	cmpl   $0x24,(%edx)
 804a507:	0f 95 c3             	setne  %bl
 804a50a:	22 1c 24             	and    (%esp),%bl
 804a50d:	88 1c 24             	mov    %bl,(%esp)
 804a510:	8b 1a                	mov    (%edx),%ebx
 804a512:	81 eb 02 01 00 00    	sub    $0x102,%ebx
 804a518:	83 fb 02             	cmp    $0x2,%ebx
 804a51b:	0f 97 c3             	seta   %bl
 804a51e:	22 1c 24             	and    (%esp),%bl
					break;
				case '+':
					relax(i, 4, la, pr);
					break;
				case '-':
					if(i != p && (!not_a_num(i-1) || tokens[i-1].type == ')')) relax(i, 4, la, pr);
 804a521:	83 3a 29             	cmpl   $0x29,(%edx)
 804a524:	0f 94 04 24          	sete   (%esp)
 804a528:	3a 1c 24             	cmp    (%esp),%bl
 804a52b:	0f 87 d0 fe ff ff    	ja     804a401 <find_the_last_operator+0x221>
 804a531:	e9 22 fd ff ff       	jmp    804a258 <find_the_last_operator+0x78>
 804a536:	8d 76 00             	lea    0x0(%esi),%esi
 804a539:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	}
	return flag;
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
 804a540:	83 ff 0a             	cmp    $0xa,%edi
 804a543:	0f 87 1f fd ff ff    	ja     804a268 <find_the_last_operator+0x88>
 804a549:	89 c5                	mov    %eax,%ebp
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a54b:	83 c0 01             	add    $0x1,%eax
 804a54e:	83 c2 24             	add    $0x24,%edx
 804a551:	39 c6                	cmp    %eax,%esi
}

uint32_t relax(uint32_t i, uint32_t v, uint32_t *la, uint32_t *pr) {
	if(v >= *pr) {
		*la = i;
		*pr = v;
 804a553:	bf 0a 00 00 00       	mov    $0xa,%edi
uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
	la = &las;
	pr = &pri;
	for(i = p; i <= q; i ++) {
 804a558:	0f 83 b2 fc ff ff    	jae    804a210 <find_the_last_operator+0x30>
 804a55e:	e9 0f fd ff ff       	jmp    804a272 <find_the_last_operator+0x92>
	return 0;
}

uint32_t find_the_last_operator(uint32_t p,uint32_t q) {
	uint32_t i, j = 0, *la = 0, *pr = 0;
	uint32_t las = 0, pri = 0;
 804a563:	31 ed                	xor    %ebp,%ebp
 804a565:	e9 08 fd ff ff       	jmp    804a272 <find_the_last_operator+0x92>
 804a56a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804a570 <eval>:
		}
	}
	return *la;
}

uint32_t eval(uint32_t p, uint32_t q, bool *success) {
 804a570:	55                   	push   %ebp
 804a571:	57                   	push   %edi
 804a572:	56                   	push   %esi
 804a573:	53                   	push   %ebx
 804a574:	83 ec 1c             	sub    $0x1c,%esp
 804a577:	8b 5c 24 30          	mov    0x30(%esp),%ebx
 804a57b:	8b 74 24 34          	mov    0x34(%esp),%esi
 804a57f:	8b 7c 24 38          	mov    0x38(%esp),%edi
	int i;
	uint32_t op, val1, val2, ret;
	if(p > q) {
 804a583:	39 f3                	cmp    %esi,%ebx
 804a585:	77 34                	ja     804a5bb <eval+0x4b>
 804a587:	89 f6                	mov    %esi,%esi
 804a589:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		/* Bad expression */
		printf("p is less then q\n");
		*success = false;
		return 0;
	}
	else if(p == q) { 
 804a590:	0f 84 12 01 00 00    	je     804a6a8 <eval+0x138>
					   printf("dont have this number!\n");
					   *success = false;
					   return 0;
		}
	}
	else if(check_parentheses(p, q, success) == true) {
 804a596:	83 ec 04             	sub    $0x4,%esp
 804a599:	57                   	push   %edi
 804a59a:	56                   	push   %esi
 804a59b:	53                   	push   %ebx
 804a59c:	e8 0f fb ff ff       	call   804a0b0 <check_parentheses>
 804a5a1:	83 c4 10             	add    $0x10,%esp
 804a5a4:	3c 01                	cmp    $0x1,%al
 804a5a6:	75 38                	jne    804a5e0 <eval+0x70>
		if(!(*success)) {
 804a5a8:	80 3f 00             	cmpb   $0x0,(%edi)
 804a5ab:	0f 84 e7 00 00 00    	je     804a698 <eval+0x128>
			return 0;
		}
		return eval(p + 1, q - 1, success); 
 804a5b1:	83 ee 01             	sub    $0x1,%esi
 804a5b4:	83 c3 01             	add    $0x1,%ebx
}

uint32_t eval(uint32_t p, uint32_t q, bool *success) {
	int i;
	uint32_t op, val1, val2, ret;
	if(p > q) {
 804a5b7:	39 de                	cmp    %ebx,%esi
 804a5b9:	73 d5                	jae    804a590 <eval+0x20>
		/* Bad expression */
		printf("p is less then q\n");
 804a5bb:	83 ec 0c             	sub    $0xc,%esp
		*success = false;
		return 0;
 804a5be:	31 db                	xor    %ebx,%ebx
uint32_t eval(uint32_t p, uint32_t q, bool *success) {
	int i;
	uint32_t op, val1, val2, ret;
	if(p > q) {
		/* Bad expression */
		printf("p is less then q\n");
 804a5c0:	68 85 ee 05 08       	push   $0x805ee85
 804a5c5:	e8 96 e4 ff ff       	call   8048a60 <puts@plt>
		*success = false;
 804a5ca:	c6 07 00             	movb   $0x0,(%edi)
		return 0;
 804a5cd:	83 c4 10             	add    $0x10,%esp
						*success = false;
						return 0;
			}
		}
	}
}
 804a5d0:	83 c4 1c             	add    $0x1c,%esp
 804a5d3:	89 d8                	mov    %ebx,%eax
 804a5d5:	5b                   	pop    %ebx
 804a5d6:	5e                   	pop    %esi
 804a5d7:	5f                   	pop    %edi
 804a5d8:	5d                   	pop    %ebp
 804a5d9:	c3                   	ret    
 804a5da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			return 0;
		}
		return eval(p + 1, q - 1, success); 
	}
	else {
		op = find_the_last_operator(p, q);
 804a5e0:	83 ec 08             	sub    $0x8,%esp
 804a5e3:	56                   	push   %esi
 804a5e4:	53                   	push   %ebx
 804a5e5:	e8 f6 fb ff ff       	call   804a1e0 <find_the_last_operator>
 804a5ea:	83 c4 10             	add    $0x10,%esp
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
 804a5ed:	39 d8                	cmp    %ebx,%eax
			return 0;
		}
		return eval(p + 1, q - 1, success); 
	}
	else {
		op = find_the_last_operator(p, q);
 804a5ef:	89 c5                	mov    %eax,%ebp
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
 804a5f1:	74 42                	je     804a635 <eval+0xc5>
 804a5f3:	8d 48 ff             	lea    -0x1(%eax),%ecx

Token tokens[32];
int nr_token;

bool not_a_num(uint32_t p) {
		if(tokens[p].type != NUM && tokens[p].type != ONUM && tokens[p].type != HNUM && tokens[p].type != '$' && tokens[p].type != VAR) {
 804a5f6:	8d 04 c9             	lea    (%ecx,%ecx,8),%eax
 804a5f9:	8b 14 85 c0 84 0c 08 	mov    0x80c84c0(,%eax,4),%edx
		}
		return eval(p + 1, q - 1, success); 
	}
	else {
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
 804a600:	83 fa 29             	cmp    $0x29,%edx
 804a603:	0f 94 44 24 08       	sete   0x8(%esp)

Token tokens[32];
int nr_token;

bool not_a_num(uint32_t p) {
		if(tokens[p].type != NUM && tokens[p].type != ONUM && tokens[p].type != HNUM && tokens[p].type != '$' && tokens[p].type != VAR) {
 804a608:	81 fa 0d 01 00 00    	cmp    $0x10d,%edx
 804a60e:	0f 95 44 24 0f       	setne  0xf(%esp)
 804a613:	83 fa 24             	cmp    $0x24,%edx
 804a616:	0f 95 c0             	setne  %al
 804a619:	22 44 24 0f          	and    0xf(%esp),%al
 804a61d:	81 ea 02 01 00 00    	sub    $0x102,%edx
 804a623:	83 fa 02             	cmp    $0x2,%edx
 804a626:	0f 97 c2             	seta   %dl
 804a629:	21 d0                	and    %edx,%eax
		}
		return eval(p + 1, q - 1, success); 
	}
	else {
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
 804a62b:	38 44 24 08          	cmp    %al,0x8(%esp)
 804a62f:	0f 83 e6 00 00 00    	jae    804a71b <eval+0x1ab>
						*success = false;
						return 0;
			}
		}
		else {
			val2 = eval(op + 1, q, success);
 804a635:	8d 45 01             	lea    0x1(%ebp),%eax
 804a638:	83 ec 04             	sub    $0x4,%esp
 804a63b:	57                   	push   %edi
 804a63c:	56                   	push   %esi
 804a63d:	50                   	push   %eax
 804a63e:	e8 2d ff ff ff       	call   804a570 <eval>
			if(!(*success)) return 0;
 804a643:	83 c4 10             	add    $0x10,%esp
 804a646:	80 3f 00             	cmpb   $0x0,(%edi)
 804a649:	74 4d                	je     804a698 <eval+0x128>
			switch(tokens[op].type) {
 804a64b:	8d 54 ed 00          	lea    0x0(%ebp,%ebp,8),%edx
 804a64f:	8b 14 95 c0 84 0c 08 	mov    0x80c84c0(,%edx,4),%edx
 804a656:	83 fa 2a             	cmp    $0x2a,%edx
 804a659:	0f 84 f2 02 00 00    	je     804a951 <eval+0x3e1>
 804a65f:	0f 8e 03 02 00 00    	jle    804a868 <eval+0x2f8>
				case '-': return -val2;
 804a665:	89 c3                	mov    %eax,%ebx
 804a667:	f7 db                	neg    %ebx
			}
		}
		else {
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a669:	83 fa 2d             	cmp    $0x2d,%edx
 804a66c:	0f 84 5e ff ff ff    	je     804a5d0 <eval+0x60>
				case '-': return -val2;
				case '*': return hwaddr_read(val2, 4);
				case '!': return !val2;
				case '~': return ~val2;
 804a672:	f7 d0                	not    %eax
			}
		}
		else {
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a674:	83 fa 7e             	cmp    $0x7e,%edx
				case '-': return -val2;
				case '*': return hwaddr_read(val2, 4);
				case '!': return !val2;
				case '~': return ~val2;
 804a677:	89 c3                	mov    %eax,%ebx
			}
		}
		else {
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a679:	0f 84 51 ff ff ff    	je     804a5d0 <eval+0x60>
				case '-': return -val2;
				case '*': return hwaddr_read(val2, 4);
				case '!': return !val2;
				case '~': return ~val2;
				default:
						printf("the operator deosn't implemented.\n");
 804a67f:	83 ec 0c             	sub    $0xc,%esp
 804a682:	68 8c ef 05 08       	push   $0x805ef8c
 804a687:	e8 d4 e3 ff ff       	call   8048a60 <puts@plt>
						*success = false;
 804a68c:	c6 07 00             	movb   $0x0,(%edi)
						return 0;
 804a68f:	83 c4 10             	add    $0x10,%esp
 804a692:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
			}
		}
	}
}
 804a698:	83 c4 1c             	add    $0x1c,%esp
				case '!': return !val2;
				case '~': return ~val2;
				default:
						printf("the operator deosn't implemented.\n");
						*success = false;
						return 0;
 804a69b:	31 db                	xor    %ebx,%ebx
			}
		}
	}
}
 804a69d:	89 d8                	mov    %ebx,%eax
 804a69f:	5b                   	pop    %ebx
 804a6a0:	5e                   	pop    %esi
 804a6a1:	5f                   	pop    %edi
 804a6a2:	5d                   	pop    %ebp
 804a6a3:	c3                   	ret    
 804a6a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

Token tokens[32];
int nr_token;

bool not_a_num(uint32_t p) {
		if(tokens[p].type != NUM && tokens[p].type != ONUM && tokens[p].type != HNUM && tokens[p].type != '$' && tokens[p].type != VAR) {
 804a6a8:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
 804a6ab:	8b 04 85 c0 84 0c 08 	mov    0x80c84c0(,%eax,4),%eax
 804a6b2:	3d 0d 01 00 00       	cmp    $0x10d,%eax
 804a6b7:	0f 95 c1             	setne  %cl
 804a6ba:	83 f8 24             	cmp    $0x24,%eax
 804a6bd:	0f 95 c2             	setne  %dl
 804a6c0:	84 d1                	test   %dl,%cl
 804a6c2:	74 25                	je     804a6e9 <eval+0x179>
 804a6c4:	8d 90 fe fe ff ff    	lea    -0x102(%eax),%edx
 804a6ca:	83 fa 02             	cmp    $0x2,%edx
 804a6cd:	76 1a                	jbe    804a6e9 <eval+0x179>
		*success = false;
		return 0;
	}
	else if(p == q) { 
		if(not_a_num(p)){
			printf("not a number!\n");
 804a6cf:	83 ec 0c             	sub    $0xc,%esp
			*success = false;
			return 0;
 804a6d2:	31 db                	xor    %ebx,%ebx
		*success = false;
		return 0;
	}
	else if(p == q) { 
		if(not_a_num(p)){
			printf("not a number!\n");
 804a6d4:	68 da ee 05 08       	push   $0x805eeda
 804a6d9:	e8 82 e3 ff ff       	call   8048a60 <puts@plt>
			*success = false;
 804a6de:	c6 07 00             	movb   $0x0,(%edi)
			return 0;
 804a6e1:	83 c4 10             	add    $0x10,%esp
 804a6e4:	e9 e7 fe ff ff       	jmp    804a5d0 <eval+0x60>
		}
		switch(tokens[p].type) {
 804a6e9:	3d 03 01 00 00       	cmp    $0x103,%eax
 804a6ee:	0f 84 0a 01 00 00    	je     804a7fe <eval+0x28e>
 804a6f4:	0f 8f b6 00 00 00    	jg     804a7b0 <eval+0x240>
 804a6fa:	83 f8 24             	cmp    $0x24,%eax
 804a6fd:	0f 84 94 01 00 00    	je     804a897 <eval+0x327>
 804a703:	3d 02 01 00 00       	cmp    $0x102,%eax
 804a708:	0f 85 6f 01 00 00    	jne    804a87d <eval+0x30d>
			case NUM: return strtol(tokens[p].str, NULL, 10); 
 804a70e:	c7 44 24 38 0a 00 00 	movl   $0xa,0x38(%esp)
 804a715:	00 
 804a716:	e9 eb 00 00 00       	jmp    804a806 <eval+0x296>
		return eval(p + 1, q - 1, success); 
	}
	else {
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
 804a71b:	83 ec 04             	sub    $0x4,%esp
 804a71e:	57                   	push   %edi
 804a71f:	51                   	push   %ecx
 804a720:	53                   	push   %ebx
 804a721:	e8 4a fe ff ff       	call   804a570 <eval>
 804a726:	89 44 24 18          	mov    %eax,0x18(%esp)
			val2 = eval(op + 1, q, success);
 804a72a:	8d 45 01             	lea    0x1(%ebp),%eax
 804a72d:	83 c4 0c             	add    $0xc,%esp
 804a730:	57                   	push   %edi
 804a731:	56                   	push   %esi
 804a732:	50                   	push   %eax
 804a733:	e8 38 fe ff ff       	call   804a570 <eval>
			if(!(*success)) return 0;
 804a738:	83 c4 10             	add    $0x10,%esp
 804a73b:	80 3f 00             	cmpb   $0x0,(%edi)
	}
	else {
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
 804a73e:	89 c1                	mov    %eax,%ecx
			if(!(*success)) return 0;
 804a740:	0f 84 52 ff ff ff    	je     804a698 <eval+0x128>
			switch(tokens[op].type) {
 804a746:	8d 44 ed 00          	lea    0x0(%ebp,%ebp,8),%eax
 804a74a:	8b 54 24 08          	mov    0x8(%esp),%edx
 804a74e:	8b 04 85 c0 84 0c 08 	mov    0x80c84c0(,%eax,4),%eax
 804a755:	83 f8 5e             	cmp    $0x5e,%eax
 804a758:	0f 84 30 03 00 00    	je     804aa8e <eval+0x51e>
 804a75e:	0f 8e c4 00 00 00    	jle    804a828 <eval+0x2b8>
 804a764:	3d 07 01 00 00       	cmp    $0x107,%eax
 804a769:	0f 84 28 03 00 00    	je     804aa97 <eval+0x527>
 804a76f:	0f 8f f4 01 00 00    	jg     804a969 <eval+0x3f9>
 804a775:	3d 01 01 00 00       	cmp    $0x101,%eax
 804a77a:	0f 84 38 03 00 00    	je     804aab8 <eval+0x548>
 804a780:	0f 8e 1d 03 00 00    	jle    804aaa3 <eval+0x533>
 804a786:	3d 05 01 00 00       	cmp    $0x105,%eax
 804a78b:	0f 84 e5 02 00 00    	je     804aa76 <eval+0x506>
				case RS: return val1 >> val2;
				case '%': return val1 % val2;
				case '<': return val1 < val2;
				case '>': return val1 > val2;
				case NOT_LE: return val1 >= val2;
				case NOT_LA: return val1 <= val2;
 804a791:	31 db                	xor    %ebx,%ebx
 804a793:	39 ca                	cmp    %ecx,%edx
 804a795:	0f 96 c3             	setbe  %bl
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a798:	3d 06 01 00 00       	cmp    $0x106,%eax
 804a79d:	0f 84 2d fe ff ff    	je     804a5d0 <eval+0x60>
 804a7a3:	e9 d7 fe ff ff       	jmp    804a67f <eval+0x10f>
 804a7a8:	90                   	nop
 804a7a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		if(not_a_num(p)){
			printf("not a number!\n");
			*success = false;
			return 0;
		}
		switch(tokens[p].type) {
 804a7b0:	3d 04 01 00 00       	cmp    $0x104,%eax
 804a7b5:	0f 84 89 01 00 00    	je     804a944 <eval+0x3d4>
 804a7bb:	3d 0d 01 00 00       	cmp    $0x10d,%eax
 804a7c0:	0f 85 b7 00 00 00    	jne    804a87d <eval+0x30d>
						  if(strcmp("eip", tokens[p].str+1) == 0) return cpu.eip;
						  printf("register name wrong.\n");
						  *success = false;
						  return 0;
			case VAR:
						  ret = read_sym(tokens[p].str);
 804a7c6:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
 804a7c9:	83 ec 0c             	sub    $0xc,%esp
 804a7cc:	8d 04 85 c4 84 0c 08 	lea    0x80c84c4(,%eax,4),%eax
 804a7d3:	50                   	push   %eax
 804a7d4:	e8 e7 ed ff ff       	call   80495c0 <read_sym>
						  if(ret) return ret;
 804a7d9:	83 c4 10             	add    $0x10,%esp
 804a7dc:	85 c0                	test   %eax,%eax
 804a7de:	89 c3                	mov    %eax,%ebx
 804a7e0:	0f 85 ea fd ff ff    	jne    804a5d0 <eval+0x60>
						  printf("dont have this variable\n");
 804a7e6:	83 ec 0c             	sub    $0xc,%esp
 804a7e9:	68 ab ee 05 08       	push   $0x805eeab
 804a7ee:	e8 6d e2 ff ff       	call   8048a60 <puts@plt>
						  *success = false;
 804a7f3:	c6 07 00             	movb   $0x0,(%edi)
						  return 0;
 804a7f6:	83 c4 10             	add    $0x10,%esp
 804a7f9:	e9 d2 fd ff ff       	jmp    804a5d0 <eval+0x60>
			return 0;
		}
		switch(tokens[p].type) {
			case NUM: return strtol(tokens[p].str, NULL, 10); 
			case ONUM: return strtol(tokens[p].str, NULL, 8); 
			case HNUM: return strtol(tokens[p].str, NULL, 16); 
 804a7fe:	c7 44 24 38 10 00 00 	movl   $0x10,0x38(%esp)
 804a805:	00 
			*success = false;
			return 0;
		}
		switch(tokens[p].type) {
			case NUM: return strtol(tokens[p].str, NULL, 10); 
			case ONUM: return strtol(tokens[p].str, NULL, 8); 
 804a806:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
 804a809:	c7 44 24 34 00 00 00 	movl   $0x0,0x34(%esp)
 804a810:	00 
 804a811:	8d 04 85 c4 84 0c 08 	lea    0x80c84c4(,%eax,4),%eax
 804a818:	89 44 24 30          	mov    %eax,0x30(%esp)
						*success = false;
						return 0;
			}
		}
	}
}
 804a81c:	83 c4 1c             	add    $0x1c,%esp
 804a81f:	5b                   	pop    %ebx
 804a820:	5e                   	pop    %esi
 804a821:	5f                   	pop    %edi
 804a822:	5d                   	pop    %ebp
			*success = false;
			return 0;
		}
		switch(tokens[p].type) {
			case NUM: return strtol(tokens[p].str, NULL, 10); 
			case ONUM: return strtol(tokens[p].str, NULL, 8); 
 804a823:	e9 78 e3 ff ff       	jmp    8048ba0 <strtol@plt>
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a828:	83 f8 2b             	cmp    $0x2b,%eax
 804a82b:	0f 84 3d 02 00 00    	je     804aa6e <eval+0x4fe>
 804a831:	0f 8e 66 01 00 00    	jle    804a99d <eval+0x42d>
 804a837:	83 f8 2f             	cmp    $0x2f,%eax
 804a83a:	0f 84 f8 01 00 00    	je     804aa38 <eval+0x4c8>
 804a840:	0f 8e da 01 00 00    	jle    804aa20 <eval+0x4b0>
 804a846:	83 f8 3c             	cmp    $0x3c,%eax
 804a849:	0f 84 33 02 00 00    	je     804aa82 <eval+0x512>
				case '^': return val1 ^ val2;
				case LS: return val1 << val2;
				case RS: return val1 >> val2;
				case '%': return val1 % val2;
				case '<': return val1 < val2;
				case '>': return val1 > val2;
 804a84f:	31 db                	xor    %ebx,%ebx
 804a851:	39 ca                	cmp    %ecx,%edx
 804a853:	0f 97 c3             	seta   %bl
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a856:	83 f8 3e             	cmp    $0x3e,%eax
 804a859:	0f 84 71 fd ff ff    	je     804a5d0 <eval+0x60>
 804a85f:	e9 1b fe ff ff       	jmp    804a67f <eval+0x10f>
 804a864:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
				case '-': return -val2;
				case '*': return hwaddr_read(val2, 4);
				case '!': return !val2;
 804a868:	31 db                	xor    %ebx,%ebx
 804a86a:	85 c0                	test   %eax,%eax
 804a86c:	0f 94 c3             	sete   %bl
			}
		}
		else {
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a86f:	83 fa 21             	cmp    $0x21,%edx
 804a872:	0f 84 58 fd ff ff    	je     804a5d0 <eval+0x60>
 804a878:	e9 02 fe ff ff       	jmp    804a67f <eval+0x10f>
						  if(ret) return ret;
						  printf("dont have this variable\n");
						  *success = false;
						  return 0;
			default:
					   printf("dont have this number!\n");
 804a87d:	83 ec 0c             	sub    $0xc,%esp
					   *success = false;
					   return 0;
 804a880:	31 db                	xor    %ebx,%ebx
						  if(ret) return ret;
						  printf("dont have this variable\n");
						  *success = false;
						  return 0;
			default:
					   printf("dont have this number!\n");
 804a882:	68 c3 ee 05 08       	push   $0x805eec3
 804a887:	e8 d4 e1 ff ff       	call   8048a60 <puts@plt>
					   *success = false;
 804a88c:	c6 07 00             	movb   $0x0,(%edi)
					   return 0;
 804a88f:	83 c4 10             	add    $0x10,%esp
 804a892:	e9 39 fd ff ff       	jmp    804a5d0 <eval+0x60>
 804a897:	8d 04 db             	lea    (%ebx,%ebx,8),%eax
		if(not_a_num(p)){
			printf("not a number!\n");
			*success = false;
			return 0;
		}
		switch(tokens[p].type) {
 804a89a:	31 db                	xor    %ebx,%ebx
 804a89c:	8d 2c 85 c1 84 0c 08 	lea    0x80c84c1(,%eax,4),%ebp
 804a8a3:	8d 75 04             	lea    0x4(%ebp),%esi
 804a8a6:	8d 76 00             	lea    0x0(%esi),%esi
 804a8a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
			case NUM: return strtol(tokens[p].str, NULL, 10); 
			case ONUM: return strtol(tokens[p].str, NULL, 8); 
			case HNUM: return strtol(tokens[p].str, NULL, 16); 
			case '$':
						  for(i = R_EAX; i <= R_EDI; i ++) {
							  if(strcmp(regsl[i], tokens[p].str+1) == 0) {
 804a8b0:	83 ec 08             	sub    $0x8,%esp
 804a8b3:	56                   	push   %esi
 804a8b4:	ff 34 9d c0 5c 07 08 	pushl  0x8075cc0(,%ebx,4)
 804a8bb:	e8 80 e0 ff ff       	call   8048940 <strcmp@plt>
 804a8c0:	83 c4 10             	add    $0x10,%esp
 804a8c3:	85 c0                	test   %eax,%eax
 804a8c5:	0f 84 fe 00 00 00    	je     804a9c9 <eval+0x459>
		switch(tokens[p].type) {
			case NUM: return strtol(tokens[p].str, NULL, 10); 
			case ONUM: return strtol(tokens[p].str, NULL, 8); 
			case HNUM: return strtol(tokens[p].str, NULL, 16); 
			case '$':
						  for(i = R_EAX; i <= R_EDI; i ++) {
 804a8cb:	83 c3 01             	add    $0x1,%ebx
 804a8ce:	83 fb 08             	cmp    $0x8,%ebx
 804a8d1:	75 dd                	jne    804a8b0 <eval+0x340>
 804a8d3:	30 db                	xor    %bl,%bl
 804a8d5:	8d 76 00             	lea    0x0(%esi),%esi
							  if(strcmp(regsl[i], tokens[p].str+1) == 0) {
								  return reg_l(i);
							  }
						  }
						  for(i = R_AX; i <= R_DI; i ++) {
							  if(strcmp(regsw[i], tokens[p].str+1) == 0) {
 804a8d8:	83 ec 08             	sub    $0x8,%esp
 804a8db:	56                   	push   %esi
 804a8dc:	ff 34 9d a0 5c 07 08 	pushl  0x8075ca0(,%ebx,4)
 804a8e3:	e8 58 e0 ff ff       	call   8048940 <strcmp@plt>
 804a8e8:	83 c4 10             	add    $0x10,%esp
 804a8eb:	85 c0                	test   %eax,%eax
 804a8ed:	0f 84 e2 00 00 00    	je     804a9d5 <eval+0x465>
						  for(i = R_EAX; i <= R_EDI; i ++) {
							  if(strcmp(regsl[i], tokens[p].str+1) == 0) {
								  return reg_l(i);
							  }
						  }
						  for(i = R_AX; i <= R_DI; i ++) {
 804a8f3:	83 c3 01             	add    $0x1,%ebx
 804a8f6:	83 fb 08             	cmp    $0x8,%ebx
 804a8f9:	75 dd                	jne    804a8d8 <eval+0x368>
 804a8fb:	30 db                	xor    %bl,%bl
							  if(strcmp(regsw[i], tokens[p].str+1) == 0) {
								  return reg_w(i);
							  }
						  }
						  for(i = R_AL; i <= R_BH; i ++) {
							  if(strcmp(regsb[i], tokens[p].str+1) == 0) {
 804a8fd:	83 ec 08             	sub    $0x8,%esp
 804a900:	56                   	push   %esi
 804a901:	ff 34 9d 80 5c 07 08 	pushl  0x8075c80(,%ebx,4)
 804a908:	e8 33 e0 ff ff       	call   8048940 <strcmp@plt>
 804a90d:	83 c4 10             	add    $0x10,%esp
 804a910:	85 c0                	test   %eax,%eax
 804a912:	0f 84 f3 00 00 00    	je     804aa0b <eval+0x49b>
						  for(i = R_AX; i <= R_DI; i ++) {
							  if(strcmp(regsw[i], tokens[p].str+1) == 0) {
								  return reg_w(i);
							  }
						  }
						  for(i = R_AL; i <= R_BH; i ++) {
 804a918:	83 c3 01             	add    $0x1,%ebx
 804a91b:	83 fb 08             	cmp    $0x8,%ebx
 804a91e:	75 dd                	jne    804a8fd <eval+0x38d>
							  if(strcmp(regsb[i], tokens[p].str+1) == 0) {
								  return reg_b(i);
							  }
						  }
						  if(strcmp("eip", tokens[p].str+1) == 0) return cpu.eip;
 804a920:	80 7d 04 65          	cmpb   $0x65,0x4(%ebp)
 804a924:	0f 84 b8 00 00 00    	je     804a9e2 <eval+0x472>
						  printf("register name wrong.\n");
 804a92a:	83 ec 0c             	sub    $0xc,%esp
						  *success = false;
						  return 0;
 804a92d:	31 db                	xor    %ebx,%ebx
							  if(strcmp(regsb[i], tokens[p].str+1) == 0) {
								  return reg_b(i);
							  }
						  }
						  if(strcmp("eip", tokens[p].str+1) == 0) return cpu.eip;
						  printf("register name wrong.\n");
 804a92f:	68 96 ee 05 08       	push   $0x805ee96
 804a934:	e8 27 e1 ff ff       	call   8048a60 <puts@plt>
						  *success = false;
 804a939:	c6 07 00             	movb   $0x0,(%edi)
						  return 0;
 804a93c:	83 c4 10             	add    $0x10,%esp
 804a93f:	e9 8c fc ff ff       	jmp    804a5d0 <eval+0x60>
			*success = false;
			return 0;
		}
		switch(tokens[p].type) {
			case NUM: return strtol(tokens[p].str, NULL, 10); 
			case ONUM: return strtol(tokens[p].str, NULL, 8); 
 804a944:	c7 44 24 38 08 00 00 	movl   $0x8,0x38(%esp)
 804a94b:	00 
 804a94c:	e9 b5 fe ff ff       	jmp    804a806 <eval+0x296>
		else {
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
				case '-': return -val2;
				case '*': return hwaddr_read(val2, 4);
 804a951:	c7 44 24 34 04 00 00 	movl   $0x4,0x34(%esp)
 804a958:	00 
 804a959:	89 44 24 30          	mov    %eax,0x30(%esp)
						*success = false;
						return 0;
			}
		}
	}
}
 804a95d:	83 c4 1c             	add    $0x1c,%esp
 804a960:	5b                   	pop    %ebx
 804a961:	5e                   	pop    %esi
 804a962:	5f                   	pop    %edi
 804a963:	5d                   	pop    %ebp
		else {
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
				case '-': return -val2;
				case '*': return hwaddr_read(val2, 4);
 804a964:	e9 67 05 00 00       	jmp    804aed0 <hwaddr_read>
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a969:	3d 09 01 00 00       	cmp    $0x109,%eax
 804a96e:	0f 84 e4 00 00 00    	je     804aa58 <eval+0x4e8>
 804a974:	0f 8c cb 00 00 00    	jl     804aa45 <eval+0x4d5>
				case '&': return val1 & val2;
				case '|': return val1 | val2;
				case AND: return val1 && val2;
				case OR: return val1 || val2;
				case '^': return val1 ^ val2;
				case LS: return val1 << val2;
 804a97a:	89 d3                	mov    %edx,%ebx
 804a97c:	d3 e3                	shl    %cl,%ebx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a97e:	3d 0b 01 00 00       	cmp    $0x10b,%eax
 804a983:	0f 84 47 fc ff ff    	je     804a5d0 <eval+0x60>
				case '|': return val1 | val2;
				case AND: return val1 && val2;
				case OR: return val1 || val2;
				case '^': return val1 ^ val2;
				case LS: return val1 << val2;
				case RS: return val1 >> val2;
 804a989:	d3 ea                	shr    %cl,%edx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a98b:	3d 0c 01 00 00       	cmp    $0x10c,%eax
				case '|': return val1 | val2;
				case AND: return val1 && val2;
				case OR: return val1 || val2;
				case '^': return val1 ^ val2;
				case LS: return val1 << val2;
				case RS: return val1 >> val2;
 804a990:	89 d3                	mov    %edx,%ebx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a992:	0f 84 38 fc ff ff    	je     804a5d0 <eval+0x60>
 804a998:	e9 e2 fc ff ff       	jmp    804a67f <eval+0x10f>
				case '+': return val1 + val2;
				case '-': return val1 - val2;
				case '*': return val1 * val2;
				case '/': return val1 / val2;
				case '&': return val1 & val2;
 804a99d:	89 cb                	mov    %ecx,%ebx
 804a99f:	21 d3                	and    %edx,%ebx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804a9a1:	83 f8 26             	cmp    $0x26,%eax
 804a9a4:	0f 84 26 fc ff ff    	je     804a5d0 <eval+0x60>
 804a9aa:	83 f8 2a             	cmp    $0x2a,%eax
 804a9ad:	0f 84 b1 00 00 00    	je     804aa64 <eval+0x4f4>
 804a9b3:	83 f8 25             	cmp    $0x25,%eax
 804a9b6:	0f 85 c3 fc ff ff    	jne    804a67f <eval+0x10f>
				case AND: return val1 && val2;
				case OR: return val1 || val2;
				case '^': return val1 ^ val2;
				case LS: return val1 << val2;
				case RS: return val1 >> val2;
				case '%': return val1 % val2;
 804a9bc:	89 d0                	mov    %edx,%eax
 804a9be:	31 d2                	xor    %edx,%edx
 804a9c0:	f7 f1                	div    %ecx
 804a9c2:	89 d3                	mov    %edx,%ebx
 804a9c4:	e9 07 fc ff ff       	jmp    804a5d0 <eval+0x60>
			case ONUM: return strtol(tokens[p].str, NULL, 8); 
			case HNUM: return strtol(tokens[p].str, NULL, 16); 
			case '$':
						  for(i = R_EAX; i <= R_EDI; i ++) {
							  if(strcmp(regsl[i], tokens[p].str+1) == 0) {
								  return reg_l(i);
 804a9c9:	8b 1c 9d c0 af 0f 10 	mov    0x100fafc0(,%ebx,4),%ebx
 804a9d0:	e9 fb fb ff ff       	jmp    804a5d0 <eval+0x60>
							  }
						  }
						  for(i = R_AX; i <= R_DI; i ++) {
							  if(strcmp(regsw[i], tokens[p].str+1) == 0) {
								  return reg_w(i);
 804a9d5:	0f b7 1c 9d c0 af 0f 	movzwl 0x100fafc0(,%ebx,4),%ebx
 804a9dc:	10 
 804a9dd:	e9 ee fb ff ff       	jmp    804a5d0 <eval+0x60>
						  for(i = R_AL; i <= R_BH; i ++) {
							  if(strcmp(regsb[i], tokens[p].str+1) == 0) {
								  return reg_b(i);
							  }
						  }
						  if(strcmp("eip", tokens[p].str+1) == 0) return cpu.eip;
 804a9e2:	80 7e 01 69          	cmpb   $0x69,0x1(%esi)
 804a9e6:	0f 85 3e ff ff ff    	jne    804a92a <eval+0x3ba>
 804a9ec:	80 7e 02 70          	cmpb   $0x70,0x2(%esi)
 804a9f0:	0f 85 34 ff ff ff    	jne    804a92a <eval+0x3ba>
 804a9f6:	80 7e 03 00          	cmpb   $0x0,0x3(%esi)
 804a9fa:	0f 85 2a ff ff ff    	jne    804a92a <eval+0x3ba>
 804aa00:	8b 1d e0 af 0f 10    	mov    0x100fafe0,%ebx
 804aa06:	e9 c5 fb ff ff       	jmp    804a5d0 <eval+0x60>
								  return reg_w(i);
							  }
						  }
						  for(i = R_AL; i <= R_BH; i ++) {
							  if(strcmp(regsb[i], tokens[p].str+1) == 0) {
								  return reg_b(i);
 804aa0b:	89 d8                	mov    %ebx,%eax
 804aa0d:	c1 fb 02             	sar    $0x2,%ebx
 804aa10:	83 e0 03             	and    $0x3,%eax
 804aa13:	0f b6 9c 83 c0 af 0f 	movzbl 0x100fafc0(%ebx,%eax,4),%ebx
 804aa1a:	10 
 804aa1b:	e9 b0 fb ff ff       	jmp    804a5d0 <eval+0x60>
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
				case '+': return val1 + val2;
				case '-': return val1 - val2;
 804aa20:	29 ca                	sub    %ecx,%edx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804aa22:	83 f8 2d             	cmp    $0x2d,%eax
				case '+': return val1 + val2;
				case '-': return val1 - val2;
 804aa25:	89 d3                	mov    %edx,%ebx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804aa27:	0f 84 a3 fb ff ff    	je     804a5d0 <eval+0x60>
 804aa2d:	e9 4d fc ff ff       	jmp    804a67f <eval+0x10f>
 804aa32:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
				case '+': return val1 + val2;
				case '-': return val1 - val2;
				case '*': return val1 * val2;
				case '/': return val1 / val2;
 804aa38:	89 d0                	mov    %edx,%eax
 804aa3a:	31 d2                	xor    %edx,%edx
 804aa3c:	f7 f1                	div    %ecx
 804aa3e:	89 c3                	mov    %eax,%ebx
 804aa40:	e9 8b fb ff ff       	jmp    804a5d0 <eval+0x60>
				case '&': return val1 & val2;
				case '|': return val1 | val2;
				case AND: return val1 && val2;
 804aa45:	85 c9                	test   %ecx,%ecx
 804aa47:	0f 95 c0             	setne  %al
 804aa4a:	31 db                	xor    %ebx,%ebx
 804aa4c:	85 d2                	test   %edx,%edx
 804aa4e:	0f 95 c3             	setne  %bl
 804aa51:	21 c3                	and    %eax,%ebx
 804aa53:	e9 78 fb ff ff       	jmp    804a5d0 <eval+0x60>
				case OR: return val1 || val2;
 804aa58:	31 db                	xor    %ebx,%ebx
 804aa5a:	09 d1                	or     %edx,%ecx
 804aa5c:	0f 95 c3             	setne  %bl
 804aa5f:	e9 6c fb ff ff       	jmp    804a5d0 <eval+0x60>
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
				case '+': return val1 + val2;
				case '-': return val1 - val2;
				case '*': return val1 * val2;
 804aa64:	0f af ca             	imul   %edx,%ecx
 804aa67:	89 cb                	mov    %ecx,%ebx
 804aa69:	e9 62 fb ff ff       	jmp    804a5d0 <eval+0x60>
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
				case '+': return val1 + val2;
 804aa6e:	8d 1c 11             	lea    (%ecx,%edx,1),%ebx
 804aa71:	e9 5a fb ff ff       	jmp    804a5d0 <eval+0x60>
				case '%': return val1 % val2;
				case '<': return val1 < val2;
				case '>': return val1 > val2;
				case NOT_LE: return val1 >= val2;
				case NOT_LA: return val1 <= val2;
				case NOT_EQ: return val1 != val2;
 804aa76:	31 db                	xor    %ebx,%ebx
 804aa78:	39 ca                	cmp    %ecx,%edx
 804aa7a:	0f 95 c3             	setne  %bl
 804aa7d:	e9 4e fb ff ff       	jmp    804a5d0 <eval+0x60>
				case OR: return val1 || val2;
				case '^': return val1 ^ val2;
				case LS: return val1 << val2;
				case RS: return val1 >> val2;
				case '%': return val1 % val2;
				case '<': return val1 < val2;
 804aa82:	31 db                	xor    %ebx,%ebx
 804aa84:	39 ca                	cmp    %ecx,%edx
 804aa86:	0f 92 c3             	setb   %bl
 804aa89:	e9 42 fb ff ff       	jmp    804a5d0 <eval+0x60>
				case '/': return val1 / val2;
				case '&': return val1 & val2;
				case '|': return val1 | val2;
				case AND: return val1 && val2;
				case OR: return val1 || val2;
				case '^': return val1 ^ val2;
 804aa8e:	31 d1                	xor    %edx,%ecx
 804aa90:	89 cb                	mov    %ecx,%ebx
 804aa92:	e9 39 fb ff ff       	jmp    804a5d0 <eval+0x60>
				case LS: return val1 << val2;
				case RS: return val1 >> val2;
				case '%': return val1 % val2;
				case '<': return val1 < val2;
				case '>': return val1 > val2;
				case NOT_LE: return val1 >= val2;
 804aa97:	31 db                	xor    %ebx,%ebx
 804aa99:	39 ca                	cmp    %ecx,%edx
 804aa9b:	0f 93 c3             	setae  %bl
 804aa9e:	e9 2d fb ff ff       	jmp    804a5d0 <eval+0x60>
				case '+': return val1 + val2;
				case '-': return val1 - val2;
				case '*': return val1 * val2;
				case '/': return val1 / val2;
				case '&': return val1 & val2;
				case '|': return val1 | val2;
 804aaa3:	09 d1                	or     %edx,%ecx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804aaa5:	83 f8 7c             	cmp    $0x7c,%eax
				case '+': return val1 + val2;
				case '-': return val1 - val2;
				case '*': return val1 * val2;
				case '/': return val1 / val2;
				case '&': return val1 & val2;
				case '|': return val1 | val2;
 804aaa8:	89 cb                	mov    %ecx,%ebx
		op = find_the_last_operator(p, q);
		if(op != p && (!not_a_num(op-1) || tokens[op-1].type == ')')) {
			val1 = eval(p, op - 1, success);
			val2 = eval(op + 1, q, success);
			if(!(*success)) return 0;
			switch(tokens[op].type) {
 804aaaa:	0f 84 20 fb ff ff    	je     804a5d0 <eval+0x60>
 804aab0:	e9 ca fb ff ff       	jmp    804a67f <eval+0x10f>
 804aab5:	8d 76 00             	lea    0x0(%esi),%esi
				case '<': return val1 < val2;
				case '>': return val1 > val2;
				case NOT_LE: return val1 >= val2;
				case NOT_LA: return val1 <= val2;
				case NOT_EQ: return val1 != val2;
				case EQ: return val1 == val2;
 804aab8:	31 db                	xor    %ebx,%ebx
 804aaba:	39 ca                	cmp    %ecx,%edx
 804aabc:	0f 94 c3             	sete   %bl
 804aabf:	e9 0c fb ff ff       	jmp    804a5d0 <eval+0x60>
 804aac4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804aaca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804aad0 <expr>:
			}
		}
	}
}

uint32_t expr(char *e, bool *success) {
 804aad0:	55                   	push   %ebp
 804aad1:	57                   	push   %edi
 804aad2:	56                   	push   %esi
 804aad3:	53                   	push   %ebx
 804aad4:	83 ec 2c             	sub    $0x2c,%esp
static bool make_token(char *e) {
	int position = 0;
	int i;
	regmatch_t pmatch;
	
	nr_token = 0;
 804aad7:	c7 05 80 84 0c 08 00 	movl   $0x0,0x80c8480
 804aade:	00 00 00 
 804aae1:	8d 74 24 18          	lea    0x18(%esp),%esi
		}
		else return false;
}

static bool make_token(char *e) {
	int position = 0;
 804aae5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 804aaec:	00 
	int i;
	regmatch_t pmatch;
	
	nr_token = 0;

	while(e[position] != '\0') {
 804aaed:	8b 5c 24 08          	mov    0x8(%esp),%ebx
 804aaf1:	03 5c 24 40          	add    0x40(%esp),%ebx
 804aaf5:	80 3b 00             	cmpb   $0x0,(%ebx)
 804aaf8:	0f 84 58 01 00 00    	je     804ac56 <expr+0x186>
 804aafe:	bf 00 7f 07 08       	mov    $0x8077f00,%edi
 804ab03:	31 ed                	xor    %ebp,%ebp
 804ab05:	8d 76 00             	lea    0x0(%esi),%esi
		/* Try all rules one by one. */
		for(i = 0; i < NR_REGEX; i ++) {
			if(regexec(&re[i], e + position, 1, &pmatch, 0) == 0 && pmatch.rm_so == 0) {
 804ab08:	83 ec 0c             	sub    $0xc,%esp
 804ab0b:	6a 00                	push   $0x0
 804ab0d:	56                   	push   %esi
 804ab0e:	6a 01                	push   $0x1
 804ab10:	53                   	push   %ebx
 804ab11:	57                   	push   %edi
 804ab12:	e8 29 e0 ff ff       	call   8048b40 <regexec@plt>
 804ab17:	83 c4 20             	add    $0x20,%esp
 804ab1a:	85 c0                	test   %eax,%eax
 804ab1c:	75 08                	jne    804ab26 <expr+0x56>
 804ab1e:	8b 44 24 18          	mov    0x18(%esp),%eax
 804ab22:	85 c0                	test   %eax,%eax
 804ab24:	74 42                	je     804ab68 <expr+0x98>
	
	nr_token = 0;

	while(e[position] != '\0') {
		/* Try all rules one by one. */
		for(i = 0; i < NR_REGEX; i ++) {
 804ab26:	83 c5 01             	add    $0x1,%ebp
 804ab29:	83 c7 20             	add    $0x20,%edi
 804ab2c:	83 fd 1c             	cmp    $0x1c,%ebp
 804ab2f:	75 d7                	jne    804ab08 <expr+0x38>
				break;
			}
		}

		if(i == NR_REGEX) {
			printf("no match at position %d\n%s\n%*.s^\n", position, e, position, "");
 804ab31:	83 ec 0c             	sub    $0xc,%esp
 804ab34:	68 0c ec 05 08       	push   $0x805ec0c
 804ab39:	8b 44 24 18          	mov    0x18(%esp),%eax
 804ab3d:	50                   	push   %eax
 804ab3e:	ff 74 24 54          	pushl  0x54(%esp)
 804ab42:	50                   	push   %eax
 804ab43:	68 44 f0 05 08       	push   $0x805f044
 804ab48:	e8 03 de ff ff       	call   8048950 <printf@plt>
	}
}

uint32_t expr(char *e, bool *success) {
	if(!make_token(e)) {
		*success = false;
 804ab4d:	8b 44 24 64          	mov    0x64(%esp),%eax
		return 0;
 804ab51:	83 c4 20             	add    $0x20,%esp
	}
}

uint32_t expr(char *e, bool *success) {
	if(!make_token(e)) {
		*success = false;
 804ab54:	c6 00 00             	movb   $0x0,(%eax)
		return 0;
	}

	/* TODO: Insert codes to evaluate the expression. */
	return eval(0, nr_token-1, success);
}
 804ab57:	83 c4 2c             	add    $0x2c,%esp
}

uint32_t expr(char *e, bool *success) {
	if(!make_token(e)) {
		*success = false;
		return 0;
 804ab5a:	31 c0                	xor    %eax,%eax
	}

	/* TODO: Insert codes to evaluate the expression. */
	return eval(0, nr_token-1, success);
}
 804ab5c:	5b                   	pop    %ebx
 804ab5d:	5e                   	pop    %esi
 804ab5e:	5f                   	pop    %edi
 804ab5f:	5d                   	pop    %ebp
 804ab60:	c3                   	ret    
 804ab61:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	while(e[position] != '\0') {
		/* Try all rules one by one. */
		for(i = 0; i < NR_REGEX; i ++) {
			if(regexec(&re[i], e + position, 1, &pmatch, 0) == 0 && pmatch.rm_so == 0) {
				char *substr_start = e + position;
				int substr_len = pmatch.rm_eo;
 804ab68:	8b 7c 24 1c          	mov    0x1c(%esp),%edi

				Log("match rules[%d] = \"%s\" at position %d with len %d: %.*s", i, rules[i].regex, position, substr_len, substr_len, substr_start);
 804ab6c:	8b 14 ed c0 f0 05 08 	mov    0x805f0c0(,%ebp,8),%edx
 804ab73:	83 ec 04             	sub    $0x4,%esp
 804ab76:	53                   	push   %ebx
 804ab77:	57                   	push   %edi
 804ab78:	57                   	push   %edi
 804ab79:	ff 74 24 18          	pushl  0x18(%esp)
 804ab7d:	52                   	push   %edx
 804ab7e:	89 54 24 24          	mov    %edx,0x24(%esp)
 804ab82:	55                   	push   %ebp
 804ab83:	68 80 f0 05 08       	push   $0x805f080
 804ab88:	6a 6c                	push   $0x6c
 804ab8a:	68 4a ee 05 08       	push   $0x805ee4a
 804ab8f:	68 b0 ef 05 08       	push   $0x805efb0
 804ab94:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804ab9a:	e8 21 df ff ff       	call   8048ac0 <fprintf@plt>
 804ab9f:	83 c4 24             	add    $0x24,%esp
 804aba2:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804aba8:	e8 b3 dd ff ff       	call   8048960 <fflush@plt>
 804abad:	83 c4 0c             	add    $0xc,%esp
 804abb0:	53                   	push   %ebx
 804abb1:	57                   	push   %edi
 804abb2:	57                   	push   %edi
 804abb3:	ff 74 24 18          	pushl  0x18(%esp)
 804abb7:	8b 54 24 20          	mov    0x20(%esp),%edx
 804abbb:	52                   	push   %edx
 804abbc:	55                   	push   %ebp
 804abbd:	68 80 f0 05 08       	push   $0x805f080
 804abc2:	6a 6c                	push   $0x6c
 804abc4:	68 4a ee 05 08       	push   $0x805ee4a
 804abc9:	68 00 f0 05 08       	push   $0x805f000
 804abce:	ff 35 28 5d 07 08    	pushl  0x8075d28
 804abd4:	e8 e7 de ff ff       	call   8048ac0 <fprintf@plt>
 804abd9:	83 c4 24             	add    $0x24,%esp
 804abdc:	ff 35 28 5d 07 08    	pushl  0x8075d28
 804abe2:	e8 79 dd ff ff       	call   8048960 <fflush@plt>
				/* TODO: Now a new token is recognized with rules[i]. Add codes
				 * to record the token in the array ``tokens''. For certain 
				 * types of tokens, some extra actions should be performed.
				 */

				switch(rules[i].token_type) {
 804abe7:	8b 04 ed c4 f0 05 08 	mov    0x805f0c4(,%ebp,8),%eax
			if(regexec(&re[i], e + position, 1, &pmatch, 0) == 0 && pmatch.rm_so == 0) {
				char *substr_start = e + position;
				int substr_len = pmatch.rm_eo;

				Log("match rules[%d] = \"%s\" at position %d with len %d: %.*s", i, rules[i].regex, position, substr_len, substr_len, substr_start);
				position += substr_len;
 804abee:	01 7c 24 18          	add    %edi,0x18(%esp)
				/* TODO: Now a new token is recognized with rules[i]. Add codes
				 * to record the token in the array ``tokens''. For certain 
				 * types of tokens, some extra actions should be performed.
				 */

				switch(rules[i].token_type) {
 804abf2:	83 c4 10             	add    $0x10,%esp
 804abf5:	3d 00 01 00 00       	cmp    $0x100,%eax
 804abfa:	0f 84 ed fe ff ff    	je     804aaed <expr+0x1d>
					case NOTYPE: break;
					default: 
						tokens[nr_token].type = rules[i].token_type;
 804ac00:	8b 2d 80 84 0c 08    	mov    0x80c8480,%ebp
						strncpy(tokens[nr_token].str, substr_start, substr_len);
 804ac06:	83 ec 04             	sub    $0x4,%esp
 804ac09:	57                   	push   %edi
 804ac0a:	53                   	push   %ebx
				 */

				switch(rules[i].token_type) {
					case NOTYPE: break;
					default: 
						tokens[nr_token].type = rules[i].token_type;
 804ac0b:	8d 4c ed 00          	lea    0x0(%ebp,%ebp,8),%ecx
						strncpy(tokens[nr_token].str, substr_start, substr_len);
						tokens[nr_token].str[substr_len] = '\0';
						nr_token++;
 804ac0f:	83 c5 01             	add    $0x1,%ebp
				 */

				switch(rules[i].token_type) {
					case NOTYPE: break;
					default: 
						tokens[nr_token].type = rules[i].token_type;
 804ac12:	8d 14 8d 00 00 00 00 	lea    0x0(,%ecx,4),%edx
 804ac19:	89 04 8d c0 84 0c 08 	mov    %eax,0x80c84c0(,%ecx,4)
						strncpy(tokens[nr_token].str, substr_start, substr_len);
 804ac20:	8d 82 c4 84 0c 08    	lea    0x80c84c4(%edx),%eax
 804ac26:	89 54 24 18          	mov    %edx,0x18(%esp)
 804ac2a:	50                   	push   %eax
 804ac2b:	e8 00 df ff ff       	call   8048b30 <strncpy@plt>
						tokens[nr_token].str[substr_len] = '\0';
 804ac30:	8b 54 24 1c          	mov    0x1c(%esp),%edx
						nr_token++;
 804ac34:	83 c4 10             	add    $0x10,%esp
	int i;
	regmatch_t pmatch;
	
	nr_token = 0;

	while(e[position] != '\0') {
 804ac37:	8b 5c 24 08          	mov    0x8(%esp),%ebx
 804ac3b:	03 5c 24 40          	add    0x40(%esp),%ebx
					case NOTYPE: break;
					default: 
						tokens[nr_token].type = rules[i].token_type;
						strncpy(tokens[nr_token].str, substr_start, substr_len);
						tokens[nr_token].str[substr_len] = '\0';
						nr_token++;
 804ac3f:	89 2d 80 84 0c 08    	mov    %ebp,0x80c8480
				switch(rules[i].token_type) {
					case NOTYPE: break;
					default: 
						tokens[nr_token].type = rules[i].token_type;
						strncpy(tokens[nr_token].str, substr_start, substr_len);
						tokens[nr_token].str[substr_len] = '\0';
 804ac45:	c6 84 17 c4 84 0c 08 	movb   $0x0,0x80c84c4(%edi,%edx,1)
 804ac4c:	00 
	int i;
	regmatch_t pmatch;
	
	nr_token = 0;

	while(e[position] != '\0') {
 804ac4d:	80 3b 00             	cmpb   $0x0,(%ebx)
 804ac50:	0f 85 a8 fe ff ff    	jne    804aafe <expr+0x2e>
		*success = false;
		return 0;
	}

	/* TODO: Insert codes to evaluate the expression. */
	return eval(0, nr_token-1, success);
 804ac56:	a1 80 84 0c 08       	mov    0x80c8480,%eax
 804ac5b:	83 ec 04             	sub    $0x4,%esp
 804ac5e:	ff 74 24 48          	pushl  0x48(%esp)
 804ac62:	83 e8 01             	sub    $0x1,%eax
 804ac65:	50                   	push   %eax
 804ac66:	6a 00                	push   $0x0
 804ac68:	e8 03 f9 ff ff       	call   804a570 <eval>
 804ac6d:	83 c4 10             	add    $0x10,%esp
}
 804ac70:	83 c4 2c             	add    $0x2c,%esp
 804ac73:	5b                   	pop    %ebx
 804ac74:	5e                   	pop    %esi
 804ac75:	5f                   	pop    %edi
 804ac76:	5d                   	pop    %ebp
 804ac77:	c3                   	ret    
 804ac78:	66 90                	xchg   %ax,%ax
 804ac7a:	66 90                	xchg   %ax,%ax
 804ac7c:	66 90                	xchg   %ax,%ax
 804ac7e:	66 90                	xchg   %ax,%ax

0804ac80 <print_bin_instr>:
char asm_buf[128];

/* Used with exception handling. */
jmp_buf jbuf;

void print_bin_instr(swaddr_t eip, int len) {
 804ac80:	55                   	push   %ebp
 804ac81:	57                   	push   %edi
 804ac82:	56                   	push   %esi
 804ac83:	53                   	push   %ebx
 804ac84:	83 ec 10             	sub    $0x10,%esp
 804ac87:	8b 5c 24 24          	mov    0x24(%esp),%ebx
 804ac8b:	8b 6c 24 28          	mov    0x28(%esp),%ebp
	int i;
	int l = sprintf(asm_buf, "%8x:   ", eip);
 804ac8f:	53                   	push   %ebx
 804ac90:	68 a0 f1 05 08       	push   $0x805f1a0
 804ac95:	68 80 8a 0c 08       	push   $0x80c8a80
 804ac9a:	e8 f1 de ff ff       	call   8048b90 <sprintf@plt>
	for(i = 0; i < len; i ++) {
 804ac9f:	83 c4 10             	add    $0x10,%esp
 804aca2:	85 ed                	test   %ebp,%ebp
/* Used with exception handling. */
jmp_buf jbuf;

void print_bin_instr(swaddr_t eip, int len) {
	int i;
	int l = sprintf(asm_buf, "%8x:   ", eip);
 804aca4:	89 c6                	mov    %eax,%esi
	for(i = 0; i < len; i ++) {
 804aca6:	7e 34                	jle    804acdc <print_bin_instr+0x5c>
 804aca8:	8d 3c 2b             	lea    (%ebx,%ebp,1),%edi
 804acab:	90                   	nop
 804acac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 804acb0:	83 ec 08             	sub    $0x8,%esp
 804acb3:	6a 01                	push   $0x1
 804acb5:	53                   	push   %ebx
 804acb6:	83 c3 01             	add    $0x1,%ebx
 804acb9:	e8 92 02 00 00       	call   804af50 <swaddr_read>
		l += sprintf(asm_buf + l, "%02x ", instr_fetch(eip + i, 1));
 804acbe:	83 c4 0c             	add    $0xc,%esp
 804acc1:	50                   	push   %eax
 804acc2:	8d 86 80 8a 0c 08    	lea    0x80c8a80(%esi),%eax
 804acc8:	68 a8 f1 05 08       	push   $0x805f1a8
 804accd:	50                   	push   %eax
 804acce:	e8 bd de ff ff       	call   8048b90 <sprintf@plt>
jmp_buf jbuf;

void print_bin_instr(swaddr_t eip, int len) {
	int i;
	int l = sprintf(asm_buf, "%8x:   ", eip);
	for(i = 0; i < len; i ++) {
 804acd3:	83 c4 10             	add    $0x10,%esp
		l += sprintf(asm_buf + l, "%02x ", instr_fetch(eip + i, 1));
 804acd6:	01 c6                	add    %eax,%esi
jmp_buf jbuf;

void print_bin_instr(swaddr_t eip, int len) {
	int i;
	int l = sprintf(asm_buf, "%8x:   ", eip);
	for(i = 0; i < len; i ++) {
 804acd8:	39 fb                	cmp    %edi,%ebx
 804acda:	75 d4                	jne    804acb0 <print_bin_instr+0x30>
		l += sprintf(asm_buf + l, "%02x ", instr_fetch(eip + i, 1));
	}
	sprintf(asm_buf + l, "%*.s", 50 - (12 + 3 * len), "");
 804acdc:	8d 44 6d 00          	lea    0x0(%ebp,%ebp,2),%eax
 804ace0:	81 c6 80 8a 0c 08    	add    $0x80c8a80,%esi
 804ace6:	68 0c ec 05 08       	push   $0x805ec0c
 804aceb:	f7 d8                	neg    %eax
 804aced:	83 c0 26             	add    $0x26,%eax
 804acf0:	50                   	push   %eax
 804acf1:	68 ae f1 05 08       	push   $0x805f1ae
 804acf6:	56                   	push   %esi
 804acf7:	e8 94 de ff ff       	call   8048b90 <sprintf@plt>
}
 804acfc:	83 c4 1c             	add    $0x1c,%esp
 804acff:	5b                   	pop    %ebx
 804ad00:	5e                   	pop    %esi
 804ad01:	5f                   	pop    %edi
 804ad02:	5d                   	pop    %ebp
 804ad03:	c3                   	ret    
 804ad04:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804ad0a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804ad10 <do_int3>:

/* This function will be called when an `int3' instruction is being executed. */
void do_int3() {
 804ad10:	83 ec 14             	sub    $0x14,%esp
	printf("\nHit breakpoint at eip = 0x%08x\n", cpu.eip);
 804ad13:	ff 35 e0 af 0f 10    	pushl  0x100fafe0
 804ad19:	68 b4 f1 05 08       	push   $0x805f1b4
 804ad1e:	e8 2d dc ff ff       	call   8048950 <printf@plt>
	nemu_state = STOP;
 804ad23:	c7 05 80 82 07 08 00 	movl   $0x0,0x8078280
 804ad2a:	00 00 00 
}
 804ad2d:	83 c4 1c             	add    $0x1c,%esp
 804ad30:	c3                   	ret    
 804ad31:	eb 0d                	jmp    804ad40 <cpu_exec>
 804ad33:	90                   	nop
 804ad34:	90                   	nop
 804ad35:	90                   	nop
 804ad36:	90                   	nop
 804ad37:	90                   	nop
 804ad38:	90                   	nop
 804ad39:	90                   	nop
 804ad3a:	90                   	nop
 804ad3b:	90                   	nop
 804ad3c:	90                   	nop
 804ad3d:	90                   	nop
 804ad3e:	90                   	nop
 804ad3f:	90                   	nop

0804ad40 <cpu_exec>:

/* Simulate how the CPU works. */
void cpu_exec(volatile uint32_t n) {
 804ad40:	56                   	push   %esi
 804ad41:	53                   	push   %ebx
 804ad42:	83 ec 14             	sub    $0x14,%esp
	if(nemu_state == END) {
 804ad45:	83 3d 80 82 07 08 02 	cmpl   $0x2,0x8078280
 804ad4c:	0f 84 5e 01 00 00    	je     804aeb0 <cpu_exec+0x170>
		return;
	}
	nemu_state = RUNNING;

#ifdef DEBUG
	volatile uint32_t n_temp = n;
 804ad52:	8b 44 24 20          	mov    0x20(%esp),%eax
#endif

	setjmp(jbuf);
 804ad56:	83 ec 0c             	sub    $0xc,%esp
void cpu_exec(volatile uint32_t n) {
	if(nemu_state == END) {
		printf("Program execution has ended. To restart the program, exit NEMU and run again.\n");
		return;
	}
	nemu_state = RUNNING;
 804ad59:	c7 05 80 82 07 08 01 	movl   $0x1,0x8078280
 804ad60:	00 00 00 

#ifdef DEBUG
	volatile uint32_t n_temp = n;
 804ad63:	89 44 24 18          	mov    %eax,0x18(%esp)
#endif

	setjmp(jbuf);
 804ad67:	68 40 89 0c 08       	push   $0x80c8940
 804ad6c:	e8 ff db ff ff       	call   8048970 <_setjmp@plt>

	for(; n > 0; n --) {
 804ad71:	8b 44 24 30          	mov    0x30(%esp),%eax
 804ad75:	83 c4 10             	add    $0x10,%esp
 804ad78:	85 c0                	test   %eax,%eax
 804ad7a:	0f 84 15 01 00 00    	je     804ae95 <cpu_exec+0x155>
		}
#endif

		/* TODO: check watchpoints here. */
		bool flag = true;
		check_wp(&flag);
 804ad80:	8d 74 24 0b          	lea    0xb(%esp),%esi
 804ad84:	eb 2e                	jmp    804adb4 <cpu_exec+0x74>
 804ad86:	8d 76 00             	lea    0x0(%esi),%esi
 804ad89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		if(!flag) {
			nemu_state = STOP;
			printf("\nHit breakpoint at eip = 0x%08x\n", cpu.eip);
		}

		if(nemu_state != RUNNING) { return; }
 804ad90:	83 3d 80 82 07 08 01 	cmpl   $0x1,0x8078280
 804ad97:	0f 85 f2 00 00 00    	jne    804ae8f <cpu_exec+0x14f>
	volatile uint32_t n_temp = n;
#endif

	setjmp(jbuf);

	for(; n > 0; n --) {
 804ad9d:	8b 44 24 20          	mov    0x20(%esp),%eax
 804ada1:	83 e8 01             	sub    $0x1,%eax
 804ada4:	89 44 24 20          	mov    %eax,0x20(%esp)
 804ada8:	8b 44 24 20          	mov    0x20(%esp),%eax
 804adac:	85 c0                	test   %eax,%eax
 804adae:	0f 84 ec 00 00 00    	je     804aea0 <cpu_exec+0x160>
#ifdef DEBUG
		swaddr_t eip_temp = cpu.eip;
		if((n & 0xffff) == 0) {
 804adb4:	8b 54 24 20          	mov    0x20(%esp),%edx

	setjmp(jbuf);

	for(; n > 0; n --) {
#ifdef DEBUG
		swaddr_t eip_temp = cpu.eip;
 804adb8:	8b 1d e0 af 0f 10    	mov    0x100fafe0,%ebx
		if((n & 0xffff) == 0) {
 804adbe:	66 85 d2             	test   %dx,%dx
 804adc1:	89 d8                	mov    %ebx,%eax
 804adc3:	75 18                	jne    804addd <cpu_exec+0x9d>
			/* Output some dots while executing the program. */
			fputc('.', stderr);
 804adc5:	83 ec 08             	sub    $0x8,%esp
 804adc8:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804adce:	6a 2e                	push   $0x2e
 804add0:	e8 9b dd ff ff       	call   8048b70 <fputc@plt>
 804add5:	a1 e0 af 0f 10       	mov    0x100fafe0,%eax
 804adda:	83 c4 10             	add    $0x10,%esp
		}
#endif

		/* Execute one instruction, including instruction fetch,
		 * instruction decode, and the actual execution. */
		int instr_len = exec(cpu.eip);
 804addd:	83 ec 0c             	sub    $0xc,%esp
 804ade0:	50                   	push   %eax
 804ade1:	e8 6a 1d 00 00       	call   804cb50 <exec>
 804ade6:	5a                   	pop    %edx
 804ade7:	59                   	pop    %ecx

		cpu.eip += instr_len;

#ifdef DEBUG
		print_bin_instr(eip_temp, instr_len);
 804ade8:	50                   	push   %eax
 804ade9:	53                   	push   %ebx

		/* Execute one instruction, including instruction fetch,
		 * instruction decode, and the actual execution. */
		int instr_len = exec(cpu.eip);

		cpu.eip += instr_len;
 804adea:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0

#ifdef DEBUG
		print_bin_instr(eip_temp, instr_len);
 804adf0:	e8 8b fe ff ff       	call   804ac80 <print_bin_instr>
 804adf5:	5b                   	pop    %ebx
 804adf6:	58                   	pop    %eax
		strcat(asm_buf, assembly);
 804adf7:	68 00 8a 0c 08       	push   $0x80c8a00
 804adfc:	68 80 8a 0c 08       	push   $0x80c8a80
 804ae01:	e8 1a dc ff ff       	call   8048a20 <strcat@plt>
		Log_write("%s\n", asm_buf);
 804ae06:	83 c4 0c             	add    $0xc,%esp
 804ae09:	68 80 8a 0c 08       	push   $0x80c8a80
 804ae0e:	68 be ed 05 08       	push   $0x805edbe
 804ae13:	ff 35 28 5d 07 08    	pushl  0x8075d28
 804ae19:	e8 a2 dc ff ff       	call   8048ac0 <fprintf@plt>
 804ae1e:	58                   	pop    %eax
 804ae1f:	ff 35 28 5d 07 08    	pushl  0x8075d28
 804ae25:	e8 36 db ff ff       	call   8048960 <fflush@plt>
 804ae2a:	83 c4 10             	add    $0x10,%esp
		if(n_temp < MAX_INSTR_TO_PRINT) {
 804ae2d:	8b 44 24 0c          	mov    0xc(%esp),%eax
 804ae31:	83 f8 09             	cmp    $0x9,%eax
 804ae34:	77 10                	ja     804ae46 <cpu_exec+0x106>
			printf("%s\n", asm_buf);
 804ae36:	83 ec 0c             	sub    $0xc,%esp
 804ae39:	68 80 8a 0c 08       	push   $0x80c8a80
 804ae3e:	e8 1d dc ff ff       	call   8048a60 <puts@plt>
 804ae43:	83 c4 10             	add    $0x10,%esp
		}
#endif

		/* TODO: check watchpoints here. */
		bool flag = true;
 804ae46:	c6 44 24 0b 01       	movb   $0x1,0xb(%esp)
		check_wp(&flag);
 804ae4b:	83 ec 0c             	sub    $0xc,%esp
 804ae4e:	56                   	push   %esi
 804ae4f:	e8 cc f0 ff ff       	call   8049f20 <check_wp>
 804ae54:	83 c4 10             	add    $0x10,%esp
		if(!flag) {
 804ae57:	80 7c 24 0b 00       	cmpb   $0x0,0xb(%esp)
 804ae5c:	0f 85 2e ff ff ff    	jne    804ad90 <cpu_exec+0x50>
			nemu_state = STOP;
			printf("\nHit breakpoint at eip = 0x%08x\n", cpu.eip);
 804ae62:	83 ec 08             	sub    $0x8,%esp
 804ae65:	ff 35 e0 af 0f 10    	pushl  0x100fafe0

		/* TODO: check watchpoints here. */
		bool flag = true;
		check_wp(&flag);
		if(!flag) {
			nemu_state = STOP;
 804ae6b:	c7 05 80 82 07 08 00 	movl   $0x0,0x8078280
 804ae72:	00 00 00 
			printf("\nHit breakpoint at eip = 0x%08x\n", cpu.eip);
 804ae75:	68 b4 f1 05 08       	push   $0x805f1b4
 804ae7a:	e8 d1 da ff ff       	call   8048950 <printf@plt>
 804ae7f:	83 c4 10             	add    $0x10,%esp
		}

		if(nemu_state != RUNNING) { return; }
 804ae82:	83 3d 80 82 07 08 01 	cmpl   $0x1,0x8078280
 804ae89:	0f 84 0e ff ff ff    	je     804ad9d <cpu_exec+0x5d>
	}

	if(nemu_state == RUNNING) { 
		nemu_state = STOP; 
	}
}
 804ae8f:	83 c4 14             	add    $0x14,%esp
 804ae92:	5b                   	pop    %ebx
 804ae93:	5e                   	pop    %esi
 804ae94:	c3                   	ret    
		}

		if(nemu_state != RUNNING) { return; }
	}

	if(nemu_state == RUNNING) { 
 804ae95:	83 3d 80 82 07 08 01 	cmpl   $0x1,0x8078280
 804ae9c:	75 f1                	jne    804ae8f <cpu_exec+0x14f>
 804ae9e:	66 90                	xchg   %ax,%ax
		nemu_state = STOP; 
 804aea0:	c7 05 80 82 07 08 00 	movl   $0x0,0x8078280
 804aea7:	00 00 00 
	}
}
 804aeaa:	83 c4 14             	add    $0x14,%esp
 804aead:	5b                   	pop    %ebx
 804aeae:	5e                   	pop    %esi
 804aeaf:	c3                   	ret    
}

/* Simulate how the CPU works. */
void cpu_exec(volatile uint32_t n) {
	if(nemu_state == END) {
		printf("Program execution has ended. To restart the program, exit NEMU and run again.\n");
 804aeb0:	83 ec 0c             	sub    $0xc,%esp
 804aeb3:	68 d8 f1 05 08       	push   $0x805f1d8
 804aeb8:	e8 a3 db ff ff       	call   8048a60 <puts@plt>
 804aebd:	83 c4 10             	add    $0x10,%esp
	}

	if(nemu_state == RUNNING) { 
		nemu_state = STOP; 
	}
}
 804aec0:	83 c4 14             	add    $0x14,%esp
 804aec3:	5b                   	pop    %ebx
 804aec4:	5e                   	pop    %esi
 804aec5:	c3                   	ret    
 804aec6:	66 90                	xchg   %ax,%ax
 804aec8:	66 90                	xchg   %ax,%ax
 804aeca:	66 90                	xchg   %ax,%ax
 804aecc:	66 90                	xchg   %ax,%ax
 804aece:	66 90                	xchg   %ax,%ax

0804aed0 <hwaddr_read>:
uint32_t l1cache_read(hwaddr_t, size_t);
void l1cache_write(hwaddr_t, size_t, uint32_t);

/* Memory accessing interfaces */

uint32_t hwaddr_read(hwaddr_t addr, size_t len) {
 804aed0:	53                   	push   %ebx
 804aed1:	83 ec 10             	sub    $0x10,%esp
 804aed4:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
 804aed8:	53                   	push   %ebx
 804aed9:	ff 74 24 1c          	pushl  0x1c(%esp)
 804aedd:	e8 2e 07 00 00       	call   804b610 <l1cache_read>
 804aee2:	b9 04 00 00 00       	mov    $0x4,%ecx
 804aee7:	ba ff ff ff ff       	mov    $0xffffffff,%edx
	//return dram_read(addr, len) & (~0u >> ((4 - len) << 3));
}
 804aeec:	83 c4 18             	add    $0x18,%esp
void l1cache_write(hwaddr_t, size_t, uint32_t);

/* Memory accessing interfaces */

uint32_t hwaddr_read(hwaddr_t addr, size_t len) {
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
 804aeef:	29 d9                	sub    %ebx,%ecx
 804aef1:	c1 e1 03             	shl    $0x3,%ecx
 804aef4:	d3 ea                	shr    %cl,%edx
 804aef6:	21 d0                	and    %edx,%eax
	//return dram_read(addr, len) & (~0u >> ((4 - len) << 3));
}
 804aef8:	5b                   	pop    %ebx
 804aef9:	c3                   	ret    
 804aefa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804af00 <hwaddr_write>:

void hwaddr_write(hwaddr_t addr, size_t len, uint32_t data) {
	l1cache_write(addr, len, data);
 804af00:	e9 cb 08 00 00       	jmp    804b7d0 <l1cache_write>
 804af05:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804af09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804af10 <lnaddr_read>:
	//dram_write(addr, len, data);
}

uint32_t lnaddr_read(lnaddr_t addr, size_t len) {
 804af10:	53                   	push   %ebx
 804af11:	83 ec 10             	sub    $0x10,%esp
 804af14:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
void l1cache_write(hwaddr_t, size_t, uint32_t);

/* Memory accessing interfaces */

uint32_t hwaddr_read(hwaddr_t addr, size_t len) {
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
 804af18:	53                   	push   %ebx
 804af19:	ff 74 24 1c          	pushl  0x1c(%esp)
 804af1d:	e8 ee 06 00 00       	call   804b610 <l1cache_read>
 804af22:	b9 04 00 00 00       	mov    $0x4,%ecx
 804af27:	ba ff ff ff ff       	mov    $0xffffffff,%edx
	//dram_write(addr, len, data);
}

uint32_t lnaddr_read(lnaddr_t addr, size_t len) {
	return hwaddr_read(addr, len);
}
 804af2c:	83 c4 18             	add    $0x18,%esp
void l1cache_write(hwaddr_t, size_t, uint32_t);

/* Memory accessing interfaces */

uint32_t hwaddr_read(hwaddr_t addr, size_t len) {
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
 804af2f:	29 d9                	sub    %ebx,%ecx
 804af31:	c1 e1 03             	shl    $0x3,%ecx
 804af34:	d3 ea                	shr    %cl,%edx
 804af36:	21 d0                	and    %edx,%eax
	//dram_write(addr, len, data);
}

uint32_t lnaddr_read(lnaddr_t addr, size_t len) {
	return hwaddr_read(addr, len);
}
 804af38:	5b                   	pop    %ebx
 804af39:	c3                   	ret    
 804af3a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804af40 <lnaddr_write>:
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
	//return dram_read(addr, len) & (~0u >> ((4 - len) << 3));
}

void hwaddr_write(hwaddr_t addr, size_t len, uint32_t data) {
	l1cache_write(addr, len, data);
 804af40:	e9 8b 08 00 00       	jmp    804b7d0 <l1cache_write>
 804af45:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804af49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804af50 <swaddr_read>:

void lnaddr_write(lnaddr_t addr, size_t len, uint32_t data) {
	hwaddr_write(addr, len, data);
}

uint32_t swaddr_read(swaddr_t addr, size_t len) {
 804af50:	53                   	push   %ebx
 804af51:	83 ec 08             	sub    $0x8,%esp
 804af54:	8b 5c 24 14          	mov    0x14(%esp),%ebx
#ifdef DEBUG
	assert(len == 1 || len == 2 || len == 4);
 804af58:	8d 43 ff             	lea    -0x1(%ebx),%eax
 804af5b:	83 f8 01             	cmp    $0x1,%eax
 804af5e:	76 05                	jbe    804af65 <swaddr_read+0x15>
 804af60:	83 fb 04             	cmp    $0x4,%ebx
 804af63:	75 25                	jne    804af8a <swaddr_read+0x3a>
void l1cache_write(hwaddr_t, size_t, uint32_t);

/* Memory accessing interfaces */

uint32_t hwaddr_read(hwaddr_t addr, size_t len) {
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
 804af65:	83 ec 08             	sub    $0x8,%esp
 804af68:	53                   	push   %ebx
 804af69:	ff 74 24 1c          	pushl  0x1c(%esp)
 804af6d:	e8 9e 06 00 00       	call   804b610 <l1cache_read>
 804af72:	b9 04 00 00 00       	mov    $0x4,%ecx
 804af77:	ba ff ff ff ff       	mov    $0xffffffff,%edx
uint32_t swaddr_read(swaddr_t addr, size_t len) {
#ifdef DEBUG
	assert(len == 1 || len == 2 || len == 4);
#endif
	return lnaddr_read(addr, len);
}
 804af7c:	83 c4 18             	add    $0x18,%esp
void l1cache_write(hwaddr_t, size_t, uint32_t);

/* Memory accessing interfaces */

uint32_t hwaddr_read(hwaddr_t addr, size_t len) {
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
 804af7f:	29 d9                	sub    %ebx,%ecx
 804af81:	c1 e1 03             	shl    $0x3,%ecx
 804af84:	d3 ea                	shr    %cl,%edx
 804af86:	21 d0                	and    %edx,%eax
uint32_t swaddr_read(swaddr_t addr, size_t len) {
#ifdef DEBUG
	assert(len == 1 || len == 2 || len == 4);
#endif
	return lnaddr_read(addr, len);
}
 804af88:	5b                   	pop    %ebx
 804af89:	c3                   	ret    
	hwaddr_write(addr, len, data);
}

uint32_t swaddr_read(swaddr_t addr, size_t len) {
#ifdef DEBUG
	assert(len == 1 || len == 2 || len == 4);
 804af8a:	68 6e f2 05 08       	push   $0x805f26e
 804af8f:	6a 1e                	push   $0x1e
 804af91:	68 26 f2 05 08       	push   $0x805f226
 804af96:	68 40 f2 05 08       	push   $0x805f240
 804af9b:	e8 10 dc ff ff       	call   8048bb0 <__assert_fail@plt>

0804afa0 <swaddr_write>:
#endif
	return lnaddr_read(addr, len);
}

void swaddr_write(swaddr_t addr, size_t len, uint32_t data) {
 804afa0:	53                   	push   %ebx
 804afa1:	83 ec 08             	sub    $0x8,%esp
 804afa4:	8b 44 24 14          	mov    0x14(%esp),%eax
 804afa8:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 804afac:	8b 5c 24 18          	mov    0x18(%esp),%ebx
#ifdef DEBUG
	assert(len == 1 || len == 2 || len == 4);
 804afb0:	8d 50 ff             	lea    -0x1(%eax),%edx
 804afb3:	83 fa 01             	cmp    $0x1,%edx
 804afb6:	76 05                	jbe    804afbd <swaddr_write+0x1d>
 804afb8:	83 f8 04             	cmp    $0x4,%eax
 804afbb:	75 15                	jne    804afd2 <swaddr_write+0x32>
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
	//return dram_read(addr, len) & (~0u >> ((4 - len) << 3));
}

void hwaddr_write(hwaddr_t addr, size_t len, uint32_t data) {
	l1cache_write(addr, len, data);
 804afbd:	89 5c 24 18          	mov    %ebx,0x18(%esp)
 804afc1:	89 44 24 14          	mov    %eax,0x14(%esp)
 804afc5:	89 4c 24 10          	mov    %ecx,0x10(%esp)
void swaddr_write(swaddr_t addr, size_t len, uint32_t data) {
#ifdef DEBUG
	assert(len == 1 || len == 2 || len == 4);
#endif
	lnaddr_write(addr, len, data);
}
 804afc9:	83 c4 08             	add    $0x8,%esp
 804afcc:	5b                   	pop    %ebx
	return l1cache_read(addr, len) & (~0u >> ((4 - len) << 3));
	//return dram_read(addr, len) & (~0u >> ((4 - len) << 3));
}

void hwaddr_write(hwaddr_t addr, size_t len, uint32_t data) {
	l1cache_write(addr, len, data);
 804afcd:	e9 fe 07 00 00       	jmp    804b7d0 <l1cache_write>
	return lnaddr_read(addr, len);
}

void swaddr_write(swaddr_t addr, size_t len, uint32_t data) {
#ifdef DEBUG
	assert(len == 1 || len == 2 || len == 4);
 804afd2:	68 61 f2 05 08       	push   $0x805f261
 804afd7:	6a 25                	push   $0x25
 804afd9:	68 26 f2 05 08       	push   $0x805f226
 804afde:	68 40 f2 05 08       	push   $0x805f240
 804afe3:	e8 c8 db ff ff       	call   8048bb0 <__assert_fail@plt>
 804afe8:	66 90                	xchg   %ax,%ax
 804afea:	66 90                	xchg   %ax,%ax
 804afec:	66 90                	xchg   %ax,%ax
 804afee:	66 90                	xchg   %ax,%ax

0804aff0 <ddr3_write>:

	/* burst read */
	memcpy(data, rowbufs[rank][bank].buf + col, BURST_LEN);
}

static void ddr3_write(hwaddr_t addr, void *data, uint8_t *mask) {
 804aff0:	55                   	push   %ebp
 804aff1:	57                   	push   %edi
 804aff2:	56                   	push   %esi
 804aff3:	53                   	push   %ebx
 804aff4:	83 ec 1c             	sub    $0x1c,%esp
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);
 804aff7:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
 804affc:	0f 87 3e 01 00 00    	ja     804b140 <ddr3_write+0x150>

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
 804b002:	83 e0 f8             	and    $0xfffffff8,%eax
 804b005:	89 cb                	mov    %ecx,%ebx
	uint32_t rank = temp.rank;
 804b007:	89 c1                	mov    %eax,%ecx
	uint32_t bank = temp.bank;
 804b009:	89 c5                	mov    %eax,%ebp
static void ddr3_write(hwaddr_t addr, void *data, uint8_t *mask) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
 804b00b:	c1 e9 17             	shr    $0x17,%ecx
	uint32_t bank = temp.bank;
 804b00e:	c1 ed 14             	shr    $0x14,%ebp
static void ddr3_write(hwaddr_t addr, void *data, uint8_t *mask) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
 804b011:	83 e1 0f             	and    $0xf,%ecx
	uint32_t bank = temp.bank;
 804b014:	83 e5 07             	and    $0x7,%ebp
static void ddr3_write(hwaddr_t addr, void *data, uint8_t *mask) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
 804b017:	89 cf                	mov    %ecx,%edi
 804b019:	89 4c 24 08          	mov    %ecx,0x8(%esp)
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
 804b01d:	89 c1                	mov    %eax,%ecx
	uint32_t col = temp.col;
 804b01f:	25 f8 03 00 00       	and    $0x3f8,%eax

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
 804b024:	c1 e9 0a             	shr    $0xa,%ecx
	uint32_t col = temp.col;
 804b027:	89 44 24 0c          	mov    %eax,0xc(%esp)

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
 804b02b:	89 e8                	mov    %ebp,%eax

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
 804b02d:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
	uint32_t col = temp.col;

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
 804b033:	c1 e0 0a             	shl    $0xa,%eax

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
 804b036:	89 4c 24 04          	mov    %ecx,0x4(%esp)
	uint32_t col = temp.col;

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
 804b03a:	8d 0c e8             	lea    (%eax,%ebp,8),%ecx
 804b03d:	69 c7 40 20 00 00    	imul   $0x2040,%edi,%eax
 804b043:	8d 84 01 00 8b 0c 10 	lea    0x100c8b00(%ecx,%eax,1),%eax
 804b04a:	80 b8 04 04 00 00 00 	cmpb   $0x0,0x404(%eax)
 804b051:	74 0c                	je     804b05f <ddr3_write+0x6f>
 804b053:	8b 7c 24 04          	mov    0x4(%esp),%edi
 804b057:	39 b8 00 04 00 00    	cmp    %edi,0x400(%eax)
 804b05d:	74 47                	je     804b0a6 <ddr3_write+0xb6>
		/* read a row into row buffer */
		memcpy(rowbufs[rank][bank].buf, dram[rank][bank][row], NR_COL);
 804b05f:	8b 7c 24 08          	mov    0x8(%esp),%edi
 804b063:	89 e8                	mov    %ebp,%eax
 804b065:	c1 e0 0a             	shl    $0xa,%eax
 804b068:	8d 0c e8             	lea    (%eax,%ebp,8),%ecx
 804b06b:	8d 74 fd 00          	lea    0x0(%ebp,%edi,8),%esi
 804b06f:	69 c7 40 20 00 00    	imul   $0x2040,%edi,%eax
 804b075:	c1 e6 0a             	shl    $0xa,%esi
 804b078:	03 74 24 04          	add    0x4(%esp),%esi
 804b07c:	8d 84 01 00 8b 0c 10 	lea    0x100c8b00(%ecx,%eax,1),%eax
 804b083:	b9 00 01 00 00       	mov    $0x100,%ecx
 804b088:	c1 e6 0a             	shl    $0xa,%esi
 804b08b:	89 c7                	mov    %eax,%edi
		rowbufs[rank][bank].row_idx = row;
		rowbufs[rank][bank].valid = true;
 804b08d:	c6 80 04 04 00 00 01 	movb   $0x1,0x404(%eax)
	uint32_t row = temp.row;
	uint32_t col = temp.col;

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
		/* read a row into row buffer */
		memcpy(rowbufs[rank][bank].buf, dram[rank][bank][row], NR_COL);
 804b094:	81 c6 00 8b 0c 08    	add    $0x80c8b00,%esi
 804b09a:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		rowbufs[rank][bank].row_idx = row;
 804b09c:	8b 7c 24 04          	mov    0x4(%esp),%edi
 804b0a0:	89 b8 00 04 00 00    	mov    %edi,0x400(%eax)
		rowbufs[rank][bank].valid = true;
	}

	/* burst write */
	memcpy_with_mask(rowbufs[rank][bank].buf + col, data, BURST_LEN, mask);
 804b0a6:	89 e8                	mov    %ebp,%eax
 804b0a8:	31 f6                	xor    %esi,%esi
 804b0aa:	c1 e0 0a             	shl    $0xa,%eax
 804b0ad:	8d 0c e8             	lea    (%eax,%ebp,8),%ecx
 804b0b0:	69 44 24 08 40 20 00 	imul   $0x2040,0x8(%esp),%eax
 804b0b7:	00 
 804b0b8:	8d 84 01 00 8b 0c 10 	lea    0x100c8b00(%ecx,%eax,1),%eax
 804b0bf:	03 44 24 0c          	add    0xc(%esp),%eax
 804b0c3:	90                   	nop
 804b0c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#include "common.h"

inline static void memcpy_with_mask(void *dest, const void *src, size_t len, uint8_t *mask) {
	int i;
	for(i = 0; i < len; i ++) {
		if(mask[i]) {
 804b0c8:	80 3c 33 00          	cmpb   $0x0,(%ebx,%esi,1)
 804b0cc:	74 07                	je     804b0d5 <ddr3_write+0xe5>
			((uint8_t *)dest)[i] = ((uint8_t *)src)[i];
 804b0ce:	0f b6 0c 32          	movzbl (%edx,%esi,1),%ecx
 804b0d2:	88 0c 30             	mov    %cl,(%eax,%esi,1)

#include "common.h"

inline static void memcpy_with_mask(void *dest, const void *src, size_t len, uint8_t *mask) {
	int i;
	for(i = 0; i < len; i ++) {
 804b0d5:	83 c6 01             	add    $0x1,%esi
 804b0d8:	83 fe 08             	cmp    $0x8,%esi
 804b0db:	75 eb                	jne    804b0c8 <ddr3_write+0xd8>

	/* write back to dram */
	memcpy(dram[rank][bank][row], rowbufs[rank][bank].buf, NR_COL);
 804b0dd:	8b 7c 24 08          	mov    0x8(%esp),%edi
 804b0e1:	89 ea                	mov    %ebp,%edx
 804b0e3:	c1 e2 0a             	shl    $0xa,%edx
 804b0e6:	8d 1c ea             	lea    (%edx,%ebp,8),%ebx
 804b0e9:	8d 44 fd 00          	lea    0x0(%ebp,%edi,8),%eax
 804b0ed:	69 d7 40 20 00 00    	imul   $0x2040,%edi,%edx
 804b0f3:	c1 e0 0a             	shl    $0xa,%eax
 804b0f6:	03 44 24 04          	add    0x4(%esp),%eax
 804b0fa:	01 da                	add    %ebx,%edx
 804b0fc:	8d b2 00 8b 0c 10    	lea    0x100c8b00(%edx),%esi
 804b102:	8b 92 00 8b 0c 10    	mov    0x100c8b00(%edx),%edx
 804b108:	c1 e0 0a             	shl    $0xa,%eax
 804b10b:	8d 88 00 8b 0c 08    	lea    0x80c8b00(%eax),%ecx
 804b111:	89 90 00 8b 0c 08    	mov    %edx,0x80c8b00(%eax)
 804b117:	8b 86 fc 03 00 00    	mov    0x3fc(%esi),%eax
 804b11d:	8d 79 04             	lea    0x4(%ecx),%edi
 804b120:	83 e7 fc             	and    $0xfffffffc,%edi
 804b123:	89 81 fc 03 00 00    	mov    %eax,0x3fc(%ecx)
 804b129:	29 f9                	sub    %edi,%ecx
 804b12b:	29 ce                	sub    %ecx,%esi
 804b12d:	81 c1 00 04 00 00    	add    $0x400,%ecx
 804b133:	c1 e9 02             	shr    $0x2,%ecx
 804b136:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
}
 804b138:	83 c4 1c             	add    $0x1c,%esp
 804b13b:	5b                   	pop    %ebx
 804b13c:	5e                   	pop    %esi
 804b13d:	5f                   	pop    %edi
 804b13e:	5d                   	pop    %ebp
 804b13f:	c3                   	ret    
	/* burst read */
	memcpy(data, rowbufs[rank][bank].buf + col, BURST_LEN);
}

static void ddr3_write(hwaddr_t addr, void *data, uint8_t *mask) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);
 804b140:	83 ec 0c             	sub    $0xc,%esp
 804b143:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804b149:	89 c3                	mov    %eax,%ebx
 804b14b:	e8 10 d8 ff ff       	call   8048960 <fflush@plt>
 804b150:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804b156:	6a 07                	push   $0x7
 804b158:	6a 01                	push   $0x1
 804b15a:	68 92 e8 05 08       	push   $0x805e892
 804b15f:	e8 ac d8 ff ff       	call   8048a10 <fwrite@plt>
 804b164:	83 c4 1c             	add    $0x1c,%esp
 804b167:	53                   	push   %ebx
 804b168:	68 94 f2 05 08       	push   $0x805f294
 804b16d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804b173:	e8 48 d9 ff ff       	call   8048ac0 <fprintf@plt>
 804b178:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804b17e:	6a 05                	push   $0x5
 804b180:	6a 01                	push   $0x1
 804b182:	68 42 f3 05 08       	push   $0x805f342
 804b187:	e8 84 d8 ff ff       	call   8048a10 <fwrite@plt>
 804b18c:	83 c4 20             	add    $0x20,%esp
 804b18f:	68 fd f2 05 08       	push   $0x805f2fd
 804b194:	6a 4c                	push   $0x4c
 804b196:	68 7a f2 05 08       	push   $0x805f27a
 804b19b:	68 cc f2 05 08       	push   $0x805f2cc
 804b1a0:	e8 0b da ff ff       	call   8048bb0 <__assert_fail@plt>
 804b1a5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804b1a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804b1b0 <ddr3_read>:
			rowbufs[i][j].valid = false;
		}
	}
}

static void ddr3_read(hwaddr_t addr, void *data) {
 804b1b0:	55                   	push   %ebp
 804b1b1:	57                   	push   %edi
 804b1b2:	56                   	push   %esi
 804b1b3:	53                   	push   %ebx
 804b1b4:	83 ec 1c             	sub    $0x1c,%esp
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);
 804b1b7:	3d ff ff ff 07       	cmp    $0x7ffffff,%eax
 804b1bc:	0f 87 ce 00 00 00    	ja     804b290 <ddr3_read+0xe0>

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
 804b1c2:	83 e0 f8             	and    $0xfffffff8,%eax
 804b1c5:	89 d5                	mov    %edx,%ebp
	uint32_t rank = temp.rank;
	uint32_t bank = temp.bank;
 804b1c7:	89 c2                	mov    %eax,%edx
static void ddr3_read(hwaddr_t addr, void *data) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
 804b1c9:	89 c3                	mov    %eax,%ebx
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
 804b1cb:	89 c1                	mov    %eax,%ecx
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
	uint32_t bank = temp.bank;
 804b1cd:	c1 ea 14             	shr    $0x14,%edx
	uint32_t row = temp.row;
	uint32_t col = temp.col;
 804b1d0:	25 f8 03 00 00       	and    $0x3f8,%eax
static void ddr3_read(hwaddr_t addr, void *data) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
 804b1d5:	c1 eb 17             	shr    $0x17,%ebx
	uint32_t bank = temp.bank;
 804b1d8:	83 e2 07             	and    $0x7,%edx
	uint32_t row = temp.row;
 804b1db:	c1 e9 0a             	shr    $0xa,%ecx
	uint32_t col = temp.col;
 804b1de:	89 44 24 0c          	mov    %eax,0xc(%esp)

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
 804b1e2:	89 d0                	mov    %edx,%eax

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
 804b1e4:	81 e1 ff 03 00 00    	and    $0x3ff,%ecx
static void ddr3_read(hwaddr_t addr, void *data) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
 804b1ea:	83 e3 0f             	and    $0xf,%ebx
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
	uint32_t col = temp.col;

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
 804b1ed:	c1 e0 0a             	shl    $0xa,%eax

	dram_addr temp;
	temp.addr = addr & ~BURST_MASK;
	uint32_t rank = temp.rank;
	uint32_t bank = temp.bank;
	uint32_t row = temp.row;
 804b1f0:	89 4c 24 08          	mov    %ecx,0x8(%esp)
	uint32_t col = temp.col;

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
 804b1f4:	8d 0c d0             	lea    (%eax,%edx,8),%ecx
 804b1f7:	69 c3 40 20 00 00    	imul   $0x2040,%ebx,%eax
 804b1fd:	8d 84 01 00 8b 0c 10 	lea    0x100c8b00(%ecx,%eax,1),%eax
 804b204:	80 b8 04 04 00 00 00 	cmpb   $0x0,0x404(%eax)
 804b20b:	74 0c                	je     804b219 <ddr3_read+0x69>
 804b20d:	8b 7c 24 08          	mov    0x8(%esp),%edi
 804b211:	39 b8 00 04 00 00    	cmp    %edi,0x400(%eax)
 804b217:	74 42                	je     804b25b <ddr3_read+0xab>
		/* read a row into row buffer */
		memcpy(rowbufs[rank][bank].buf, dram[rank][bank][row], NR_COL);
 804b219:	89 d0                	mov    %edx,%eax
 804b21b:	8d 34 da             	lea    (%edx,%ebx,8),%esi
 804b21e:	c1 e0 0a             	shl    $0xa,%eax
 804b221:	8d 0c d0             	lea    (%eax,%edx,8),%ecx
 804b224:	c1 e6 0a             	shl    $0xa,%esi
 804b227:	03 74 24 08          	add    0x8(%esp),%esi
 804b22b:	69 c3 40 20 00 00    	imul   $0x2040,%ebx,%eax
 804b231:	8d 84 01 00 8b 0c 10 	lea    0x100c8b00(%ecx,%eax,1),%eax
 804b238:	c1 e6 0a             	shl    $0xa,%esi
 804b23b:	b9 00 01 00 00       	mov    $0x100,%ecx
 804b240:	81 c6 00 8b 0c 08    	add    $0x80c8b00,%esi
 804b246:	89 c7                	mov    %eax,%edi
		rowbufs[rank][bank].row_idx = row;
		rowbufs[rank][bank].valid = true;
 804b248:	c6 80 04 04 00 00 01 	movb   $0x1,0x404(%eax)
	uint32_t row = temp.row;
	uint32_t col = temp.col;

	if(!(rowbufs[rank][bank].valid && rowbufs[rank][bank].row_idx == row) ) {
		/* read a row into row buffer */
		memcpy(rowbufs[rank][bank].buf, dram[rank][bank][row], NR_COL);
 804b24f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
		rowbufs[rank][bank].row_idx = row;
 804b251:	8b 7c 24 08          	mov    0x8(%esp),%edi
 804b255:	89 b8 00 04 00 00    	mov    %edi,0x400(%eax)
		rowbufs[rank][bank].valid = true;
	}

	/* burst read */
	memcpy(data, rowbufs[rank][bank].buf + col, BURST_LEN);
 804b25b:	89 d0                	mov    %edx,%eax
 804b25d:	c1 e0 0a             	shl    $0xa,%eax
 804b260:	8d 04 d0             	lea    (%eax,%edx,8),%eax
 804b263:	69 db 40 20 00 00    	imul   $0x2040,%ebx,%ebx
 804b269:	8d 84 18 00 8b 0c 10 	lea    0x100c8b00(%eax,%ebx,1),%eax
 804b270:	03 44 24 0c          	add    0xc(%esp),%eax
 804b274:	8b 10                	mov    (%eax),%edx
 804b276:	89 55 00             	mov    %edx,0x0(%ebp)
 804b279:	8b 40 04             	mov    0x4(%eax),%eax
 804b27c:	89 45 04             	mov    %eax,0x4(%ebp)
}
 804b27f:	83 c4 1c             	add    $0x1c,%esp
 804b282:	5b                   	pop    %ebx
 804b283:	5e                   	pop    %esi
 804b284:	5f                   	pop    %edi
 804b285:	5d                   	pop    %ebp
 804b286:	c3                   	ret    
 804b287:	89 f6                	mov    %esi,%esi
 804b289:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		}
	}
}

static void ddr3_read(hwaddr_t addr, void *data) {
	Assert(addr < HW_MEM_SIZE, "physical address %x is outside of the physical memory!", addr);
 804b290:	83 ec 0c             	sub    $0xc,%esp
 804b293:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804b299:	89 c3                	mov    %eax,%ebx
 804b29b:	e8 c0 d6 ff ff       	call   8048960 <fflush@plt>
 804b2a0:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804b2a6:	6a 07                	push   $0x7
 804b2a8:	6a 01                	push   $0x1
 804b2aa:	68 92 e8 05 08       	push   $0x805e892
 804b2af:	e8 5c d7 ff ff       	call   8048a10 <fwrite@plt>
 804b2b4:	83 c4 1c             	add    $0x1c,%esp
 804b2b7:	53                   	push   %ebx
 804b2b8:	68 94 f2 05 08       	push   $0x805f294
 804b2bd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804b2c3:	e8 f8 d7 ff ff       	call   8048ac0 <fprintf@plt>
 804b2c8:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804b2ce:	6a 05                	push   $0x5
 804b2d0:	6a 01                	push   $0x1
 804b2d2:	68 42 f3 05 08       	push   $0x805f342
 804b2d7:	e8 34 d7 ff ff       	call   8048a10 <fwrite@plt>
 804b2dc:	83 c4 20             	add    $0x20,%esp
 804b2df:	68 08 f3 05 08       	push   $0x805f308
 804b2e4:	6a 37                	push   $0x37
 804b2e6:	68 7a f2 05 08       	push   $0x805f27a
 804b2eb:	68 cc f2 05 08       	push   $0x805f2cc
 804b2f0:	e8 bb d8 ff ff       	call   8048bb0 <__assert_fail@plt>
 804b2f5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804b2f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804b300 <init_ddr3>:
	bool valid;
} RB;

RB rowbufs[NR_RANK][NR_BANK];

void init_ddr3() {
 804b300:	31 d2                	xor    %edx,%edx
 804b302:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804b308:	31 c0                	xor    %eax,%eax
 804b30a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	int i, j;
	for(i = 0; i < NR_RANK; i ++) {
		for(j = 0; j < NR_BANK; j ++) {
			rowbufs[i][j].valid = false;
 804b310:	c6 84 02 04 8f 0c 10 	movb   $0x0,0x100c8f04(%edx,%eax,1)
 804b317:	00 
 804b318:	05 08 04 00 00       	add    $0x408,%eax
RB rowbufs[NR_RANK][NR_BANK];

void init_ddr3() {
	int i, j;
	for(i = 0; i < NR_RANK; i ++) {
		for(j = 0; j < NR_BANK; j ++) {
 804b31d:	3d 40 20 00 00       	cmp    $0x2040,%eax
 804b322:	75 ec                	jne    804b310 <init_ddr3+0x10>
 804b324:	81 c2 40 20 00 00    	add    $0x2040,%edx

RB rowbufs[NR_RANK][NR_BANK];

void init_ddr3() {
	int i, j;
	for(i = 0; i < NR_RANK; i ++) {
 804b32a:	81 fa 00 04 02 00    	cmp    $0x20400,%edx
 804b330:	75 d6                	jne    804b308 <init_ddr3+0x8>
 804b332:	f3 c3                	repz ret 
 804b334:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804b33a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804b340 <dram_read>:

	/* write back to dram */
	memcpy(dram[rank][bank][row], rowbufs[rank][bank].buf, NR_COL);
}

uint32_t dram_read(hwaddr_t addr, size_t len) {
 804b340:	56                   	push   %esi
 804b341:	53                   	push   %ebx
 804b342:	83 ec 14             	sub    $0x14,%esp
 804b345:	8b 5c 24 20          	mov    0x20(%esp),%ebx
	uint32_t offset = addr & BURST_MASK;
	uint8_t temp[2 * BURST_LEN];
	
	ddr3_read(addr, temp);
 804b349:	89 e2                	mov    %esp,%edx
 804b34b:	89 d8                	mov    %ebx,%eax
	/* write back to dram */
	memcpy(dram[rank][bank][row], rowbufs[rank][bank].buf, NR_COL);
}

uint32_t dram_read(hwaddr_t addr, size_t len) {
	uint32_t offset = addr & BURST_MASK;
 804b34d:	89 de                	mov    %ebx,%esi
	uint8_t temp[2 * BURST_LEN];
	
	ddr3_read(addr, temp);
 804b34f:	e8 5c fe ff ff       	call   804b1b0 <ddr3_read>

	if(offset + len > BURST_LEN) {
 804b354:	8b 44 24 24          	mov    0x24(%esp),%eax
	/* write back to dram */
	memcpy(dram[rank][bank][row], rowbufs[rank][bank].buf, NR_COL);
}

uint32_t dram_read(hwaddr_t addr, size_t len) {
	uint32_t offset = addr & BURST_MASK;
 804b358:	83 e6 07             	and    $0x7,%esi
	uint8_t temp[2 * BURST_LEN];
	
	ddr3_read(addr, temp);

	if(offset + len > BURST_LEN) {
 804b35b:	01 f0                	add    %esi,%eax
 804b35d:	83 f8 08             	cmp    $0x8,%eax
 804b360:	76 0c                	jbe    804b36e <dram_read+0x2e>
		/* data cross the burst boundary */
		ddr3_read(addr + BURST_LEN, temp + BURST_LEN);
 804b362:	8d 43 08             	lea    0x8(%ebx),%eax
 804b365:	8d 54 24 08          	lea    0x8(%esp),%edx
 804b369:	e8 42 fe ff ff       	call   804b1b0 <ddr3_read>
	}

	return unalign_rw(temp + offset, 4);
 804b36e:	8b 04 34             	mov    (%esp,%esi,1),%eax
}
 804b371:	83 c4 14             	add    $0x14,%esp
 804b374:	5b                   	pop    %ebx
 804b375:	5e                   	pop    %esi
 804b376:	c3                   	ret    
 804b377:	89 f6                	mov    %esi,%esi
 804b379:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804b380 <dram_write>:

void dram_write(hwaddr_t addr, size_t len, uint32_t data) {
 804b380:	57                   	push   %edi
 804b381:	56                   	push   %esi
 804b382:	53                   	push   %ebx
 804b383:	83 ec 20             	sub    $0x20,%esp
 804b386:	8b 74 24 30          	mov    0x30(%esp),%esi
	uint32_t offset = addr & BURST_MASK;
	uint8_t temp[2 * BURST_LEN];
	uint8_t mask[2 * BURST_LEN];
	memset(mask, 0, 2 * BURST_LEN);

	*(uint32_t *)(temp + offset) = data;
 804b38a:	8b 44 24 38          	mov    0x38(%esp),%eax
	memset(mask + offset, 1, len);
 804b38e:	83 ec 04             	sub    $0x4,%esp
	}

	return unalign_rw(temp + offset, 4);
}

void dram_write(hwaddr_t addr, size_t len, uint32_t data) {
 804b391:	8b 5c 24 38          	mov    0x38(%esp),%ebx
	uint32_t offset = addr & BURST_MASK;
	uint8_t temp[2 * BURST_LEN];
	uint8_t mask[2 * BURST_LEN];
	memset(mask, 0, 2 * BURST_LEN);
 804b395:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 804b39c:	00 
 804b39d:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
 804b3a4:	00 
 804b3a5:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 804b3ac:	00 

	return unalign_rw(temp + offset, 4);
}

void dram_write(hwaddr_t addr, size_t len, uint32_t data) {
	uint32_t offset = addr & BURST_MASK;
 804b3ad:	89 f7                	mov    %esi,%edi
	uint8_t temp[2 * BURST_LEN];
	uint8_t mask[2 * BURST_LEN];
	memset(mask, 0, 2 * BURST_LEN);
 804b3af:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
 804b3b6:	00 

	return unalign_rw(temp + offset, 4);
}

void dram_write(hwaddr_t addr, size_t len, uint32_t data) {
	uint32_t offset = addr & BURST_MASK;
 804b3b7:	83 e7 07             	and    $0x7,%edi
	uint8_t temp[2 * BURST_LEN];
	uint8_t mask[2 * BURST_LEN];
	memset(mask, 0, 2 * BURST_LEN);

	*(uint32_t *)(temp + offset) = data;
 804b3ba:	89 44 3c 04          	mov    %eax,0x4(%esp,%edi,1)
	memset(mask + offset, 1, len);
 804b3be:	53                   	push   %ebx

	ddr3_write(addr, temp, mask);

	if(offset + len > BURST_LEN) {
 804b3bf:	01 fb                	add    %edi,%ebx
	uint8_t temp[2 * BURST_LEN];
	uint8_t mask[2 * BURST_LEN];
	memset(mask, 0, 2 * BURST_LEN);

	*(uint32_t *)(temp + offset) = data;
	memset(mask + offset, 1, len);
 804b3c1:	6a 01                	push   $0x1
 804b3c3:	8d 44 24 1c          	lea    0x1c(%esp),%eax
 804b3c7:	01 f8                	add    %edi,%eax
 804b3c9:	50                   	push   %eax
 804b3ca:	e8 21 d7 ff ff       	call   8048af0 <memset@plt>

	ddr3_write(addr, temp, mask);
 804b3cf:	8d 4c 24 20          	lea    0x20(%esp),%ecx
 804b3d3:	8d 54 24 10          	lea    0x10(%esp),%edx
 804b3d7:	89 f0                	mov    %esi,%eax
 804b3d9:	e8 12 fc ff ff       	call   804aff0 <ddr3_write>

	if(offset + len > BURST_LEN) {
 804b3de:	83 c4 10             	add    $0x10,%esp
 804b3e1:	83 fb 08             	cmp    $0x8,%ebx
 804b3e4:	76 10                	jbe    804b3f6 <dram_write+0x76>
		/* data cross the burst boundary */
		ddr3_write(addr + BURST_LEN, temp + BURST_LEN, mask + BURST_LEN);
 804b3e6:	8d 46 08             	lea    0x8(%esi),%eax
 804b3e9:	8d 4c 24 18          	lea    0x18(%esp),%ecx
 804b3ed:	8d 54 24 08          	lea    0x8(%esp),%edx
 804b3f1:	e8 fa fb ff ff       	call   804aff0 <ddr3_write>
	}
}
 804b3f6:	83 c4 20             	add    $0x20,%esp
 804b3f9:	5b                   	pop    %ebx
 804b3fa:	5e                   	pop    %esi
 804b3fb:	5f                   	pop    %edi
 804b3fc:	c3                   	ret    
 804b3fd:	66 90                	xchg   %ax,%ax
 804b3ff:	90                   	nop

0804b400 <init_l1cache>:
l1CB l1cache[CACHE_SET_SIZE][CACHE_WAY_SIZE];

uint32_t dram_read(hwaddr_t addr, size_t len);
void dram_write(hwaddr_t addr, size_t len, uint32_t data);

void init_l1cache() {
 804b400:	31 d2                	xor    %edx,%edx
 804b402:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804b408:	31 c0                	xor    %eax,%eax
 804b40a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	int i, j;
	for(i = 0; i < CACHE_SET_SIZE; i ++) {
		for(j = 0; j < CACHE_WAY_SIZE; j ++) {
			l1cache[i][j].valid = false;
 804b410:	c6 84 02 44 8f 0e 10 	movb   $0x0,0x100e8f44(%edx,%eax,1)
 804b417:	00 
 804b418:	83 c0 48             	add    $0x48,%eax
void dram_write(hwaddr_t addr, size_t len, uint32_t data);

void init_l1cache() {
	int i, j;
	for(i = 0; i < CACHE_SET_SIZE; i ++) {
		for(j = 0; j < CACHE_WAY_SIZE; j ++) {
 804b41b:	3d 40 02 00 00       	cmp    $0x240,%eax
 804b420:	75 ee                	jne    804b410 <init_l1cache+0x10>
 804b422:	81 c2 40 02 00 00    	add    $0x240,%edx
uint32_t dram_read(hwaddr_t addr, size_t len);
void dram_write(hwaddr_t addr, size_t len, uint32_t data);

void init_l1cache() {
	int i, j;
	for(i = 0; i < CACHE_SET_SIZE; i ++) {
 804b428:	81 fa 00 20 01 00    	cmp    $0x12000,%edx
 804b42e:	75 d8                	jne    804b408 <init_l1cache+0x8>
 804b430:	f3 c3                	repz ret 
 804b432:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804b439:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804b440 <check_cache>:
			l1cache[i][j].valid = false;
		}
	}
}

uint8_t check_cache(hwaddr_t addr) {
 804b440:	55                   	push   %ebp
 804b441:	57                   	push   %edi
 804b442:	56                   	push   %esi
 804b443:	53                   	push   %ebx
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
	uint8_t way = 0;
	int i;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
 804b444:	31 db                	xor    %ebx,%ebx
			l1cache[i][j].valid = false;
		}
	}
}

uint8_t check_cache(hwaddr_t addr) {
 804b446:	83 ec 5c             	sub    $0x5c,%esp
 804b449:	8b 44 24 70          	mov    0x70(%esp),%eax
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
 804b44d:	89 c5                	mov    %eax,%ebp
}

uint8_t check_cache(hwaddr_t addr) {
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b44f:	89 c7                	mov    %eax,%edi
	uint32_t set = temp.set;
 804b451:	c1 ed 06             	shr    $0x6,%ebp
}

uint8_t check_cache(hwaddr_t addr) {
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b454:	c1 ef 0d             	shr    $0xd,%edi
	uint32_t set = temp.set;
 804b457:	83 e5 7f             	and    $0x7f,%ebp
}

uint8_t check_cache(hwaddr_t addr) {
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b45a:	81 e7 ff 3f 00 00    	and    $0x3fff,%edi
 804b460:	8d 54 ed 00          	lea    0x0(%ebp,%ebp,8),%edx
	uint32_t set = temp.set;
 804b464:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
 804b468:	c1 e2 06             	shl    $0x6,%edx
 804b46b:	81 c2 00 8f 0e 10    	add    $0x100e8f00,%edx
 804b471:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	uint8_t way = 0;
	int i;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
	if(l1cache[set][way].valid && (l1cache[set][way].tag == tag)) {
 804b478:	80 7a 44 00          	cmpb   $0x0,0x44(%edx)
 804b47c:	74 09                	je     804b487 <check_cache+0x47>
 804b47e:	39 7a 40             	cmp    %edi,0x40(%edx)
 804b481:	0f 84 42 01 00 00    	je     804b5c9 <check_cache+0x189>
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
	uint8_t way = 0;
	int i;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
 804b487:	83 c3 01             	add    $0x1,%ebx
 804b48a:	83 c2 48             	add    $0x48,%edx
 804b48d:	80 fb 08             	cmp    $0x8,%bl
 804b490:	75 e6                	jne    804b478 <check_cache+0x38>
		break;
	}

	if(!success) {
		uint8_t temp1[CACHE_BLOCK_SIZE];
		hwaddr_t addr_temp = addr & ~CACHE_BLOCK_MASK;
 804b492:	83 e0 c0             	and    $0xffffffc0,%eax
 804b495:	8d 6c 24 10          	lea    0x10(%esp),%ebp
 804b499:	8d 74 24 50          	lea    0x50(%esp),%esi
 804b49d:	89 c3                	mov    %eax,%ebx
 804b49f:	29 eb                	sub    %ebp,%ebx
 804b4a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804b4a8:	8d 04 2b             	lea    (%ebx,%ebp,1),%eax
		for(i = 0;i < CACHE_BLOCK_SIZE;i++) {
			temp1[i] = (uint8_t)(dram_read(addr_temp + i , 1) & 0xff);
 804b4ab:	83 ec 08             	sub    $0x8,%esp
 804b4ae:	83 c5 01             	add    $0x1,%ebp
 804b4b1:	6a 01                	push   $0x1
 804b4b3:	50                   	push   %eax
 804b4b4:	e8 87 fe ff ff       	call   804b340 <dram_read>
 804b4b9:	88 45 ff             	mov    %al,-0x1(%ebp)
	}

	if(!success) {
		uint8_t temp1[CACHE_BLOCK_SIZE];
		hwaddr_t addr_temp = addr & ~CACHE_BLOCK_MASK;
		for(i = 0;i < CACHE_BLOCK_SIZE;i++) {
 804b4bc:	83 c4 10             	add    $0x10,%esp
 804b4bf:	39 f5                	cmp    %esi,%ebp
 804b4c1:	75 e5                	jne    804b4a8 <check_cache+0x68>
			temp1[i] = (uint8_t)(dram_read(addr_temp + i , 1) & 0xff);
		}
		way = (rand() * CACHE_WAY_SIZE) >> CACHE_WAY_WIDTH;
 804b4c3:	e8 88 d6 ff ff       	call   8048b50 <rand@plt>
 804b4c8:	c1 e0 03             	shl    $0x3,%eax
		memcpy(l1cache[set][way].buf, temp1, CACHE_BLOCK_SIZE);
 804b4cb:	8b 4c 24 10          	mov    0x10(%esp),%ecx
		l1cache[set][way].valid = true;
		l1cache[set][way].tag = tag;
		Log("Miss");
 804b4cf:	83 ec 0c             	sub    $0xc,%esp
		uint8_t temp1[CACHE_BLOCK_SIZE];
		hwaddr_t addr_temp = addr & ~CACHE_BLOCK_MASK;
		for(i = 0;i < CACHE_BLOCK_SIZE;i++) {
			temp1[i] = (uint8_t)(dram_read(addr_temp + i , 1) & 0xff);
		}
		way = (rand() * CACHE_WAY_SIZE) >> CACHE_WAY_WIDTH;
 804b4d2:	c1 f8 03             	sar    $0x3,%eax
 804b4d5:	89 c3                	mov    %eax,%ebx
		memcpy(l1cache[set][way].buf, temp1, CACHE_BLOCK_SIZE);
 804b4d7:	0f b6 c0             	movzbl %al,%eax
 804b4da:	8d 14 c0             	lea    (%eax,%eax,8),%edx
 804b4dd:	8b 44 24 18          	mov    0x18(%esp),%eax
 804b4e1:	8d 04 c0             	lea    (%eax,%eax,8),%eax
 804b4e4:	c1 e0 06             	shl    $0x6,%eax
 804b4e7:	8d 14 d0             	lea    (%eax,%edx,8),%edx
 804b4ea:	8d 82 00 8f 0e 10    	lea    0x100e8f00(%edx),%eax
 804b4f0:	89 8a 00 8f 0e 10    	mov    %ecx,0x100e8f00(%edx)
 804b4f6:	8b 54 24 20          	mov    0x20(%esp),%edx
 804b4fa:	89 50 04             	mov    %edx,0x4(%eax)
 804b4fd:	8b 54 24 24          	mov    0x24(%esp),%edx
 804b501:	89 50 08             	mov    %edx,0x8(%eax)
 804b504:	8b 54 24 28          	mov    0x28(%esp),%edx
 804b508:	89 50 0c             	mov    %edx,0xc(%eax)
 804b50b:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 804b50f:	89 50 10             	mov    %edx,0x10(%eax)
 804b512:	8b 54 24 30          	mov    0x30(%esp),%edx
 804b516:	89 50 14             	mov    %edx,0x14(%eax)
 804b519:	8b 54 24 34          	mov    0x34(%esp),%edx
 804b51d:	89 50 18             	mov    %edx,0x18(%eax)
 804b520:	8b 54 24 38          	mov    0x38(%esp),%edx
 804b524:	89 50 1c             	mov    %edx,0x1c(%eax)
 804b527:	8b 54 24 3c          	mov    0x3c(%esp),%edx
 804b52b:	89 50 20             	mov    %edx,0x20(%eax)
 804b52e:	8b 54 24 40          	mov    0x40(%esp),%edx
 804b532:	89 50 24             	mov    %edx,0x24(%eax)
 804b535:	8b 54 24 44          	mov    0x44(%esp),%edx
 804b539:	89 50 28             	mov    %edx,0x28(%eax)
 804b53c:	8b 54 24 48          	mov    0x48(%esp),%edx
 804b540:	89 50 2c             	mov    %edx,0x2c(%eax)
 804b543:	8b 54 24 4c          	mov    0x4c(%esp),%edx
 804b547:	89 50 30             	mov    %edx,0x30(%eax)
 804b54a:	8b 54 24 50          	mov    0x50(%esp),%edx
 804b54e:	89 50 34             	mov    %edx,0x34(%eax)
 804b551:	8b 54 24 54          	mov    0x54(%esp),%edx
 804b555:	89 50 38             	mov    %edx,0x38(%eax)
 804b558:	8b 54 24 58          	mov    0x58(%esp),%edx
 804b55c:	89 50 3c             	mov    %edx,0x3c(%eax)
		l1cache[set][way].valid = true;
 804b55f:	c6 40 44 01          	movb   $0x1,0x44(%eax)
		l1cache[set][way].tag = tag;
 804b563:	89 78 40             	mov    %edi,0x40(%eax)
		Log("Miss");
 804b566:	68 9f f3 05 08       	push   $0x805f39f
 804b56b:	6a 46                	push   $0x46
 804b56d:	68 12 f3 05 08       	push   $0x805f312
 804b572:	68 2c f3 05 08       	push   $0x805f32c
 804b577:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804b57d:	e8 3e d5 ff ff       	call   8048ac0 <fprintf@plt>
 804b582:	83 c4 14             	add    $0x14,%esp
 804b585:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804b58b:	e8 d0 d3 ff ff       	call   8048960 <fflush@plt>
 804b590:	c7 04 24 9f f3 05 08 	movl   $0x805f39f,(%esp)
 804b597:	6a 46                	push   $0x46
 804b599:	68 12 f3 05 08       	push   $0x805f312
 804b59e:	68 48 f3 05 08       	push   $0x805f348
	}	
	else {
		Log("Hit");
 804b5a3:	ff 35 28 5d 07 08    	pushl  0x8075d28
 804b5a9:	e8 12 d5 ff ff       	call   8048ac0 <fprintf@plt>
 804b5ae:	83 c4 14             	add    $0x14,%esp
 804b5b1:	ff 35 28 5d 07 08    	pushl  0x8075d28
 804b5b7:	e8 a4 d3 ff ff       	call   8048960 <fflush@plt>
 804b5bc:	83 c4 10             	add    $0x10,%esp
	}
	return way;
}
 804b5bf:	89 d8                	mov    %ebx,%eax
 804b5c1:	83 c4 5c             	add    $0x5c,%esp
 804b5c4:	5b                   	pop    %ebx
 804b5c5:	5e                   	pop    %esi
 804b5c6:	5f                   	pop    %edi
 804b5c7:	5d                   	pop    %ebp
 804b5c8:	c3                   	ret    
		l1cache[set][way].valid = true;
		l1cache[set][way].tag = tag;
		Log("Miss");
	}	
	else {
		Log("Hit");
 804b5c9:	83 ec 0c             	sub    $0xc,%esp
 804b5cc:	68 9f f3 05 08       	push   $0x805f39f
 804b5d1:	6a 49                	push   $0x49
 804b5d3:	68 12 f3 05 08       	push   $0x805f312
 804b5d8:	68 59 f3 05 08       	push   $0x805f359
 804b5dd:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804b5e3:	e8 d8 d4 ff ff       	call   8048ac0 <fprintf@plt>
 804b5e8:	83 c4 14             	add    $0x14,%esp
 804b5eb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804b5f1:	e8 6a d3 ff ff       	call   8048960 <fflush@plt>
 804b5f6:	c7 04 24 9f f3 05 08 	movl   $0x805f39f,(%esp)
 804b5fd:	6a 49                	push   $0x49
 804b5ff:	68 12 f3 05 08       	push   $0x805f312
 804b604:	68 74 f3 05 08       	push   $0x805f374
 804b609:	eb 98                	jmp    804b5a3 <check_cache+0x163>
 804b60b:	90                   	nop
 804b60c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804b610 <l1cache_read>:
	}
	return way;
}

uint32_t l1cache_read(hwaddr_t addr, size_t len) {
 804b610:	55                   	push   %ebp
 804b611:	57                   	push   %edi
 804b612:	56                   	push   %esi
 804b613:	53                   	push   %ebx
 804b614:	81 ec 8c 00 00 00    	sub    $0x8c,%esp
 804b61a:	8b b4 24 a4 00 00 00 	mov    0xa4(%esp),%esi
 804b621:	8b bc 24 a0 00 00 00 	mov    0xa0(%esp),%edi
	assert(len == 1 || len == 2 || len == 4);
 804b628:	8d 46 ff             	lea    -0x1(%esi),%eax
 804b62b:	83 f8 01             	cmp    $0x1,%eax
 804b62e:	76 09                	jbe    804b639 <l1cache_read+0x29>
 804b630:	83 fe 04             	cmp    $0x4,%esi
 804b633:	0f 85 79 01 00 00    	jne    804b7b2 <l1cache_read+0x1a2>
	l1cache_addr temp;
	temp.addr = addr;

	uint32_t set = temp.set;
	uint8_t way = check_cache(addr);
 804b639:	83 ec 0c             	sub    $0xc,%esp
uint32_t l1cache_read(hwaddr_t addr, size_t len) {
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;

	uint32_t set = temp.set;
 804b63c:	89 fd                	mov    %edi,%ebp
	uint8_t way = check_cache(addr);
	uint32_t block = temp.block;
 804b63e:	89 fb                	mov    %edi,%ebx
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;

	uint32_t set = temp.set;
	uint8_t way = check_cache(addr);
 804b640:	57                   	push   %edi
uint32_t l1cache_read(hwaddr_t addr, size_t len) {
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;

	uint32_t set = temp.set;
 804b641:	c1 ed 06             	shr    $0x6,%ebp
	uint8_t way = check_cache(addr);
	uint32_t block = temp.block;
 804b644:	83 e3 3f             	and    $0x3f,%ebx
uint32_t l1cache_read(hwaddr_t addr, size_t len) {
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;

	uint32_t set = temp.set;
 804b647:	83 e5 7f             	and    $0x7f,%ebp
	uint8_t way = check_cache(addr);
 804b64a:	e8 f1 fd ff ff       	call   804b440 <check_cache>
	uint32_t block = temp.block;

	uint8_t buf[CACHE_BLOCK_SIZE << 1];
	memcpy(buf, l1cache[set][way].buf, CACHE_BLOCK_SIZE);
 804b64f:	0f b6 c0             	movzbl %al,%eax
 804b652:	8d 14 c0             	lea    (%eax,%eax,8),%edx
 804b655:	8d 44 ed 00          	lea    0x0(%ebp,%ebp,8),%eax
 804b659:	c1 e0 06             	shl    $0x6,%eax
 804b65c:	8d 14 d0             	lea    (%eax,%edx,8),%edx
 804b65f:	8d 82 00 8f 0e 10    	lea    0x100e8f00(%edx),%eax
 804b665:	8b 92 00 8f 0e 10    	mov    0x100e8f00(%edx),%edx
 804b66b:	89 54 24 10          	mov    %edx,0x10(%esp)
 804b66f:	8b 50 04             	mov    0x4(%eax),%edx
 804b672:	89 54 24 14          	mov    %edx,0x14(%esp)
 804b676:	8b 50 08             	mov    0x8(%eax),%edx
 804b679:	89 54 24 18          	mov    %edx,0x18(%esp)
 804b67d:	8b 50 0c             	mov    0xc(%eax),%edx
 804b680:	89 54 24 1c          	mov    %edx,0x1c(%esp)
 804b684:	8b 50 10             	mov    0x10(%eax),%edx
 804b687:	89 54 24 20          	mov    %edx,0x20(%esp)
 804b68b:	8b 50 14             	mov    0x14(%eax),%edx
 804b68e:	89 54 24 24          	mov    %edx,0x24(%esp)
 804b692:	8b 50 18             	mov    0x18(%eax),%edx
 804b695:	89 54 24 28          	mov    %edx,0x28(%esp)
 804b699:	8b 50 1c             	mov    0x1c(%eax),%edx
 804b69c:	89 54 24 2c          	mov    %edx,0x2c(%esp)
 804b6a0:	8b 50 20             	mov    0x20(%eax),%edx
 804b6a3:	89 54 24 30          	mov    %edx,0x30(%esp)
 804b6a7:	8b 50 24             	mov    0x24(%eax),%edx
 804b6aa:	89 54 24 34          	mov    %edx,0x34(%esp)
 804b6ae:	8b 50 28             	mov    0x28(%eax),%edx
 804b6b1:	89 54 24 38          	mov    %edx,0x38(%esp)
 804b6b5:	8b 50 2c             	mov    0x2c(%eax),%edx
 804b6b8:	89 54 24 3c          	mov    %edx,0x3c(%esp)
 804b6bc:	8b 50 30             	mov    0x30(%eax),%edx
 804b6bf:	89 54 24 40          	mov    %edx,0x40(%esp)
 804b6c3:	8b 50 34             	mov    0x34(%eax),%edx
 804b6c6:	89 54 24 44          	mov    %edx,0x44(%esp)
 804b6ca:	8b 50 38             	mov    0x38(%eax),%edx
 804b6cd:	8b 40 3c             	mov    0x3c(%eax),%eax
 804b6d0:	89 54 24 48          	mov    %edx,0x48(%esp)
 804b6d4:	89 44 24 4c          	mov    %eax,0x4c(%esp)
	if(block + len >= CACHE_BLOCK_SIZE) {
 804b6d8:	8d 04 1e             	lea    (%esi,%ebx,1),%eax
 804b6db:	83 c4 10             	add    $0x10,%esp
 804b6de:	83 f8 3f             	cmp    $0x3f,%eax
 804b6e1:	0f 86 ac 00 00 00    	jbe    804b793 <l1cache_read+0x183>
		temp.addr += CACHE_BLOCK_SIZE;
		set = temp.set;
		way = check_cache(temp.addr);
 804b6e7:	83 ec 0c             	sub    $0xc,%esp
	uint32_t block = temp.block;

	uint8_t buf[CACHE_BLOCK_SIZE << 1];
	memcpy(buf, l1cache[set][way].buf, CACHE_BLOCK_SIZE);
	if(block + len >= CACHE_BLOCK_SIZE) {
		temp.addr += CACHE_BLOCK_SIZE;
 804b6ea:	83 c7 40             	add    $0x40,%edi
		set = temp.set;
		way = check_cache(temp.addr);
 804b6ed:	57                   	push   %edi

	uint8_t buf[CACHE_BLOCK_SIZE << 1];
	memcpy(buf, l1cache[set][way].buf, CACHE_BLOCK_SIZE);
	if(block + len >= CACHE_BLOCK_SIZE) {
		temp.addr += CACHE_BLOCK_SIZE;
		set = temp.set;
 804b6ee:	89 fd                	mov    %edi,%ebp
 804b6f0:	c1 ed 06             	shr    $0x6,%ebp
		way = check_cache(temp.addr);
 804b6f3:	e8 48 fd ff ff       	call   804b440 <check_cache>

	uint8_t buf[CACHE_BLOCK_SIZE << 1];
	memcpy(buf, l1cache[set][way].buf, CACHE_BLOCK_SIZE);
	if(block + len >= CACHE_BLOCK_SIZE) {
		temp.addr += CACHE_BLOCK_SIZE;
		set = temp.set;
 804b6f8:	83 e5 7f             	and    $0x7f,%ebp
		way = check_cache(temp.addr);
		memcpy(buf + CACHE_BLOCK_SIZE, l1cache[set][way].buf, CACHE_BLOCK_SIZE);
 804b6fb:	0f b6 c0             	movzbl %al,%eax
 804b6fe:	8d 14 c0             	lea    (%eax,%eax,8),%edx
 804b701:	8d 44 ed 00          	lea    0x0(%ebp,%ebp,8),%eax
 804b705:	c1 e0 06             	shl    $0x6,%eax
 804b708:	8d 14 d0             	lea    (%eax,%edx,8),%edx
 804b70b:	8d 82 00 8f 0e 10    	lea    0x100e8f00(%edx),%eax
 804b711:	8b 92 00 8f 0e 10    	mov    0x100e8f00(%edx),%edx
 804b717:	89 54 24 50          	mov    %edx,0x50(%esp)
 804b71b:	8b 50 04             	mov    0x4(%eax),%edx
 804b71e:	89 54 24 54          	mov    %edx,0x54(%esp)
 804b722:	8b 50 08             	mov    0x8(%eax),%edx
 804b725:	89 54 24 58          	mov    %edx,0x58(%esp)
 804b729:	8b 50 0c             	mov    0xc(%eax),%edx
 804b72c:	89 54 24 5c          	mov    %edx,0x5c(%esp)
 804b730:	8b 50 10             	mov    0x10(%eax),%edx
 804b733:	89 54 24 60          	mov    %edx,0x60(%esp)
 804b737:	8b 50 14             	mov    0x14(%eax),%edx
 804b73a:	89 54 24 64          	mov    %edx,0x64(%esp)
 804b73e:	8b 50 18             	mov    0x18(%eax),%edx
 804b741:	89 54 24 68          	mov    %edx,0x68(%esp)
 804b745:	8b 50 1c             	mov    0x1c(%eax),%edx
 804b748:	89 54 24 6c          	mov    %edx,0x6c(%esp)
 804b74c:	8b 50 20             	mov    0x20(%eax),%edx
 804b74f:	89 54 24 70          	mov    %edx,0x70(%esp)
 804b753:	8b 50 24             	mov    0x24(%eax),%edx
 804b756:	89 54 24 74          	mov    %edx,0x74(%esp)
 804b75a:	8b 50 28             	mov    0x28(%eax),%edx
 804b75d:	89 54 24 78          	mov    %edx,0x78(%esp)
 804b761:	8b 50 2c             	mov    0x2c(%eax),%edx
 804b764:	89 54 24 7c          	mov    %edx,0x7c(%esp)
 804b768:	8b 50 30             	mov    0x30(%eax),%edx
 804b76b:	89 94 24 80 00 00 00 	mov    %edx,0x80(%esp)
 804b772:	8b 50 34             	mov    0x34(%eax),%edx
 804b775:	89 94 24 84 00 00 00 	mov    %edx,0x84(%esp)
 804b77c:	8b 50 38             	mov    0x38(%eax),%edx
 804b77f:	8b 40 3c             	mov    0x3c(%eax),%eax
 804b782:	89 94 24 88 00 00 00 	mov    %edx,0x88(%esp)
 804b789:	89 84 24 8c 00 00 00 	mov    %eax,0x8c(%esp)
 804b790:	83 c4 10             	add    $0x10,%esp
	}
	return (*(uint32_t *)(buf + block)) & (~0u >> ((4 - len) << 3));
 804b793:	b9 04 00 00 00       	mov    $0x4,%ecx
 804b798:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 804b79d:	29 f1                	sub    %esi,%ecx
 804b79f:	c1 e1 03             	shl    $0x3,%ecx
 804b7a2:	d3 e8                	shr    %cl,%eax
 804b7a4:	23 04 1c             	and    (%esp,%ebx,1),%eax
}
 804b7a7:	81 c4 8c 00 00 00    	add    $0x8c,%esp
 804b7ad:	5b                   	pop    %ebx
 804b7ae:	5e                   	pop    %esi
 804b7af:	5f                   	pop    %edi
 804b7b0:	5d                   	pop    %ebp
 804b7b1:	c3                   	ret    
	}
	return way;
}

uint32_t l1cache_read(hwaddr_t addr, size_t len) {
	assert(len == 1 || len == 2 || len == 4);
 804b7b2:	68 92 f3 05 08       	push   $0x805f392
 804b7b7:	6a 4f                	push   $0x4f
 804b7b9:	68 12 f3 05 08       	push   $0x805f312
 804b7be:	68 40 f2 05 08       	push   $0x805f240
 804b7c3:	e8 e8 d3 ff ff       	call   8048bb0 <__assert_fail@plt>
 804b7c8:	90                   	nop
 804b7c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804b7d0 <l1cache_write>:
		memcpy(buf + CACHE_BLOCK_SIZE, l1cache[set][way].buf, CACHE_BLOCK_SIZE);
	}
	return (*(uint32_t *)(buf + block)) & (~0u >> ((4 - len) << 3));
}

void l1cache_write(hwaddr_t addr, size_t len, uint32_t data) {
 804b7d0:	55                   	push   %ebp
 804b7d1:	57                   	push   %edi
 804b7d2:	56                   	push   %esi
 804b7d3:	53                   	push   %ebx
 804b7d4:	83 ec 0c             	sub    $0xc,%esp
 804b7d7:	8b 7c 24 24          	mov    0x24(%esp),%edi
 804b7db:	8b 5c 24 20          	mov    0x20(%esp),%ebx
 804b7df:	8b 4c 24 28          	mov    0x28(%esp),%ecx
	assert(len == 1 || len == 2 || len == 4);
 804b7e3:	8d 47 ff             	lea    -0x1(%edi),%eax
 804b7e6:	83 f8 01             	cmp    $0x1,%eax
 804b7e9:	76 09                	jbe    804b7f4 <l1cache_write+0x24>
 804b7eb:	83 ff 04             	cmp    $0x4,%edi
 804b7ee:	0f 85 d7 00 00 00    	jne    804b8cb <l1cache_write+0xfb>
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
 804b7f4:	89 de                	mov    %ebx,%esi

void l1cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b7f6:	89 da                	mov    %ebx,%edx
	uint32_t set = temp.set;
 804b7f8:	31 ed                	xor    %ebp,%ebp
 804b7fa:	c1 ee 06             	shr    $0x6,%esi

void l1cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b7fd:	c1 ea 0d             	shr    $0xd,%edx
	uint32_t set = temp.set;
 804b800:	83 e6 7f             	and    $0x7f,%esi

void l1cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
	l1cache_addr temp;
	temp.addr = addr;
	uint32_t tag = temp.tag;
 804b803:	81 e2 ff 3f 00 00    	and    $0x3fff,%edx
 804b809:	8d 04 f6             	lea    (%esi,%esi,8),%eax
 804b80c:	c1 e0 06             	shl    $0x6,%eax
 804b80f:	05 00 8f 0e 10       	add    $0x100e8f00,%eax
 804b814:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	uint32_t set = temp.set;
	uint8_t way = 0;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
	if(l1cache[set][way].valid && (l1cache[set][way].tag == tag)) {
 804b818:	80 78 44 00          	cmpb   $0x0,0x44(%eax)
 804b81c:	74 05                	je     804b823 <l1cache_write+0x53>
 804b81e:	39 50 40             	cmp    %edx,0x40(%eax)
 804b821:	74 6d                	je     804b890 <l1cache_write+0xc0>
 804b823:	83 c5 01             	add    $0x1,%ebp
 804b826:	83 c0 48             	add    $0x48,%eax
	temp.addr = addr;
	uint32_t tag = temp.tag;
	uint32_t set = temp.set;
	uint8_t way = 0;
	bool success = false;
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
 804b829:	83 fd 08             	cmp    $0x8,%ebp
 804b82c:	75 ea                	jne    804b818 <l1cache_write+0x48>
	if(l1cache[set][way].valid && (l1cache[set][way].tag == tag)) {
		success = true;
		break;
	}
	dram_write(addr, len, data);
 804b82e:	83 ec 04             	sub    $0x4,%esp
 804b831:	51                   	push   %ecx
 804b832:	57                   	push   %edi
 804b833:	53                   	push   %ebx
 804b834:	e8 47 fb ff ff       	call   804b380 <dram_write>
 804b839:	83 c4 10             	add    $0x10,%esp
		for(i = 0;i < CACHE_BLOCK_SIZE; i ++) {
			temp1[i] = (uint8_t)(dram_read(addr_temp + i, 1) & 0xff);
		}
		memcpy(l1cache[set][way].buf, temp1, CACHE_BLOCK_SIZE);*/
	}
	uint32_t block = temp.block;
 804b83c:	89 d8                	mov    %ebx,%eax
 804b83e:	83 e0 3f             	and    $0x3f,%eax
	if(block + len >= CACHE_BLOCK_SIZE) {
 804b841:	01 c7                	add    %eax,%edi
 804b843:	83 ff 3f             	cmp    $0x3f,%edi
 804b846:	76 3e                	jbe    804b886 <l1cache_write+0xb6>
		success = false;
		temp.addr += CACHE_BLOCK_SIZE;
 804b848:	83 c3 40             	add    $0x40,%ebx
		set = temp.set;
		tag = temp.tag;
 804b84b:	31 d2                	xor    %edx,%edx
	}
	uint32_t block = temp.block;
	if(block + len >= CACHE_BLOCK_SIZE) {
		success = false;
		temp.addr += CACHE_BLOCK_SIZE;
		set = temp.set;
 804b84d:	89 d9                	mov    %ebx,%ecx
		tag = temp.tag;
 804b84f:	c1 eb 0d             	shr    $0xd,%ebx
	}
	uint32_t block = temp.block;
	if(block + len >= CACHE_BLOCK_SIZE) {
		success = false;
		temp.addr += CACHE_BLOCK_SIZE;
		set = temp.set;
 804b852:	c1 e9 06             	shr    $0x6,%ecx
		tag = temp.tag;
 804b855:	81 e3 ff 3f 00 00    	and    $0x3fff,%ebx
	}
	uint32_t block = temp.block;
	if(block + len >= CACHE_BLOCK_SIZE) {
		success = false;
		temp.addr += CACHE_BLOCK_SIZE;
		set = temp.set;
 804b85b:	83 e1 7f             	and    $0x7f,%ecx
 804b85e:	8d 04 c9             	lea    (%ecx,%ecx,8),%eax
 804b861:	c1 e0 06             	shl    $0x6,%eax
 804b864:	05 00 8f 0e 10       	add    $0x100e8f00,%eax
 804b869:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		tag = temp.tag;
		for(way = 0; way < CACHE_WAY_SIZE; way ++)
		if(l1cache[set][way].valid && (l1cache[set][way].tag == tag)) {
 804b870:	80 78 44 00          	cmpb   $0x0,0x44(%eax)
 804b874:	74 05                	je     804b87b <l1cache_write+0xab>
 804b876:	39 58 40             	cmp    %ebx,0x40(%eax)
 804b879:	74 3d                	je     804b8b8 <l1cache_write+0xe8>
 804b87b:	83 c2 01             	add    $0x1,%edx
 804b87e:	83 c0 48             	add    $0x48,%eax
	if(block + len >= CACHE_BLOCK_SIZE) {
		success = false;
		temp.addr += CACHE_BLOCK_SIZE;
		set = temp.set;
		tag = temp.tag;
		for(way = 0; way < CACHE_WAY_SIZE; way ++)
 804b881:	83 fa 08             	cmp    $0x8,%edx
 804b884:	75 ea                	jne    804b870 <l1cache_write+0xa0>
			}
			memcpy(l1cache[set][way].buf, temp1, CACHE_BLOCK_SIZE);*/
		}
	}
	return;
}
 804b886:	83 c4 0c             	add    $0xc,%esp
 804b889:	5b                   	pop    %ebx
 804b88a:	5e                   	pop    %esi
 804b88b:	5f                   	pop    %edi
 804b88c:	5d                   	pop    %ebp
 804b88d:	c3                   	ret    
 804b88e:	66 90                	xchg   %ax,%ax
	for(way = 0; way < CACHE_WAY_SIZE; way ++)
	if(l1cache[set][way].valid && (l1cache[set][way].tag == tag)) {
		success = true;
		break;
	}
	dram_write(addr, len, data);
 804b890:	83 ec 04             	sub    $0x4,%esp
 804b893:	51                   	push   %ecx
 804b894:	57                   	push   %edi
 804b895:	53                   	push   %ebx
 804b896:	e8 e5 fa ff ff       	call   804b380 <dram_write>
	if(success){
		l1cache[set][way].valid = false;
 804b89b:	8d 04 f6             	lea    (%esi,%esi,8),%eax
 804b89e:	8d 54 ed 00          	lea    0x0(%ebp,%ebp,8),%edx
 804b8a2:	83 c4 10             	add    $0x10,%esp
 804b8a5:	c1 e0 06             	shl    $0x6,%eax
 804b8a8:	c6 84 d0 44 8f 0e 10 	movb   $0x0,0x100e8f44(%eax,%edx,8)
 804b8af:	00 
 804b8b0:	eb 8a                	jmp    804b83c <l1cache_write+0x6c>
 804b8b2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		if(l1cache[set][way].valid && (l1cache[set][way].tag == tag)) {
			success = true;
			break;
		}
		if(success) {
			l1cache[set][way].valid = false;
 804b8b8:	8d 04 c9             	lea    (%ecx,%ecx,8),%eax
 804b8bb:	8d 14 d2             	lea    (%edx,%edx,8),%edx
 804b8be:	c1 e0 06             	shl    $0x6,%eax
 804b8c1:	c6 84 d0 44 8f 0e 10 	movb   $0x0,0x100e8f44(%eax,%edx,8)
 804b8c8:	00 
 804b8c9:	eb bb                	jmp    804b886 <l1cache_write+0xb6>
	}
	return (*(uint32_t *)(buf + block)) & (~0u >> ((4 - len) << 3));
}

void l1cache_write(hwaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
 804b8cb:	68 84 f3 05 08       	push   $0x805f384
 804b8d0:	6a 63                	push   $0x63
 804b8d2:	68 12 f3 05 08       	push   $0x805f312
 804b8d7:	68 40 f2 05 08       	push   $0x805f240
 804b8dc:	e8 cf d2 ff ff       	call   8048bb0 <__assert_fail@plt>
 804b8e1:	66 90                	xchg   %ax,%ax
 804b8e3:	66 90                	xchg   %ax,%ax
 804b8e5:	66 90                	xchg   %ax,%ax
 804b8e7:	66 90                	xchg   %ax,%ax
 804b8e9:	66 90                	xchg   %ax,%ax
 804b8eb:	66 90                	xchg   %ax,%ax
 804b8ed:	66 90                	xchg   %ax,%ax
 804b8ef:	90                   	nop

0804b8f0 <movs_w>:
#include "cpu/exec/template-start.h"

#define instr movs

make_helper(concat(movs_, SUFFIX)) {
 804b8f0:	83 ec 14             	sub    $0x14,%esp
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
 804b8f3:	6a 02                	push   $0x2
 804b8f5:	ff 35 d8 af 0f 10    	pushl  0x100fafd8
 804b8fb:	e8 50 f6 ff ff       	call   804af50 <swaddr_read>
 804b900:	83 c4 0c             	add    $0xc,%esp
 804b903:	0f b7 c0             	movzwl %ax,%eax
 804b906:	50                   	push   %eax
 804b907:	6a 02                	push   $0x2
 804b909:	ff 35 dc af 0f 10    	pushl  0x100fafdc
 804b90f:	e8 8c f6 ff ff       	call   804afa0 <swaddr_write>
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804b914:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
 804b91b:	ba 01 00 00 00       	mov    $0x1,%edx
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804b920:	68 18 af 0f 10       	push   $0x100faf18
 804b925:	68 ab f3 05 08       	push   $0x805f3ab
 804b92a:	6a 50                	push   $0x50
 804b92c:	68 00 8a 0c 08       	push   $0x80c8a00

#define instr movs

make_helper(concat(movs_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804b931:	c0 e8 02             	shr    $0x2,%al
 804b934:	83 e0 01             	and    $0x1,%eax
 804b937:	01 c0                	add    %eax,%eax
 804b939:	29 c2                	sub    %eax,%edx
 804b93b:	89 d0                	mov    %edx,%eax
 804b93d:	01 c0                	add    %eax,%eax
 804b93f:	01 05 dc af 0f 10    	add    %eax,0x100fafdc
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804b945:	01 05 d8 af 0f 10    	add    %eax,0x100fafd8
	print_asm_template1();
 804b94b:	e8 b0 d1 ff ff       	call   8048b00 <snprintf@plt>
 804b950:	83 c4 20             	add    $0x20,%esp
 804b953:	83 f8 4f             	cmp    $0x4f,%eax
 804b956:	7f 10                	jg     804b968 <movs_w+0x78>
	return 1;
}
 804b958:	b8 01 00 00 00       	mov    $0x1,%eax
 804b95d:	83 c4 0c             	add    $0xc,%esp
 804b960:	c3                   	ret    
 804b961:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

make_helper(concat(movs_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804b968:	83 ec 0c             	sub    $0xc,%esp
 804b96b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804b971:	e8 ea cf ff ff       	call   8048960 <fflush@plt>
 804b976:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804b97c:	6a 07                	push   $0x7
 804b97e:	6a 01                	push   $0x1
 804b980:	68 92 e8 05 08       	push   $0x805e892
 804b985:	e8 86 d0 ff ff       	call   8048a10 <fwrite@plt>
 804b98a:	83 c4 20             	add    $0x20,%esp
 804b98d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804b993:	6a 10                	push   $0x10
 804b995:	6a 01                	push   $0x1
 804b997:	68 b4 f3 05 08       	push   $0x805f3b4
 804b99c:	e8 6f d0 ff ff       	call   8048a10 <fwrite@plt>
 804b9a1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804b9a7:	6a 05                	push   $0x5
 804b9a9:	6a 01                	push   $0x1
 804b9ab:	68 42 f3 05 08       	push   $0x805f342
 804b9b0:	e8 5b d0 ff ff       	call   8048a10 <fwrite@plt>
 804b9b5:	83 c4 20             	add    $0x20,%esp
 804b9b8:	68 18 af 0f 10       	push   $0x100faf18
 804b9bd:	68 ab f3 05 08       	push   $0x805f3ab
 804b9c2:	6a 50                	push   $0x50
 804b9c4:	68 00 8a 0c 08       	push   $0x80c8a00
 804b9c9:	e8 32 d1 ff ff       	call   8048b00 <snprintf@plt>
 804b9ce:	83 c4 10             	add    $0x10,%esp
 804b9d1:	83 f8 4f             	cmp    $0x4f,%eax
 804b9d4:	7e 82                	jle    804b958 <movs_w+0x68>
 804b9d6:	68 de f4 05 08       	push   $0x805f4de
 804b9db:	6a 09                	push   $0x9
 804b9dd:	68 d8 f3 05 08       	push   $0x805f3d8
 804b9e2:	68 00 f4 05 08       	push   $0x805f400
 804b9e7:	e8 c4 d1 ff ff       	call   8048bb0 <__assert_fail@plt>
 804b9ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804b9f0 <movs_l>:
#include "cpu/exec/template-start.h"

#define instr movs

make_helper(concat(movs_, SUFFIX)) {
 804b9f0:	83 ec 14             	sub    $0x14,%esp
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
 804b9f3:	6a 04                	push   $0x4
 804b9f5:	ff 35 d8 af 0f 10    	pushl  0x100fafd8
 804b9fb:	e8 50 f5 ff ff       	call   804af50 <swaddr_read>
 804ba00:	83 c4 0c             	add    $0xc,%esp
 804ba03:	50                   	push   %eax
 804ba04:	6a 04                	push   $0x4
 804ba06:	ff 35 dc af 0f 10    	pushl  0x100fafdc
 804ba0c:	e8 8f f5 ff ff       	call   804afa0 <swaddr_write>
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804ba11:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
 804ba18:	8b 0d dc af 0f 10    	mov    0x100fafdc,%ecx
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804ba1e:	68 18 af 0f 10       	push   $0x100faf18
 804ba23:	68 c5 f3 05 08       	push   $0x805f3c5
 804ba28:	6a 50                	push   $0x50
 804ba2a:	68 00 8a 0c 08       	push   $0x80c8a00
 804ba2f:	8d 51 04             	lea    0x4(%ecx),%edx
 804ba32:	8b 0d d8 af 0f 10    	mov    0x100fafd8,%ecx

#define instr movs

make_helper(concat(movs_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804ba38:	c0 e8 02             	shr    $0x2,%al
 804ba3b:	83 e0 01             	and    $0x1,%eax
 804ba3e:	c1 e0 03             	shl    $0x3,%eax
 804ba41:	29 c2                	sub    %eax,%edx
 804ba43:	89 15 dc af 0f 10    	mov    %edx,0x100fafdc
 804ba49:	8d 51 04             	lea    0x4(%ecx),%edx
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804ba4c:	29 c2                	sub    %eax,%edx
 804ba4e:	89 15 d8 af 0f 10    	mov    %edx,0x100fafd8
	print_asm_template1();
 804ba54:	e8 a7 d0 ff ff       	call   8048b00 <snprintf@plt>
 804ba59:	83 c4 20             	add    $0x20,%esp
 804ba5c:	83 f8 4f             	cmp    $0x4f,%eax
 804ba5f:	7f 0f                	jg     804ba70 <movs_l+0x80>
	return 1;
}
 804ba61:	b8 01 00 00 00       	mov    $0x1,%eax
 804ba66:	83 c4 0c             	add    $0xc,%esp
 804ba69:	c3                   	ret    
 804ba6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

make_helper(concat(movs_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804ba70:	83 ec 0c             	sub    $0xc,%esp
 804ba73:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804ba79:	e8 e2 ce ff ff       	call   8048960 <fflush@plt>
 804ba7e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ba84:	6a 07                	push   $0x7
 804ba86:	6a 01                	push   $0x1
 804ba88:	68 92 e8 05 08       	push   $0x805e892
 804ba8d:	e8 7e cf ff ff       	call   8048a10 <fwrite@plt>
 804ba92:	83 c4 20             	add    $0x20,%esp
 804ba95:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ba9b:	6a 10                	push   $0x10
 804ba9d:	6a 01                	push   $0x1
 804ba9f:	68 b4 f3 05 08       	push   $0x805f3b4
 804baa4:	e8 67 cf ff ff       	call   8048a10 <fwrite@plt>
 804baa9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804baaf:	6a 05                	push   $0x5
 804bab1:	6a 01                	push   $0x1
 804bab3:	68 42 f3 05 08       	push   $0x805f342
 804bab8:	e8 53 cf ff ff       	call   8048a10 <fwrite@plt>
 804babd:	83 c4 20             	add    $0x20,%esp
 804bac0:	68 18 af 0f 10       	push   $0x100faf18
 804bac5:	68 c5 f3 05 08       	push   $0x805f3c5
 804baca:	6a 50                	push   $0x50
 804bacc:	68 00 8a 0c 08       	push   $0x80c8a00
 804bad1:	e8 2a d0 ff ff       	call   8048b00 <snprintf@plt>
 804bad6:	83 c4 10             	add    $0x10,%esp
 804bad9:	83 f8 4f             	cmp    $0x4f,%eax
 804badc:	7e 83                	jle    804ba61 <movs_l+0x71>
 804bade:	68 d7 f4 05 08       	push   $0x805f4d7
 804bae3:	6a 09                	push   $0x9
 804bae5:	68 d8 f3 05 08       	push   $0x805f3d8
 804baea:	68 48 f4 05 08       	push   $0x805f448
 804baef:	e8 bc d0 ff ff       	call   8048bb0 <__assert_fail@plt>
 804baf4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804bafa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804bb00 <movs_b>:
#include "cpu/exec/template-start.h"

#define instr movs

make_helper(concat(movs_, SUFFIX)) {
 804bb00:	83 ec 14             	sub    $0x14,%esp
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
 804bb03:	6a 01                	push   $0x1
 804bb05:	ff 35 d8 af 0f 10    	pushl  0x100fafd8
 804bb0b:	e8 40 f4 ff ff       	call   804af50 <swaddr_read>
 804bb10:	83 c4 0c             	add    $0xc,%esp
 804bb13:	0f b6 c0             	movzbl %al,%eax
 804bb16:	50                   	push   %eax
 804bb17:	6a 01                	push   $0x1
 804bb19:	ff 35 dc af 0f 10    	pushl  0x100fafdc
 804bb1f:	e8 7c f4 ff ff       	call   804afa0 <swaddr_write>
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804bb24:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
 804bb2b:	8b 0d dc af 0f 10    	mov    0x100fafdc,%ecx
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804bb31:	68 18 af 0f 10       	push   $0x100faf18
 804bb36:	68 ce f3 05 08       	push   $0x805f3ce
 804bb3b:	6a 50                	push   $0x50
 804bb3d:	68 00 8a 0c 08       	push   $0x80c8a00
 804bb42:	8d 51 01             	lea    0x1(%ecx),%edx
 804bb45:	8b 0d d8 af 0f 10    	mov    0x100fafd8,%ecx

#define instr movs

make_helper(concat(movs_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804bb4b:	c0 e8 02             	shr    $0x2,%al
 804bb4e:	83 e0 01             	and    $0x1,%eax
 804bb51:	01 c0                	add    %eax,%eax
 804bb53:	29 c2                	sub    %eax,%edx
 804bb55:	89 15 dc af 0f 10    	mov    %edx,0x100fafdc
 804bb5b:	8d 51 01             	lea    0x1(%ecx),%edx
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804bb5e:	29 c2                	sub    %eax,%edx
 804bb60:	89 15 d8 af 0f 10    	mov    %edx,0x100fafd8
	print_asm_template1();
 804bb66:	e8 95 cf ff ff       	call   8048b00 <snprintf@plt>
 804bb6b:	83 c4 20             	add    $0x20,%esp
 804bb6e:	83 f8 4f             	cmp    $0x4f,%eax
 804bb71:	7f 0d                	jg     804bb80 <movs_b+0x80>
	return 1;
}
 804bb73:	b8 01 00 00 00       	mov    $0x1,%eax
 804bb78:	83 c4 0c             	add    $0xc,%esp
 804bb7b:	c3                   	ret    
 804bb7c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

make_helper(concat(movs_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) MEM_R(reg_l(R_ESI)));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804bb80:	83 ec 0c             	sub    $0xc,%esp
 804bb83:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804bb89:	e8 d2 cd ff ff       	call   8048960 <fflush@plt>
 804bb8e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804bb94:	6a 07                	push   $0x7
 804bb96:	6a 01                	push   $0x1
 804bb98:	68 92 e8 05 08       	push   $0x805e892
 804bb9d:	e8 6e ce ff ff       	call   8048a10 <fwrite@plt>
 804bba2:	83 c4 20             	add    $0x20,%esp
 804bba5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804bbab:	6a 10                	push   $0x10
 804bbad:	6a 01                	push   $0x1
 804bbaf:	68 b4 f3 05 08       	push   $0x805f3b4
 804bbb4:	e8 57 ce ff ff       	call   8048a10 <fwrite@plt>
 804bbb9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804bbbf:	6a 05                	push   $0x5
 804bbc1:	6a 01                	push   $0x1
 804bbc3:	68 42 f3 05 08       	push   $0x805f342
 804bbc8:	e8 43 ce ff ff       	call   8048a10 <fwrite@plt>
 804bbcd:	83 c4 20             	add    $0x20,%esp
 804bbd0:	68 18 af 0f 10       	push   $0x100faf18
 804bbd5:	68 ce f3 05 08       	push   $0x805f3ce
 804bbda:	6a 50                	push   $0x50
 804bbdc:	68 00 8a 0c 08       	push   $0x80c8a00
 804bbe1:	e8 1a cf ff ff       	call   8048b00 <snprintf@plt>
 804bbe6:	83 c4 10             	add    $0x10,%esp
 804bbe9:	83 f8 4f             	cmp    $0x4f,%eax
 804bbec:	7e 85                	jle    804bb73 <movs_b+0x73>
 804bbee:	68 e5 f4 05 08       	push   $0x805f4e5
 804bbf3:	6a 09                	push   $0x9
 804bbf5:	68 d8 f3 05 08       	push   $0x805f3d8
 804bbfa:	68 90 f4 05 08       	push   $0x805f490
 804bbff:	e8 ac cf ff ff       	call   8048bb0 <__assert_fail@plt>
 804bc04:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804bc0a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804bc10 <movs_v>:

#define DATA_BYTE 4
#include "movs-template.h"
#undef DATA_BYTE

make_helper_v(movs)
 804bc10:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804bc17:	8b 54 24 04          	mov    0x4(%esp),%edx
 804bc1b:	b8 f0 b8 04 08       	mov    $0x804b8f0,%eax
 804bc20:	75 05                	jne    804bc27 <movs_v+0x17>
 804bc22:	b8 f0 b9 04 08       	mov    $0x804b9f0,%eax
 804bc27:	89 54 24 04          	mov    %edx,0x4(%esp)
 804bc2b:	ff e0                	jmp    *%eax
 804bc2d:	66 90                	xchg   %ax,%ax
 804bc2f:	90                   	nop

0804bc30 <do_call_w>:
#include "cpu/exec/template-start.h"

#define instr call

static void do_execute() {
 804bc30:	83 ec 10             	sub    $0x10,%esp
	if(instr_fetch(cpu.eip, 1) == 0xff)
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
#elif DATA_BYTE == 2
	reg_w(R_SP)= reg_w(R_SP)- DATA_BYTE;
 804bc33:	0f b7 05 d0 af 0f 10 	movzwl 0x100fafd0,%eax
	swaddr_write(reg_w(R_SP), DATA_BYTE, cpu.ip + 3);
 804bc3a:	0f b7 15 e0 af 0f 10 	movzwl 0x100fafe0,%edx
	if(instr_fetch(cpu.eip, 1) == 0xff)
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
#elif DATA_BYTE == 2
	reg_w(R_SP)= reg_w(R_SP)- DATA_BYTE;
 804bc41:	83 e8 02             	sub    $0x2,%eax
	swaddr_write(reg_w(R_SP), DATA_BYTE, cpu.ip + 3);
 804bc44:	83 c2 03             	add    $0x3,%edx
	if(instr_fetch(cpu.eip, 1) == 0xff)
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
#elif DATA_BYTE == 2
	reg_w(R_SP)= reg_w(R_SP)- DATA_BYTE;
 804bc47:	66 a3 d0 af 0f 10    	mov    %ax,0x100fafd0
	swaddr_write(reg_w(R_SP), DATA_BYTE, cpu.ip + 3);
 804bc4d:	0f b7 c0             	movzwl %ax,%eax
 804bc50:	52                   	push   %edx
 804bc51:	6a 02                	push   $0x2
 804bc53:	50                   	push   %eax
 804bc54:	e8 47 f3 ff ff       	call   804afa0 <swaddr_write>
 804bc59:	58                   	pop    %eax
 804bc5a:	5a                   	pop    %edx
 804bc5b:	6a 01                	push   $0x1
 804bc5d:	ff 35 e0 af 0f 10    	pushl  0x100fafe0
 804bc63:	e8 e8 f2 ff ff       	call   804af50 <swaddr_read>
	if(instr_fetch(cpu.eip, 1) == 0xff)
 804bc68:	83 c4 10             	add    $0x10,%esp
 804bc6b:	3d ff 00 00 00       	cmp    $0xff,%eax
 804bc70:	0f 84 c2 00 00 00    	je     804bd38 <do_call_w+0x108>
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
 804bc76:	a1 e0 af 0f 10       	mov    0x100fafe0,%eax
 804bc7b:	03 05 14 af 0f 10    	add    0x100faf14,%eax
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804bc81:	68 18 af 0f 10       	push   $0x100faf18
 804bc86:	68 ec f4 05 08       	push   $0x805f4ec
	swaddr_write(reg_w(R_SP), DATA_BYTE, cpu.ip + 3);
	if(instr_fetch(cpu.eip, 1) == 0xff)
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
	cpu.eip = cpu.eip & 0xffff;
 804bc8b:	25 ff ff 00 00       	and    $0xffff,%eax
#endif
	print_asm_template1();
 804bc90:	6a 50                	push   $0x50
 804bc92:	68 00 8a 0c 08       	push   $0x80c8a00
	swaddr_write(reg_w(R_SP), DATA_BYTE, cpu.ip + 3);
	if(instr_fetch(cpu.eip, 1) == 0xff)
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
	cpu.eip = cpu.eip & 0xffff;
 804bc97:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
#endif
	print_asm_template1();
 804bc9c:	e8 5f ce ff ff       	call   8048b00 <snprintf@plt>
 804bca1:	83 c4 10             	add    $0x10,%esp
 804bca4:	83 f8 4f             	cmp    $0x4f,%eax
 804bca7:	7f 07                	jg     804bcb0 <do_call_w+0x80>
}
 804bca9:	83 c4 0c             	add    $0xc,%esp
 804bcac:	c3                   	ret    
 804bcad:	8d 76 00             	lea    0x0(%esi),%esi
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804bcb0:	83 ec 0c             	sub    $0xc,%esp
 804bcb3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804bcb9:	e8 a2 cc ff ff       	call   8048960 <fflush@plt>
 804bcbe:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804bcc4:	6a 07                	push   $0x7
 804bcc6:	6a 01                	push   $0x1
 804bcc8:	68 92 e8 05 08       	push   $0x805e892
 804bccd:	e8 3e cd ff ff       	call   8048a10 <fwrite@plt>
 804bcd2:	83 c4 20             	add    $0x20,%esp
 804bcd5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804bcdb:	6a 10                	push   $0x10
 804bcdd:	6a 01                	push   $0x1
 804bcdf:	68 b4 f3 05 08       	push   $0x805f3b4
 804bce4:	e8 27 cd ff ff       	call   8048a10 <fwrite@plt>
 804bce9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804bcef:	6a 05                	push   $0x5
 804bcf1:	6a 01                	push   $0x1
 804bcf3:	68 42 f3 05 08       	push   $0x805f342
 804bcf8:	e8 13 cd ff ff       	call   8048a10 <fwrite@plt>
 804bcfd:	83 c4 20             	add    $0x20,%esp
 804bd00:	68 18 af 0f 10       	push   $0x100faf18
 804bd05:	68 ec f4 05 08       	push   $0x805f4ec
 804bd0a:	6a 50                	push   $0x50
 804bd0c:	68 00 8a 0c 08       	push   $0x80c8a00
 804bd11:	e8 ea cd ff ff       	call   8048b00 <snprintf@plt>
 804bd16:	83 c4 10             	add    $0x10,%esp
 804bd19:	83 f8 4f             	cmp    $0x4f,%eax
 804bd1c:	7e 8b                	jle    804bca9 <do_call_w+0x79>
 804bd1e:	68 c1 f5 05 08       	push   $0x805f5c1
 804bd23:	6a 16                	push   $0x16
 804bd25:	68 00 f5 05 08       	push   $0x805f500
 804bd2a:	68 28 f5 05 08       	push   $0x805f528
 804bd2f:	e8 7c ce ff ff       	call   8048bb0 <__assert_fail@plt>
 804bd34:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + op_src->val;
#elif DATA_BYTE == 2
	reg_w(R_SP)= reg_w(R_SP)- DATA_BYTE;
	swaddr_write(reg_w(R_SP), DATA_BYTE, cpu.ip + 3);
	if(instr_fetch(cpu.eip, 1) == 0xff)
		cpu.eip = op_src->val - 2;
 804bd38:	a1 14 af 0f 10       	mov    0x100faf14,%eax
 804bd3d:	83 e8 02             	sub    $0x2,%eax
 804bd40:	e9 3c ff ff ff       	jmp    804bc81 <do_call_w+0x51>
 804bd45:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804bd49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804bd50 <call_i_w>:
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
}

make_instr_helper(i)
 804bd50:	53                   	push   %ebx
 804bd51:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804bd54:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804bd58:	83 c0 01             	add    $0x1,%eax
 804bd5b:	50                   	push   %eax
 804bd5c:	e8 4f 0a 01 00       	call   805c7b0 <decode_i_w>
 804bd61:	89 c3                	mov    %eax,%ebx
	execute();
 804bd63:	e8 c8 fe ff ff       	call   804bc30 <do_call_w>
 804bd68:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804bd6b:	8d 43 01             	lea    0x1(%ebx),%eax
 804bd6e:	5b                   	pop    %ebx
 804bd6f:	c3                   	ret    

0804bd70 <call_rm_w>:
make_instr_helper(rm)
 804bd70:	53                   	push   %ebx
 804bd71:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804bd74:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804bd78:	83 c0 01             	add    $0x1,%eax
 804bd7b:	50                   	push   %eax
 804bd7c:	e8 df 0b 01 00       	call   805c960 <decode_rm_w>
 804bd81:	89 c3                	mov    %eax,%ebx
	execute();
 804bd83:	e8 a8 fe ff ff       	call   804bc30 <do_call_w>
 804bd88:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804bd8b:	8d 43 01             	lea    0x1(%ebx),%eax
 804bd8e:	5b                   	pop    %ebx
 804bd8f:	c3                   	ret    

0804bd90 <do_call_l>:
#include "cpu/exec/template-start.h"

#define instr call

static void do_execute() {
 804bd90:	83 ec 10             	sub    $0x10,%esp
#if DATA_BYTE == 4
	reg_l(R_ESP) = reg_l(R_ESP) - DATA_BYTE;
	swaddr_write(reg_l(R_ESP), DATA_BYTE, cpu.eip + 5);
 804bd93:	8b 0d e0 af 0f 10    	mov    0x100fafe0,%ecx

#define instr call

static void do_execute() {
#if DATA_BYTE == 4
	reg_l(R_ESP) = reg_l(R_ESP) - DATA_BYTE;
 804bd99:	a1 d0 af 0f 10       	mov    0x100fafd0,%eax
	swaddr_write(reg_l(R_ESP), DATA_BYTE, cpu.eip + 5);
 804bd9e:	8d 51 05             	lea    0x5(%ecx),%edx

#define instr call

static void do_execute() {
#if DATA_BYTE == 4
	reg_l(R_ESP) = reg_l(R_ESP) - DATA_BYTE;
 804bda1:	83 e8 04             	sub    $0x4,%eax
 804bda4:	a3 d0 af 0f 10       	mov    %eax,0x100fafd0
	swaddr_write(reg_l(R_ESP), DATA_BYTE, cpu.eip + 5);
 804bda9:	52                   	push   %edx
 804bdaa:	6a 04                	push   $0x4
 804bdac:	50                   	push   %eax
 804bdad:	e8 ee f1 ff ff       	call   804afa0 <swaddr_write>

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 804bdb2:	58                   	pop    %eax
 804bdb3:	5a                   	pop    %edx
 804bdb4:	6a 01                	push   $0x1
 804bdb6:	ff 35 e0 af 0f 10    	pushl  0x100fafe0
 804bdbc:	e8 8f f1 ff ff       	call   804af50 <swaddr_read>
	if(instr_fetch(cpu.eip, 1) == 0xff)
 804bdc1:	83 c4 10             	add    $0x10,%esp
 804bdc4:	3d ff 00 00 00       	cmp    $0xff,%eax
		cpu.eip = op_src->val - 2;
 804bdc9:	a1 14 af 0f 10       	mov    0x100faf14,%eax

static void do_execute() {
#if DATA_BYTE == 4
	reg_l(R_ESP) = reg_l(R_ESP) - DATA_BYTE;
	swaddr_write(reg_l(R_ESP), DATA_BYTE, cpu.eip + 5);
	if(instr_fetch(cpu.eip, 1) == 0xff)
 804bdce:	0f 84 b4 00 00 00    	je     804be88 <do_call_l+0xf8>
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
 804bdd4:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804bdda:	68 18 af 0f 10       	push   $0x100faf18
 804bddf:	68 f5 f4 05 08       	push   $0x805f4f5
 804bde4:	6a 50                	push   $0x50
 804bde6:	68 00 8a 0c 08       	push   $0x80c8a00
 804bdeb:	e8 10 cd ff ff       	call   8048b00 <snprintf@plt>
 804bdf0:	83 c4 10             	add    $0x10,%esp
 804bdf3:	83 f8 4f             	cmp    $0x4f,%eax
 804bdf6:	7f 08                	jg     804be00 <do_call_l+0x70>
}
 804bdf8:	83 c4 0c             	add    $0xc,%esp
 804bdfb:	c3                   	ret    
 804bdfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = op_src->val - 2;
	else
		cpu.eip = cpu.eip + op_src->val;
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804be00:	83 ec 0c             	sub    $0xc,%esp
 804be03:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804be09:	e8 52 cb ff ff       	call   8048960 <fflush@plt>
 804be0e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804be14:	6a 07                	push   $0x7
 804be16:	6a 01                	push   $0x1
 804be18:	68 92 e8 05 08       	push   $0x805e892
 804be1d:	e8 ee cb ff ff       	call   8048a10 <fwrite@plt>
 804be22:	83 c4 20             	add    $0x20,%esp
 804be25:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804be2b:	6a 10                	push   $0x10
 804be2d:	6a 01                	push   $0x1
 804be2f:	68 b4 f3 05 08       	push   $0x805f3b4
 804be34:	e8 d7 cb ff ff       	call   8048a10 <fwrite@plt>
 804be39:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804be3f:	6a 05                	push   $0x5
 804be41:	6a 01                	push   $0x1
 804be43:	68 42 f3 05 08       	push   $0x805f342
 804be48:	e8 c3 cb ff ff       	call   8048a10 <fwrite@plt>
 804be4d:	83 c4 20             	add    $0x20,%esp
 804be50:	68 18 af 0f 10       	push   $0x100faf18
 804be55:	68 f5 f4 05 08       	push   $0x805f4f5
 804be5a:	6a 50                	push   $0x50
 804be5c:	68 00 8a 0c 08       	push   $0x80c8a00
 804be61:	e8 9a cc ff ff       	call   8048b00 <snprintf@plt>
 804be66:	83 c4 10             	add    $0x10,%esp
 804be69:	83 f8 4f             	cmp    $0x4f,%eax
 804be6c:	7e 8a                	jle    804bdf8 <do_call_l+0x68>
 804be6e:	68 b7 f5 05 08       	push   $0x805f5b7
 804be73:	6a 16                	push   $0x16
 804be75:	68 00 f5 05 08       	push   $0x805f500
 804be7a:	68 70 f5 05 08       	push   $0x805f570
 804be7f:	e8 2c cd ff ff       	call   8048bb0 <__assert_fail@plt>
 804be84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static void do_execute() {
#if DATA_BYTE == 4
	reg_l(R_ESP) = reg_l(R_ESP) - DATA_BYTE;
	swaddr_write(reg_l(R_ESP), DATA_BYTE, cpu.eip + 5);
	if(instr_fetch(cpu.eip, 1) == 0xff)
		cpu.eip = op_src->val - 2;
 804be88:	83 e8 02             	sub    $0x2,%eax
 804be8b:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
 804be90:	e9 45 ff ff ff       	jmp    804bdda <do_call_l+0x4a>
 804be95:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 804be99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804bea0 <call_i_l>:
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
}

make_instr_helper(i)
 804bea0:	53                   	push   %ebx
 804bea1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804bea4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804bea8:	83 c0 01             	add    $0x1,%eax
 804beab:	50                   	push   %eax
 804beac:	e8 8f 0c 01 00       	call   805cb40 <decode_i_l>
 804beb1:	89 c3                	mov    %eax,%ebx
	execute();
 804beb3:	e8 d8 fe ff ff       	call   804bd90 <do_call_l>
 804beb8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804bebb:	8d 43 01             	lea    0x1(%ebx),%eax
 804bebe:	5b                   	pop    %ebx
 804bebf:	c3                   	ret    

0804bec0 <call_rm_l>:
make_instr_helper(rm)
 804bec0:	53                   	push   %ebx
 804bec1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804bec4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804bec8:	83 c0 01             	add    $0x1,%eax
 804becb:	50                   	push   %eax
 804becc:	e8 5f 0e 01 00       	call   805cd30 <decode_rm_l>
 804bed1:	89 c3                	mov    %eax,%ebx
	execute();
 804bed3:	e8 b8 fe ff ff       	call   804bd90 <do_call_l>
 804bed8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804bedb:	8d 43 01             	lea    0x1(%ebx),%eax
 804bede:	5b                   	pop    %ebx
 804bedf:	c3                   	ret    

0804bee0 <call_i_v>:
#include "call-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(call_i)
 804bee0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804bee7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804beeb:	b8 50 bd 04 08       	mov    $0x804bd50,%eax
 804bef0:	75 05                	jne    804bef7 <call_i_v+0x17>
 804bef2:	b8 a0 be 04 08       	mov    $0x804bea0,%eax
 804bef7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804befb:	ff e0                	jmp    *%eax
 804befd:	8d 76 00             	lea    0x0(%esi),%esi

0804bf00 <call_rm_v>:
make_helper_v(call_rm)
 804bf00:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804bf07:	8b 54 24 04          	mov    0x4(%esp),%edx
 804bf0b:	b8 70 bd 04 08       	mov    $0x804bd70,%eax
 804bf10:	75 05                	jne    804bf17 <call_rm_v+0x17>
 804bf12:	b8 c0 be 04 08       	mov    $0x804bec0,%eax
 804bf17:	89 54 24 04          	mov    %edx,0x4(%esp)
 804bf1b:	ff e0                	jmp    *%eax
 804bf1d:	66 90                	xchg   %ax,%ax
 804bf1f:	90                   	nop

0804bf20 <cld>:
#include "cpu/exec/helper.h"

int cld(uint32_t eip) {
	cpu.DF = 0;
 804bf20:	80 25 e5 af 0f 10 fb 	andb   $0xfb,0x100fafe5
	return 1;
}
 804bf27:	b8 01 00 00 00       	mov    $0x1,%eax
 804bf2c:	c3                   	ret    
 804bf2d:	66 90                	xchg   %ax,%ax
 804bf2f:	90                   	nop

0804bf30 <ret_i_w>:
#include "cpu/exec/template-start.h"

#define instr ret

make_helper(ret_i_w) {
 804bf30:	53                   	push   %ebx
	decode_i_w(eip + 1);
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
 804bf31:	bb 04 00 00 00       	mov    $0x4,%ebx
#include "cpu/exec/template-start.h"

#define instr ret

make_helper(ret_i_w) {
 804bf36:	83 ec 14             	sub    $0x14,%esp
	decode_i_w(eip + 1);
 804bf39:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804bf3d:	83 c0 01             	add    $0x1,%eax
 804bf40:	50                   	push   %eax
 804bf41:	e8 6a 08 01 00       	call   805c7b0 <decode_i_w>
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
 804bf46:	0f b6 0d 04 af 0f 10 	movzbl 0x100faf04,%ecx
 804bf4d:	58                   	pop    %eax
 804bf4e:	89 d8                	mov    %ebx,%eax
 804bf50:	5a                   	pop    %edx
 804bf51:	d3 f8                	sar    %cl,%eax
 804bf53:	50                   	push   %eax
 804bf54:	ff 35 d0 af 0f 10    	pushl  0x100fafd0
 804bf5a:	e8 f1 ef ff ff       	call   804af50 <swaddr_read>
	reg_l(R_ESP) = reg_l(R_ESP) + (4 >> ops_decoded.is_data_size_16);
 804bf5f:	0f b6 0d 04 af 0f 10 	movzbl 0x100faf04,%ecx

#define instr ret

make_helper(ret_i_w) {
	decode_i_w(eip + 1);
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
 804bf66:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
 804bf6b:	a1 d0 af 0f 10       	mov    0x100fafd0,%eax
 804bf70:	03 05 14 af 0f 10    	add    0x100faf14,%eax
	reg_l(R_ESP) = reg_l(R_ESP) + (4 >> ops_decoded.is_data_size_16);
	reg_l(R_ESP) += op_src->val;
	print_asm_template1();
 804bf76:	68 18 af 0f 10       	push   $0x100faf18
 804bf7b:	68 cb f5 05 08       	push   $0x805f5cb
 804bf80:	6a 50                	push   $0x50
 804bf82:	68 00 8a 0c 08       	push   $0x80c8a00
#define instr ret

make_helper(ret_i_w) {
	decode_i_w(eip + 1);
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
	reg_l(R_ESP) = reg_l(R_ESP) + (4 >> ops_decoded.is_data_size_16);
 804bf87:	d3 fb                	sar    %cl,%ebx
	reg_l(R_ESP) += op_src->val;
 804bf89:	01 c3                	add    %eax,%ebx
 804bf8b:	89 1d d0 af 0f 10    	mov    %ebx,0x100fafd0
	print_asm_template1();
 804bf91:	e8 6a cb ff ff       	call   8048b00 <snprintf@plt>
 804bf96:	83 c4 20             	add    $0x20,%esp
 804bf99:	83 f8 4f             	cmp    $0x4f,%eax
 804bf9c:	7f 0a                	jg     804bfa8 <ret_i_w+0x78>
	return 0;
}
 804bf9e:	83 c4 08             	add    $0x8,%esp
 804bfa1:	31 c0                	xor    %eax,%eax
 804bfa3:	5b                   	pop    %ebx
 804bfa4:	c3                   	ret    
 804bfa5:	8d 76 00             	lea    0x0(%esi),%esi
make_helper(ret_i_w) {
	decode_i_w(eip + 1);
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
	reg_l(R_ESP) = reg_l(R_ESP) + (4 >> ops_decoded.is_data_size_16);
	reg_l(R_ESP) += op_src->val;
	print_asm_template1();
 804bfa8:	83 ec 0c             	sub    $0xc,%esp
 804bfab:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804bfb1:	e8 aa c9 ff ff       	call   8048960 <fflush@plt>
 804bfb6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804bfbc:	6a 07                	push   $0x7
 804bfbe:	6a 01                	push   $0x1
 804bfc0:	68 92 e8 05 08       	push   $0x805e892
 804bfc5:	e8 46 ca ff ff       	call   8048a10 <fwrite@plt>
 804bfca:	83 c4 20             	add    $0x20,%esp
 804bfcd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804bfd3:	6a 10                	push   $0x10
 804bfd5:	6a 01                	push   $0x1
 804bfd7:	68 b4 f3 05 08       	push   $0x805f3b4
 804bfdc:	e8 2f ca ff ff       	call   8048a10 <fwrite@plt>
 804bfe1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804bfe7:	6a 05                	push   $0x5
 804bfe9:	6a 01                	push   $0x1
 804bfeb:	68 42 f3 05 08       	push   $0x805f342
 804bff0:	e8 1b ca ff ff       	call   8048a10 <fwrite@plt>
 804bff5:	83 c4 20             	add    $0x20,%esp
 804bff8:	68 18 af 0f 10       	push   $0x100faf18
 804bffd:	68 cb f5 05 08       	push   $0x805f5cb
 804c002:	6a 50                	push   $0x50
 804c004:	68 00 8a 0c 08       	push   $0x80c8a00
 804c009:	e8 f2 ca ff ff       	call   8048b00 <snprintf@plt>
 804c00e:	83 c4 10             	add    $0x10,%esp
 804c011:	83 f8 4f             	cmp    $0x4f,%eax
 804c014:	7e 88                	jle    804bf9e <ret_i_w+0x6e>
 804c016:	68 bb f6 05 08       	push   $0x805f6bb
 804c01b:	6a 0a                	push   $0xa
 804c01d:	68 fc f5 05 08       	push   $0x805f5fc
 804c022:	68 24 f6 05 08       	push   $0x805f624
 804c027:	e8 84 cb ff ff       	call   8048bb0 <__assert_fail@plt>
 804c02c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804c030 <ret>:
#include "ret-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper(ret) {
 804c030:	53                   	push   %ebx
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
 804c031:	bb 04 00 00 00       	mov    $0x4,%ebx
 804c036:	89 d8                	mov    %ebx,%eax
#include "ret-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper(ret) {
 804c038:	83 ec 10             	sub    $0x10,%esp
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
 804c03b:	0f b6 0d 04 af 0f 10 	movzbl 0x100faf04,%ecx
 804c042:	d3 f8                	sar    %cl,%eax
 804c044:	50                   	push   %eax
 804c045:	ff 35 d0 af 0f 10    	pushl  0x100fafd0
 804c04b:	e8 00 ef ff ff       	call   804af50 <swaddr_read>
	reg_l(R_ESP) = reg_l(R_ESP) + (4 >> ops_decoded.is_data_size_16);
 804c050:	0f b6 0d 04 af 0f 10 	movzbl 0x100faf04,%ecx
	print_asm_template1();
 804c057:	68 18 af 0f 10       	push   $0x100faf18
 804c05c:	68 d3 f5 05 08       	push   $0x805f5d3
 804c061:	6a 50                	push   $0x50
 804c063:	68 00 8a 0c 08       	push   $0x80c8a00
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper(ret) {
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
 804c068:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
	reg_l(R_ESP) = reg_l(R_ESP) + (4 >> ops_decoded.is_data_size_16);
 804c06d:	d3 fb                	sar    %cl,%ebx
 804c06f:	01 1d d0 af 0f 10    	add    %ebx,0x100fafd0
	print_asm_template1();
 804c075:	e8 86 ca ff ff       	call   8048b00 <snprintf@plt>
 804c07a:	83 c4 20             	add    $0x20,%esp
 804c07d:	83 f8 4f             	cmp    $0x4f,%eax
 804c080:	7f 0e                	jg     804c090 <ret+0x60>
	return 0;
}
 804c082:	83 c4 08             	add    $0x8,%esp
 804c085:	31 c0                	xor    %eax,%eax
 804c087:	5b                   	pop    %ebx
 804c088:	c3                   	ret    
 804c089:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
/* for instruction encoding overloading */

make_helper(ret) {
	cpu.eip = swaddr_read(reg_l(R_ESP), (4 >> ops_decoded.is_data_size_16)); 
	reg_l(R_ESP) = reg_l(R_ESP) + (4 >> ops_decoded.is_data_size_16);
	print_asm_template1();
 804c090:	83 ec 0c             	sub    $0xc,%esp
 804c093:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804c099:	e8 c2 c8 ff ff       	call   8048960 <fflush@plt>
 804c09e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c0a4:	6a 07                	push   $0x7
 804c0a6:	6a 01                	push   $0x1
 804c0a8:	68 92 e8 05 08       	push   $0x805e892
 804c0ad:	e8 5e c9 ff ff       	call   8048a10 <fwrite@plt>
 804c0b2:	83 c4 20             	add    $0x20,%esp
 804c0b5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c0bb:	6a 10                	push   $0x10
 804c0bd:	6a 01                	push   $0x1
 804c0bf:	68 b4 f3 05 08       	push   $0x805f3b4
 804c0c4:	e8 47 c9 ff ff       	call   8048a10 <fwrite@plt>
 804c0c9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c0cf:	6a 05                	push   $0x5
 804c0d1:	6a 01                	push   $0x1
 804c0d3:	68 42 f3 05 08       	push   $0x805f342
 804c0d8:	e8 33 c9 ff ff       	call   8048a10 <fwrite@plt>
 804c0dd:	83 c4 20             	add    $0x20,%esp
 804c0e0:	68 18 af 0f 10       	push   $0x100faf18
 804c0e5:	68 d3 f5 05 08       	push   $0x805f5d3
 804c0ea:	6a 50                	push   $0x50
 804c0ec:	68 00 8a 0c 08       	push   $0x80c8a00
 804c0f1:	e8 0a ca ff ff       	call   8048b00 <snprintf@plt>
 804c0f6:	83 c4 10             	add    $0x10,%esp
 804c0f9:	83 f8 4f             	cmp    $0x4f,%eax
 804c0fc:	7e 84                	jle    804c082 <ret+0x52>
 804c0fe:	68 b7 f6 05 08       	push   $0x805f6b7
 804c103:	6a 0c                	push   $0xc
 804c105:	68 e0 f5 05 08       	push   $0x805f5e0
 804c10a:	68 6c f6 05 08       	push   $0x805f66c
 804c10f:	e8 9c ca ff ff       	call   8048bb0 <__assert_fail@plt>
 804c114:	66 90                	xchg   %ax,%ax
 804c116:	66 90                	xchg   %ax,%ax
 804c118:	66 90                	xchg   %ax,%ax
 804c11a:	66 90                	xchg   %ax,%ax
 804c11c:	66 90                	xchg   %ax,%ax
 804c11e:	66 90                	xchg   %ax,%ax

0804c120 <leave_r_l>:
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
}

make_instr_helper(r)
 804c120:	53                   	push   %ebx
 804c121:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804c124:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804c128:	83 c0 01             	add    $0x1,%eax
 804c12b:	50                   	push   %eax
 804c12c:	e8 1f 0c 01 00       	call   805cd50 <decode_r_l>
 804c131:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
 804c133:	a1 d4 af 0f 10       	mov    0x100fafd4,%eax
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c138:	5a                   	pop    %edx
 804c139:	59                   	pop    %ecx
 804c13a:	6a 04                	push   $0x4
 804c13c:	50                   	push   %eax
#include "cpu/exec/template-start.h"

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
 804c13d:	a3 d0 af 0f 10       	mov    %eax,0x100fafd0
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c142:	e8 09 ee ff ff       	call   804af50 <swaddr_read>
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c147:	68 18 af 0f 10       	push   $0x100faf18
 804c14c:	68 c3 f6 05 08       	push   $0x805f6c3
 804c151:	6a 50                	push   $0x50
 804c153:	68 00 8a 0c 08       	push   $0x80c8a00
#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
	reg_l(R_ESP) += DATA_BYTE;
 804c158:	83 05 d0 af 0f 10 04 	addl   $0x4,0x100fafd0

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c15f:	a3 d4 af 0f 10       	mov    %eax,0x100fafd4
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c164:	e8 97 c9 ff ff       	call   8048b00 <snprintf@plt>
 804c169:	83 c4 20             	add    $0x20,%esp
 804c16c:	83 f8 4f             	cmp    $0x4f,%eax
 804c16f:	7f 0f                	jg     804c180 <leave_r_l+0x60>
}

make_instr_helper(r)
 804c171:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804c174:	8d 43 01             	lea    0x1(%ebx),%eax
 804c177:	5b                   	pop    %ebx
 804c178:	c3                   	ret    
 804c179:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c180:	83 ec 0c             	sub    $0xc,%esp
 804c183:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804c189:	e8 d2 c7 ff ff       	call   8048960 <fflush@plt>
 804c18e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c194:	6a 07                	push   $0x7
 804c196:	6a 01                	push   $0x1
 804c198:	68 92 e8 05 08       	push   $0x805e892
 804c19d:	e8 6e c8 ff ff       	call   8048a10 <fwrite@plt>
 804c1a2:	83 c4 20             	add    $0x20,%esp
 804c1a5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c1ab:	6a 10                	push   $0x10
 804c1ad:	6a 01                	push   $0x1
 804c1af:	68 b4 f3 05 08       	push   $0x805f3b4
 804c1b4:	e8 57 c8 ff ff       	call   8048a10 <fwrite@plt>
 804c1b9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c1bf:	6a 05                	push   $0x5
 804c1c1:	6a 01                	push   $0x1
 804c1c3:	68 42 f3 05 08       	push   $0x805f342
 804c1c8:	e8 43 c8 ff ff       	call   8048a10 <fwrite@plt>
 804c1cd:	83 c4 20             	add    $0x20,%esp
 804c1d0:	68 18 af 0f 10       	push   $0x100faf18
 804c1d5:	68 c3 f6 05 08       	push   $0x805f6c3
 804c1da:	6a 50                	push   $0x50
 804c1dc:	68 00 8a 0c 08       	push   $0x80c8a00
 804c1e1:	e8 1a c9 ff ff       	call   8048b00 <snprintf@plt>
 804c1e6:	83 c4 10             	add    $0x10,%esp
 804c1e9:	83 f8 4f             	cmp    $0x4f,%eax
 804c1ec:	7e 83                	jle    804c171 <leave_r_l+0x51>
 804c1ee:	68 e8 f7 05 08       	push   $0x805f7e8
 804c1f3:	6a 09                	push   $0x9
 804c1f5:	68 e4 f6 05 08       	push   $0x805f6e4
 804c1fa:	68 10 f7 05 08       	push   $0x805f710
 804c1ff:	e8 ac c9 ff ff       	call   8048bb0 <__assert_fail@plt>
 804c204:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804c20a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804c210 <leave_r_w>:
}

make_instr_helper(r)
 804c210:	53                   	push   %ebx
 804c211:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804c214:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804c218:	83 c0 01             	add    $0x1,%eax
 804c21b:	50                   	push   %eax
 804c21c:	e8 5f 07 01 00       	call   805c980 <decode_r_w>
 804c221:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
 804c223:	a1 d4 af 0f 10       	mov    0x100fafd4,%eax
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c228:	5a                   	pop    %edx
 804c229:	59                   	pop    %ecx
 804c22a:	6a 02                	push   $0x2
 804c22c:	50                   	push   %eax
#include "cpu/exec/template-start.h"

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
 804c22d:	a3 d0 af 0f 10       	mov    %eax,0x100fafd0
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c232:	e8 19 ed ff ff       	call   804af50 <swaddr_read>
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c237:	68 18 af 0f 10       	push   $0x100faf18
 804c23c:	68 cd f6 05 08       	push   $0x805f6cd
 804c241:	6a 50                	push   $0x50
 804c243:	68 00 8a 0c 08       	push   $0x80c8a00
#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
	reg_l(R_ESP) += DATA_BYTE;
 804c248:	83 05 d0 af 0f 10 02 	addl   $0x2,0x100fafd0

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c24f:	66 a3 d4 af 0f 10    	mov    %ax,0x100fafd4
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c255:	e8 a6 c8 ff ff       	call   8048b00 <snprintf@plt>
 804c25a:	83 c4 20             	add    $0x20,%esp
 804c25d:	83 f8 4f             	cmp    $0x4f,%eax
 804c260:	7f 0e                	jg     804c270 <leave_r_w+0x60>
}

make_instr_helper(r)
 804c262:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804c265:	8d 43 01             	lea    0x1(%ebx),%eax
 804c268:	5b                   	pop    %ebx
 804c269:	c3                   	ret    
 804c26a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c270:	83 ec 0c             	sub    $0xc,%esp
 804c273:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804c279:	e8 e2 c6 ff ff       	call   8048960 <fflush@plt>
 804c27e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c284:	6a 07                	push   $0x7
 804c286:	6a 01                	push   $0x1
 804c288:	68 92 e8 05 08       	push   $0x805e892
 804c28d:	e8 7e c7 ff ff       	call   8048a10 <fwrite@plt>
 804c292:	83 c4 20             	add    $0x20,%esp
 804c295:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c29b:	6a 10                	push   $0x10
 804c29d:	6a 01                	push   $0x1
 804c29f:	68 b4 f3 05 08       	push   $0x805f3b4
 804c2a4:	e8 67 c7 ff ff       	call   8048a10 <fwrite@plt>
 804c2a9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c2af:	6a 05                	push   $0x5
 804c2b1:	6a 01                	push   $0x1
 804c2b3:	68 42 f3 05 08       	push   $0x805f342
 804c2b8:	e8 53 c7 ff ff       	call   8048a10 <fwrite@plt>
 804c2bd:	83 c4 20             	add    $0x20,%esp
 804c2c0:	68 18 af 0f 10       	push   $0x100faf18
 804c2c5:	68 cd f6 05 08       	push   $0x805f6cd
 804c2ca:	6a 50                	push   $0x50
 804c2cc:	68 00 8a 0c 08       	push   $0x80c8a00
 804c2d1:	e8 2a c8 ff ff       	call   8048b00 <snprintf@plt>
 804c2d6:	83 c4 10             	add    $0x10,%esp
 804c2d9:	83 f8 4f             	cmp    $0x4f,%eax
 804c2dc:	7e 84                	jle    804c262 <leave_r_w+0x52>
 804c2de:	68 f3 f7 05 08       	push   $0x805f7f3
 804c2e3:	6a 09                	push   $0x9
 804c2e5:	68 e4 f6 05 08       	push   $0x805f6e4
 804c2ea:	68 58 f7 05 08       	push   $0x805f758
 804c2ef:	e8 bc c8 ff ff       	call   8048bb0 <__assert_fail@plt>
 804c2f4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804c2fa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804c300 <leave_r_b>:
}

make_instr_helper(r)
 804c300:	53                   	push   %ebx
 804c301:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804c304:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804c308:	83 c0 01             	add    $0x1,%eax
 804c30b:	50                   	push   %eax
 804c30c:	e8 3f 03 01 00       	call   805c650 <decode_r_b>
 804c311:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
 804c313:	a1 d4 af 0f 10       	mov    0x100fafd4,%eax
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c318:	5a                   	pop    %edx
 804c319:	59                   	pop    %ecx
 804c31a:	6a 01                	push   $0x1
 804c31c:	50                   	push   %eax
#include "cpu/exec/template-start.h"

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
 804c31d:	a3 d0 af 0f 10       	mov    %eax,0x100fafd0
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c322:	e8 29 ec ff ff       	call   804af50 <swaddr_read>
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c327:	68 18 af 0f 10       	push   $0x100faf18
 804c32c:	68 d7 f6 05 08       	push   $0x805f6d7
 804c331:	6a 50                	push   $0x50
 804c333:	68 00 8a 0c 08       	push   $0x80c8a00
#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
	reg_l(R_ESP) += DATA_BYTE;
 804c338:	83 05 d0 af 0f 10 01 	addl   $0x1,0x100fafd0

#define instr leave

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
 804c33f:	a2 c5 af 0f 10       	mov    %al,0x100fafc5
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c344:	e8 b7 c7 ff ff       	call   8048b00 <snprintf@plt>
 804c349:	83 c4 20             	add    $0x20,%esp
 804c34c:	83 f8 4f             	cmp    $0x4f,%eax
 804c34f:	7f 0f                	jg     804c360 <leave_r_b+0x60>
}

make_instr_helper(r)
 804c351:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804c354:	8d 43 01             	lea    0x1(%ebx),%eax
 804c357:	5b                   	pop    %ebx
 804c358:	c3                   	ret    
 804c359:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_EBP);
	concat(reg_, SUFFIX)(R_EBP) = swaddr_read(reg_l(R_ESP), DATA_BYTE);
	reg_l(R_ESP) += DATA_BYTE;
	print_asm_template1();
 804c360:	83 ec 0c             	sub    $0xc,%esp
 804c363:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804c369:	e8 f2 c5 ff ff       	call   8048960 <fflush@plt>
 804c36e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c374:	6a 07                	push   $0x7
 804c376:	6a 01                	push   $0x1
 804c378:	68 92 e8 05 08       	push   $0x805e892
 804c37d:	e8 8e c6 ff ff       	call   8048a10 <fwrite@plt>
 804c382:	83 c4 20             	add    $0x20,%esp
 804c385:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c38b:	6a 10                	push   $0x10
 804c38d:	6a 01                	push   $0x1
 804c38f:	68 b4 f3 05 08       	push   $0x805f3b4
 804c394:	e8 77 c6 ff ff       	call   8048a10 <fwrite@plt>
 804c399:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c39f:	6a 05                	push   $0x5
 804c3a1:	6a 01                	push   $0x1
 804c3a3:	68 42 f3 05 08       	push   $0x805f342
 804c3a8:	e8 63 c6 ff ff       	call   8048a10 <fwrite@plt>
 804c3ad:	83 c4 20             	add    $0x20,%esp
 804c3b0:	68 18 af 0f 10       	push   $0x100faf18
 804c3b5:	68 d7 f6 05 08       	push   $0x805f6d7
 804c3ba:	6a 50                	push   $0x50
 804c3bc:	68 00 8a 0c 08       	push   $0x80c8a00
 804c3c1:	e8 3a c7 ff ff       	call   8048b00 <snprintf@plt>
 804c3c6:	83 c4 10             	add    $0x10,%esp
 804c3c9:	83 f8 4f             	cmp    $0x4f,%eax
 804c3cc:	7e 83                	jle    804c351 <leave_r_b+0x51>
 804c3ce:	68 fe f7 05 08       	push   $0x805f7fe
 804c3d3:	6a 09                	push   $0x9
 804c3d5:	68 e4 f6 05 08       	push   $0x805f6e4
 804c3da:	68 a0 f7 05 08       	push   $0x805f7a0
 804c3df:	e8 cc c7 ff ff       	call   8048bb0 <__assert_fail@plt>
 804c3e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804c3ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804c3f0 <leave_r_v>:
#include "leave-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(leave_r)
 804c3f0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804c3f7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804c3fb:	b8 10 c2 04 08       	mov    $0x804c210,%eax
 804c400:	75 05                	jne    804c407 <leave_r_v+0x17>
 804c402:	b8 20 c1 04 08       	mov    $0x804c120,%eax
 804c407:	89 54 24 04          	mov    %edx,0x4(%esp)
 804c40b:	ff e0                	jmp    *%eax
 804c40d:	66 90                	xchg   %ax,%ax
 804c40f:	90                   	nop

0804c410 <cmps_w>:
#include "cpu/exec/template-start.h"

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
 804c410:	0f b7 15 dc af 0f 10 	movzwl 0x100fafdc,%edx
 804c417:	0f b7 0d d8 af 0f 10 	movzwl 0x100fafd8,%ecx
#include "cpu/exec/template-start.h"

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
 804c41e:	57                   	push   %edi
 804c41f:	56                   	push   %esi
 804c420:	53                   	push   %ebx
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804c421:	68 18 af 0f 10       	push   $0x100faf18
 804c426:	68 09 f8 05 08       	push   $0x805f809
 804c42b:	6a 50                	push   $0x50
#include "cpu/exec/template-start.h"

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
 804c42d:	89 cb                	mov    %ecx,%ebx
 804c42f:	29 d1                	sub    %edx,%ecx
 804c431:	89 d6                	mov    %edx,%esi
	uint32_t pf = (res & 255);
 804c433:	0f b6 d1             	movzbl %cl,%edx
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804c436:	68 00 8a 0c 08       	push   $0x80c8a00
#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 804c43b:	89 d0                	mov    %edx,%eax
 804c43d:	c1 e8 04             	shr    $0x4,%eax
 804c440:	31 c2                	xor    %eax,%edx
	pf = (pf >> 2) ^ pf;
 804c442:	89 d0                	mov    %edx,%eax
 804c444:	c1 e8 02             	shr    $0x2,%eax
 804c447:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 804c449:	89 c2                	mov    %eax,%edx
 804c44b:	d1 ea                	shr    %edx
 804c44d:	89 d7                	mov    %edx,%edi
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c44f:	89 f2                	mov    %esi,%edx
 804c451:	0f b6 35 e4 af 0f 10 	movzbl 0x100fafe4,%esi
make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 804c458:	31 c7                	xor    %eax,%edi
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c45a:	29 d3                	sub    %edx,%ebx
make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 804c45c:	89 fa                	mov    %edi,%edx
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c45e:	83 e3 01             	and    $0x1,%ebx
	cpu.PF = (pf & 1);
 804c461:	83 e2 01             	and    $0x1,%edx
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c464:	83 e6 fa             	and    $0xfffffffa,%esi
	cpu.PF = (pf & 1);
 804c467:	c1 e2 02             	shl    $0x2,%edx
 804c46a:	89 f0                	mov    %esi,%eax
 804c46c:	09 d8                	or     %ebx,%eax
 804c46e:	09 d0                	or     %edx,%eax
	cpu.ZF = (res == 0);
 804c470:	85 c9                	test   %ecx,%ecx
 804c472:	0f 94 c2             	sete   %dl
 804c475:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = (res >> 31) & 1;
 804c478:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 804c47b:	c1 e2 06             	shl    $0x6,%edx
	cpu.SF = (res >> 31) & 1;
 804c47e:	c1 e1 07             	shl    $0x7,%ecx
 804c481:	09 d0                	or     %edx,%eax
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c483:	ba 01 00 00 00       	mov    $0x1,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 804c488:	09 c8                	or     %ecx,%eax
 804c48a:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
 804c48f:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
 804c496:	83 e0 f7             	and    $0xfffffff7,%eax
 804c499:	a2 e5 af 0f 10       	mov    %al,0x100fafe5
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c49e:	c0 e8 02             	shr    $0x2,%al
 804c4a1:	83 e0 01             	and    $0x1,%eax
 804c4a4:	01 c0                	add    %eax,%eax
 804c4a6:	29 c2                	sub    %eax,%edx
 804c4a8:	89 d0                	mov    %edx,%eax
 804c4aa:	01 c0                	add    %eax,%eax
 804c4ac:	01 05 d8 af 0f 10    	add    %eax,0x100fafd8
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c4b2:	01 05 dc af 0f 10    	add    %eax,0x100fafdc
	print_asm_template1();
 804c4b8:	e8 43 c6 ff ff       	call   8048b00 <snprintf@plt>
 804c4bd:	83 c4 10             	add    $0x10,%esp
 804c4c0:	83 f8 4f             	cmp    $0x4f,%eax
 804c4c3:	7f 0b                	jg     804c4d0 <cmps_w+0xc0>
	return 1;
}
 804c4c5:	b8 01 00 00 00       	mov    $0x1,%eax
 804c4ca:	5b                   	pop    %ebx
 804c4cb:	5e                   	pop    %esi
 804c4cc:	5f                   	pop    %edi
 804c4cd:	c3                   	ret    
 804c4ce:	66 90                	xchg   %ax,%ax
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804c4d0:	83 ec 0c             	sub    $0xc,%esp
 804c4d3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804c4d9:	e8 82 c4 ff ff       	call   8048960 <fflush@plt>
 804c4de:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c4e4:	6a 07                	push   $0x7
 804c4e6:	6a 01                	push   $0x1
 804c4e8:	68 92 e8 05 08       	push   $0x805e892
 804c4ed:	e8 1e c5 ff ff       	call   8048a10 <fwrite@plt>
 804c4f2:	83 c4 20             	add    $0x20,%esp
 804c4f5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c4fb:	6a 10                	push   $0x10
 804c4fd:	6a 01                	push   $0x1
 804c4ff:	68 b4 f3 05 08       	push   $0x805f3b4
 804c504:	e8 07 c5 ff ff       	call   8048a10 <fwrite@plt>
 804c509:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c50f:	6a 05                	push   $0x5
 804c511:	6a 01                	push   $0x1
 804c513:	68 42 f3 05 08       	push   $0x805f342
 804c518:	e8 f3 c4 ff ff       	call   8048a10 <fwrite@plt>
 804c51d:	83 c4 20             	add    $0x20,%esp
 804c520:	68 18 af 0f 10       	push   $0x100faf18
 804c525:	68 09 f8 05 08       	push   $0x805f809
 804c52a:	6a 50                	push   $0x50
 804c52c:	68 00 8a 0c 08       	push   $0x80c8a00
 804c531:	e8 ca c5 ff ff       	call   8048b00 <snprintf@plt>
 804c536:	83 c4 10             	add    $0x10,%esp
 804c539:	83 f8 4f             	cmp    $0x4f,%eax
 804c53c:	7e 87                	jle    804c4c5 <cmps_w+0xb5>
 804c53e:	68 2a f9 05 08       	push   $0x805f92a
 804c543:	6a 12                	push   $0x12
 804c545:	68 24 f8 05 08       	push   $0x805f824
 804c54a:	68 4c f8 05 08       	push   $0x805f84c
 804c54f:	e8 5c c6 ff ff       	call   8048bb0 <__assert_fail@plt>
 804c554:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804c55a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804c560 <cmps_l>:
#include "cpu/exec/template-start.h"

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
 804c560:	55                   	push   %ebp
 804c561:	57                   	push   %edi
 804c562:	56                   	push   %esi
 804c563:	53                   	push   %ebx
 804c564:	83 ec 0c             	sub    $0xc,%esp
	uint32_t res = REG(R_ESI) - REG(R_EDI);
 804c567:	8b 0d d8 af 0f 10    	mov    0x100fafd8,%ecx
 804c56d:	8b 15 dc af 0f 10    	mov    0x100fafdc,%edx
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804c573:	68 18 af 0f 10       	push   $0x100faf18
 804c578:	68 12 f8 05 08       	push   $0x805f812
 804c57d:	6a 50                	push   $0x50
 804c57f:	68 00 8a 0c 08       	push   $0x80c8a00
#include "cpu/exec/template-start.h"

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
 804c584:	89 cf                	mov    %ecx,%edi
 804c586:	29 d7                	sub    %edx,%edi
	uint32_t pf = (res & 255);
 804c588:	89 f8                	mov    %edi,%eax
 804c58a:	0f b6 c0             	movzbl %al,%eax
	pf = (pf >> 4) ^ pf;
 804c58d:	89 c3                	mov    %eax,%ebx
 804c58f:	c1 eb 04             	shr    $0x4,%ebx
 804c592:	31 d8                	xor    %ebx,%eax
	pf = (pf >> 2) ^ pf;
 804c594:	89 c3                	mov    %eax,%ebx
 804c596:	c1 eb 02             	shr    $0x2,%ebx
 804c599:	31 d8                	xor    %ebx,%eax
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c59b:	89 cb                	mov    %ecx,%ebx
 804c59d:	29 d3                	sub    %edx,%ebx
make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 804c59f:	89 c6                	mov    %eax,%esi
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c5a1:	83 e3 01             	and    $0x1,%ebx
make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 804c5a4:	d1 ee                	shr    %esi
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c5a6:	89 dd                	mov    %ebx,%ebp
 804c5a8:	0f b6 1d e4 af 0f 10 	movzbl 0x100fafe4,%ebx
make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 804c5af:	31 f0                	xor    %esi,%eax
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
 804c5b1:	83 e0 01             	and    $0x1,%eax
 804c5b4:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c5bb:	83 e3 fa             	and    $0xfffffffa,%ebx
	cpu.PF = (pf & 1);
 804c5be:	09 eb                	or     %ebp,%ebx
 804c5c0:	09 f3                	or     %esi,%ebx
	cpu.ZF = (res == 0);
 804c5c2:	85 ff                	test   %edi,%edi
 804c5c4:	0f 94 c0             	sete   %al
	cpu.SF = (res >> 31) & 1;
 804c5c7:	c1 ef 1f             	shr    $0x1f,%edi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 804c5ca:	83 e3 3f             	and    $0x3f,%ebx
 804c5cd:	c1 e0 06             	shl    $0x6,%eax
	cpu.SF = (res >> 31) & 1;
 804c5d0:	89 fd                	mov    %edi,%ebp
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 804c5d2:	89 c6                	mov    %eax,%esi
	cpu.SF = (res >> 31) & 1;
 804c5d4:	c1 e5 07             	shl    $0x7,%ebp
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
 804c5d7:	89 c8                	mov    %ecx,%eax
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 804c5d9:	09 f3                	or     %esi,%ebx
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
 804c5db:	c1 e8 1f             	shr    $0x1f,%eax
 804c5de:	83 c1 04             	add    $0x4,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 804c5e1:	09 eb                	or     %ebp,%ebx
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
 804c5e3:	31 c7                	xor    %eax,%edi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 804c5e5:	88 1d e4 af 0f 10    	mov    %bl,0x100fafe4
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
 804c5eb:	89 d3                	mov    %edx,%ebx
 804c5ed:	83 c2 04             	add    $0x4,%edx
 804c5f0:	c1 eb 1f             	shr    $0x1f,%ebx
 804c5f3:	31 d8                	xor    %ebx,%eax
 804c5f5:	0f b6 1d e5 af 0f 10 	movzbl 0x100fafe5,%ebx
 804c5fc:	21 f8                	and    %edi,%eax
 804c5fe:	c1 e0 03             	shl    $0x3,%eax
 804c601:	83 e3 f7             	and    $0xfffffff7,%ebx
 804c604:	09 d8                	or     %ebx,%eax
 804c606:	a2 e5 af 0f 10       	mov    %al,0x100fafe5
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c60b:	c0 e8 02             	shr    $0x2,%al
 804c60e:	83 e0 01             	and    $0x1,%eax
 804c611:	c1 e0 03             	shl    $0x3,%eax
 804c614:	29 c1                	sub    %eax,%ecx
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c616:	29 c2                	sub    %eax,%edx
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c618:	89 0d d8 af 0f 10    	mov    %ecx,0x100fafd8
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c61e:	89 15 dc af 0f 10    	mov    %edx,0x100fafdc
	print_asm_template1();
 804c624:	e8 d7 c4 ff ff       	call   8048b00 <snprintf@plt>
 804c629:	83 c4 10             	add    $0x10,%esp
 804c62c:	83 f8 4f             	cmp    $0x4f,%eax
 804c62f:	7f 0f                	jg     804c640 <cmps_l+0xe0>
	return 1;
}
 804c631:	83 c4 0c             	add    $0xc,%esp
 804c634:	b8 01 00 00 00       	mov    $0x1,%eax
 804c639:	5b                   	pop    %ebx
 804c63a:	5e                   	pop    %esi
 804c63b:	5f                   	pop    %edi
 804c63c:	5d                   	pop    %ebp
 804c63d:	c3                   	ret    
 804c63e:	66 90                	xchg   %ax,%ax
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804c640:	83 ec 0c             	sub    $0xc,%esp
 804c643:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804c649:	e8 12 c3 ff ff       	call   8048960 <fflush@plt>
 804c64e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c654:	6a 07                	push   $0x7
 804c656:	6a 01                	push   $0x1
 804c658:	68 92 e8 05 08       	push   $0x805e892
 804c65d:	e8 ae c3 ff ff       	call   8048a10 <fwrite@plt>
 804c662:	83 c4 20             	add    $0x20,%esp
 804c665:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c66b:	6a 10                	push   $0x10
 804c66d:	6a 01                	push   $0x1
 804c66f:	68 b4 f3 05 08       	push   $0x805f3b4
 804c674:	e8 97 c3 ff ff       	call   8048a10 <fwrite@plt>
 804c679:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c67f:	6a 05                	push   $0x5
 804c681:	6a 01                	push   $0x1
 804c683:	68 42 f3 05 08       	push   $0x805f342
 804c688:	e8 83 c3 ff ff       	call   8048a10 <fwrite@plt>
 804c68d:	83 c4 20             	add    $0x20,%esp
 804c690:	68 18 af 0f 10       	push   $0x100faf18
 804c695:	68 12 f8 05 08       	push   $0x805f812
 804c69a:	6a 50                	push   $0x50
 804c69c:	68 00 8a 0c 08       	push   $0x80c8a00
 804c6a1:	e8 5a c4 ff ff       	call   8048b00 <snprintf@plt>
 804c6a6:	83 c4 10             	add    $0x10,%esp
 804c6a9:	83 f8 4f             	cmp    $0x4f,%eax
 804c6ac:	7e 83                	jle    804c631 <cmps_l+0xd1>
 804c6ae:	68 23 f9 05 08       	push   $0x805f923
 804c6b3:	6a 12                	push   $0x12
 804c6b5:	68 24 f8 05 08       	push   $0x805f824
 804c6ba:	68 94 f8 05 08       	push   $0x805f894
 804c6bf:	e8 ec c4 ff ff       	call   8048bb0 <__assert_fail@plt>
 804c6c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804c6ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804c6d0 <cmps_b>:
#include "cpu/exec/template-start.h"

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
 804c6d0:	56                   	push   %esi
 804c6d1:	53                   	push   %ebx
 804c6d2:	83 ec 04             	sub    $0x4,%esp
	uint32_t res = REG(R_ESI) - REG(R_EDI);
 804c6d5:	0f b6 0d c9 af 0f 10 	movzbl 0x100fafc9,%ecx
 804c6dc:	0f b6 15 cd af 0f 10 	movzbl 0x100fafcd,%edx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c6e3:	0f b6 35 e4 af 0f 10 	movzbl 0x100fafe4,%esi
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804c6ea:	68 18 af 0f 10       	push   $0x100faf18
 804c6ef:	68 1b f8 05 08       	push   $0x805f81b
 804c6f4:	6a 50                	push   $0x50
 804c6f6:	68 00 8a 0c 08       	push   $0x80c8a00
#include "cpu/exec/template-start.h"

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
 804c6fb:	89 cb                	mov    %ecx,%ebx
 804c6fd:	29 d1                	sub    %edx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c6ff:	2a 1d cd af 0f 10    	sub    0x100fafcd,%bl

#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
 804c705:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c708:	83 e6 fa             	and    $0xfffffffa,%esi
#define instr cmps

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 804c70b:	89 c2                	mov    %eax,%edx
 804c70d:	c1 ea 04             	shr    $0x4,%edx
 804c710:	31 d0                	xor    %edx,%eax
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
 804c712:	83 e3 01             	and    $0x1,%ebx

make_helper(concat(cmps_, SUFFIX)) {
	uint32_t res = REG(R_ESI) - REG(R_EDI);
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804c715:	89 c2                	mov    %eax,%edx
 804c717:	c1 ea 02             	shr    $0x2,%edx
 804c71a:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 804c71c:	89 c2                	mov    %eax,%edx
 804c71e:	d1 ea                	shr    %edx
 804c720:	31 c2                	xor    %eax,%edx
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
 804c722:	89 f0                	mov    %esi,%eax
 804c724:	8b 35 d8 af 0f 10    	mov    0x100fafd8,%esi
 804c72a:	83 e2 01             	and    $0x1,%edx
 804c72d:	09 d8                	or     %ebx,%eax
 804c72f:	8b 1d dc af 0f 10    	mov    0x100fafdc,%ebx
 804c735:	c1 e2 02             	shl    $0x2,%edx
 804c738:	09 d0                	or     %edx,%eax
	cpu.ZF = (res == 0);
 804c73a:	85 c9                	test   %ecx,%ecx
 804c73c:	0f 94 c2             	sete   %dl
 804c73f:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = (res >> 31) & 1;
 804c742:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = REG(R_ESI) - REG(R_EDI);
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 804c745:	c1 e2 06             	shl    $0x6,%edx
	cpu.SF = (res >> 31) & 1;
 804c748:	c1 e1 07             	shl    $0x7,%ecx
 804c74b:	09 d0                	or     %edx,%eax
 804c74d:	8d 56 01             	lea    0x1(%esi),%edx
 804c750:	09 c8                	or     %ecx,%eax
 804c752:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
 804c757:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
 804c75e:	83 e0 f7             	and    $0xfffffff7,%eax
 804c761:	a2 e5 af 0f 10       	mov    %al,0x100fafe5
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c766:	c0 e8 02             	shr    $0x2,%al
 804c769:	83 e0 01             	and    $0x1,%eax
 804c76c:	01 c0                	add    %eax,%eax
 804c76e:	29 c2                	sub    %eax,%edx
 804c770:	89 15 d8 af 0f 10    	mov    %edx,0x100fafd8
 804c776:	8d 53 01             	lea    0x1(%ebx),%edx
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 804c779:	29 c2                	sub    %eax,%edx
 804c77b:	89 15 dc af 0f 10    	mov    %edx,0x100fafdc
	print_asm_template1();
 804c781:	e8 7a c3 ff ff       	call   8048b00 <snprintf@plt>
 804c786:	83 c4 10             	add    $0x10,%esp
 804c789:	83 f8 4f             	cmp    $0x4f,%eax
 804c78c:	7f 12                	jg     804c7a0 <cmps_b+0xd0>
	return 1;
}
 804c78e:	83 c4 04             	add    $0x4,%esp
 804c791:	b8 01 00 00 00       	mov    $0x1,%eax
 804c796:	5b                   	pop    %ebx
 804c797:	5e                   	pop    %esi
 804c798:	c3                   	ret    
 804c799:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((REG((R_ESI)) >> 31) ^ (REG((R_EDI)) >> 31)) & ((REG((R_ESI)) >> 31) ^ (res >> 31)) & 1;
	reg_l(R_ESI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 804c7a0:	83 ec 0c             	sub    $0xc,%esp
 804c7a3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804c7a9:	e8 b2 c1 ff ff       	call   8048960 <fflush@plt>
 804c7ae:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c7b4:	6a 07                	push   $0x7
 804c7b6:	6a 01                	push   $0x1
 804c7b8:	68 92 e8 05 08       	push   $0x805e892
 804c7bd:	e8 4e c2 ff ff       	call   8048a10 <fwrite@plt>
 804c7c2:	83 c4 20             	add    $0x20,%esp
 804c7c5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c7cb:	6a 10                	push   $0x10
 804c7cd:	6a 01                	push   $0x1
 804c7cf:	68 b4 f3 05 08       	push   $0x805f3b4
 804c7d4:	e8 37 c2 ff ff       	call   8048a10 <fwrite@plt>
 804c7d9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804c7df:	6a 05                	push   $0x5
 804c7e1:	6a 01                	push   $0x1
 804c7e3:	68 42 f3 05 08       	push   $0x805f342
 804c7e8:	e8 23 c2 ff ff       	call   8048a10 <fwrite@plt>
 804c7ed:	83 c4 20             	add    $0x20,%esp
 804c7f0:	68 18 af 0f 10       	push   $0x100faf18
 804c7f5:	68 1b f8 05 08       	push   $0x805f81b
 804c7fa:	6a 50                	push   $0x50
 804c7fc:	68 00 8a 0c 08       	push   $0x80c8a00
 804c801:	e8 fa c2 ff ff       	call   8048b00 <snprintf@plt>
 804c806:	83 c4 10             	add    $0x10,%esp
 804c809:	83 f8 4f             	cmp    $0x4f,%eax
 804c80c:	7e 80                	jle    804c78e <cmps_b+0xbe>
 804c80e:	68 31 f9 05 08       	push   $0x805f931
 804c813:	6a 12                	push   $0x12
 804c815:	68 24 f8 05 08       	push   $0x805f824
 804c81a:	68 dc f8 05 08       	push   $0x805f8dc
 804c81f:	e8 8c c3 ff ff       	call   8048bb0 <__assert_fail@plt>
 804c824:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804c82a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804c830 <cmps_v>:

#define DATA_BYTE 4
#include "cmps-template.h"
#undef DATA_BYTE

make_helper_v(cmps)
 804c830:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804c837:	8b 54 24 04          	mov    0x4(%esp),%edx
 804c83b:	b8 10 c4 04 08       	mov    $0x804c410,%eax
 804c840:	75 05                	jne    804c847 <cmps_v+0x17>
 804c842:	b8 60 c5 04 08       	mov    $0x804c560,%eax
 804c847:	89 54 24 04          	mov    %edx,0x4(%esp)
 804c84b:	ff e0                	jmp    *%eax
 804c84d:	66 90                	xchg   %ax,%ax
 804c84f:	90                   	nop

0804c850 <group5>:
make_group(group4,
	inc_rm_b, dec_rm_b, inv, inv, 
	inv, inv, inv, inv)

/* 0xff */
make_group(group5,
 804c850:	53                   	push   %ebx
 804c851:	83 ec 10             	sub    $0x10,%esp
 804c854:	8b 5c 24 18          	mov    0x18(%esp),%ebx

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 804c858:	6a 01                	push   $0x1
 804c85a:	8d 43 01             	lea    0x1(%ebx),%eax
 804c85d:	50                   	push   %eax
 804c85e:	e8 ed e6 ff ff       	call   804af50 <swaddr_read>
 804c863:	c0 e8 03             	shr    $0x3,%al
 804c866:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804c86a:	83 e0 07             	and    $0x7,%eax
 804c86d:	8b 04 85 80 f9 05 08 	mov    0x805f980(,%eax,4),%eax
 804c874:	83 c4 18             	add    $0x18,%esp
 804c877:	5b                   	pop    %ebx
 804c878:	ff e0                	jmp    *%eax
 804c87a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804c880 <group4>:
make_group(group3_v,
	test_i2rm_v, inv, not_rm_v, neg_rm_v, 
	mul_rm_v, imul_rm2a_v, div_rm_v, idiv_rm_v)

/* 0xfe */
make_group(group4,
 804c880:	53                   	push   %ebx
 804c881:	83 ec 10             	sub    $0x10,%esp
 804c884:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804c888:	6a 01                	push   $0x1
 804c88a:	8d 43 01             	lea    0x1(%ebx),%eax
 804c88d:	50                   	push   %eax
 804c88e:	e8 bd e6 ff ff       	call   804af50 <swaddr_read>
 804c893:	c0 e8 03             	shr    $0x3,%al
 804c896:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804c89a:	83 e0 07             	and    $0x7,%eax
 804c89d:	8b 04 85 a0 f9 05 08 	mov    0x805f9a0(,%eax,4),%eax
 804c8a4:	83 c4 18             	add    $0x18,%esp
 804c8a7:	5b                   	pop    %ebx
 804c8a8:	ff e0                	jmp    *%eax
 804c8aa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804c8b0 <group3_v>:
make_group(group3_b,
	test_i2rm_b, inv, not_rm_b, neg_rm_b, 
	mul_rm_b, imul_rm2a_b, div_rm_b, idiv_rm_b)

/* 0xf7 */
make_group(group3_v,
 804c8b0:	53                   	push   %ebx
 804c8b1:	83 ec 10             	sub    $0x10,%esp
 804c8b4:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804c8b8:	6a 01                	push   $0x1
 804c8ba:	8d 43 01             	lea    0x1(%ebx),%eax
 804c8bd:	50                   	push   %eax
 804c8be:	e8 8d e6 ff ff       	call   804af50 <swaddr_read>
 804c8c3:	c0 e8 03             	shr    $0x3,%al
 804c8c6:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804c8ca:	83 e0 07             	and    $0x7,%eax
 804c8cd:	8b 04 85 c0 f9 05 08 	mov    0x805f9c0(,%eax,4),%eax
 804c8d4:	83 c4 18             	add    $0x18,%esp
 804c8d7:	5b                   	pop    %ebx
 804c8d8:	ff e0                	jmp    *%eax
 804c8da:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804c8e0 <group3_b>:
make_group(group2_cl_v,
	inv, inv, inv, inv, 
	shl_rm_cl_v, shr_rm_cl_v, inv, sar_rm_cl_v)

/* 0xf6 */
make_group(group3_b,
 804c8e0:	53                   	push   %ebx
 804c8e1:	83 ec 10             	sub    $0x10,%esp
 804c8e4:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804c8e8:	6a 01                	push   $0x1
 804c8ea:	8d 43 01             	lea    0x1(%ebx),%eax
 804c8ed:	50                   	push   %eax
 804c8ee:	e8 5d e6 ff ff       	call   804af50 <swaddr_read>
 804c8f3:	c0 e8 03             	shr    $0x3,%al
 804c8f6:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804c8fa:	83 e0 07             	and    $0x7,%eax
 804c8fd:	8b 04 85 e0 f9 05 08 	mov    0x805f9e0(,%eax,4),%eax
 804c904:	83 c4 18             	add    $0x18,%esp
 804c907:	5b                   	pop    %ebx
 804c908:	ff e0                	jmp    *%eax
 804c90a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804c910 <group2_cl_v>:
make_group(group2_cl_b,
	inv, inv, inv, inv, 
	shl_rm_cl_b, shr_rm_cl_b, inv, sar_rm_cl_b)

/* 0xd3 */
make_group(group2_cl_v,
 804c910:	53                   	push   %ebx
 804c911:	83 ec 10             	sub    $0x10,%esp
 804c914:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804c918:	6a 01                	push   $0x1
 804c91a:	8d 43 01             	lea    0x1(%ebx),%eax
 804c91d:	50                   	push   %eax
 804c91e:	e8 2d e6 ff ff       	call   804af50 <swaddr_read>
 804c923:	c0 e8 03             	shr    $0x3,%al
 804c926:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804c92a:	83 e0 07             	and    $0x7,%eax
 804c92d:	8b 04 85 00 fa 05 08 	mov    0x805fa00(,%eax,4),%eax
 804c934:	83 c4 18             	add    $0x18,%esp
 804c937:	5b                   	pop    %ebx
 804c938:	ff e0                	jmp    *%eax
 804c93a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804c940 <group2_cl_b>:
make_group(group2_1_v,
	inv, inv, inv, inv, 
	shl_rm_1_v, shr_rm_1_v, inv, sar_rm_1_v)

/* 0xd2 */
make_group(group2_cl_b,
 804c940:	53                   	push   %ebx
 804c941:	83 ec 10             	sub    $0x10,%esp
 804c944:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804c948:	6a 01                	push   $0x1
 804c94a:	8d 43 01             	lea    0x1(%ebx),%eax
 804c94d:	50                   	push   %eax
 804c94e:	e8 fd e5 ff ff       	call   804af50 <swaddr_read>
 804c953:	c0 e8 03             	shr    $0x3,%al
 804c956:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804c95a:	83 e0 07             	and    $0x7,%eax
 804c95d:	8b 04 85 20 fa 05 08 	mov    0x805fa20(,%eax,4),%eax
 804c964:	83 c4 18             	add    $0x18,%esp
 804c967:	5b                   	pop    %ebx
 804c968:	ff e0                	jmp    *%eax
 804c96a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804c970 <group2_1_v>:
make_group(group2_1_b,
	inv, inv, inv, inv, 
	shl_rm_1_b, shr_rm_1_b, inv, sar_rm_1_b)

/* 0xd1 */
make_group(group2_1_v,
 804c970:	53                   	push   %ebx
 804c971:	83 ec 10             	sub    $0x10,%esp
 804c974:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804c978:	6a 01                	push   $0x1
 804c97a:	8d 43 01             	lea    0x1(%ebx),%eax
 804c97d:	50                   	push   %eax
 804c97e:	e8 cd e5 ff ff       	call   804af50 <swaddr_read>
 804c983:	c0 e8 03             	shr    $0x3,%al
 804c986:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804c98a:	83 e0 07             	and    $0x7,%eax
 804c98d:	8b 04 85 40 fa 05 08 	mov    0x805fa40(,%eax,4),%eax
 804c994:	83 c4 18             	add    $0x18,%esp
 804c997:	5b                   	pop    %ebx
 804c998:	ff e0                	jmp    *%eax
 804c99a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804c9a0 <group2_1_b>:
make_group(group2_i_v,
	inv, inv, inv, inv, 
	shl_rm_imm_v, shr_rm_imm_v, inv, sar_rm_imm_v)

/* 0xd0 */
make_group(group2_1_b,
 804c9a0:	53                   	push   %ebx
 804c9a1:	83 ec 10             	sub    $0x10,%esp
 804c9a4:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804c9a8:	6a 01                	push   $0x1
 804c9aa:	8d 43 01             	lea    0x1(%ebx),%eax
 804c9ad:	50                   	push   %eax
 804c9ae:	e8 9d e5 ff ff       	call   804af50 <swaddr_read>
 804c9b3:	c0 e8 03             	shr    $0x3,%al
 804c9b6:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804c9ba:	83 e0 07             	and    $0x7,%eax
 804c9bd:	8b 04 85 60 fa 05 08 	mov    0x805fa60(,%eax,4),%eax
 804c9c4:	83 c4 18             	add    $0x18,%esp
 804c9c7:	5b                   	pop    %ebx
 804c9c8:	ff e0                	jmp    *%eax
 804c9ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804c9d0 <group2_i_v>:
make_group(group2_i_b,
	inv, inv, inv, inv, 
	shl_rm_imm_b, shr_rm_imm_b, inv, sar_rm_imm_b)

/* 0xc1 */
make_group(group2_i_v,
 804c9d0:	53                   	push   %ebx
 804c9d1:	83 ec 10             	sub    $0x10,%esp
 804c9d4:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804c9d8:	6a 01                	push   $0x1
 804c9da:	8d 43 01             	lea    0x1(%ebx),%eax
 804c9dd:	50                   	push   %eax
 804c9de:	e8 6d e5 ff ff       	call   804af50 <swaddr_read>
 804c9e3:	c0 e8 03             	shr    $0x3,%al
 804c9e6:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804c9ea:	83 e0 07             	and    $0x7,%eax
 804c9ed:	8b 04 85 80 fa 05 08 	mov    0x805fa80(,%eax,4),%eax
 804c9f4:	83 c4 18             	add    $0x18,%esp
 804c9f7:	5b                   	pop    %ebx
 804c9f8:	ff e0                	jmp    *%eax
 804c9fa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804ca00 <group2_i_b>:
make_group(group1_sx_v,
	add_si2rm_v, or_si2rm_v, adc_si2rm_v, sbb_si2rm_v, 
	and_si2rm_v, sub_si2rm_v, xor_si2rm_v, cmp_si2rm_v)

/* 0xc0 */
make_group(group2_i_b,
 804ca00:	53                   	push   %ebx
 804ca01:	83 ec 10             	sub    $0x10,%esp
 804ca04:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804ca08:	6a 01                	push   $0x1
 804ca0a:	8d 43 01             	lea    0x1(%ebx),%eax
 804ca0d:	50                   	push   %eax
 804ca0e:	e8 3d e5 ff ff       	call   804af50 <swaddr_read>
 804ca13:	c0 e8 03             	shr    $0x3,%al
 804ca16:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804ca1a:	83 e0 07             	and    $0x7,%eax
 804ca1d:	8b 04 85 a0 fa 05 08 	mov    0x805faa0(,%eax,4),%eax
 804ca24:	83 c4 18             	add    $0x18,%esp
 804ca27:	5b                   	pop    %ebx
 804ca28:	ff e0                	jmp    *%eax
 804ca2a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804ca30 <group1_sx_v>:
make_group(group1_v,
	add_i2rm_v, or_i2rm_v, adc_i2rm_v, sbb_i2rm_v, 
	and_i2rm_v, sub_i2rm_v, xor_i2rm_v, cmp_i2rm_v)

/* 0x83 */
make_group(group1_sx_v,
 804ca30:	53                   	push   %ebx
 804ca31:	83 ec 10             	sub    $0x10,%esp
 804ca34:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804ca38:	6a 01                	push   $0x1
 804ca3a:	8d 43 01             	lea    0x1(%ebx),%eax
 804ca3d:	50                   	push   %eax
 804ca3e:	e8 0d e5 ff ff       	call   804af50 <swaddr_read>
 804ca43:	c0 e8 03             	shr    $0x3,%al
 804ca46:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804ca4a:	83 e0 07             	and    $0x7,%eax
 804ca4d:	8b 04 85 c0 fa 05 08 	mov    0x805fac0(,%eax,4),%eax
 804ca54:	83 c4 18             	add    $0x18,%esp
 804ca57:	5b                   	pop    %ebx
 804ca58:	ff e0                	jmp    *%eax
 804ca5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804ca60 <group1_v>:
make_group(group1_b,
	add_i2rm_b, or_i2rm_b, adc_i2rm_b, sbb_i2rm_b, 
	and_i2rm_b, sub_i2rm_b, xor_i2rm_b, cmp_i2rm_b)

/* 0x81 */
make_group(group1_v,
 804ca60:	53                   	push   %ebx
 804ca61:	83 ec 10             	sub    $0x10,%esp
 804ca64:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804ca68:	6a 01                	push   $0x1
 804ca6a:	8d 43 01             	lea    0x1(%ebx),%eax
 804ca6d:	50                   	push   %eax
 804ca6e:	e8 dd e4 ff ff       	call   804af50 <swaddr_read>
 804ca73:	c0 e8 03             	shr    $0x3,%al
 804ca76:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804ca7a:	83 e0 07             	and    $0x7,%eax
 804ca7d:	8b 04 85 e0 fa 05 08 	mov    0x805fae0(,%eax,4),%eax
 804ca84:	83 c4 18             	add    $0x18,%esp
 804ca87:	5b                   	pop    %ebx
 804ca88:	ff e0                	jmp    *%eax
 804ca8a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804ca90 <group1_b>:
		m.val = instr_fetch(eip + 1, 1); \
		return concat(opcode_table_, name) [m.opcode](eip); \
	}
	
/* 0x80 */
make_group(group1_b,
 804ca90:	53                   	push   %ebx
 804ca91:	83 ec 10             	sub    $0x10,%esp
 804ca94:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804ca98:	6a 01                	push   $0x1
 804ca9a:	8d 43 01             	lea    0x1(%ebx),%eax
 804ca9d:	50                   	push   %eax
 804ca9e:	e8 ad e4 ff ff       	call   804af50 <swaddr_read>
 804caa3:	c0 e8 03             	shr    $0x3,%al
 804caa6:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804caaa:	83 e0 07             	and    $0x7,%eax
 804caad:	8b 04 85 00 fb 05 08 	mov    0x805fb00(,%eax,4),%eax
 804cab4:	83 c4 18             	add    $0x18,%esp
 804cab7:	5b                   	pop    %ebx
 804cab8:	ff e0                	jmp    *%eax
 804caba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804cac0 <_2byte_esc>:
make_helper(exec) {
	ops_decoded.opcode = instr_fetch(eip, 1);
	return opcode_table[ ops_decoded.opcode ](eip);
}

static make_helper(_2byte_esc) {
 804cac0:	53                   	push   %ebx
 804cac1:	83 ec 10             	sub    $0x10,%esp
	eip ++;
 804cac4:	8b 44 24 18          	mov    0x18(%esp),%eax
 804cac8:	6a 01                	push   $0x1
 804caca:	8d 58 01             	lea    0x1(%eax),%ebx
 804cacd:	53                   	push   %ebx
 804cace:	e8 7d e4 ff ff       	call   804af50 <swaddr_read>
	uint32_t opcode = instr_fetch(eip, 1);
	ops_decoded.opcode = opcode | 0x100;
 804cad3:	89 c2                	mov    %eax,%edx
	return _2byte_opcode_table[opcode](eip) + 1; 
 804cad5:	89 1c 24             	mov    %ebx,(%esp)
}

static make_helper(_2byte_esc) {
	eip ++;
	uint32_t opcode = instr_fetch(eip, 1);
	ops_decoded.opcode = opcode | 0x100;
 804cad8:	80 ce 01             	or     $0x1,%dh
 804cadb:	89 15 00 af 0f 10    	mov    %edx,0x100faf00
	return _2byte_opcode_table[opcode](eip) + 1; 
 804cae1:	ff 14 85 80 54 07 08 	call   *0x8075480(,%eax,4)
}
 804cae8:	83 c4 18             	add    $0x18,%esp

static make_helper(_2byte_esc) {
	eip ++;
	uint32_t opcode = instr_fetch(eip, 1);
	ops_decoded.opcode = opcode | 0x100;
	return _2byte_opcode_table[opcode](eip) + 1; 
 804caeb:	83 c0 01             	add    $0x1,%eax
}
 804caee:	5b                   	pop    %ebx
 804caef:	c3                   	ret    

0804caf0 <group7>:

make_group(group6,
	inv, inv, inv, inv, 
	inv, inv, inv, inv)

make_group(group7,
 804caf0:	53                   	push   %ebx
 804caf1:	83 ec 10             	sub    $0x10,%esp
 804caf4:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804caf8:	6a 01                	push   $0x1
 804cafa:	8d 43 01             	lea    0x1(%ebx),%eax
 804cafd:	50                   	push   %eax
 804cafe:	e8 4d e4 ff ff       	call   804af50 <swaddr_read>
 804cb03:	c0 e8 03             	shr    $0x3,%al
 804cb06:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804cb0a:	83 e0 07             	and    $0x7,%eax
 804cb0d:	8b 04 85 40 f9 05 08 	mov    0x805f940(,%eax,4),%eax
 804cb14:	83 c4 18             	add    $0x18,%esp
 804cb17:	5b                   	pop    %ebx
 804cb18:	ff e0                	jmp    *%eax
 804cb1a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804cb20 <group6>:
/* 0xff */
make_group(group5,
	inc_rm_v, dec_rm_v, call_rm_v, inv, 
	jmp_rm_v, jmp_rm_v, push_rm_v, inv)

make_group(group6,
 804cb20:	53                   	push   %ebx
 804cb21:	83 ec 10             	sub    $0x10,%esp
 804cb24:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804cb28:	6a 01                	push   $0x1
 804cb2a:	8d 43 01             	lea    0x1(%ebx),%eax
 804cb2d:	50                   	push   %eax
 804cb2e:	e8 1d e4 ff ff       	call   804af50 <swaddr_read>
 804cb33:	c0 e8 03             	shr    $0x3,%al
 804cb36:	89 5c 24 20          	mov    %ebx,0x20(%esp)
 804cb3a:	83 e0 07             	and    $0x7,%eax
 804cb3d:	8b 04 85 60 f9 05 08 	mov    0x805f960(,%eax,4),%eax
 804cb44:	83 c4 18             	add    $0x18,%esp
 804cb47:	5b                   	pop    %ebx
 804cb48:	ff e0                	jmp    *%eax
 804cb4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804cb50 <exec>:
/* 0xf4 */	inv, inv, inv, inv,
/* 0xf8 */	inv, inv, inv, inv,
/* 0xfc */	inv, inv, inv, inv
};

make_helper(exec) {
 804cb50:	53                   	push   %ebx
 804cb51:	83 ec 10             	sub    $0x10,%esp
 804cb54:	8b 5c 24 18          	mov    0x18(%esp),%ebx
 804cb58:	6a 01                	push   $0x1
 804cb5a:	53                   	push   %ebx
 804cb5b:	e8 f0 e3 ff ff       	call   804af50 <swaddr_read>
	ops_decoded.opcode = instr_fetch(eip, 1);
	return opcode_table[ ops_decoded.opcode ](eip);
 804cb60:	89 5c 24 20          	mov    %ebx,0x20(%esp)
/* 0xf8 */	inv, inv, inv, inv,
/* 0xfc */	inv, inv, inv, inv
};

make_helper(exec) {
	ops_decoded.opcode = instr_fetch(eip, 1);
 804cb64:	a3 00 af 0f 10       	mov    %eax,0x100faf00
	return opcode_table[ ops_decoded.opcode ](eip);
 804cb69:	8b 04 85 80 58 07 08 	mov    0x8075880(,%eax,4),%eax
}
 804cb70:	83 c4 18             	add    $0x18,%esp
 804cb73:	5b                   	pop    %ebx
/* 0xfc */	inv, inv, inv, inv
};

make_helper(exec) {
	ops_decoded.opcode = instr_fetch(eip, 1);
	return opcode_table[ ops_decoded.opcode ](eip);
 804cb74:	ff e0                	jmp    *%eax
 804cb76:	66 90                	xchg   %ax,%ax
 804cb78:	66 90                	xchg   %ax,%ax
 804cb7a:	66 90                	xchg   %ax,%ax
 804cb7c:	66 90                	xchg   %ax,%ax
 804cb7e:	66 90                	xchg   %ax,%ax

0804cb80 <sets_rm_b>:
	int8_t res = cpu.SF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804cb80:	53                   	push   %ebx
 804cb81:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804cb84:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804cb88:	83 c0 01             	add    $0x1,%eax
 804cb8b:	50                   	push   %eax
 804cb8c:	e8 9f fa 00 00       	call   805c630 <decode_rm_b>
 804cb91:	89 c3                	mov    %eax,%ebx

#define instr sets

static void do_execute() {
	int8_t res = cpu.SF;
	OPERAND_W(op_src, res);
 804cb93:	58                   	pop    %eax
 804cb94:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr sets

static void do_execute() {
	int8_t res = cpu.SF;
 804cb95:	0f b6 15 e4 af 0f 10 	movzbl 0x100fafe4,%edx
 804cb9c:	c0 ea 07             	shr    $0x7,%dl
	OPERAND_W(op_src, res);
 804cb9f:	0f b6 d2             	movzbl %dl,%edx
 804cba2:	52                   	push   %edx
 804cba3:	68 08 af 0f 10       	push   $0x100faf08
 804cba8:	e8 93 fb 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804cbad:	68 18 af 0f 10       	push   $0x100faf18
 804cbb2:	68 20 fb 05 08       	push   $0x805fb20
 804cbb7:	6a 50                	push   $0x50
 804cbb9:	68 00 8a 0c 08       	push   $0x80c8a00
 804cbbe:	e8 3d bf ff ff       	call   8048b00 <snprintf@plt>
 804cbc3:	83 c4 20             	add    $0x20,%esp
 804cbc6:	83 f8 4f             	cmp    $0x4f,%eax
 804cbc9:	7f 0d                	jg     804cbd8 <sets_rm_b+0x58>
}

make_instr_helper(rm)
 804cbcb:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804cbce:	8d 43 01             	lea    0x1(%ebx),%eax
 804cbd1:	5b                   	pop    %ebx
 804cbd2:	c3                   	ret    
 804cbd3:	90                   	nop
 804cbd4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr sets

static void do_execute() {
	int8_t res = cpu.SF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804cbd8:	83 ec 0c             	sub    $0xc,%esp
 804cbdb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804cbe1:	e8 7a bd ff ff       	call   8048960 <fflush@plt>
 804cbe6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804cbec:	6a 07                	push   $0x7
 804cbee:	6a 01                	push   $0x1
 804cbf0:	68 92 e8 05 08       	push   $0x805e892
 804cbf5:	e8 16 be ff ff       	call   8048a10 <fwrite@plt>
 804cbfa:	83 c4 20             	add    $0x20,%esp
 804cbfd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804cc03:	6a 10                	push   $0x10
 804cc05:	6a 01                	push   $0x1
 804cc07:	68 b4 f3 05 08       	push   $0x805f3b4
 804cc0c:	e8 ff bd ff ff       	call   8048a10 <fwrite@plt>
 804cc11:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804cc17:	6a 05                	push   $0x5
 804cc19:	6a 01                	push   $0x1
 804cc1b:	68 42 f3 05 08       	push   $0x805f342
 804cc20:	e8 eb bd ff ff       	call   8048a10 <fwrite@plt>
 804cc25:	83 c4 20             	add    $0x20,%esp
 804cc28:	68 18 af 0f 10       	push   $0x100faf18
 804cc2d:	68 20 fb 05 08       	push   $0x805fb20
 804cc32:	6a 50                	push   $0x50
 804cc34:	68 00 8a 0c 08       	push   $0x80c8a00
 804cc39:	e8 c2 be ff ff       	call   8048b00 <snprintf@plt>
 804cc3e:	83 c4 10             	add    $0x10,%esp
 804cc41:	83 f8 4f             	cmp    $0x4f,%eax
 804cc44:	7e 85                	jle    804cbcb <sets_rm_b+0x4b>
 804cc46:	68 9b fb 05 08       	push   $0x805fb9b
 804cc4b:	6a 08                	push   $0x8
 804cc4d:	68 2c fb 05 08       	push   $0x805fb2c
 804cc52:	68 54 fb 05 08       	push   $0x805fb54
 804cc57:	e8 54 bf ff ff       	call   8048bb0 <__assert_fail@plt>
 804cc5c:	66 90                	xchg   %ax,%ax
 804cc5e:	66 90                	xchg   %ax,%ax

0804cc60 <setb_rm_b>:
	int8_t res = cpu.CF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804cc60:	53                   	push   %ebx
 804cc61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804cc64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804cc68:	83 c0 01             	add    $0x1,%eax
 804cc6b:	50                   	push   %eax
 804cc6c:	e8 bf f9 00 00       	call   805c630 <decode_rm_b>
 804cc71:	89 c3                	mov    %eax,%ebx

#define instr setb

static void do_execute() {
	int8_t res = cpu.CF;
	OPERAND_W(op_src, res);
 804cc73:	58                   	pop    %eax
 804cc74:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setb

static void do_execute() {
	int8_t res = cpu.CF;
 804cc75:	0f b6 15 e4 af 0f 10 	movzbl 0x100fafe4,%edx
	OPERAND_W(op_src, res);
 804cc7c:	83 e2 01             	and    $0x1,%edx
 804cc7f:	52                   	push   %edx
 804cc80:	68 08 af 0f 10       	push   $0x100faf08
 804cc85:	e8 b6 fa 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804cc8a:	68 18 af 0f 10       	push   $0x100faf18
 804cc8f:	68 a5 fb 05 08       	push   $0x805fba5
 804cc94:	6a 50                	push   $0x50
 804cc96:	68 00 8a 0c 08       	push   $0x80c8a00
 804cc9b:	e8 60 be ff ff       	call   8048b00 <snprintf@plt>
 804cca0:	83 c4 20             	add    $0x20,%esp
 804cca3:	83 f8 4f             	cmp    $0x4f,%eax
 804cca6:	7f 08                	jg     804ccb0 <setb_rm_b+0x50>
}

make_instr_helper(rm)
 804cca8:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804ccab:	8d 43 01             	lea    0x1(%ebx),%eax
 804ccae:	5b                   	pop    %ebx
 804ccaf:	c3                   	ret    
#define instr setb

static void do_execute() {
	int8_t res = cpu.CF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804ccb0:	83 ec 0c             	sub    $0xc,%esp
 804ccb3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804ccb9:	e8 a2 bc ff ff       	call   8048960 <fflush@plt>
 804ccbe:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ccc4:	6a 07                	push   $0x7
 804ccc6:	6a 01                	push   $0x1
 804ccc8:	68 92 e8 05 08       	push   $0x805e892
 804cccd:	e8 3e bd ff ff       	call   8048a10 <fwrite@plt>
 804ccd2:	83 c4 20             	add    $0x20,%esp
 804ccd5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ccdb:	6a 10                	push   $0x10
 804ccdd:	6a 01                	push   $0x1
 804ccdf:	68 b4 f3 05 08       	push   $0x805f3b4
 804cce4:	e8 27 bd ff ff       	call   8048a10 <fwrite@plt>
 804cce9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ccef:	6a 05                	push   $0x5
 804ccf1:	6a 01                	push   $0x1
 804ccf3:	68 42 f3 05 08       	push   $0x805f342
 804ccf8:	e8 13 bd ff ff       	call   8048a10 <fwrite@plt>
 804ccfd:	83 c4 20             	add    $0x20,%esp
 804cd00:	68 18 af 0f 10       	push   $0x100faf18
 804cd05:	68 a5 fb 05 08       	push   $0x805fba5
 804cd0a:	6a 50                	push   $0x50
 804cd0c:	68 00 8a 0c 08       	push   $0x80c8a00
 804cd11:	e8 ea bd ff ff       	call   8048b00 <snprintf@plt>
 804cd16:	83 c4 10             	add    $0x10,%esp
 804cd19:	83 f8 4f             	cmp    $0x4f,%eax
 804cd1c:	7e 8a                	jle    804cca8 <setb_rm_b+0x48>
 804cd1e:	68 1f fc 05 08       	push   $0x805fc1f
 804cd23:	6a 08                	push   $0x8
 804cd25:	68 b0 fb 05 08       	push   $0x805fbb0
 804cd2a:	68 d8 fb 05 08       	push   $0x805fbd8
 804cd2f:	e8 7c be ff ff       	call   8048bb0 <__assert_fail@plt>
 804cd34:	66 90                	xchg   %ax,%ax
 804cd36:	66 90                	xchg   %ax,%ax
 804cd38:	66 90                	xchg   %ax,%ax
 804cd3a:	66 90                	xchg   %ax,%ax
 804cd3c:	66 90                	xchg   %ax,%ax
 804cd3e:	66 90                	xchg   %ax,%ax

0804cd40 <setne_rm_b>:
	int8_t res = !cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804cd40:	53                   	push   %ebx
 804cd41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804cd44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804cd48:	83 c0 01             	add    $0x1,%eax
 804cd4b:	50                   	push   %eax
 804cd4c:	e8 df f8 00 00       	call   805c630 <decode_rm_b>
 804cd51:	89 c3                	mov    %eax,%ebx

#define instr setne

static void do_execute() {
	int8_t res = !cpu.ZF;
	OPERAND_W(op_src, res);
 804cd53:	58                   	pop    %eax
 804cd54:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setne

static void do_execute() {
	int8_t res = !cpu.ZF;
 804cd55:	0f b6 15 e4 af 0f 10 	movzbl 0x100fafe4,%edx
 804cd5c:	c0 ea 06             	shr    $0x6,%dl
 804cd5f:	83 f2 01             	xor    $0x1,%edx
 804cd62:	83 e2 01             	and    $0x1,%edx
	OPERAND_W(op_src, res);
 804cd65:	52                   	push   %edx
 804cd66:	68 08 af 0f 10       	push   $0x100faf08
 804cd6b:	e8 d0 f9 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804cd70:	68 18 af 0f 10       	push   $0x100faf18
 804cd75:	68 29 fc 05 08       	push   $0x805fc29
 804cd7a:	6a 50                	push   $0x50
 804cd7c:	68 00 8a 0c 08       	push   $0x80c8a00
 804cd81:	e8 7a bd ff ff       	call   8048b00 <snprintf@plt>
 804cd86:	83 c4 20             	add    $0x20,%esp
 804cd89:	83 f8 4f             	cmp    $0x4f,%eax
 804cd8c:	7f 12                	jg     804cda0 <setne_rm_b+0x60>
}

make_instr_helper(rm)
 804cd8e:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804cd91:	8d 43 01             	lea    0x1(%ebx),%eax
 804cd94:	5b                   	pop    %ebx
 804cd95:	c3                   	ret    
 804cd96:	8d 76 00             	lea    0x0(%esi),%esi
 804cd99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#define instr setne

static void do_execute() {
	int8_t res = !cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804cda0:	83 ec 0c             	sub    $0xc,%esp
 804cda3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804cda9:	e8 b2 bb ff ff       	call   8048960 <fflush@plt>
 804cdae:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804cdb4:	6a 07                	push   $0x7
 804cdb6:	6a 01                	push   $0x1
 804cdb8:	68 92 e8 05 08       	push   $0x805e892
 804cdbd:	e8 4e bc ff ff       	call   8048a10 <fwrite@plt>
 804cdc2:	83 c4 20             	add    $0x20,%esp
 804cdc5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804cdcb:	6a 10                	push   $0x10
 804cdcd:	6a 01                	push   $0x1
 804cdcf:	68 b4 f3 05 08       	push   $0x805f3b4
 804cdd4:	e8 37 bc ff ff       	call   8048a10 <fwrite@plt>
 804cdd9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804cddf:	6a 05                	push   $0x5
 804cde1:	6a 01                	push   $0x1
 804cde3:	68 42 f3 05 08       	push   $0x805f342
 804cde8:	e8 23 bc ff ff       	call   8048a10 <fwrite@plt>
 804cded:	83 c4 20             	add    $0x20,%esp
 804cdf0:	68 18 af 0f 10       	push   $0x100faf18
 804cdf5:	68 29 fc 05 08       	push   $0x805fc29
 804cdfa:	6a 50                	push   $0x50
 804cdfc:	68 00 8a 0c 08       	push   $0x80c8a00
 804ce01:	e8 fa bc ff ff       	call   8048b00 <snprintf@plt>
 804ce06:	83 c4 10             	add    $0x10,%esp
 804ce09:	83 f8 4f             	cmp    $0x4f,%eax
 804ce0c:	7e 80                	jle    804cd8e <setne_rm_b+0x4e>
 804ce0e:	68 a8 fc 05 08       	push   $0x805fca8
 804ce13:	6a 08                	push   $0x8
 804ce15:	68 34 fc 05 08       	push   $0x805fc34
 804ce1a:	68 60 fc 05 08       	push   $0x805fc60
 804ce1f:	e8 8c bd ff ff       	call   8048bb0 <__assert_fail@plt>
 804ce24:	66 90                	xchg   %ax,%ax
 804ce26:	66 90                	xchg   %ax,%ax
 804ce28:	66 90                	xchg   %ax,%ax
 804ce2a:	66 90                	xchg   %ax,%ax
 804ce2c:	66 90                	xchg   %ax,%ax
 804ce2e:	66 90                	xchg   %ax,%ax

0804ce30 <sete_rm_b>:
	int8_t res = cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804ce30:	53                   	push   %ebx
 804ce31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804ce34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ce38:	83 c0 01             	add    $0x1,%eax
 804ce3b:	50                   	push   %eax
 804ce3c:	e8 ef f7 00 00       	call   805c630 <decode_rm_b>
 804ce41:	89 c3                	mov    %eax,%ebx

#define instr sete

static void do_execute() {
	int8_t res = cpu.ZF;
	OPERAND_W(op_src, res);
 804ce43:	58                   	pop    %eax
 804ce44:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr sete

static void do_execute() {
	int8_t res = cpu.ZF;
 804ce45:	0f b6 15 e4 af 0f 10 	movzbl 0x100fafe4,%edx
 804ce4c:	c0 ea 06             	shr    $0x6,%dl
	OPERAND_W(op_src, res);
 804ce4f:	83 e2 01             	and    $0x1,%edx
 804ce52:	52                   	push   %edx
 804ce53:	68 08 af 0f 10       	push   $0x100faf08
 804ce58:	e8 e3 f8 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804ce5d:	68 18 af 0f 10       	push   $0x100faf18
 804ce62:	68 b3 fc 05 08       	push   $0x805fcb3
 804ce67:	6a 50                	push   $0x50
 804ce69:	68 00 8a 0c 08       	push   $0x80c8a00
 804ce6e:	e8 8d bc ff ff       	call   8048b00 <snprintf@plt>
 804ce73:	83 c4 20             	add    $0x20,%esp
 804ce76:	83 f8 4f             	cmp    $0x4f,%eax
 804ce79:	7f 0d                	jg     804ce88 <sete_rm_b+0x58>
}

make_instr_helper(rm)
 804ce7b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804ce7e:	8d 43 01             	lea    0x1(%ebx),%eax
 804ce81:	5b                   	pop    %ebx
 804ce82:	c3                   	ret    
 804ce83:	90                   	nop
 804ce84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr sete

static void do_execute() {
	int8_t res = cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804ce88:	83 ec 0c             	sub    $0xc,%esp
 804ce8b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804ce91:	e8 ca ba ff ff       	call   8048960 <fflush@plt>
 804ce96:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ce9c:	6a 07                	push   $0x7
 804ce9e:	6a 01                	push   $0x1
 804cea0:	68 92 e8 05 08       	push   $0x805e892
 804cea5:	e8 66 bb ff ff       	call   8048a10 <fwrite@plt>
 804ceaa:	83 c4 20             	add    $0x20,%esp
 804cead:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ceb3:	6a 10                	push   $0x10
 804ceb5:	6a 01                	push   $0x1
 804ceb7:	68 b4 f3 05 08       	push   $0x805f3b4
 804cebc:	e8 4f bb ff ff       	call   8048a10 <fwrite@plt>
 804cec1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804cec7:	6a 05                	push   $0x5
 804cec9:	6a 01                	push   $0x1
 804cecb:	68 42 f3 05 08       	push   $0x805f342
 804ced0:	e8 3b bb ff ff       	call   8048a10 <fwrite@plt>
 804ced5:	83 c4 20             	add    $0x20,%esp
 804ced8:	68 18 af 0f 10       	push   $0x100faf18
 804cedd:	68 b3 fc 05 08       	push   $0x805fcb3
 804cee2:	6a 50                	push   $0x50
 804cee4:	68 00 8a 0c 08       	push   $0x80c8a00
 804cee9:	e8 12 bc ff ff       	call   8048b00 <snprintf@plt>
 804ceee:	83 c4 10             	add    $0x10,%esp
 804cef1:	83 f8 4f             	cmp    $0x4f,%eax
 804cef4:	7e 85                	jle    804ce7b <sete_rm_b+0x4b>
 804cef6:	68 2b fd 05 08       	push   $0x805fd2b
 804cefb:	6a 08                	push   $0x8
 804cefd:	68 bc fc 05 08       	push   $0x805fcbc
 804cf02:	68 e4 fc 05 08       	push   $0x805fce4
 804cf07:	e8 a4 bc ff ff       	call   8048bb0 <__assert_fail@plt>
 804cf0c:	66 90                	xchg   %ax,%ax
 804cf0e:	66 90                	xchg   %ax,%ax

0804cf10 <setns_rm_b>:
	int8_t res = !cpu.SF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804cf10:	53                   	push   %ebx
 804cf11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804cf14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804cf18:	83 c0 01             	add    $0x1,%eax
 804cf1b:	50                   	push   %eax
 804cf1c:	e8 0f f7 00 00       	call   805c630 <decode_rm_b>
 804cf21:	89 c3                	mov    %eax,%ebx

#define instr setns

static void do_execute() {
	int8_t res = !cpu.SF;
	OPERAND_W(op_src, res);
 804cf23:	58                   	pop    %eax
 804cf24:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setns

static void do_execute() {
	int8_t res = !cpu.SF;
 804cf25:	0f be 15 e4 af 0f 10 	movsbl 0x100fafe4,%edx
 804cf2c:	f7 d2                	not    %edx
 804cf2e:	c1 ea 1f             	shr    $0x1f,%edx
	OPERAND_W(op_src, res);
 804cf31:	52                   	push   %edx
 804cf32:	68 08 af 0f 10       	push   $0x100faf08
 804cf37:	e8 04 f8 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804cf3c:	68 18 af 0f 10       	push   $0x100faf18
 804cf41:	68 35 fd 05 08       	push   $0x805fd35
 804cf46:	6a 50                	push   $0x50
 804cf48:	68 00 8a 0c 08       	push   $0x80c8a00
 804cf4d:	e8 ae bb ff ff       	call   8048b00 <snprintf@plt>
 804cf52:	83 c4 20             	add    $0x20,%esp
 804cf55:	83 f8 4f             	cmp    $0x4f,%eax
 804cf58:	7f 0e                	jg     804cf68 <setns_rm_b+0x58>
}

make_instr_helper(rm)
 804cf5a:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804cf5d:	8d 43 01             	lea    0x1(%ebx),%eax
 804cf60:	5b                   	pop    %ebx
 804cf61:	c3                   	ret    
 804cf62:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define instr setns

static void do_execute() {
	int8_t res = !cpu.SF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804cf68:	83 ec 0c             	sub    $0xc,%esp
 804cf6b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804cf71:	e8 ea b9 ff ff       	call   8048960 <fflush@plt>
 804cf76:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804cf7c:	6a 07                	push   $0x7
 804cf7e:	6a 01                	push   $0x1
 804cf80:	68 92 e8 05 08       	push   $0x805e892
 804cf85:	e8 86 ba ff ff       	call   8048a10 <fwrite@plt>
 804cf8a:	83 c4 20             	add    $0x20,%esp
 804cf8d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804cf93:	6a 10                	push   $0x10
 804cf95:	6a 01                	push   $0x1
 804cf97:	68 b4 f3 05 08       	push   $0x805f3b4
 804cf9c:	e8 6f ba ff ff       	call   8048a10 <fwrite@plt>
 804cfa1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804cfa7:	6a 05                	push   $0x5
 804cfa9:	6a 01                	push   $0x1
 804cfab:	68 42 f3 05 08       	push   $0x805f342
 804cfb0:	e8 5b ba ff ff       	call   8048a10 <fwrite@plt>
 804cfb5:	83 c4 20             	add    $0x20,%esp
 804cfb8:	68 18 af 0f 10       	push   $0x100faf18
 804cfbd:	68 35 fd 05 08       	push   $0x805fd35
 804cfc2:	6a 50                	push   $0x50
 804cfc4:	68 00 8a 0c 08       	push   $0x80c8a00
 804cfc9:	e8 32 bb ff ff       	call   8048b00 <snprintf@plt>
 804cfce:	83 c4 10             	add    $0x10,%esp
 804cfd1:	83 f8 4f             	cmp    $0x4f,%eax
 804cfd4:	7e 84                	jle    804cf5a <setns_rm_b+0x4a>
 804cfd6:	68 b4 fd 05 08       	push   $0x805fdb4
 804cfdb:	6a 08                	push   $0x8
 804cfdd:	68 40 fd 05 08       	push   $0x805fd40
 804cfe2:	68 6c fd 05 08       	push   $0x805fd6c
 804cfe7:	e8 c4 bb ff ff       	call   8048bb0 <__assert_fail@plt>
 804cfec:	66 90                	xchg   %ax,%ax
 804cfee:	66 90                	xchg   %ax,%ax

0804cff0 <setnp_rm_b>:
	int8_t res = !cpu.PF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804cff0:	53                   	push   %ebx
 804cff1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804cff4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804cff8:	83 c0 01             	add    $0x1,%eax
 804cffb:	50                   	push   %eax
 804cffc:	e8 2f f6 00 00       	call   805c630 <decode_rm_b>
 804d001:	89 c3                	mov    %eax,%ebx

#define instr setnp

static void do_execute() {
	int8_t res = !cpu.PF;
	OPERAND_W(op_src, res);
 804d003:	58                   	pop    %eax
 804d004:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setnp

static void do_execute() {
	int8_t res = !cpu.PF;
 804d005:	0f b6 15 e4 af 0f 10 	movzbl 0x100fafe4,%edx
 804d00c:	c0 ea 02             	shr    $0x2,%dl
 804d00f:	83 f2 01             	xor    $0x1,%edx
 804d012:	83 e2 01             	and    $0x1,%edx
	OPERAND_W(op_src, res);
 804d015:	52                   	push   %edx
 804d016:	68 08 af 0f 10       	push   $0x100faf08
 804d01b:	e8 20 f7 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804d020:	68 18 af 0f 10       	push   $0x100faf18
 804d025:	68 bf fd 05 08       	push   $0x805fdbf
 804d02a:	6a 50                	push   $0x50
 804d02c:	68 00 8a 0c 08       	push   $0x80c8a00
 804d031:	e8 ca ba ff ff       	call   8048b00 <snprintf@plt>
 804d036:	83 c4 20             	add    $0x20,%esp
 804d039:	83 f8 4f             	cmp    $0x4f,%eax
 804d03c:	7f 12                	jg     804d050 <setnp_rm_b+0x60>
}

make_instr_helper(rm)
 804d03e:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d041:	8d 43 01             	lea    0x1(%ebx),%eax
 804d044:	5b                   	pop    %ebx
 804d045:	c3                   	ret    
 804d046:	8d 76 00             	lea    0x0(%esi),%esi
 804d049:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#define instr setnp

static void do_execute() {
	int8_t res = !cpu.PF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d050:	83 ec 0c             	sub    $0xc,%esp
 804d053:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804d059:	e8 02 b9 ff ff       	call   8048960 <fflush@plt>
 804d05e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d064:	6a 07                	push   $0x7
 804d066:	6a 01                	push   $0x1
 804d068:	68 92 e8 05 08       	push   $0x805e892
 804d06d:	e8 9e b9 ff ff       	call   8048a10 <fwrite@plt>
 804d072:	83 c4 20             	add    $0x20,%esp
 804d075:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d07b:	6a 10                	push   $0x10
 804d07d:	6a 01                	push   $0x1
 804d07f:	68 b4 f3 05 08       	push   $0x805f3b4
 804d084:	e8 87 b9 ff ff       	call   8048a10 <fwrite@plt>
 804d089:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d08f:	6a 05                	push   $0x5
 804d091:	6a 01                	push   $0x1
 804d093:	68 42 f3 05 08       	push   $0x805f342
 804d098:	e8 73 b9 ff ff       	call   8048a10 <fwrite@plt>
 804d09d:	83 c4 20             	add    $0x20,%esp
 804d0a0:	68 18 af 0f 10       	push   $0x100faf18
 804d0a5:	68 bf fd 05 08       	push   $0x805fdbf
 804d0aa:	6a 50                	push   $0x50
 804d0ac:	68 00 8a 0c 08       	push   $0x80c8a00
 804d0b1:	e8 4a ba ff ff       	call   8048b00 <snprintf@plt>
 804d0b6:	83 c4 10             	add    $0x10,%esp
 804d0b9:	83 f8 4f             	cmp    $0x4f,%eax
 804d0bc:	7e 80                	jle    804d03e <setnp_rm_b+0x4e>
 804d0be:	68 40 fe 05 08       	push   $0x805fe40
 804d0c3:	6a 08                	push   $0x8
 804d0c5:	68 cc fd 05 08       	push   $0x805fdcc
 804d0ca:	68 f8 fd 05 08       	push   $0x805fdf8
 804d0cf:	e8 dc ba ff ff       	call   8048bb0 <__assert_fail@plt>
 804d0d4:	66 90                	xchg   %ax,%ax
 804d0d6:	66 90                	xchg   %ax,%ax
 804d0d8:	66 90                	xchg   %ax,%ax
 804d0da:	66 90                	xchg   %ax,%ax
 804d0dc:	66 90                	xchg   %ax,%ax
 804d0de:	66 90                	xchg   %ax,%ax

0804d0e0 <setno_rm_b>:
	int8_t res = !cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d0e0:	53                   	push   %ebx
 804d0e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d0e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d0e8:	83 c0 01             	add    $0x1,%eax
 804d0eb:	50                   	push   %eax
 804d0ec:	e8 3f f5 00 00       	call   805c630 <decode_rm_b>
 804d0f1:	89 c3                	mov    %eax,%ebx

#define instr setno

static void do_execute() {
	int8_t res = !cpu.OF;
	OPERAND_W(op_src, res);
 804d0f3:	58                   	pop    %eax
 804d0f4:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setno

static void do_execute() {
	int8_t res = !cpu.OF;
 804d0f5:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 804d0fc:	c0 ea 03             	shr    $0x3,%dl
 804d0ff:	83 f2 01             	xor    $0x1,%edx
 804d102:	83 e2 01             	and    $0x1,%edx
	OPERAND_W(op_src, res);
 804d105:	52                   	push   %edx
 804d106:	68 08 af 0f 10       	push   $0x100faf08
 804d10b:	e8 30 f6 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804d110:	68 18 af 0f 10       	push   $0x100faf18
 804d115:	68 4b fe 05 08       	push   $0x805fe4b
 804d11a:	6a 50                	push   $0x50
 804d11c:	68 00 8a 0c 08       	push   $0x80c8a00
 804d121:	e8 da b9 ff ff       	call   8048b00 <snprintf@plt>
 804d126:	83 c4 20             	add    $0x20,%esp
 804d129:	83 f8 4f             	cmp    $0x4f,%eax
 804d12c:	7f 12                	jg     804d140 <setno_rm_b+0x60>
}

make_instr_helper(rm)
 804d12e:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d131:	8d 43 01             	lea    0x1(%ebx),%eax
 804d134:	5b                   	pop    %ebx
 804d135:	c3                   	ret    
 804d136:	8d 76 00             	lea    0x0(%esi),%esi
 804d139:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#define instr setno

static void do_execute() {
	int8_t res = !cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d140:	83 ec 0c             	sub    $0xc,%esp
 804d143:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804d149:	e8 12 b8 ff ff       	call   8048960 <fflush@plt>
 804d14e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d154:	6a 07                	push   $0x7
 804d156:	6a 01                	push   $0x1
 804d158:	68 92 e8 05 08       	push   $0x805e892
 804d15d:	e8 ae b8 ff ff       	call   8048a10 <fwrite@plt>
 804d162:	83 c4 20             	add    $0x20,%esp
 804d165:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d16b:	6a 10                	push   $0x10
 804d16d:	6a 01                	push   $0x1
 804d16f:	68 b4 f3 05 08       	push   $0x805f3b4
 804d174:	e8 97 b8 ff ff       	call   8048a10 <fwrite@plt>
 804d179:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d17f:	6a 05                	push   $0x5
 804d181:	6a 01                	push   $0x1
 804d183:	68 42 f3 05 08       	push   $0x805f342
 804d188:	e8 83 b8 ff ff       	call   8048a10 <fwrite@plt>
 804d18d:	83 c4 20             	add    $0x20,%esp
 804d190:	68 18 af 0f 10       	push   $0x100faf18
 804d195:	68 4b fe 05 08       	push   $0x805fe4b
 804d19a:	6a 50                	push   $0x50
 804d19c:	68 00 8a 0c 08       	push   $0x80c8a00
 804d1a1:	e8 5a b9 ff ff       	call   8048b00 <snprintf@plt>
 804d1a6:	83 c4 10             	add    $0x10,%esp
 804d1a9:	83 f8 4f             	cmp    $0x4f,%eax
 804d1ac:	7e 80                	jle    804d12e <setno_rm_b+0x4e>
 804d1ae:	68 cc fe 05 08       	push   $0x805fecc
 804d1b3:	6a 08                	push   $0x8
 804d1b5:	68 58 fe 05 08       	push   $0x805fe58
 804d1ba:	68 84 fe 05 08       	push   $0x805fe84
 804d1bf:	e8 ec b9 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d1c4:	66 90                	xchg   %ax,%ax
 804d1c6:	66 90                	xchg   %ax,%ax
 804d1c8:	66 90                	xchg   %ax,%ax
 804d1ca:	66 90                	xchg   %ax,%ax
 804d1cc:	66 90                	xchg   %ax,%ax
 804d1ce:	66 90                	xchg   %ax,%ax

0804d1d0 <setae_rm_b>:
	int8_t res = !cpu.CF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d1d0:	53                   	push   %ebx
 804d1d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d1d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d1d8:	83 c0 01             	add    $0x1,%eax
 804d1db:	50                   	push   %eax
 804d1dc:	e8 4f f4 00 00       	call   805c630 <decode_rm_b>
 804d1e1:	89 c3                	mov    %eax,%ebx

#define instr setae

static void do_execute() {
	int8_t res = !cpu.CF;
	OPERAND_W(op_src, res);
 804d1e3:	58                   	pop    %eax
 804d1e4:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setae

static void do_execute() {
	int8_t res = !cpu.CF;
 804d1e5:	0f b6 15 e4 af 0f 10 	movzbl 0x100fafe4,%edx
 804d1ec:	f7 d2                	not    %edx
	OPERAND_W(op_src, res);
 804d1ee:	83 e2 01             	and    $0x1,%edx
 804d1f1:	52                   	push   %edx
 804d1f2:	68 08 af 0f 10       	push   $0x100faf08
 804d1f7:	e8 44 f5 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804d1fc:	68 18 af 0f 10       	push   $0x100faf18
 804d201:	68 d7 fe 05 08       	push   $0x805fed7
 804d206:	6a 50                	push   $0x50
 804d208:	68 00 8a 0c 08       	push   $0x80c8a00
 804d20d:	e8 ee b8 ff ff       	call   8048b00 <snprintf@plt>
 804d212:	83 c4 20             	add    $0x20,%esp
 804d215:	83 f8 4f             	cmp    $0x4f,%eax
 804d218:	7f 0e                	jg     804d228 <setae_rm_b+0x58>
}

make_instr_helper(rm)
 804d21a:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d21d:	8d 43 01             	lea    0x1(%ebx),%eax
 804d220:	5b                   	pop    %ebx
 804d221:	c3                   	ret    
 804d222:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define instr setae

static void do_execute() {
	int8_t res = !cpu.CF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d228:	83 ec 0c             	sub    $0xc,%esp
 804d22b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804d231:	e8 2a b7 ff ff       	call   8048960 <fflush@plt>
 804d236:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d23c:	6a 07                	push   $0x7
 804d23e:	6a 01                	push   $0x1
 804d240:	68 92 e8 05 08       	push   $0x805e892
 804d245:	e8 c6 b7 ff ff       	call   8048a10 <fwrite@plt>
 804d24a:	83 c4 20             	add    $0x20,%esp
 804d24d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d253:	6a 10                	push   $0x10
 804d255:	6a 01                	push   $0x1
 804d257:	68 b4 f3 05 08       	push   $0x805f3b4
 804d25c:	e8 af b7 ff ff       	call   8048a10 <fwrite@plt>
 804d261:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d267:	6a 05                	push   $0x5
 804d269:	6a 01                	push   $0x1
 804d26b:	68 42 f3 05 08       	push   $0x805f342
 804d270:	e8 9b b7 ff ff       	call   8048a10 <fwrite@plt>
 804d275:	83 c4 20             	add    $0x20,%esp
 804d278:	68 18 af 0f 10       	push   $0x100faf18
 804d27d:	68 d7 fe 05 08       	push   $0x805fed7
 804d282:	6a 50                	push   $0x50
 804d284:	68 00 8a 0c 08       	push   $0x80c8a00
 804d289:	e8 72 b8 ff ff       	call   8048b00 <snprintf@plt>
 804d28e:	83 c4 10             	add    $0x10,%esp
 804d291:	83 f8 4f             	cmp    $0x4f,%eax
 804d294:	7e 84                	jle    804d21a <setae_rm_b+0x4a>
 804d296:	68 58 ff 05 08       	push   $0x805ff58
 804d29b:	6a 08                	push   $0x8
 804d29d:	68 e4 fe 05 08       	push   $0x805fee4
 804d2a2:	68 10 ff 05 08       	push   $0x805ff10
 804d2a7:	e8 04 b9 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d2ac:	66 90                	xchg   %ax,%ax
 804d2ae:	66 90                	xchg   %ax,%ax

0804d2b0 <setle_rm_b>:
	int8_t res = cpu.ZF || cpu.SF != cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d2b0:	53                   	push   %ebx
 804d2b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d2b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d2b8:	83 c0 01             	add    $0x1,%eax
 804d2bb:	50                   	push   %eax
 804d2bc:	e8 6f f3 00 00       	call   805c630 <decode_rm_b>
 804d2c1:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr setle

static void do_execute() {
	int8_t res = cpu.ZF || cpu.SF != cpu.OF;
 804d2c3:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 804d2ca:	83 c4 10             	add    $0x10,%esp
 804d2cd:	ba 01 00 00 00       	mov    $0x1,%edx
 804d2d2:	a8 40                	test   $0x40,%al
 804d2d4:	75 15                	jne    804d2eb <setle_rm_b+0x3b>
 804d2d6:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 804d2dd:	c0 e8 07             	shr    $0x7,%al
 804d2e0:	c0 ea 03             	shr    $0x3,%dl
 804d2e3:	83 e2 01             	and    $0x1,%edx
 804d2e6:	31 c2                	xor    %eax,%edx
 804d2e8:	0f b6 d2             	movzbl %dl,%edx
	OPERAND_W(op_src, res);
 804d2eb:	83 ec 08             	sub    $0x8,%esp
 804d2ee:	52                   	push   %edx
 804d2ef:	68 08 af 0f 10       	push   $0x100faf08
 804d2f4:	e8 47 f4 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804d2f9:	68 18 af 0f 10       	push   $0x100faf18
 804d2fe:	68 63 ff 05 08       	push   $0x805ff63
 804d303:	6a 50                	push   $0x50
 804d305:	68 00 8a 0c 08       	push   $0x80c8a00
 804d30a:	e8 f1 b7 ff ff       	call   8048b00 <snprintf@plt>
 804d30f:	83 c4 20             	add    $0x20,%esp
 804d312:	83 f8 4f             	cmp    $0x4f,%eax
 804d315:	7f 09                	jg     804d320 <setle_rm_b+0x70>
}

make_instr_helper(rm)
 804d317:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d31a:	8d 43 01             	lea    0x1(%ebx),%eax
 804d31d:	5b                   	pop    %ebx
 804d31e:	c3                   	ret    
 804d31f:	90                   	nop
#define instr setle

static void do_execute() {
	int8_t res = cpu.ZF || cpu.SF != cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d320:	83 ec 0c             	sub    $0xc,%esp
 804d323:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804d329:	e8 32 b6 ff ff       	call   8048960 <fflush@plt>
 804d32e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d334:	6a 07                	push   $0x7
 804d336:	6a 01                	push   $0x1
 804d338:	68 92 e8 05 08       	push   $0x805e892
 804d33d:	e8 ce b6 ff ff       	call   8048a10 <fwrite@plt>
 804d342:	83 c4 20             	add    $0x20,%esp
 804d345:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d34b:	6a 10                	push   $0x10
 804d34d:	6a 01                	push   $0x1
 804d34f:	68 b4 f3 05 08       	push   $0x805f3b4
 804d354:	e8 b7 b6 ff ff       	call   8048a10 <fwrite@plt>
 804d359:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d35f:	6a 05                	push   $0x5
 804d361:	6a 01                	push   $0x1
 804d363:	68 42 f3 05 08       	push   $0x805f342
 804d368:	e8 a3 b6 ff ff       	call   8048a10 <fwrite@plt>
 804d36d:	83 c4 20             	add    $0x20,%esp
 804d370:	68 18 af 0f 10       	push   $0x100faf18
 804d375:	68 63 ff 05 08       	push   $0x805ff63
 804d37a:	6a 50                	push   $0x50
 804d37c:	68 00 8a 0c 08       	push   $0x80c8a00
 804d381:	e8 7a b7 ff ff       	call   8048b00 <snprintf@plt>
 804d386:	83 c4 10             	add    $0x10,%esp
 804d389:	83 f8 4f             	cmp    $0x4f,%eax
 804d38c:	7e 89                	jle    804d317 <setle_rm_b+0x67>
 804d38e:	68 e4 ff 05 08       	push   $0x805ffe4
 804d393:	6a 08                	push   $0x8
 804d395:	68 70 ff 05 08       	push   $0x805ff70
 804d39a:	68 9c ff 05 08       	push   $0x805ff9c
 804d39f:	e8 0c b8 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d3a4:	66 90                	xchg   %ax,%ax
 804d3a6:	66 90                	xchg   %ax,%ax
 804d3a8:	66 90                	xchg   %ax,%ax
 804d3aa:	66 90                	xchg   %ax,%ax
 804d3ac:	66 90                	xchg   %ax,%ax
 804d3ae:	66 90                	xchg   %ax,%ax

0804d3b0 <seta_rm_b>:
	int8_t res = !cpu.CF && !cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d3b0:	53                   	push   %ebx
 804d3b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d3b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d3b8:	83 c0 01             	add    $0x1,%eax
 804d3bb:	50                   	push   %eax
 804d3bc:	e8 6f f2 00 00       	call   805c630 <decode_rm_b>
 804d3c1:	89 c3                	mov    %eax,%ebx

#define instr seta

static void do_execute() {
	int8_t res = !cpu.CF && !cpu.ZF;
	OPERAND_W(op_src, res);
 804d3c3:	58                   	pop    %eax
#include "cpu/exec/template-start.h"

#define instr seta

static void do_execute() {
	int8_t res = !cpu.CF && !cpu.ZF;
 804d3c4:	31 c0                	xor    %eax,%eax
 804d3c6:	f6 05 e4 af 0f 10 41 	testb  $0x41,0x100fafe4
	OPERAND_W(op_src, res);
 804d3cd:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr seta

static void do_execute() {
	int8_t res = !cpu.CF && !cpu.ZF;
 804d3ce:	0f 94 c0             	sete   %al
	OPERAND_W(op_src, res);
 804d3d1:	50                   	push   %eax
 804d3d2:	68 08 af 0f 10       	push   $0x100faf08
 804d3d7:	e8 64 f3 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804d3dc:	68 18 af 0f 10       	push   $0x100faf18
 804d3e1:	68 ef ff 05 08       	push   $0x805ffef
 804d3e6:	6a 50                	push   $0x50
 804d3e8:	68 00 8a 0c 08       	push   $0x80c8a00
 804d3ed:	e8 0e b7 ff ff       	call   8048b00 <snprintf@plt>
 804d3f2:	83 c4 20             	add    $0x20,%esp
 804d3f5:	83 f8 4f             	cmp    $0x4f,%eax
 804d3f8:	7f 0e                	jg     804d408 <seta_rm_b+0x58>
}

make_instr_helper(rm)
 804d3fa:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d3fd:	8d 43 01             	lea    0x1(%ebx),%eax
 804d400:	5b                   	pop    %ebx
 804d401:	c3                   	ret    
 804d402:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define instr seta

static void do_execute() {
	int8_t res = !cpu.CF && !cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d408:	83 ec 0c             	sub    $0xc,%esp
 804d40b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804d411:	e8 4a b5 ff ff       	call   8048960 <fflush@plt>
 804d416:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d41c:	6a 07                	push   $0x7
 804d41e:	6a 01                	push   $0x1
 804d420:	68 92 e8 05 08       	push   $0x805e892
 804d425:	e8 e6 b5 ff ff       	call   8048a10 <fwrite@plt>
 804d42a:	83 c4 20             	add    $0x20,%esp
 804d42d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d433:	6a 10                	push   $0x10
 804d435:	6a 01                	push   $0x1
 804d437:	68 b4 f3 05 08       	push   $0x805f3b4
 804d43c:	e8 cf b5 ff ff       	call   8048a10 <fwrite@plt>
 804d441:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d447:	6a 05                	push   $0x5
 804d449:	6a 01                	push   $0x1
 804d44b:	68 42 f3 05 08       	push   $0x805f342
 804d450:	e8 bb b5 ff ff       	call   8048a10 <fwrite@plt>
 804d455:	83 c4 20             	add    $0x20,%esp
 804d458:	68 18 af 0f 10       	push   $0x100faf18
 804d45d:	68 ef ff 05 08       	push   $0x805ffef
 804d462:	6a 50                	push   $0x50
 804d464:	68 00 8a 0c 08       	push   $0x80c8a00
 804d469:	e8 92 b6 ff ff       	call   8048b00 <snprintf@plt>
 804d46e:	83 c4 10             	add    $0x10,%esp
 804d471:	83 f8 4f             	cmp    $0x4f,%eax
 804d474:	7e 84                	jle    804d3fa <seta_rm_b+0x4a>
 804d476:	68 67 00 06 08       	push   $0x8060067
 804d47b:	6a 08                	push   $0x8
 804d47d:	68 f8 ff 05 08       	push   $0x805fff8
 804d482:	68 20 00 06 08       	push   $0x8060020
 804d487:	e8 24 b7 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d48c:	66 90                	xchg   %ax,%ax
 804d48e:	66 90                	xchg   %ax,%ax

0804d490 <setp_rm_b>:
	int8_t res = cpu.PF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d490:	53                   	push   %ebx
 804d491:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d494:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d498:	83 c0 01             	add    $0x1,%eax
 804d49b:	50                   	push   %eax
 804d49c:	e8 8f f1 00 00       	call   805c630 <decode_rm_b>
 804d4a1:	89 c3                	mov    %eax,%ebx

#define instr setp

static void do_execute() {
	int8_t res = cpu.PF;
	OPERAND_W(op_src, res);
 804d4a3:	58                   	pop    %eax
 804d4a4:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setp

static void do_execute() {
	int8_t res = cpu.PF;
 804d4a5:	0f b6 15 e4 af 0f 10 	movzbl 0x100fafe4,%edx
 804d4ac:	c0 ea 02             	shr    $0x2,%dl
	OPERAND_W(op_src, res);
 804d4af:	83 e2 01             	and    $0x1,%edx
 804d4b2:	52                   	push   %edx
 804d4b3:	68 08 af 0f 10       	push   $0x100faf08
 804d4b8:	e8 83 f2 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804d4bd:	68 18 af 0f 10       	push   $0x100faf18
 804d4c2:	68 71 00 06 08       	push   $0x8060071
 804d4c7:	6a 50                	push   $0x50
 804d4c9:	68 00 8a 0c 08       	push   $0x80c8a00
 804d4ce:	e8 2d b6 ff ff       	call   8048b00 <snprintf@plt>
 804d4d3:	83 c4 20             	add    $0x20,%esp
 804d4d6:	83 f8 4f             	cmp    $0x4f,%eax
 804d4d9:	7f 0d                	jg     804d4e8 <setp_rm_b+0x58>
}

make_instr_helper(rm)
 804d4db:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d4de:	8d 43 01             	lea    0x1(%ebx),%eax
 804d4e1:	5b                   	pop    %ebx
 804d4e2:	c3                   	ret    
 804d4e3:	90                   	nop
 804d4e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr setp

static void do_execute() {
	int8_t res = cpu.PF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d4e8:	83 ec 0c             	sub    $0xc,%esp
 804d4eb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804d4f1:	e8 6a b4 ff ff       	call   8048960 <fflush@plt>
 804d4f6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d4fc:	6a 07                	push   $0x7
 804d4fe:	6a 01                	push   $0x1
 804d500:	68 92 e8 05 08       	push   $0x805e892
 804d505:	e8 06 b5 ff ff       	call   8048a10 <fwrite@plt>
 804d50a:	83 c4 20             	add    $0x20,%esp
 804d50d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d513:	6a 10                	push   $0x10
 804d515:	6a 01                	push   $0x1
 804d517:	68 b4 f3 05 08       	push   $0x805f3b4
 804d51c:	e8 ef b4 ff ff       	call   8048a10 <fwrite@plt>
 804d521:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d527:	6a 05                	push   $0x5
 804d529:	6a 01                	push   $0x1
 804d52b:	68 42 f3 05 08       	push   $0x805f342
 804d530:	e8 db b4 ff ff       	call   8048a10 <fwrite@plt>
 804d535:	83 c4 20             	add    $0x20,%esp
 804d538:	68 18 af 0f 10       	push   $0x100faf18
 804d53d:	68 71 00 06 08       	push   $0x8060071
 804d542:	6a 50                	push   $0x50
 804d544:	68 00 8a 0c 08       	push   $0x80c8a00
 804d549:	e8 b2 b5 ff ff       	call   8048b00 <snprintf@plt>
 804d54e:	83 c4 10             	add    $0x10,%esp
 804d551:	83 f8 4f             	cmp    $0x4f,%eax
 804d554:	7e 85                	jle    804d4db <setp_rm_b+0x4b>
 804d556:	68 eb 00 06 08       	push   $0x80600eb
 804d55b:	6a 08                	push   $0x8
 804d55d:	68 7c 00 06 08       	push   $0x806007c
 804d562:	68 a4 00 06 08       	push   $0x80600a4
 804d567:	e8 44 b6 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d56c:	66 90                	xchg   %ax,%ax
 804d56e:	66 90                	xchg   %ax,%ax

0804d570 <setge_rm_b>:
	int8_t res = cpu.SF == cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d570:	53                   	push   %ebx
 804d571:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d574:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d578:	83 c0 01             	add    $0x1,%eax
 804d57b:	50                   	push   %eax
 804d57c:	e8 af f0 00 00       	call   805c630 <decode_rm_b>
 804d581:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr setge

static void do_execute() {
	int8_t res = cpu.SF == cpu.OF;
 804d583:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
	OPERAND_W(op_src, res);
 804d58a:	58                   	pop    %eax
 804d58b:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setge

static void do_execute() {
	int8_t res = cpu.SF == cpu.OF;
 804d58c:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 804d593:	31 c0                	xor    %eax,%eax
 804d595:	c0 e9 07             	shr    $0x7,%cl
 804d598:	c0 ea 03             	shr    $0x3,%dl
 804d59b:	83 e2 01             	and    $0x1,%edx
 804d59e:	38 d1                	cmp    %dl,%cl
 804d5a0:	0f 94 c0             	sete   %al
	OPERAND_W(op_src, res);
 804d5a3:	50                   	push   %eax
 804d5a4:	68 08 af 0f 10       	push   $0x100faf08
 804d5a9:	e8 92 f1 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804d5ae:	68 18 af 0f 10       	push   $0x100faf18
 804d5b3:	68 f5 00 06 08       	push   $0x80600f5
 804d5b8:	6a 50                	push   $0x50
 804d5ba:	68 00 8a 0c 08       	push   $0x80c8a00
 804d5bf:	e8 3c b5 ff ff       	call   8048b00 <snprintf@plt>
 804d5c4:	83 c4 20             	add    $0x20,%esp
 804d5c7:	83 f8 4f             	cmp    $0x4f,%eax
 804d5ca:	7f 0c                	jg     804d5d8 <setge_rm_b+0x68>
}

make_instr_helper(rm)
 804d5cc:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d5cf:	8d 43 01             	lea    0x1(%ebx),%eax
 804d5d2:	5b                   	pop    %ebx
 804d5d3:	c3                   	ret    
 804d5d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr setge

static void do_execute() {
	int8_t res = cpu.SF == cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d5d8:	83 ec 0c             	sub    $0xc,%esp
 804d5db:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804d5e1:	e8 7a b3 ff ff       	call   8048960 <fflush@plt>
 804d5e6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d5ec:	6a 07                	push   $0x7
 804d5ee:	6a 01                	push   $0x1
 804d5f0:	68 92 e8 05 08       	push   $0x805e892
 804d5f5:	e8 16 b4 ff ff       	call   8048a10 <fwrite@plt>
 804d5fa:	83 c4 20             	add    $0x20,%esp
 804d5fd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d603:	6a 10                	push   $0x10
 804d605:	6a 01                	push   $0x1
 804d607:	68 b4 f3 05 08       	push   $0x805f3b4
 804d60c:	e8 ff b3 ff ff       	call   8048a10 <fwrite@plt>
 804d611:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d617:	6a 05                	push   $0x5
 804d619:	6a 01                	push   $0x1
 804d61b:	68 42 f3 05 08       	push   $0x805f342
 804d620:	e8 eb b3 ff ff       	call   8048a10 <fwrite@plt>
 804d625:	83 c4 20             	add    $0x20,%esp
 804d628:	68 18 af 0f 10       	push   $0x100faf18
 804d62d:	68 f5 00 06 08       	push   $0x80600f5
 804d632:	6a 50                	push   $0x50
 804d634:	68 00 8a 0c 08       	push   $0x80c8a00
 804d639:	e8 c2 b4 ff ff       	call   8048b00 <snprintf@plt>
 804d63e:	83 c4 10             	add    $0x10,%esp
 804d641:	83 f8 4f             	cmp    $0x4f,%eax
 804d644:	7e 86                	jle    804d5cc <setge_rm_b+0x5c>
 804d646:	68 74 01 06 08       	push   $0x8060174
 804d64b:	6a 08                	push   $0x8
 804d64d:	68 00 01 06 08       	push   $0x8060100
 804d652:	68 2c 01 06 08       	push   $0x806012c
 804d657:	e8 54 b5 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d65c:	66 90                	xchg   %ax,%ax
 804d65e:	66 90                	xchg   %ax,%ax

0804d660 <setg_rm_b>:
	int8_t res = !cpu.ZF && cpu.SF == cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d660:	53                   	push   %ebx
 804d661:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d664:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d668:	83 c0 01             	add    $0x1,%eax
 804d66b:	50                   	push   %eax
 804d66c:	e8 bf ef 00 00       	call   805c630 <decode_rm_b>
 804d671:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr setg

static void do_execute() {
	int8_t res = !cpu.ZF && cpu.SF == cpu.OF;
 804d673:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 804d67a:	83 c4 10             	add    $0x10,%esp
 804d67d:	31 d2                	xor    %edx,%edx
 804d67f:	a8 40                	test   $0x40,%al
 804d681:	75 18                	jne    804d69b <setg_rm_b+0x3b>
 804d683:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 804d68a:	c0 e8 07             	shr    $0x7,%al
 804d68d:	c0 ea 03             	shr    $0x3,%dl
 804d690:	83 e2 01             	and    $0x1,%edx
 804d693:	38 d0                	cmp    %dl,%al
 804d695:	0f 94 c2             	sete   %dl
 804d698:	0f b6 d2             	movzbl %dl,%edx
	OPERAND_W(op_src, res);
 804d69b:	83 ec 08             	sub    $0x8,%esp
 804d69e:	52                   	push   %edx
 804d69f:	68 08 af 0f 10       	push   $0x100faf08
 804d6a4:	e8 97 f0 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804d6a9:	68 18 af 0f 10       	push   $0x100faf18
 804d6ae:	68 7f 01 06 08       	push   $0x806017f
 804d6b3:	6a 50                	push   $0x50
 804d6b5:	68 00 8a 0c 08       	push   $0x80c8a00
 804d6ba:	e8 41 b4 ff ff       	call   8048b00 <snprintf@plt>
 804d6bf:	83 c4 20             	add    $0x20,%esp
 804d6c2:	83 f8 4f             	cmp    $0x4f,%eax
 804d6c5:	7f 09                	jg     804d6d0 <setg_rm_b+0x70>
}

make_instr_helper(rm)
 804d6c7:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d6ca:	8d 43 01             	lea    0x1(%ebx),%eax
 804d6cd:	5b                   	pop    %ebx
 804d6ce:	c3                   	ret    
 804d6cf:	90                   	nop
#define instr setg

static void do_execute() {
	int8_t res = !cpu.ZF && cpu.SF == cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d6d0:	83 ec 0c             	sub    $0xc,%esp
 804d6d3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804d6d9:	e8 82 b2 ff ff       	call   8048960 <fflush@plt>
 804d6de:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d6e4:	6a 07                	push   $0x7
 804d6e6:	6a 01                	push   $0x1
 804d6e8:	68 92 e8 05 08       	push   $0x805e892
 804d6ed:	e8 1e b3 ff ff       	call   8048a10 <fwrite@plt>
 804d6f2:	83 c4 20             	add    $0x20,%esp
 804d6f5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d6fb:	6a 10                	push   $0x10
 804d6fd:	6a 01                	push   $0x1
 804d6ff:	68 b4 f3 05 08       	push   $0x805f3b4
 804d704:	e8 07 b3 ff ff       	call   8048a10 <fwrite@plt>
 804d709:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d70f:	6a 05                	push   $0x5
 804d711:	6a 01                	push   $0x1
 804d713:	68 42 f3 05 08       	push   $0x805f342
 804d718:	e8 f3 b2 ff ff       	call   8048a10 <fwrite@plt>
 804d71d:	83 c4 20             	add    $0x20,%esp
 804d720:	68 18 af 0f 10       	push   $0x100faf18
 804d725:	68 7f 01 06 08       	push   $0x806017f
 804d72a:	6a 50                	push   $0x50
 804d72c:	68 00 8a 0c 08       	push   $0x80c8a00
 804d731:	e8 ca b3 ff ff       	call   8048b00 <snprintf@plt>
 804d736:	83 c4 10             	add    $0x10,%esp
 804d739:	83 f8 4f             	cmp    $0x4f,%eax
 804d73c:	7e 89                	jle    804d6c7 <setg_rm_b+0x67>
 804d73e:	68 f7 01 06 08       	push   $0x80601f7
 804d743:	6a 08                	push   $0x8
 804d745:	68 88 01 06 08       	push   $0x8060188
 804d74a:	68 b0 01 06 08       	push   $0x80601b0
 804d74f:	e8 5c b4 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d754:	66 90                	xchg   %ax,%ax
 804d756:	66 90                	xchg   %ax,%ax
 804d758:	66 90                	xchg   %ax,%ax
 804d75a:	66 90                	xchg   %ax,%ax
 804d75c:	66 90                	xchg   %ax,%ax
 804d75e:	66 90                	xchg   %ax,%ax

0804d760 <setl_rm_b>:
	int8_t res = cpu.SF != cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d760:	53                   	push   %ebx
 804d761:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d764:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d768:	83 c0 01             	add    $0x1,%eax
 804d76b:	50                   	push   %eax
 804d76c:	e8 bf ee 00 00       	call   805c630 <decode_rm_b>
 804d771:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr setl

static void do_execute() {
	int8_t res = cpu.SF != cpu.OF;
 804d773:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
	OPERAND_W(op_src, res);
 804d77a:	58                   	pop    %eax
 804d77b:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setl

static void do_execute() {
	int8_t res = cpu.SF != cpu.OF;
 804d77c:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 804d783:	c0 e9 07             	shr    $0x7,%cl
 804d786:	c0 ea 03             	shr    $0x3,%dl
 804d789:	83 e2 01             	and    $0x1,%edx
 804d78c:	31 ca                	xor    %ecx,%edx
	OPERAND_W(op_src, res);
 804d78e:	0f b6 d2             	movzbl %dl,%edx
 804d791:	52                   	push   %edx
 804d792:	68 08 af 0f 10       	push   $0x100faf08
 804d797:	e8 a4 ef 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804d79c:	68 18 af 0f 10       	push   $0x100faf18
 804d7a1:	68 01 02 06 08       	push   $0x8060201
 804d7a6:	6a 50                	push   $0x50
 804d7a8:	68 00 8a 0c 08       	push   $0x80c8a00
 804d7ad:	e8 4e b3 ff ff       	call   8048b00 <snprintf@plt>
 804d7b2:	83 c4 20             	add    $0x20,%esp
 804d7b5:	83 f8 4f             	cmp    $0x4f,%eax
 804d7b8:	7f 0e                	jg     804d7c8 <setl_rm_b+0x68>
}

make_instr_helper(rm)
 804d7ba:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d7bd:	8d 43 01             	lea    0x1(%ebx),%eax
 804d7c0:	5b                   	pop    %ebx
 804d7c1:	c3                   	ret    
 804d7c2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define instr setl

static void do_execute() {
	int8_t res = cpu.SF != cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d7c8:	83 ec 0c             	sub    $0xc,%esp
 804d7cb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804d7d1:	e8 8a b1 ff ff       	call   8048960 <fflush@plt>
 804d7d6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d7dc:	6a 07                	push   $0x7
 804d7de:	6a 01                	push   $0x1
 804d7e0:	68 92 e8 05 08       	push   $0x805e892
 804d7e5:	e8 26 b2 ff ff       	call   8048a10 <fwrite@plt>
 804d7ea:	83 c4 20             	add    $0x20,%esp
 804d7ed:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d7f3:	6a 10                	push   $0x10
 804d7f5:	6a 01                	push   $0x1
 804d7f7:	68 b4 f3 05 08       	push   $0x805f3b4
 804d7fc:	e8 0f b2 ff ff       	call   8048a10 <fwrite@plt>
 804d801:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d807:	6a 05                	push   $0x5
 804d809:	6a 01                	push   $0x1
 804d80b:	68 42 f3 05 08       	push   $0x805f342
 804d810:	e8 fb b1 ff ff       	call   8048a10 <fwrite@plt>
 804d815:	83 c4 20             	add    $0x20,%esp
 804d818:	68 18 af 0f 10       	push   $0x100faf18
 804d81d:	68 01 02 06 08       	push   $0x8060201
 804d822:	6a 50                	push   $0x50
 804d824:	68 00 8a 0c 08       	push   $0x80c8a00
 804d829:	e8 d2 b2 ff ff       	call   8048b00 <snprintf@plt>
 804d82e:	83 c4 10             	add    $0x10,%esp
 804d831:	83 f8 4f             	cmp    $0x4f,%eax
 804d834:	7e 84                	jle    804d7ba <setl_rm_b+0x5a>
 804d836:	68 7b 02 06 08       	push   $0x806027b
 804d83b:	6a 08                	push   $0x8
 804d83d:	68 0c 02 06 08       	push   $0x806020c
 804d842:	68 34 02 06 08       	push   $0x8060234
 804d847:	e8 64 b3 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d84c:	66 90                	xchg   %ax,%ax
 804d84e:	66 90                	xchg   %ax,%ax

0804d850 <seto_rm_b>:
	int8_t res = cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d850:	53                   	push   %ebx
 804d851:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d854:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d858:	83 c0 01             	add    $0x1,%eax
 804d85b:	50                   	push   %eax
 804d85c:	e8 cf ed 00 00       	call   805c630 <decode_rm_b>
 804d861:	89 c3                	mov    %eax,%ebx

#define instr seto

static void do_execute() {
	int8_t res = cpu.OF;
	OPERAND_W(op_src, res);
 804d863:	58                   	pop    %eax
 804d864:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr seto

static void do_execute() {
	int8_t res = cpu.OF;
 804d865:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 804d86c:	c0 ea 03             	shr    $0x3,%dl
	OPERAND_W(op_src, res);
 804d86f:	83 e2 01             	and    $0x1,%edx
 804d872:	52                   	push   %edx
 804d873:	68 08 af 0f 10       	push   $0x100faf08
 804d878:	e8 c3 ee 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804d87d:	68 18 af 0f 10       	push   $0x100faf18
 804d882:	68 85 02 06 08       	push   $0x8060285
 804d887:	6a 50                	push   $0x50
 804d889:	68 00 8a 0c 08       	push   $0x80c8a00
 804d88e:	e8 6d b2 ff ff       	call   8048b00 <snprintf@plt>
 804d893:	83 c4 20             	add    $0x20,%esp
 804d896:	83 f8 4f             	cmp    $0x4f,%eax
 804d899:	7f 0d                	jg     804d8a8 <seto_rm_b+0x58>
}

make_instr_helper(rm)
 804d89b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d89e:	8d 43 01             	lea    0x1(%ebx),%eax
 804d8a1:	5b                   	pop    %ebx
 804d8a2:	c3                   	ret    
 804d8a3:	90                   	nop
 804d8a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr seto

static void do_execute() {
	int8_t res = cpu.OF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d8a8:	83 ec 0c             	sub    $0xc,%esp
 804d8ab:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804d8b1:	e8 aa b0 ff ff       	call   8048960 <fflush@plt>
 804d8b6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d8bc:	6a 07                	push   $0x7
 804d8be:	6a 01                	push   $0x1
 804d8c0:	68 92 e8 05 08       	push   $0x805e892
 804d8c5:	e8 46 b1 ff ff       	call   8048a10 <fwrite@plt>
 804d8ca:	83 c4 20             	add    $0x20,%esp
 804d8cd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d8d3:	6a 10                	push   $0x10
 804d8d5:	6a 01                	push   $0x1
 804d8d7:	68 b4 f3 05 08       	push   $0x805f3b4
 804d8dc:	e8 2f b1 ff ff       	call   8048a10 <fwrite@plt>
 804d8e1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d8e7:	6a 05                	push   $0x5
 804d8e9:	6a 01                	push   $0x1
 804d8eb:	68 42 f3 05 08       	push   $0x805f342
 804d8f0:	e8 1b b1 ff ff       	call   8048a10 <fwrite@plt>
 804d8f5:	83 c4 20             	add    $0x20,%esp
 804d8f8:	68 18 af 0f 10       	push   $0x100faf18
 804d8fd:	68 85 02 06 08       	push   $0x8060285
 804d902:	6a 50                	push   $0x50
 804d904:	68 00 8a 0c 08       	push   $0x80c8a00
 804d909:	e8 f2 b1 ff ff       	call   8048b00 <snprintf@plt>
 804d90e:	83 c4 10             	add    $0x10,%esp
 804d911:	83 f8 4f             	cmp    $0x4f,%eax
 804d914:	7e 85                	jle    804d89b <seto_rm_b+0x4b>
 804d916:	68 ff 02 06 08       	push   $0x80602ff
 804d91b:	6a 08                	push   $0x8
 804d91d:	68 90 02 06 08       	push   $0x8060290
 804d922:	68 b8 02 06 08       	push   $0x80602b8
 804d927:	e8 84 b2 ff ff       	call   8048bb0 <__assert_fail@plt>
 804d92c:	66 90                	xchg   %ax,%ax
 804d92e:	66 90                	xchg   %ax,%ax

0804d930 <setbe_rm_b>:
	int8_t res = cpu.CF || cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
}

make_instr_helper(rm)
 804d930:	53                   	push   %ebx
 804d931:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804d934:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804d938:	83 c0 01             	add    $0x1,%eax
 804d93b:	50                   	push   %eax
 804d93c:	e8 ef ec 00 00       	call   805c630 <decode_rm_b>
 804d941:	89 c3                	mov    %eax,%ebx

#define instr setbe

static void do_execute() {
	int8_t res = cpu.CF || cpu.ZF;
	OPERAND_W(op_src, res);
 804d943:	58                   	pop    %eax
#include "cpu/exec/template-start.h"

#define instr setbe

static void do_execute() {
	int8_t res = cpu.CF || cpu.ZF;
 804d944:	31 c0                	xor    %eax,%eax
 804d946:	f6 05 e4 af 0f 10 41 	testb  $0x41,0x100fafe4
	OPERAND_W(op_src, res);
 804d94d:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr setbe

static void do_execute() {
	int8_t res = cpu.CF || cpu.ZF;
 804d94e:	0f 95 c0             	setne  %al
	OPERAND_W(op_src, res);
 804d951:	50                   	push   %eax
 804d952:	68 08 af 0f 10       	push   $0x100faf08
 804d957:	e8 e4 ed 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 804d95c:	68 18 af 0f 10       	push   $0x100faf18
 804d961:	68 09 03 06 08       	push   $0x8060309
 804d966:	6a 50                	push   $0x50
 804d968:	68 00 8a 0c 08       	push   $0x80c8a00
 804d96d:	e8 8e b1 ff ff       	call   8048b00 <snprintf@plt>
 804d972:	83 c4 20             	add    $0x20,%esp
 804d975:	83 f8 4f             	cmp    $0x4f,%eax
 804d978:	7f 0e                	jg     804d988 <setbe_rm_b+0x58>
}

make_instr_helper(rm)
 804d97a:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804d97d:	8d 43 01             	lea    0x1(%ebx),%eax
 804d980:	5b                   	pop    %ebx
 804d981:	c3                   	ret    
 804d982:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define instr setbe

static void do_execute() {
	int8_t res = cpu.CF || cpu.ZF;
	OPERAND_W(op_src, res);
	print_asm_template1();
 804d988:	83 ec 0c             	sub    $0xc,%esp
 804d98b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804d991:	e8 ca af ff ff       	call   8048960 <fflush@plt>
 804d996:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d99c:	6a 07                	push   $0x7
 804d99e:	6a 01                	push   $0x1
 804d9a0:	68 92 e8 05 08       	push   $0x805e892
 804d9a5:	e8 66 b0 ff ff       	call   8048a10 <fwrite@plt>
 804d9aa:	83 c4 20             	add    $0x20,%esp
 804d9ad:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d9b3:	6a 10                	push   $0x10
 804d9b5:	6a 01                	push   $0x1
 804d9b7:	68 b4 f3 05 08       	push   $0x805f3b4
 804d9bc:	e8 4f b0 ff ff       	call   8048a10 <fwrite@plt>
 804d9c1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804d9c7:	6a 05                	push   $0x5
 804d9c9:	6a 01                	push   $0x1
 804d9cb:	68 42 f3 05 08       	push   $0x805f342
 804d9d0:	e8 3b b0 ff ff       	call   8048a10 <fwrite@plt>
 804d9d5:	83 c4 20             	add    $0x20,%esp
 804d9d8:	68 18 af 0f 10       	push   $0x100faf18
 804d9dd:	68 09 03 06 08       	push   $0x8060309
 804d9e2:	6a 50                	push   $0x50
 804d9e4:	68 00 8a 0c 08       	push   $0x80c8a00
 804d9e9:	e8 12 b1 ff ff       	call   8048b00 <snprintf@plt>
 804d9ee:	83 c4 10             	add    $0x10,%esp
 804d9f1:	83 f8 4f             	cmp    $0x4f,%eax
 804d9f4:	7e 84                	jle    804d97a <setbe_rm_b+0x4a>
 804d9f6:	68 88 03 06 08       	push   $0x8060388
 804d9fb:	6a 08                	push   $0x8
 804d9fd:	68 14 03 06 08       	push   $0x8060314
 804da02:	68 40 03 06 08       	push   $0x8060340
 804da07:	e8 a4 b1 ff ff       	call   8048bb0 <__assert_fail@plt>
 804da0c:	66 90                	xchg   %ax,%ax
 804da0e:	66 90                	xchg   %ax,%ax

0804da10 <data_size>:
#include "cpu/exec/helper.h"

make_helper(exec);

make_helper(data_size) {
 804da10:	83 ec 18             	sub    $0x18,%esp
	ops_decoded.is_data_size_16 = true;
 804da13:	c6 05 04 af 0f 10 01 	movb   $0x1,0x100faf04
	int instr_len = exec(eip + 1);
 804da1a:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804da1e:	83 c0 01             	add    $0x1,%eax
 804da21:	50                   	push   %eax
 804da22:	e8 29 f1 ff ff       	call   804cb50 <exec>
	ops_decoded.is_data_size_16 = false;
 804da27:	c6 05 04 af 0f 10 00 	movb   $0x0,0x100faf04
	return instr_len + 1;
 804da2e:	83 c0 01             	add    $0x1,%eax
}
 804da31:	83 c4 1c             	add    $0x1c,%esp
 804da34:	c3                   	ret    
 804da35:	66 90                	xchg   %ax,%ax
 804da37:	66 90                	xchg   %ax,%ax
 804da39:	66 90                	xchg   %ax,%ax
 804da3b:	66 90                	xchg   %ax,%ax
 804da3d:	66 90                	xchg   %ax,%ax
 804da3f:	90                   	nop

0804da40 <jmp_rm_w>:
#endif
	print_asm_template1();
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(jmp_rm_, SUFFIX)) {
 804da40:	83 ec 18             	sub    $0x18,%esp
	concat(decode_rm_, SUFFIX)(eip + 1);
 804da43:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804da47:	83 c0 01             	add    $0x1,%eax
 804da4a:	50                   	push   %eax
 804da4b:	e8 10 ef 00 00       	call   805c960 <decode_rm_w>
	cpu.eip = op_src->val;
 804da50:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	print_asm_template1();
 804da55:	68 18 af 0f 10       	push   $0x100faf18
 804da5a:	68 93 03 06 08       	push   $0x8060393
 804da5f:	6a 50                	push   $0x50
 804da61:	68 00 8a 0c 08       	push   $0x80c8a00
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(jmp_rm_, SUFFIX)) {
	concat(decode_rm_, SUFFIX)(eip + 1);
	cpu.eip = op_src->val;
 804da66:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
	print_asm_template1();
 804da6b:	e8 90 b0 ff ff       	call   8048b00 <snprintf@plt>
 804da70:	83 c4 20             	add    $0x20,%esp
 804da73:	83 f8 4f             	cmp    $0x4f,%eax
 804da76:	7f 08                	jg     804da80 <jmp_rm_w+0x40>
	return 0;
}
 804da78:	31 c0                	xor    %eax,%eax
 804da7a:	83 c4 0c             	add    $0xc,%esp
 804da7d:	c3                   	ret    
 804da7e:	66 90                	xchg   %ax,%ax

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(jmp_rm_, SUFFIX)) {
	concat(decode_rm_, SUFFIX)(eip + 1);
	cpu.eip = op_src->val;
	print_asm_template1();
 804da80:	83 ec 0c             	sub    $0xc,%esp
 804da83:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804da89:	e8 d2 ae ff ff       	call   8048960 <fflush@plt>
 804da8e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804da94:	6a 07                	push   $0x7
 804da96:	6a 01                	push   $0x1
 804da98:	68 92 e8 05 08       	push   $0x805e892
 804da9d:	e8 6e af ff ff       	call   8048a10 <fwrite@plt>
 804daa2:	83 c4 20             	add    $0x20,%esp
 804daa5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804daab:	6a 10                	push   $0x10
 804daad:	6a 01                	push   $0x1
 804daaf:	68 b4 f3 05 08       	push   $0x805f3b4
 804dab4:	e8 57 af ff ff       	call   8048a10 <fwrite@plt>
 804dab9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804dabf:	6a 05                	push   $0x5
 804dac1:	6a 01                	push   $0x1
 804dac3:	68 42 f3 05 08       	push   $0x805f342
 804dac8:	e8 43 af ff ff       	call   8048a10 <fwrite@plt>
 804dacd:	83 c4 20             	add    $0x20,%esp
 804dad0:	68 18 af 0f 10       	push   $0x100faf18
 804dad5:	68 93 03 06 08       	push   $0x8060393
 804dada:	6a 50                	push   $0x50
 804dadc:	68 00 8a 0c 08       	push   $0x80c8a00
 804dae1:	e8 1a b0 ff ff       	call   8048b00 <snprintf@plt>
 804dae6:	83 c4 10             	add    $0x10,%esp
 804dae9:	83 f8 4f             	cmp    $0x4f,%eax
 804daec:	7e 8a                	jle    804da78 <jmp_rm_w+0x38>
 804daee:	68 c5 04 06 08       	push   $0x80604c5
 804daf3:	6a 16                	push   $0x16
 804daf5:	68 ac 03 06 08       	push   $0x80603ac
 804dafa:	68 d4 03 06 08       	push   $0x80603d4
 804daff:	e8 ac b0 ff ff       	call   8048bb0 <__assert_fail@plt>
 804db04:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804db0a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804db10 <jmp_rm_l>:
#endif
	print_asm_template1();
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(jmp_rm_, SUFFIX)) {
 804db10:	83 ec 18             	sub    $0x18,%esp
	concat(decode_rm_, SUFFIX)(eip + 1);
 804db13:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804db17:	83 c0 01             	add    $0x1,%eax
 804db1a:	50                   	push   %eax
 804db1b:	e8 10 f2 00 00       	call   805cd30 <decode_rm_l>
	cpu.eip = op_src->val;
 804db20:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	print_asm_template1();
 804db25:	68 18 af 0f 10       	push   $0x100faf18
 804db2a:	68 9b 03 06 08       	push   $0x806039b
 804db2f:	6a 50                	push   $0x50
 804db31:	68 00 8a 0c 08       	push   $0x80c8a00
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(jmp_rm_, SUFFIX)) {
	concat(decode_rm_, SUFFIX)(eip + 1);
	cpu.eip = op_src->val;
 804db36:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
	print_asm_template1();
 804db3b:	e8 c0 af ff ff       	call   8048b00 <snprintf@plt>
 804db40:	83 c4 20             	add    $0x20,%esp
 804db43:	83 f8 4f             	cmp    $0x4f,%eax
 804db46:	7f 08                	jg     804db50 <jmp_rm_l+0x40>
	return 0;
}
 804db48:	31 c0                	xor    %eax,%eax
 804db4a:	83 c4 0c             	add    $0xc,%esp
 804db4d:	c3                   	ret    
 804db4e:	66 90                	xchg   %ax,%ax

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(jmp_rm_, SUFFIX)) {
	concat(decode_rm_, SUFFIX)(eip + 1);
	cpu.eip = op_src->val;
	print_asm_template1();
 804db50:	83 ec 0c             	sub    $0xc,%esp
 804db53:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804db59:	e8 02 ae ff ff       	call   8048960 <fflush@plt>
 804db5e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804db64:	6a 07                	push   $0x7
 804db66:	6a 01                	push   $0x1
 804db68:	68 92 e8 05 08       	push   $0x805e892
 804db6d:	e8 9e ae ff ff       	call   8048a10 <fwrite@plt>
 804db72:	83 c4 20             	add    $0x20,%esp
 804db75:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804db7b:	6a 10                	push   $0x10
 804db7d:	6a 01                	push   $0x1
 804db7f:	68 b4 f3 05 08       	push   $0x805f3b4
 804db84:	e8 87 ae ff ff       	call   8048a10 <fwrite@plt>
 804db89:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804db8f:	6a 05                	push   $0x5
 804db91:	6a 01                	push   $0x1
 804db93:	68 42 f3 05 08       	push   $0x805f342
 804db98:	e8 73 ae ff ff       	call   8048a10 <fwrite@plt>
 804db9d:	83 c4 20             	add    $0x20,%esp
 804dba0:	68 18 af 0f 10       	push   $0x100faf18
 804dba5:	68 9b 03 06 08       	push   $0x806039b
 804dbaa:	6a 50                	push   $0x50
 804dbac:	68 00 8a 0c 08       	push   $0x80c8a00
 804dbb1:	e8 4a af ff ff       	call   8048b00 <snprintf@plt>
 804dbb6:	83 c4 10             	add    $0x10,%esp
 804dbb9:	83 f8 4f             	cmp    $0x4f,%eax
 804dbbc:	7e 8a                	jle    804db48 <jmp_rm_l+0x38>
 804dbbe:	68 b3 04 06 08       	push   $0x80604b3
 804dbc3:	6a 16                	push   $0x16
 804dbc5:	68 ac 03 06 08       	push   $0x80603ac
 804dbca:	68 1c 04 06 08       	push   $0x806041c
 804dbcf:	e8 dc af ff ff       	call   8048bb0 <__assert_fail@plt>
 804dbd4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804dbda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804dbe0 <jmp_i_l>:
	return 0;
}
#endif

make_instr_helper(i)
 804dbe0:	56                   	push   %esi
 804dbe1:	53                   	push   %ebx
 804dbe2:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804dbe5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804dbe9:	83 c0 01             	add    $0x1,%eax
 804dbec:	50                   	push   %eax
 804dbed:	e8 4e ef 00 00       	call   805cb40 <decode_i_l>
 804dbf2:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jmp

static void do_execute() {
	int res = op_src->val;
 804dbf4:	8b 35 14 af 0f 10    	mov    0x100faf14,%esi

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 804dbfa:	58                   	pop    %eax
 804dbfb:	5a                   	pop    %edx
 804dbfc:	6a 01                	push   $0x1
 804dbfe:	ff 35 e0 af 0f 10    	pushl  0x100fafe0
 804dc04:	e8 47 d3 ff ff       	call   804af50 <swaddr_read>
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
 804dc09:	83 c4 10             	add    $0x10,%esp
 804dc0c:	3d eb 00 00 00       	cmp    $0xeb,%eax
 804dc11:	74 2d                	je     804dc40 <jmp_i_l+0x60>
 804dc13:	83 ec 08             	sub    $0x8,%esp
 804dc16:	6a 01                	push   $0x1
 804dc18:	ff 35 e0 af 0f 10    	pushl  0x100fafe0
 804dc1e:	e8 2d d3 ff ff       	call   804af50 <swaddr_read>
 804dc23:	83 c4 10             	add    $0x10,%esp
 804dc26:	3d e9 00 00 00       	cmp    $0xe9,%eax
 804dc2b:	74 13                	je     804dc40 <jmp_i_l+0x60>
		cpu.eip = cpu.eip + res;
	else
		cpu.eip = res - 2;
 804dc2d:	83 ee 02             	sub    $0x2,%esi
 804dc30:	89 35 e0 af 0f 10    	mov    %esi,0x100fafe0
 804dc36:	eb 0e                	jmp    804dc46 <jmp_i_l+0x66>
 804dc38:	90                   	nop
 804dc39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
		cpu.eip = cpu.eip + res;
 804dc40:	01 35 e0 af 0f 10    	add    %esi,0x100fafe0
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804dc46:	68 18 af 0f 10       	push   $0x100faf18
 804dc4b:	68 9b 03 06 08       	push   $0x806039b
 804dc50:	6a 50                	push   $0x50
 804dc52:	68 00 8a 0c 08       	push   $0x80c8a00
 804dc57:	e8 a4 ae ff ff       	call   8048b00 <snprintf@plt>
 804dc5c:	83 c4 10             	add    $0x10,%esp
 804dc5f:	83 f8 4f             	cmp    $0x4f,%eax
 804dc62:	7f 0c                	jg     804dc70 <jmp_i_l+0x90>
	print_asm_template1();
	return 0;
}
#endif

make_instr_helper(i)
 804dc64:	83 c4 04             	add    $0x4,%esp
/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
	execute();
	return len + 1;	// "1" for opcode
 804dc67:	8d 43 01             	lea    0x1(%ebx),%eax
 804dc6a:	5b                   	pop    %ebx
 804dc6b:	5e                   	pop    %esi
 804dc6c:	c3                   	ret    
 804dc6d:	8d 76 00             	lea    0x0(%esi),%esi
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804dc70:	83 ec 0c             	sub    $0xc,%esp
 804dc73:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804dc79:	e8 e2 ac ff ff       	call   8048960 <fflush@plt>
 804dc7e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804dc84:	6a 07                	push   $0x7
 804dc86:	6a 01                	push   $0x1
 804dc88:	68 92 e8 05 08       	push   $0x805e892
 804dc8d:	e8 7e ad ff ff       	call   8048a10 <fwrite@plt>
 804dc92:	83 c4 20             	add    $0x20,%esp
 804dc95:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804dc9b:	6a 10                	push   $0x10
 804dc9d:	6a 01                	push   $0x1
 804dc9f:	68 b4 f3 05 08       	push   $0x805f3b4
 804dca4:	e8 67 ad ff ff       	call   8048a10 <fwrite@plt>
 804dca9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804dcaf:	6a 05                	push   $0x5
 804dcb1:	6a 01                	push   $0x1
 804dcb3:	68 42 f3 05 08       	push   $0x805f342
 804dcb8:	e8 53 ad ff ff       	call   8048a10 <fwrite@plt>
 804dcbd:	83 c4 20             	add    $0x20,%esp
 804dcc0:	68 18 af 0f 10       	push   $0x100faf18
 804dcc5:	68 9b 03 06 08       	push   $0x806039b
 804dcca:	6a 50                	push   $0x50
 804dccc:	68 00 8a 0c 08       	push   $0x80c8a00
 804dcd1:	e8 2a ae ff ff       	call   8048b00 <snprintf@plt>
 804dcd6:	83 c4 10             	add    $0x10,%esp
 804dcd9:	83 f8 4f             	cmp    $0x4f,%eax
 804dcdc:	7e 86                	jle    804dc64 <jmp_i_l+0x84>
 804dcde:	68 aa 04 06 08       	push   $0x80604aa
 804dce3:	6a 0f                	push   $0xf
 804dce5:	68 ac 03 06 08       	push   $0x80603ac
 804dcea:	68 1c 04 06 08       	push   $0x806041c
 804dcef:	e8 bc ae ff ff       	call   8048bb0 <__assert_fail@plt>
 804dcf4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804dcfa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804dd00 <jmp_i_w>:
	print_asm_template1();
	return 0;
}
#endif

make_instr_helper(i)
 804dd00:	56                   	push   %esi
 804dd01:	53                   	push   %ebx
 804dd02:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804dd05:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804dd09:	83 c0 01             	add    $0x1,%eax
 804dd0c:	50                   	push   %eax
 804dd0d:	e8 9e ea 00 00       	call   805c7b0 <decode_i_w>
 804dd12:	89 c6                	mov    %eax,%esi

#define instr jmp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 804dd14:	0f bf 1d 14 af 0f 10 	movswl 0x100faf14,%ebx

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 804dd1b:	58                   	pop    %eax
 804dd1c:	5a                   	pop    %edx
 804dd1d:	6a 01                	push   $0x1
 804dd1f:	ff 35 e0 af 0f 10    	pushl  0x100fafe0
 804dd25:	e8 26 d2 ff ff       	call   804af50 <swaddr_read>
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
 804dd2a:	83 c4 10             	add    $0x10,%esp
 804dd2d:	3d eb 00 00 00       	cmp    $0xeb,%eax
 804dd32:	74 24                	je     804dd58 <jmp_i_w+0x58>
 804dd34:	83 ec 08             	sub    $0x8,%esp
 804dd37:	6a 01                	push   $0x1
 804dd39:	ff 35 e0 af 0f 10    	pushl  0x100fafe0
 804dd3f:	e8 0c d2 ff ff       	call   804af50 <swaddr_read>
 804dd44:	83 c4 10             	add    $0x10,%esp
 804dd47:	3d e9 00 00 00       	cmp    $0xe9,%eax
 804dd4c:	74 0a                	je     804dd58 <jmp_i_w+0x58>
		cpu.eip = cpu.eip + res;
	else
		cpu.eip = res - 2;
 804dd4e:	8d 53 fe             	lea    -0x2(%ebx),%edx
 804dd51:	eb 0d                	jmp    804dd60 <jmp_i_w+0x60>
 804dd53:	90                   	nop
 804dd54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
		cpu.eip = cpu.eip + res;
 804dd58:	03 1d e0 af 0f 10    	add    0x100fafe0,%ebx
 804dd5e:	89 da                	mov    %ebx,%edx
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804dd60:	68 18 af 0f 10       	push   $0x100faf18
 804dd65:	68 93 03 06 08       	push   $0x8060393
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
		cpu.eip = cpu.eip + res;
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
 804dd6a:	81 e2 ff ff 00 00    	and    $0xffff,%edx
#endif
	print_asm_template1();
 804dd70:	6a 50                	push   $0x50
 804dd72:	68 00 8a 0c 08       	push   $0x80c8a00
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
		cpu.eip = cpu.eip + res;
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
 804dd77:	89 15 e0 af 0f 10    	mov    %edx,0x100fafe0
#endif
	print_asm_template1();
 804dd7d:	e8 7e ad ff ff       	call   8048b00 <snprintf@plt>
 804dd82:	83 c4 10             	add    $0x10,%esp
 804dd85:	83 f8 4f             	cmp    $0x4f,%eax
 804dd88:	7f 0e                	jg     804dd98 <jmp_i_w+0x98>
	print_asm_template1();
	return 0;
}
#endif

make_instr_helper(i)
 804dd8a:	83 c4 04             	add    $0x4,%esp
/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
	execute();
	return len + 1;	// "1" for opcode
 804dd8d:	8d 46 01             	lea    0x1(%esi),%eax
 804dd90:	5b                   	pop    %ebx
 804dd91:	5e                   	pop    %esi
 804dd92:	c3                   	ret    
 804dd93:	90                   	nop
 804dd94:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804dd98:	83 ec 0c             	sub    $0xc,%esp
 804dd9b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804dda1:	e8 ba ab ff ff       	call   8048960 <fflush@plt>
 804dda6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ddac:	6a 07                	push   $0x7
 804ddae:	6a 01                	push   $0x1
 804ddb0:	68 92 e8 05 08       	push   $0x805e892
 804ddb5:	e8 56 ac ff ff       	call   8048a10 <fwrite@plt>
 804ddba:	83 c4 20             	add    $0x20,%esp
 804ddbd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ddc3:	6a 10                	push   $0x10
 804ddc5:	6a 01                	push   $0x1
 804ddc7:	68 b4 f3 05 08       	push   $0x805f3b4
 804ddcc:	e8 3f ac ff ff       	call   8048a10 <fwrite@plt>
 804ddd1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ddd7:	6a 05                	push   $0x5
 804ddd9:	6a 01                	push   $0x1
 804dddb:	68 42 f3 05 08       	push   $0x805f342
 804dde0:	e8 2b ac ff ff       	call   8048a10 <fwrite@plt>
 804dde5:	83 c4 20             	add    $0x20,%esp
 804dde8:	68 18 af 0f 10       	push   $0x100faf18
 804dded:	68 93 03 06 08       	push   $0x8060393
 804ddf2:	6a 50                	push   $0x50
 804ddf4:	68 00 8a 0c 08       	push   $0x80c8a00
 804ddf9:	e8 02 ad ff ff       	call   8048b00 <snprintf@plt>
 804ddfe:	83 c4 10             	add    $0x10,%esp
 804de01:	83 f8 4f             	cmp    $0x4f,%eax
 804de04:	7e 84                	jle    804dd8a <jmp_i_w+0x8a>
 804de06:	68 bc 04 06 08       	push   $0x80604bc
 804de0b:	6a 0f                	push   $0xf
 804de0d:	68 ac 03 06 08       	push   $0x80603ac
 804de12:	68 d4 03 06 08       	push   $0x80603d4
 804de17:	e8 94 ad ff ff       	call   8048bb0 <__assert_fail@plt>
 804de1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0804de20 <jmp_i_b>:
	print_asm_template1();
	return 0;
}
#endif

make_instr_helper(i)
 804de20:	56                   	push   %esi
 804de21:	53                   	push   %ebx
 804de22:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804de25:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804de29:	83 c0 01             	add    $0x1,%eax
 804de2c:	50                   	push   %eax
 804de2d:	e8 0e e6 00 00       	call   805c440 <decode_i_b>
 804de32:	89 c3                	mov    %eax,%ebx

#define instr jmp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 804de34:	0f be 35 14 af 0f 10 	movsbl 0x100faf14,%esi

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 804de3b:	58                   	pop    %eax
 804de3c:	5a                   	pop    %edx
 804de3d:	6a 01                	push   $0x1
 804de3f:	ff 35 e0 af 0f 10    	pushl  0x100fafe0
 804de45:	e8 06 d1 ff ff       	call   804af50 <swaddr_read>
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
 804de4a:	83 c4 10             	add    $0x10,%esp
 804de4d:	3d eb 00 00 00       	cmp    $0xeb,%eax
 804de52:	74 2c                	je     804de80 <jmp_i_b+0x60>
 804de54:	83 ec 08             	sub    $0x8,%esp
 804de57:	6a 01                	push   $0x1
 804de59:	ff 35 e0 af 0f 10    	pushl  0x100fafe0
 804de5f:	e8 ec d0 ff ff       	call   804af50 <swaddr_read>
 804de64:	83 c4 10             	add    $0x10,%esp
 804de67:	3d e9 00 00 00       	cmp    $0xe9,%eax
 804de6c:	74 12                	je     804de80 <jmp_i_b+0x60>
		cpu.eip = cpu.eip + res;
	else
		cpu.eip = res - 2;
 804de6e:	83 ee 02             	sub    $0x2,%esi
 804de71:	89 35 e0 af 0f 10    	mov    %esi,0x100fafe0
 804de77:	eb 0d                	jmp    804de86 <jmp_i_b+0x66>
 804de79:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(instr_fetch(cpu.eip, 1) == 0xeb || instr_fetch(cpu.eip, 1) == 0xe9)
		cpu.eip = cpu.eip + res;
 804de80:	01 35 e0 af 0f 10    	add    %esi,0x100fafe0
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804de86:	68 18 af 0f 10       	push   $0x100faf18
 804de8b:	68 a3 03 06 08       	push   $0x80603a3
 804de90:	6a 50                	push   $0x50
 804de92:	68 00 8a 0c 08       	push   $0x80c8a00
 804de97:	e8 64 ac ff ff       	call   8048b00 <snprintf@plt>
 804de9c:	83 c4 10             	add    $0x10,%esp
 804de9f:	83 f8 4f             	cmp    $0x4f,%eax
 804dea2:	7f 0c                	jg     804deb0 <jmp_i_b+0x90>
	print_asm_template1();
	return 0;
}
#endif

make_instr_helper(i)
 804dea4:	83 c4 04             	add    $0x4,%esp
/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
	execute();
	return len + 1;	// "1" for opcode
 804dea7:	8d 43 01             	lea    0x1(%ebx),%eax
 804deaa:	5b                   	pop    %ebx
 804deab:	5e                   	pop    %esi
 804deac:	c3                   	ret    
 804dead:	8d 76 00             	lea    0x0(%esi),%esi
	else
		cpu.eip = res - 2;
#if DATA_BYTE == 2
	cpu.eip = cpu.eip & 0xffff;
#endif
	print_asm_template1();
 804deb0:	83 ec 0c             	sub    $0xc,%esp
 804deb3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804deb9:	e8 a2 aa ff ff       	call   8048960 <fflush@plt>
 804debe:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804dec4:	6a 07                	push   $0x7
 804dec6:	6a 01                	push   $0x1
 804dec8:	68 92 e8 05 08       	push   $0x805e892
 804decd:	e8 3e ab ff ff       	call   8048a10 <fwrite@plt>
 804ded2:	83 c4 20             	add    $0x20,%esp
 804ded5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804dedb:	6a 10                	push   $0x10
 804dedd:	6a 01                	push   $0x1
 804dedf:	68 b4 f3 05 08       	push   $0x805f3b4
 804dee4:	e8 27 ab ff ff       	call   8048a10 <fwrite@plt>
 804dee9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804deef:	6a 05                	push   $0x5
 804def1:	6a 01                	push   $0x1
 804def3:	68 42 f3 05 08       	push   $0x805f342
 804def8:	e8 13 ab ff ff       	call   8048a10 <fwrite@plt>
 804defd:	83 c4 20             	add    $0x20,%esp
 804df00:	68 18 af 0f 10       	push   $0x100faf18
 804df05:	68 a3 03 06 08       	push   $0x80603a3
 804df0a:	6a 50                	push   $0x50
 804df0c:	68 00 8a 0c 08       	push   $0x80c8a00
 804df11:	e8 ea ab ff ff       	call   8048b00 <snprintf@plt>
 804df16:	83 c4 10             	add    $0x10,%esp
 804df19:	83 f8 4f             	cmp    $0x4f,%eax
 804df1c:	7e 86                	jle    804dea4 <jmp_i_b+0x84>
 804df1e:	68 ce 04 06 08       	push   $0x80604ce
 804df23:	6a 0f                	push   $0xf
 804df25:	68 ac 03 06 08       	push   $0x80603ac
 804df2a:	68 64 04 06 08       	push   $0x8060464
 804df2f:	e8 7c ac ff ff       	call   8048bb0 <__assert_fail@plt>
 804df34:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804df3a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804df40 <jmp_i_v>:
#include "jmp-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jmp_i)
 804df40:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804df47:	8b 54 24 04          	mov    0x4(%esp),%edx
 804df4b:	b8 00 dd 04 08       	mov    $0x804dd00,%eax
 804df50:	75 05                	jne    804df57 <jmp_i_v+0x17>
 804df52:	b8 e0 db 04 08       	mov    $0x804dbe0,%eax
 804df57:	89 54 24 04          	mov    %edx,0x4(%esp)
 804df5b:	ff e0                	jmp    *%eax
 804df5d:	8d 76 00             	lea    0x0(%esi),%esi

0804df60 <jmp_rm_v>:
make_helper_v(jmp_rm)
 804df60:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804df67:	8b 54 24 04          	mov    0x4(%esp),%edx
 804df6b:	b8 40 da 04 08       	mov    $0x804da40,%eax
 804df70:	75 05                	jne    804df77 <jmp_rm_v+0x17>
 804df72:	b8 10 db 04 08       	mov    $0x804db10,%eax
 804df77:	89 54 24 04          	mov    %edx,0x4(%esp)
 804df7b:	ff e0                	jmp    *%eax
 804df7d:	66 90                	xchg   %ax,%ax
 804df7f:	90                   	nop

0804df80 <shrdi_w>:
	OPERAND_W(op_src2, out);

	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
}

make_helper(concat(shrdi_, SUFFIX)) {
 804df80:	56                   	push   %esi
 804df81:	53                   	push   %ebx
 804df82:	83 ec 10             	sub    $0x10,%esp
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
 804df85:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804df89:	83 c0 01             	add    $0x1,%eax
 804df8c:	50                   	push   %eax
 804df8d:	e8 2e ea 00 00       	call   805c9c0 <decode_si_rm2r_w>
 804df92:	89 c6                	mov    %eax,%esi
	op_dest->val = REG(op_dest->reg);
 804df94:	a1 48 af 0f 10       	mov    0x100faf48,%eax
 804df99:	83 c4 10             	add    $0x10,%esp
 804df9c:	83 f8 07             	cmp    $0x7,%eax
 804df9f:	0f 87 1d 01 00 00    	ja     804e0c2 <shrdi_w+0x142>
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804dfa5:	0f b6 1d 14 af 0f 10 	movzbl 0x100faf14,%ebx
	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
}

make_helper(concat(shrdi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
 804dfac:	0f b7 04 85 c0 af 0f 	movzwl 0x100fafc0(,%eax,4),%eax
 804dfb3:	10 
#define instr shrd

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute () {
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;
 804dfb4:	0f b7 15 84 af 0f 10 	movzwl 0x100faf84,%edx

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804dfbb:	83 e3 1f             	and    $0x1f,%ebx
	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
}

make_helper(concat(shrdi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
 804dfbe:	89 c1                	mov    %eax,%ecx
 804dfc0:	a3 4c af 0f 10       	mov    %eax,0x100faf4c
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804dfc5:	75 0c                	jne    804dfd3 <shrdi_w+0x53>
 804dfc7:	eb 1a                	jmp    804dfe3 <shrdi_w+0x63>
 804dfc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804dfd0:	0f b7 c1             	movzwl %cx,%eax
		out >>= 1;
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
 804dfd3:	c1 e0 0f             	shl    $0xf,%eax
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out >>= 1;
 804dfd6:	66 d1 ea             	shr    %dx
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
		in >>= 1;
 804dfd9:	66 d1 e9             	shr    %cx

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out >>= 1;
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
 804dfdc:	09 c2                	or     %eax,%edx
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804dfde:	80 eb 01             	sub    $0x1,%bl
 804dfe1:	75 ed                	jne    804dfd0 <shrdi_w+0x50>
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
		in >>= 1;
		count --;
	}

	OPERAND_W(op_src2, out);
 804dfe3:	83 ec 08             	sub    $0x8,%esp
 804dfe6:	0f b7 d2             	movzwl %dx,%edx
 804dfe9:	52                   	push   %edx
 804dfea:	68 78 af 0f 10       	push   $0x100faf78
 804dfef:	e8 dc ea 00 00       	call   805cad0 <write_operand_w>

	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804dff4:	58                   	pop    %eax
 804dff5:	5a                   	pop    %edx
 804dff6:	68 88 af 0f 10       	push   $0x100faf88
 804dffb:	68 50 af 0f 10       	push   $0x100faf50
 804e000:	68 18 af 0f 10       	push   $0x100faf18
 804e005:	68 d7 04 06 08       	push   $0x80604d7
 804e00a:	6a 50                	push   $0x50
 804e00c:	68 00 8a 0c 08       	push   $0x80c8a00
 804e011:	e8 ea aa ff ff       	call   8048b00 <snprintf@plt>
 804e016:	83 c4 20             	add    $0x20,%esp
 804e019:	83 f8 4f             	cmp    $0x4f,%eax
 804e01c:	7f 12                	jg     804e030 <shrdi_w+0xb0>
make_helper(concat(shrdi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
	do_execute();
	return len + 1;
}
 804e01e:	83 c4 04             	add    $0x4,%esp

make_helper(concat(shrdi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
	do_execute();
	return len + 1;
 804e021:	8d 46 01             	lea    0x1(%esi),%eax
}
 804e024:	5b                   	pop    %ebx
 804e025:	5e                   	pop    %esi
 804e026:	c3                   	ret    
 804e027:	89 f6                	mov    %esi,%esi
 804e029:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		count --;
	}

	OPERAND_W(op_src2, out);

	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804e030:	83 ec 0c             	sub    $0xc,%esp
 804e033:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804e039:	e8 22 a9 ff ff       	call   8048960 <fflush@plt>
 804e03e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e044:	6a 07                	push   $0x7
 804e046:	6a 01                	push   $0x1
 804e048:	68 92 e8 05 08       	push   $0x805e892
 804e04d:	e8 be a9 ff ff       	call   8048a10 <fwrite@plt>
 804e052:	83 c4 20             	add    $0x20,%esp
 804e055:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e05b:	6a 10                	push   $0x10
 804e05d:	6a 01                	push   $0x1
 804e05f:	68 b4 f3 05 08       	push   $0x805f3b4
 804e064:	e8 a7 a9 ff ff       	call   8048a10 <fwrite@plt>
 804e069:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e06f:	6a 05                	push   $0x5
 804e071:	6a 01                	push   $0x1
 804e073:	68 42 f3 05 08       	push   $0x805f342
 804e078:	e8 93 a9 ff ff       	call   8048a10 <fwrite@plt>
 804e07d:	83 c4 18             	add    $0x18,%esp
 804e080:	68 88 af 0f 10       	push   $0x100faf88
 804e085:	68 50 af 0f 10       	push   $0x100faf50
 804e08a:	68 18 af 0f 10       	push   $0x100faf18
 804e08f:	68 d7 04 06 08       	push   $0x80604d7
 804e094:	6a 50                	push   $0x50
 804e096:	68 00 8a 0c 08       	push   $0x80c8a00
 804e09b:	e8 60 aa ff ff       	call   8048b00 <snprintf@plt>
 804e0a0:	83 c4 20             	add    $0x20,%esp
 804e0a3:	83 f8 4f             	cmp    $0x4f,%eax
 804e0a6:	0f 8e 72 ff ff ff    	jle    804e01e <shrdi_w+0x9e>
 804e0ac:	68 2f 06 06 08       	push   $0x806062f
 804e0b1:	6a 15                	push   $0x15
 804e0b3:	68 f8 04 06 08       	push   $0x80604f8
 804e0b8:	68 20 05 06 08       	push   $0x8060520
 804e0bd:	e8 ee aa ff ff       	call   8048bb0 <__assert_fail@plt>
 804e0c2:	e8 12 ab ff ff       	call   8048bd9 <check_reg_index.part.0>
 804e0c7:	89 f6                	mov    %esi,%esi
 804e0c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804e0d0 <shrdi_l>:
}

make_helper(concat(shrdi_, SUFFIX)) {
 804e0d0:	56                   	push   %esi
 804e0d1:	53                   	push   %ebx
 804e0d2:	83 ec 10             	sub    $0x10,%esp
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
 804e0d5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e0d9:	83 c0 01             	add    $0x1,%eax
 804e0dc:	50                   	push   %eax
 804e0dd:	e8 ae ec 00 00       	call   805cd90 <decode_si_rm2r_l>
 804e0e2:	89 c3                	mov    %eax,%ebx
	op_dest->val = REG(op_dest->reg);
 804e0e4:	a1 48 af 0f 10       	mov    0x100faf48,%eax
 804e0e9:	83 c4 10             	add    $0x10,%esp
 804e0ec:	83 f8 07             	cmp    $0x7,%eax
 804e0ef:	0f 87 0d 01 00 00    	ja     804e202 <shrdi_l+0x132>
 804e0f5:	8b 0c 85 c0 af 0f 10 	mov    0x100fafc0(,%eax,4),%ecx
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804e0fc:	0f b6 05 14 af 0f 10 	movzbl 0x100faf14,%eax
#define instr shrd

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute () {
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;
 804e103:	8b 15 84 af 0f 10    	mov    0x100faf84,%edx
	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
}

make_helper(concat(shrdi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
 804e109:	89 0d 4c af 0f 10    	mov    %ecx,0x100faf4c
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804e10f:	83 e0 1f             	and    $0x1f,%eax
 804e112:	74 13                	je     804e127 <shrdi_l+0x57>
 804e114:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		out >>= 1;
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
 804e118:	89 ce                	mov    %ecx,%esi
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out >>= 1;
 804e11a:	d1 ea                	shr    %edx
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
		in >>= 1;
 804e11c:	d1 e9                	shr    %ecx

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out >>= 1;
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
 804e11e:	c1 e6 1f             	shl    $0x1f,%esi
 804e121:	09 f2                	or     %esi,%edx
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804e123:	2c 01                	sub    $0x1,%al
 804e125:	75 f1                	jne    804e118 <shrdi_l+0x48>
		out |= (in & 1) << ((DATA_BYTE << 3) - 1);
		in >>= 1;
		count --;
	}

	OPERAND_W(op_src2, out);
 804e127:	83 ec 08             	sub    $0x8,%esp
 804e12a:	52                   	push   %edx
 804e12b:	68 78 af 0f 10       	push   $0x100faf78
 804e130:	e8 6b ed 00 00       	call   805cea0 <write_operand_l>

	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804e135:	58                   	pop    %eax
 804e136:	5a                   	pop    %edx
 804e137:	68 88 af 0f 10       	push   $0x100faf88
 804e13c:	68 50 af 0f 10       	push   $0x100faf50
 804e141:	68 18 af 0f 10       	push   $0x100faf18
 804e146:	68 e6 04 06 08       	push   $0x80604e6
 804e14b:	6a 50                	push   $0x50
 804e14d:	68 00 8a 0c 08       	push   $0x80c8a00
 804e152:	e8 a9 a9 ff ff       	call   8048b00 <snprintf@plt>
 804e157:	83 c4 20             	add    $0x20,%esp
 804e15a:	83 f8 4f             	cmp    $0x4f,%eax
 804e15d:	7f 11                	jg     804e170 <shrdi_l+0xa0>
make_helper(concat(shrdi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
	do_execute();
	return len + 1;
}
 804e15f:	83 c4 04             	add    $0x4,%esp

make_helper(concat(shrdi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
	do_execute();
	return len + 1;
 804e162:	8d 43 01             	lea    0x1(%ebx),%eax
}
 804e165:	5b                   	pop    %ebx
 804e166:	5e                   	pop    %esi
 804e167:	c3                   	ret    
 804e168:	90                   	nop
 804e169:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		count --;
	}

	OPERAND_W(op_src2, out);

	print_asm("shrd" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804e170:	83 ec 0c             	sub    $0xc,%esp
 804e173:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804e179:	e8 e2 a7 ff ff       	call   8048960 <fflush@plt>
 804e17e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e184:	6a 07                	push   $0x7
 804e186:	6a 01                	push   $0x1
 804e188:	68 92 e8 05 08       	push   $0x805e892
 804e18d:	e8 7e a8 ff ff       	call   8048a10 <fwrite@plt>
 804e192:	83 c4 20             	add    $0x20,%esp
 804e195:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e19b:	6a 10                	push   $0x10
 804e19d:	6a 01                	push   $0x1
 804e19f:	68 b4 f3 05 08       	push   $0x805f3b4
 804e1a4:	e8 67 a8 ff ff       	call   8048a10 <fwrite@plt>
 804e1a9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e1af:	6a 05                	push   $0x5
 804e1b1:	6a 01                	push   $0x1
 804e1b3:	68 42 f3 05 08       	push   $0x805f342
 804e1b8:	e8 53 a8 ff ff       	call   8048a10 <fwrite@plt>
 804e1bd:	83 c4 18             	add    $0x18,%esp
 804e1c0:	68 88 af 0f 10       	push   $0x100faf88
 804e1c5:	68 50 af 0f 10       	push   $0x100faf50
 804e1ca:	68 18 af 0f 10       	push   $0x100faf18
 804e1cf:	68 e6 04 06 08       	push   $0x80604e6
 804e1d4:	6a 50                	push   $0x50
 804e1d6:	68 00 8a 0c 08       	push   $0x80c8a00
 804e1db:	e8 20 a9 ff ff       	call   8048b00 <snprintf@plt>
 804e1e0:	83 c4 20             	add    $0x20,%esp
 804e1e3:	83 f8 4f             	cmp    $0x4f,%eax
 804e1e6:	0f 8e 73 ff ff ff    	jle    804e15f <shrdi_l+0x8f>
 804e1ec:	68 25 06 06 08       	push   $0x8060625
 804e1f1:	6a 15                	push   $0x15
 804e1f3:	68 f8 04 06 08       	push   $0x80604f8
 804e1f8:	68 a4 05 06 08       	push   $0x80605a4
 804e1fd:	e8 ae a9 ff ff       	call   8048bb0 <__assert_fail@plt>
 804e202:	e8 d2 a9 ff ff       	call   8048bd9 <check_reg_index.part.0>
 804e207:	89 f6                	mov    %esi,%esi
 804e209:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804e210 <shrdi_v>:
#define DATA_BYTE 4
#include "shrd-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */
make_helper_v(shrdi)
 804e210:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804e217:	8b 54 24 04          	mov    0x4(%esp),%edx
 804e21b:	b8 80 df 04 08       	mov    $0x804df80,%eax
 804e220:	75 05                	jne    804e227 <shrdi_v+0x17>
 804e222:	b8 d0 e0 04 08       	mov    $0x804e0d0,%eax
 804e227:	89 54 24 04          	mov    %edx,0x4(%esp)
 804e22b:	ff e0                	jmp    *%eax
 804e22d:	66 90                	xchg   %ax,%ax
 804e22f:	90                   	nop

0804e230 <do_and_b>:
#include "cpu/exec/template-start.h"

#define instr and

static void do_execute () {
 804e230:	56                   	push   %esi
 804e231:	53                   	push   %ebx
 804e232:	83 ec 0c             	sub    $0xc,%esp
	DATA_TYPE result = op_dest->val & op_src->val;
 804e235:	a1 4c af 0f 10       	mov    0x100faf4c,%eax
 804e23a:	22 05 14 af 0f 10    	and    0x100faf14,%al
	OPERAND_W(op_dest, result);
 804e240:	0f b6 d8             	movzbl %al,%ebx
#include "cpu/exec/template-start.h"

#define instr and

static void do_execute () {
	DATA_TYPE result = op_dest->val & op_src->val;
 804e243:	89 c6                	mov    %eax,%esi
	OPERAND_W(op_dest, result);
 804e245:	53                   	push   %ebx
 804e246:	68 40 af 0f 10       	push   $0x100faf40
 804e24b:	e8 f0 e4 00 00       	call   805c740 <write_operand_b>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e250:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
	cpu.ZF = !result;
 804e257:	89 f0                	mov    %esi,%eax
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e259:	89 f2                	mov    %esi,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 804e25b:	80 25 e5 af 0f 10 f7 	andb   $0xf7,0x100fafe5
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e262:	83 e2 80             	and    $0xffffff80,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e265:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 804e26c:	68 18 af 0f 10       	push   $0x100faf18
 804e271:	68 49 06 06 08       	push   $0x8060649
 804e276:	6a 50                	push   $0x50
 804e278:	68 00 8a 0c 08       	push   $0x80c8a00
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e27d:	83 e1 3e             	and    $0x3e,%ecx
	cpu.ZF = !result;
 804e280:	84 c0                	test   %al,%al
 804e282:	0f 94 c0             	sete   %al
 804e285:	09 ca                	or     %ecx,%edx
 804e287:	c1 e0 06             	shl    $0x6,%eax
 804e28a:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804e28c:	89 d8                	mov    %ebx,%eax
 804e28e:	c1 e8 04             	shr    $0x4,%eax
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 804e291:	83 e2 fb             	and    $0xfffffffb,%edx
	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804e294:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 2) ^ pf;
 804e296:	89 d8                	mov    %ebx,%eax
 804e298:	c1 e8 02             	shr    $0x2,%eax
 804e29b:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 804e29d:	89 d8                	mov    %ebx,%eax
 804e29f:	d1 e8                	shr    %eax
 804e2a1:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 804e2a3:	83 e3 01             	and    $0x1,%ebx
 804e2a6:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 804e2ad:	89 d3                	mov    %edx,%ebx
 804e2af:	09 c3                	or     %eax,%ebx
 804e2b1:	88 1d e4 af 0f 10    	mov    %bl,0x100fafe4

	print_asm_template2();
 804e2b7:	e8 44 a8 ff ff       	call   8048b00 <snprintf@plt>
 804e2bc:	83 c4 20             	add    $0x20,%esp
 804e2bf:	83 f8 4f             	cmp    $0x4f,%eax
 804e2c2:	7f 0c                	jg     804e2d0 <do_and_b+0xa0>
}
 804e2c4:	83 c4 04             	add    $0x4,%esp
 804e2c7:	5b                   	pop    %ebx
 804e2c8:	5e                   	pop    %esi
 804e2c9:	c3                   	ret    
 804e2ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e2d0:	83 ec 0c             	sub    $0xc,%esp
 804e2d3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804e2d9:	e8 82 a6 ff ff       	call   8048960 <fflush@plt>
 804e2de:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e2e4:	6a 07                	push   $0x7
 804e2e6:	6a 01                	push   $0x1
 804e2e8:	68 92 e8 05 08       	push   $0x805e892
 804e2ed:	e8 1e a7 ff ff       	call   8048a10 <fwrite@plt>
 804e2f2:	83 c4 20             	add    $0x20,%esp
 804e2f5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e2fb:	6a 10                	push   $0x10
 804e2fd:	6a 01                	push   $0x1
 804e2ff:	68 b4 f3 05 08       	push   $0x805f3b4
 804e304:	e8 07 a7 ff ff       	call   8048a10 <fwrite@plt>
 804e309:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e30f:	6a 05                	push   $0x5
 804e311:	6a 01                	push   $0x1
 804e313:	68 42 f3 05 08       	push   $0x805f342
 804e318:	e8 f3 a6 ff ff       	call   8048a10 <fwrite@plt>
 804e31d:	83 c4 14             	add    $0x14,%esp
 804e320:	68 50 af 0f 10       	push   $0x100faf50
 804e325:	68 18 af 0f 10       	push   $0x100faf18
 804e32a:	68 49 06 06 08       	push   $0x8060649
 804e32f:	6a 50                	push   $0x50
 804e331:	68 00 8a 0c 08       	push   $0x80c8a00
 804e336:	e8 c5 a7 ff ff       	call   8048b00 <snprintf@plt>
 804e33b:	83 c4 20             	add    $0x20,%esp
 804e33e:	83 f8 4f             	cmp    $0x4f,%eax
 804e341:	7e 81                	jle    804e2c4 <do_and_b+0x94>
 804e343:	68 d1 07 06 08       	push   $0x80607d1
 804e348:	6a 13                	push   $0x13
 804e34a:	68 6c 06 06 08       	push   $0x806066c
 804e34f:	68 94 06 06 08       	push   $0x8060694
 804e354:	e8 57 a8 ff ff       	call   8048bb0 <__assert_fail@plt>
 804e359:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804e360 <do_and_w>:
#include "cpu/exec/template-start.h"

#define instr and

static void do_execute () {
 804e360:	53                   	push   %ebx
 804e361:	83 ec 10             	sub    $0x10,%esp
	DATA_TYPE result = op_dest->val & op_src->val;
 804e364:	8b 1d 4c af 0f 10    	mov    0x100faf4c,%ebx
 804e36a:	66 23 1d 14 af 0f 10 	and    0x100faf14,%bx
	OPERAND_W(op_dest, result);
 804e371:	0f b7 c3             	movzwl %bx,%eax
 804e374:	50                   	push   %eax
 804e375:	68 40 af 0f 10       	push   $0x100faf40
 804e37a:	e8 51 e7 00 00       	call   805cad0 <write_operand_w>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e37f:	89 da                	mov    %ebx,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 804e381:	80 25 e5 af 0f 10 f7 	andb   $0xf7,0x100fafe5
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e388:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e38f:	66 c1 ea 0f          	shr    $0xf,%dx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e393:	68 18 af 0f 10       	push   $0x100faf18
 804e398:	68 54 06 06 08       	push   $0x8060654
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e39d:	89 d0                	mov    %edx,%eax
 804e39f:	0f b6 15 e4 af 0f 10 	movzbl 0x100fafe4,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e3a6:	6a 50                	push   $0x50
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e3a8:	c1 e0 07             	shl    $0x7,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e3ab:	68 00 8a 0c 08       	push   $0x80c8a00
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e3b0:	83 e2 3e             	and    $0x3e,%edx
	cpu.ZF = !result;
 804e3b3:	66 85 db             	test   %bx,%bx
	uint32_t pf = (result & 255);
 804e3b6:	0f b6 db             	movzbl %bl,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804e3b9:	0f 94 c1             	sete   %cl
 804e3bc:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804e3be:	89 d8                	mov    %ebx,%eax
 804e3c0:	c1 e8 04             	shr    $0x4,%eax
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804e3c3:	c1 e1 06             	shl    $0x6,%ecx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804e3c6:	31 c3                	xor    %eax,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804e3c8:	09 ca                	or     %ecx,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804e3ca:	89 d8                	mov    %ebx,%eax
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 804e3cc:	83 e2 fb             	and    $0xfffffffb,%edx
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804e3cf:	c1 e8 02             	shr    $0x2,%eax
 804e3d2:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 804e3d4:	89 d8                	mov    %ebx,%eax
 804e3d6:	d1 e8                	shr    %eax
 804e3d8:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 804e3da:	83 e3 01             	and    $0x1,%ebx
 804e3dd:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 804e3e4:	89 d3                	mov    %edx,%ebx
 804e3e6:	09 c3                	or     %eax,%ebx
 804e3e8:	88 1d e4 af 0f 10    	mov    %bl,0x100fafe4

	print_asm_template2();
 804e3ee:	e8 0d a7 ff ff       	call   8048b00 <snprintf@plt>
 804e3f3:	83 c4 20             	add    $0x20,%esp
 804e3f6:	83 f8 4f             	cmp    $0x4f,%eax
 804e3f9:	7f 05                	jg     804e400 <do_and_w+0xa0>
}
 804e3fb:	83 c4 08             	add    $0x8,%esp
 804e3fe:	5b                   	pop    %ebx
 804e3ff:	c3                   	ret    
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e400:	83 ec 0c             	sub    $0xc,%esp
 804e403:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804e409:	e8 52 a5 ff ff       	call   8048960 <fflush@plt>
 804e40e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e414:	6a 07                	push   $0x7
 804e416:	6a 01                	push   $0x1
 804e418:	68 92 e8 05 08       	push   $0x805e892
 804e41d:	e8 ee a5 ff ff       	call   8048a10 <fwrite@plt>
 804e422:	83 c4 20             	add    $0x20,%esp
 804e425:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e42b:	6a 10                	push   $0x10
 804e42d:	6a 01                	push   $0x1
 804e42f:	68 b4 f3 05 08       	push   $0x805f3b4
 804e434:	e8 d7 a5 ff ff       	call   8048a10 <fwrite@plt>
 804e439:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e43f:	6a 05                	push   $0x5
 804e441:	6a 01                	push   $0x1
 804e443:	68 42 f3 05 08       	push   $0x805f342
 804e448:	e8 c3 a5 ff ff       	call   8048a10 <fwrite@plt>
 804e44d:	83 c4 14             	add    $0x14,%esp
 804e450:	68 50 af 0f 10       	push   $0x100faf50
 804e455:	68 18 af 0f 10       	push   $0x100faf18
 804e45a:	68 54 06 06 08       	push   $0x8060654
 804e45f:	6a 50                	push   $0x50
 804e461:	68 00 8a 0c 08       	push   $0x80c8a00
 804e466:	e8 95 a6 ff ff       	call   8048b00 <snprintf@plt>
 804e46b:	83 c4 20             	add    $0x20,%esp
 804e46e:	83 f8 4f             	cmp    $0x4f,%eax
 804e471:	7e 88                	jle    804e3fb <do_and_w+0x9b>
 804e473:	68 c8 07 06 08       	push   $0x80607c8
 804e478:	6a 13                	push   $0x13
 804e47a:	68 6c 06 06 08       	push   $0x806066c
 804e47f:	68 f8 06 06 08       	push   $0x80606f8
 804e484:	e8 27 a7 ff ff       	call   8048bb0 <__assert_fail@plt>
 804e489:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804e490 <and_i2a_w>:
}

make_instr_helper(i2a)
 804e490:	53                   	push   %ebx
 804e491:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e494:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e498:	83 c0 01             	add    $0x1,%eax
 804e49b:	50                   	push   %eax
 804e49c:	e8 ef e3 00 00       	call   805c890 <decode_i2a_w>
 804e4a1:	89 c3                	mov    %eax,%ebx
	execute();
 804e4a3:	e8 b8 fe ff ff       	call   804e360 <do_and_w>
 804e4a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e4ab:	8d 43 01             	lea    0x1(%ebx),%eax
 804e4ae:	5b                   	pop    %ebx
 804e4af:	c3                   	ret    

0804e4b0 <and_i2rm_w>:
make_instr_helper(i2rm)
 804e4b0:	53                   	push   %ebx
 804e4b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e4b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e4b8:	83 c0 01             	add    $0x1,%eax
 804e4bb:	50                   	push   %eax
 804e4bc:	e8 4f e4 00 00       	call   805c910 <decode_i2rm_w>
 804e4c1:	89 c3                	mov    %eax,%ebx
	execute();
 804e4c3:	e8 98 fe ff ff       	call   804e360 <do_and_w>
 804e4c8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e4cb:	8d 43 01             	lea    0x1(%ebx),%eax
 804e4ce:	5b                   	pop    %ebx
 804e4cf:	c3                   	ret    

0804e4d0 <and_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 804e4d0:	53                   	push   %ebx
 804e4d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e4d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e4d8:	83 c0 01             	add    $0x1,%eax
 804e4db:	50                   	push   %eax
 804e4dc:	e8 af e4 00 00       	call   805c990 <decode_si2rm_w>
 804e4e1:	89 c3                	mov    %eax,%ebx
	execute();
 804e4e3:	e8 78 fe ff ff       	call   804e360 <do_and_w>
 804e4e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e4eb:	8d 43 01             	lea    0x1(%ebx),%eax
 804e4ee:	5b                   	pop    %ebx
 804e4ef:	c3                   	ret    

0804e4f0 <and_r2rm_w>:
#endif
make_instr_helper(r2rm)
 804e4f0:	53                   	push   %ebx
 804e4f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e4f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e4f8:	83 c0 01             	add    $0x1,%eax
 804e4fb:	50                   	push   %eax
 804e4fc:	e8 4f e3 00 00       	call   805c850 <decode_r2rm_w>
 804e501:	89 c3                	mov    %eax,%ebx
	execute();
 804e503:	e8 58 fe ff ff       	call   804e360 <do_and_w>
 804e508:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e50b:	8d 43 01             	lea    0x1(%ebx),%eax
 804e50e:	5b                   	pop    %ebx
 804e50f:	c3                   	ret    

0804e510 <and_rm2r_w>:
make_instr_helper(rm2r)
 804e510:	53                   	push   %ebx
 804e511:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e514:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e518:	83 c0 01             	add    $0x1,%eax
 804e51b:	50                   	push   %eax
 804e51c:	e8 4f e3 00 00       	call   805c870 <decode_rm2r_w>
 804e521:	89 c3                	mov    %eax,%ebx
	execute();
 804e523:	e8 38 fe ff ff       	call   804e360 <do_and_w>
 804e528:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e52b:	8d 43 01             	lea    0x1(%ebx),%eax
 804e52e:	5b                   	pop    %ebx
 804e52f:	c3                   	ret    

0804e530 <do_and_l>:
#include "cpu/exec/template-start.h"

#define instr and

static void do_execute () {
 804e530:	53                   	push   %ebx
 804e531:	83 ec 10             	sub    $0x10,%esp
	DATA_TYPE result = op_dest->val & op_src->val;
 804e534:	8b 1d 14 af 0f 10    	mov    0x100faf14,%ebx
 804e53a:	23 1d 4c af 0f 10    	and    0x100faf4c,%ebx
	OPERAND_W(op_dest, result);
 804e540:	53                   	push   %ebx
 804e541:	68 40 af 0f 10       	push   $0x100faf40
 804e546:	e8 55 e9 00 00       	call   805cea0 <write_operand_l>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e54b:	89 da                	mov    %ebx,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 804e54d:	80 25 e5 af 0f 10 f7 	andb   $0xf7,0x100fafe5
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e554:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e55b:	c1 ea 1f             	shr    $0x1f,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e55e:	68 18 af 0f 10       	push   $0x100faf18
 804e563:	68 5f 06 06 08       	push   $0x806065f
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e568:	89 d0                	mov    %edx,%eax
 804e56a:	0f b6 15 e4 af 0f 10 	movzbl 0x100fafe4,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e571:	6a 50                	push   $0x50
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e573:	c1 e0 07             	shl    $0x7,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e576:	68 00 8a 0c 08       	push   $0x80c8a00
	DATA_TYPE result = op_dest->val & op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804e57b:	83 e2 3e             	and    $0x3e,%edx
	cpu.ZF = !result;
 804e57e:	85 db                	test   %ebx,%ebx
	uint32_t pf = (result & 255);
 804e580:	0f b6 db             	movzbl %bl,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804e583:	0f 94 c1             	sete   %cl
 804e586:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804e588:	89 d8                	mov    %ebx,%eax
 804e58a:	c1 e8 04             	shr    $0x4,%eax
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804e58d:	c1 e1 06             	shl    $0x6,%ecx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804e590:	31 c3                	xor    %eax,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804e592:	09 ca                	or     %ecx,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804e594:	89 d8                	mov    %ebx,%eax
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 804e596:	83 e2 fb             	and    $0xfffffffb,%edx
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804e599:	c1 e8 02             	shr    $0x2,%eax
 804e59c:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 804e59e:	89 d8                	mov    %ebx,%eax
 804e5a0:	d1 e8                	shr    %eax
 804e5a2:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 804e5a4:	83 e3 01             	and    $0x1,%ebx
 804e5a7:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 804e5ae:	89 d3                	mov    %edx,%ebx
 804e5b0:	09 c3                	or     %eax,%ebx
 804e5b2:	88 1d e4 af 0f 10    	mov    %bl,0x100fafe4

	print_asm_template2();
 804e5b8:	e8 43 a5 ff ff       	call   8048b00 <snprintf@plt>
 804e5bd:	83 c4 20             	add    $0x20,%esp
 804e5c0:	83 f8 4f             	cmp    $0x4f,%eax
 804e5c3:	7f 0b                	jg     804e5d0 <do_and_l+0xa0>
}
 804e5c5:	83 c4 08             	add    $0x8,%esp
 804e5c8:	5b                   	pop    %ebx
 804e5c9:	c3                   	ret    
 804e5ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804e5d0:	83 ec 0c             	sub    $0xc,%esp
 804e5d3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804e5d9:	e8 82 a3 ff ff       	call   8048960 <fflush@plt>
 804e5de:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e5e4:	6a 07                	push   $0x7
 804e5e6:	6a 01                	push   $0x1
 804e5e8:	68 92 e8 05 08       	push   $0x805e892
 804e5ed:	e8 1e a4 ff ff       	call   8048a10 <fwrite@plt>
 804e5f2:	83 c4 20             	add    $0x20,%esp
 804e5f5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e5fb:	6a 10                	push   $0x10
 804e5fd:	6a 01                	push   $0x1
 804e5ff:	68 b4 f3 05 08       	push   $0x805f3b4
 804e604:	e8 07 a4 ff ff       	call   8048a10 <fwrite@plt>
 804e609:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e60f:	6a 05                	push   $0x5
 804e611:	6a 01                	push   $0x1
 804e613:	68 42 f3 05 08       	push   $0x805f342
 804e618:	e8 f3 a3 ff ff       	call   8048a10 <fwrite@plt>
 804e61d:	83 c4 14             	add    $0x14,%esp
 804e620:	68 50 af 0f 10       	push   $0x100faf50
 804e625:	68 18 af 0f 10       	push   $0x100faf18
 804e62a:	68 5f 06 06 08       	push   $0x806065f
 804e62f:	6a 50                	push   $0x50
 804e631:	68 00 8a 0c 08       	push   $0x80c8a00
 804e636:	e8 c5 a4 ff ff       	call   8048b00 <snprintf@plt>
 804e63b:	83 c4 20             	add    $0x20,%esp
 804e63e:	83 f8 4f             	cmp    $0x4f,%eax
 804e641:	7e 82                	jle    804e5c5 <do_and_l+0x95>
 804e643:	68 bf 07 06 08       	push   $0x80607bf
 804e648:	6a 13                	push   $0x13
 804e64a:	68 6c 06 06 08       	push   $0x806066c
 804e64f:	68 5c 07 06 08       	push   $0x806075c
 804e654:	e8 57 a5 ff ff       	call   8048bb0 <__assert_fail@plt>
 804e659:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804e660 <and_i2a_l>:
}

make_instr_helper(i2a)
 804e660:	53                   	push   %ebx
 804e661:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e664:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e668:	83 c0 01             	add    $0x1,%eax
 804e66b:	50                   	push   %eax
 804e66c:	e8 ef e5 00 00       	call   805cc60 <decode_i2a_l>
 804e671:	89 c3                	mov    %eax,%ebx
	execute();
 804e673:	e8 b8 fe ff ff       	call   804e530 <do_and_l>
 804e678:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e67b:	8d 43 01             	lea    0x1(%ebx),%eax
 804e67e:	5b                   	pop    %ebx
 804e67f:	c3                   	ret    

0804e680 <and_i2rm_l>:
make_instr_helper(i2rm)
 804e680:	53                   	push   %ebx
 804e681:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e684:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e688:	83 c0 01             	add    $0x1,%eax
 804e68b:	50                   	push   %eax
 804e68c:	e8 4f e6 00 00       	call   805cce0 <decode_i2rm_l>
 804e691:	89 c3                	mov    %eax,%ebx
	execute();
 804e693:	e8 98 fe ff ff       	call   804e530 <do_and_l>
 804e698:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e69b:	8d 43 01             	lea    0x1(%ebx),%eax
 804e69e:	5b                   	pop    %ebx
 804e69f:	c3                   	ret    

0804e6a0 <and_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 804e6a0:	53                   	push   %ebx
 804e6a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e6a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e6a8:	83 c0 01             	add    $0x1,%eax
 804e6ab:	50                   	push   %eax
 804e6ac:	e8 af e6 00 00       	call   805cd60 <decode_si2rm_l>
 804e6b1:	89 c3                	mov    %eax,%ebx
	execute();
 804e6b3:	e8 78 fe ff ff       	call   804e530 <do_and_l>
 804e6b8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e6bb:	8d 43 01             	lea    0x1(%ebx),%eax
 804e6be:	5b                   	pop    %ebx
 804e6bf:	c3                   	ret    

0804e6c0 <and_r2rm_l>:
#endif
make_instr_helper(r2rm)
 804e6c0:	53                   	push   %ebx
 804e6c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e6c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e6c8:	83 c0 01             	add    $0x1,%eax
 804e6cb:	50                   	push   %eax
 804e6cc:	e8 4f e5 00 00       	call   805cc20 <decode_r2rm_l>
 804e6d1:	89 c3                	mov    %eax,%ebx
	execute();
 804e6d3:	e8 58 fe ff ff       	call   804e530 <do_and_l>
 804e6d8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e6db:	8d 43 01             	lea    0x1(%ebx),%eax
 804e6de:	5b                   	pop    %ebx
 804e6df:	c3                   	ret    

0804e6e0 <and_rm2r_l>:
make_instr_helper(rm2r)
 804e6e0:	53                   	push   %ebx
 804e6e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e6e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e6e8:	83 c0 01             	add    $0x1,%eax
 804e6eb:	50                   	push   %eax
 804e6ec:	e8 4f e5 00 00       	call   805cc40 <decode_rm2r_l>
 804e6f1:	89 c3                	mov    %eax,%ebx
	execute();
 804e6f3:	e8 38 fe ff ff       	call   804e530 <do_and_l>
 804e6f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e6fb:	8d 43 01             	lea    0x1(%ebx),%eax
 804e6fe:	5b                   	pop    %ebx
 804e6ff:	c3                   	ret    

0804e700 <and_i2a_b>:
	cpu.PF = pf & 1;

	print_asm_template2();
}

make_instr_helper(i2a)
 804e700:	53                   	push   %ebx
 804e701:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e704:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e708:	83 c0 01             	add    $0x1,%eax
 804e70b:	50                   	push   %eax
 804e70c:	e8 4f de 00 00       	call   805c560 <decode_i2a_b>
 804e711:	89 c3                	mov    %eax,%ebx
	execute();
 804e713:	e8 18 fb ff ff       	call   804e230 <do_and_b>
 804e718:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e71b:	8d 43 01             	lea    0x1(%ebx),%eax
 804e71e:	5b                   	pop    %ebx
 804e71f:	c3                   	ret    

0804e720 <and_i2rm_b>:
make_instr_helper(i2rm)
 804e720:	53                   	push   %ebx
 804e721:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e724:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e728:	83 c0 01             	add    $0x1,%eax
 804e72b:	50                   	push   %eax
 804e72c:	e8 af de 00 00       	call   805c5e0 <decode_i2rm_b>
 804e731:	89 c3                	mov    %eax,%ebx
	execute();
 804e733:	e8 f8 fa ff ff       	call   804e230 <do_and_b>
 804e738:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e73b:	8d 43 01             	lea    0x1(%ebx),%eax
 804e73e:	5b                   	pop    %ebx
 804e73f:	c3                   	ret    

0804e740 <and_r2rm_b>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
#endif
make_instr_helper(r2rm)
 804e740:	53                   	push   %ebx
 804e741:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e744:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e748:	83 c0 01             	add    $0x1,%eax
 804e74b:	50                   	push   %eax
 804e74c:	e8 cf dd 00 00       	call   805c520 <decode_r2rm_b>
 804e751:	89 c3                	mov    %eax,%ebx
	execute();
 804e753:	e8 d8 fa ff ff       	call   804e230 <do_and_b>
 804e758:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e75b:	8d 43 01             	lea    0x1(%ebx),%eax
 804e75e:	5b                   	pop    %ebx
 804e75f:	c3                   	ret    

0804e760 <and_rm2r_b>:
make_instr_helper(rm2r)
 804e760:	53                   	push   %ebx
 804e761:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e764:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e768:	83 c0 01             	add    $0x1,%eax
 804e76b:	50                   	push   %eax
 804e76c:	e8 cf dd 00 00       	call   805c540 <decode_rm2r_b>
 804e771:	89 c3                	mov    %eax,%ebx
	execute();
 804e773:	e8 b8 fa ff ff       	call   804e230 <do_and_b>
 804e778:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e77b:	8d 43 01             	lea    0x1(%ebx),%eax
 804e77e:	5b                   	pop    %ebx
 804e77f:	c3                   	ret    

0804e780 <and_i2a_v>:
#include "and-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(and_i2a)
 804e780:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804e787:	8b 54 24 04          	mov    0x4(%esp),%edx
 804e78b:	b8 90 e4 04 08       	mov    $0x804e490,%eax
 804e790:	75 05                	jne    804e797 <and_i2a_v+0x17>
 804e792:	b8 60 e6 04 08       	mov    $0x804e660,%eax
 804e797:	89 54 24 04          	mov    %edx,0x4(%esp)
 804e79b:	ff e0                	jmp    *%eax
 804e79d:	8d 76 00             	lea    0x0(%esi),%esi

0804e7a0 <and_i2rm_v>:
make_helper_v(and_i2rm)
 804e7a0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804e7a7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804e7ab:	b8 b0 e4 04 08       	mov    $0x804e4b0,%eax
 804e7b0:	75 05                	jne    804e7b7 <and_i2rm_v+0x17>
 804e7b2:	b8 80 e6 04 08       	mov    $0x804e680,%eax
 804e7b7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804e7bb:	ff e0                	jmp    *%eax
 804e7bd:	8d 76 00             	lea    0x0(%esi),%esi

0804e7c0 <and_si2rm_v>:
make_helper_v(and_si2rm)
 804e7c0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804e7c7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804e7cb:	b8 d0 e4 04 08       	mov    $0x804e4d0,%eax
 804e7d0:	75 05                	jne    804e7d7 <and_si2rm_v+0x17>
 804e7d2:	b8 a0 e6 04 08       	mov    $0x804e6a0,%eax
 804e7d7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804e7db:	ff e0                	jmp    *%eax
 804e7dd:	8d 76 00             	lea    0x0(%esi),%esi

0804e7e0 <and_r2rm_v>:
make_helper_v(and_r2rm)
 804e7e0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804e7e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804e7eb:	b8 f0 e4 04 08       	mov    $0x804e4f0,%eax
 804e7f0:	75 05                	jne    804e7f7 <and_r2rm_v+0x17>
 804e7f2:	b8 c0 e6 04 08       	mov    $0x804e6c0,%eax
 804e7f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804e7fb:	ff e0                	jmp    *%eax
 804e7fd:	8d 76 00             	lea    0x0(%esi),%esi

0804e800 <and_rm2r_v>:
make_helper_v(and_rm2r)
 804e800:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804e807:	8b 54 24 04          	mov    0x4(%esp),%edx
 804e80b:	b8 10 e5 04 08       	mov    $0x804e510,%eax
 804e810:	75 05                	jne    804e817 <and_rm2r_v+0x17>
 804e812:	b8 e0 e6 04 08       	mov    $0x804e6e0,%eax
 804e817:	89 54 24 04          	mov    %edx,0x4(%esp)
 804e81b:	ff e0                	jmp    *%eax
 804e81d:	66 90                	xchg   %ax,%ax
 804e81f:	90                   	nop

0804e820 <do_shl_b>:
#include "cpu/exec/template-start.h"

#define instr shl

static void do_execute () {
 804e820:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804e823:	0f b6 0d 14 af 0f 10 	movzbl 0x100faf14,%ecx
 804e82a:	0f b6 05 4c af 0f 10 	movzbl 0x100faf4c,%eax
 804e831:	83 e1 1f             	and    $0x1f,%ecx
	dest <<= count;
 804e834:	d3 e0                	shl    %cl,%eax
	OPERAND_W(op_dest, dest);
 804e836:	0f b6 c0             	movzbl %al,%eax
 804e839:	50                   	push   %eax
 804e83a:	68 40 af 0f 10       	push   $0x100faf40
 804e83f:	e8 fc de 00 00       	call   805c740 <write_operand_b>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804e844:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 804e84b:	68 18 af 0f 10       	push   $0x100faf18
 804e850:	68 da 07 06 08       	push   $0x80607da
 804e855:	6a 50                	push   $0x50
 804e857:	68 00 8a 0c 08       	push   $0x80c8a00
 804e85c:	e8 9f a2 ff ff       	call   8048b00 <snprintf@plt>
 804e861:	83 c4 20             	add    $0x20,%esp
 804e864:	83 f8 4f             	cmp    $0x4f,%eax
 804e867:	7f 07                	jg     804e870 <do_shl_b+0x50>
}
 804e869:	83 c4 0c             	add    $0xc,%esp
 804e86c:	c3                   	ret    
 804e86d:	8d 76 00             	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804e870:	83 ec 0c             	sub    $0xc,%esp
 804e873:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804e879:	e8 e2 a0 ff ff       	call   8048960 <fflush@plt>
 804e87e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e884:	6a 07                	push   $0x7
 804e886:	6a 01                	push   $0x1
 804e888:	68 92 e8 05 08       	push   $0x805e892
 804e88d:	e8 7e a1 ff ff       	call   8048a10 <fwrite@plt>
 804e892:	83 c4 20             	add    $0x20,%esp
 804e895:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e89b:	6a 10                	push   $0x10
 804e89d:	6a 01                	push   $0x1
 804e89f:	68 b4 f3 05 08       	push   $0x805f3b4
 804e8a4:	e8 67 a1 ff ff       	call   8048a10 <fwrite@plt>
 804e8a9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e8af:	6a 05                	push   $0x5
 804e8b1:	6a 01                	push   $0x1
 804e8b3:	68 42 f3 05 08       	push   $0x805f342
 804e8b8:	e8 53 a1 ff ff       	call   8048a10 <fwrite@plt>
 804e8bd:	83 c4 14             	add    $0x14,%esp
 804e8c0:	68 50 af 0f 10       	push   $0x100faf50
 804e8c5:	68 18 af 0f 10       	push   $0x100faf18
 804e8ca:	68 da 07 06 08       	push   $0x80607da
 804e8cf:	6a 50                	push   $0x50
 804e8d1:	68 00 8a 0c 08       	push   $0x80c8a00
 804e8d6:	e8 25 a2 ff ff       	call   8048b00 <snprintf@plt>
 804e8db:	83 c4 20             	add    $0x20,%esp
 804e8de:	83 f8 4f             	cmp    $0x4f,%eax
 804e8e1:	7e 86                	jle    804e869 <do_shl_b+0x49>
 804e8e3:	68 61 09 06 08       	push   $0x8060961
 804e8e8:	6a 11                	push   $0x11
 804e8ea:	68 fc 07 06 08       	push   $0x80607fc
 804e8ef:	68 24 08 06 08       	push   $0x8060824
 804e8f4:	e8 b7 a2 ff ff       	call   8048bb0 <__assert_fail@plt>
 804e8f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804e900 <do_shl_w>:
#include "cpu/exec/template-start.h"

#define instr shl

static void do_execute () {
 804e900:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804e903:	0f b6 0d 14 af 0f 10 	movzbl 0x100faf14,%ecx
 804e90a:	0f b7 05 4c af 0f 10 	movzwl 0x100faf4c,%eax
 804e911:	83 e1 1f             	and    $0x1f,%ecx
	dest <<= count;
 804e914:	d3 e0                	shl    %cl,%eax
	OPERAND_W(op_dest, dest);
 804e916:	0f b7 c0             	movzwl %ax,%eax
 804e919:	50                   	push   %eax
 804e91a:	68 40 af 0f 10       	push   $0x100faf40
 804e91f:	e8 ac e1 00 00       	call   805cad0 <write_operand_w>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804e924:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 804e92b:	68 18 af 0f 10       	push   $0x100faf18
 804e930:	68 e5 07 06 08       	push   $0x80607e5
 804e935:	6a 50                	push   $0x50
 804e937:	68 00 8a 0c 08       	push   $0x80c8a00
 804e93c:	e8 bf a1 ff ff       	call   8048b00 <snprintf@plt>
 804e941:	83 c4 20             	add    $0x20,%esp
 804e944:	83 f8 4f             	cmp    $0x4f,%eax
 804e947:	7f 07                	jg     804e950 <do_shl_w+0x50>
}
 804e949:	83 c4 0c             	add    $0xc,%esp
 804e94c:	c3                   	ret    
 804e94d:	8d 76 00             	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804e950:	83 ec 0c             	sub    $0xc,%esp
 804e953:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804e959:	e8 02 a0 ff ff       	call   8048960 <fflush@plt>
 804e95e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e964:	6a 07                	push   $0x7
 804e966:	6a 01                	push   $0x1
 804e968:	68 92 e8 05 08       	push   $0x805e892
 804e96d:	e8 9e a0 ff ff       	call   8048a10 <fwrite@plt>
 804e972:	83 c4 20             	add    $0x20,%esp
 804e975:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e97b:	6a 10                	push   $0x10
 804e97d:	6a 01                	push   $0x1
 804e97f:	68 b4 f3 05 08       	push   $0x805f3b4
 804e984:	e8 87 a0 ff ff       	call   8048a10 <fwrite@plt>
 804e989:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804e98f:	6a 05                	push   $0x5
 804e991:	6a 01                	push   $0x1
 804e993:	68 42 f3 05 08       	push   $0x805f342
 804e998:	e8 73 a0 ff ff       	call   8048a10 <fwrite@plt>
 804e99d:	83 c4 14             	add    $0x14,%esp
 804e9a0:	68 50 af 0f 10       	push   $0x100faf50
 804e9a5:	68 18 af 0f 10       	push   $0x100faf18
 804e9aa:	68 e5 07 06 08       	push   $0x80607e5
 804e9af:	6a 50                	push   $0x50
 804e9b1:	68 00 8a 0c 08       	push   $0x80c8a00
 804e9b6:	e8 45 a1 ff ff       	call   8048b00 <snprintf@plt>
 804e9bb:	83 c4 20             	add    $0x20,%esp
 804e9be:	83 f8 4f             	cmp    $0x4f,%eax
 804e9c1:	7e 86                	jle    804e949 <do_shl_w+0x49>
 804e9c3:	68 58 09 06 08       	push   $0x8060958
 804e9c8:	6a 11                	push   $0x11
 804e9ca:	68 fc 07 06 08       	push   $0x80607fc
 804e9cf:	68 88 08 06 08       	push   $0x8060888
 804e9d4:	e8 d7 a1 ff ff       	call   8048bb0 <__assert_fail@plt>
 804e9d9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804e9e0 <shl_rm_1_w>:
}

make_instr_helper(rm_1)
 804e9e0:	53                   	push   %ebx
 804e9e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804e9e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804e9e8:	83 c0 01             	add    $0x1,%eax
 804e9eb:	50                   	push   %eax
 804e9ec:	e8 ff df 00 00       	call   805c9f0 <decode_rm_1_w>
 804e9f1:	89 c3                	mov    %eax,%ebx
	execute();
 804e9f3:	e8 08 ff ff ff       	call   804e900 <do_shl_w>
 804e9f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804e9fb:	8d 43 01             	lea    0x1(%ebx),%eax
 804e9fe:	5b                   	pop    %ebx
 804e9ff:	c3                   	ret    

0804ea00 <shl_rm_cl_w>:
make_instr_helper(rm_cl)
 804ea00:	53                   	push   %ebx
 804ea01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804ea04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ea08:	83 c0 01             	add    $0x1,%eax
 804ea0b:	50                   	push   %eax
 804ea0c:	e8 2f e0 00 00       	call   805ca40 <decode_rm_cl_w>
 804ea11:	89 c3                	mov    %eax,%ebx
	execute();
 804ea13:	e8 e8 fe ff ff       	call   804e900 <do_shl_w>
 804ea18:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ea1b:	8d 43 01             	lea    0x1(%ebx),%eax
 804ea1e:	5b                   	pop    %ebx
 804ea1f:	c3                   	ret    

0804ea20 <shl_rm_imm_w>:
make_instr_helper(rm_imm)
 804ea20:	53                   	push   %ebx
 804ea21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804ea24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ea28:	83 c0 01             	add    $0x1,%eax
 804ea2b:	50                   	push   %eax
 804ea2c:	e8 6f e0 00 00       	call   805caa0 <decode_rm_imm_w>
 804ea31:	89 c3                	mov    %eax,%ebx
	execute();
 804ea33:	e8 c8 fe ff ff       	call   804e900 <do_shl_w>
 804ea38:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ea3b:	8d 43 01             	lea    0x1(%ebx),%eax
 804ea3e:	5b                   	pop    %ebx
 804ea3f:	c3                   	ret    

0804ea40 <do_shl_l>:
#include "cpu/exec/template-start.h"

#define instr shl

static void do_execute () {
 804ea40:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804ea43:	0f b6 0d 14 af 0f 10 	movzbl 0x100faf14,%ecx
	dest <<= count;
 804ea4a:	a1 4c af 0f 10       	mov    0x100faf4c,%eax

static void do_execute () {
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804ea4f:	83 e1 1f             	and    $0x1f,%ecx
	dest <<= count;
 804ea52:	d3 e0                	shl    %cl,%eax
	OPERAND_W(op_dest, dest);
 804ea54:	50                   	push   %eax
 804ea55:	68 40 af 0f 10       	push   $0x100faf40
 804ea5a:	e8 41 e4 00 00       	call   805cea0 <write_operand_l>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804ea5f:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 804ea66:	68 18 af 0f 10       	push   $0x100faf18
 804ea6b:	68 f0 07 06 08       	push   $0x80607f0
 804ea70:	6a 50                	push   $0x50
 804ea72:	68 00 8a 0c 08       	push   $0x80c8a00
 804ea77:	e8 84 a0 ff ff       	call   8048b00 <snprintf@plt>
 804ea7c:	83 c4 20             	add    $0x20,%esp
 804ea7f:	83 f8 4f             	cmp    $0x4f,%eax
 804ea82:	7f 0c                	jg     804ea90 <do_shl_l+0x50>
}
 804ea84:	83 c4 0c             	add    $0xc,%esp
 804ea87:	c3                   	ret    
 804ea88:	90                   	nop
 804ea89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804ea90:	83 ec 0c             	sub    $0xc,%esp
 804ea93:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804ea99:	e8 c2 9e ff ff       	call   8048960 <fflush@plt>
 804ea9e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804eaa4:	6a 07                	push   $0x7
 804eaa6:	6a 01                	push   $0x1
 804eaa8:	68 92 e8 05 08       	push   $0x805e892
 804eaad:	e8 5e 9f ff ff       	call   8048a10 <fwrite@plt>
 804eab2:	83 c4 20             	add    $0x20,%esp
 804eab5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804eabb:	6a 10                	push   $0x10
 804eabd:	6a 01                	push   $0x1
 804eabf:	68 b4 f3 05 08       	push   $0x805f3b4
 804eac4:	e8 47 9f ff ff       	call   8048a10 <fwrite@plt>
 804eac9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804eacf:	6a 05                	push   $0x5
 804ead1:	6a 01                	push   $0x1
 804ead3:	68 42 f3 05 08       	push   $0x805f342
 804ead8:	e8 33 9f ff ff       	call   8048a10 <fwrite@plt>
 804eadd:	83 c4 14             	add    $0x14,%esp
 804eae0:	68 50 af 0f 10       	push   $0x100faf50
 804eae5:	68 18 af 0f 10       	push   $0x100faf18
 804eaea:	68 f0 07 06 08       	push   $0x80607f0
 804eaef:	6a 50                	push   $0x50
 804eaf1:	68 00 8a 0c 08       	push   $0x80c8a00
 804eaf6:	e8 05 a0 ff ff       	call   8048b00 <snprintf@plt>
 804eafb:	83 c4 20             	add    $0x20,%esp
 804eafe:	83 f8 4f             	cmp    $0x4f,%eax
 804eb01:	7e 81                	jle    804ea84 <do_shl_l+0x44>
 804eb03:	68 4f 09 06 08       	push   $0x806094f
 804eb08:	6a 11                	push   $0x11
 804eb0a:	68 fc 07 06 08       	push   $0x80607fc
 804eb0f:	68 ec 08 06 08       	push   $0x80608ec
 804eb14:	e8 97 a0 ff ff       	call   8048bb0 <__assert_fail@plt>
 804eb19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804eb20 <shl_rm_1_l>:
}

make_instr_helper(rm_1)
 804eb20:	53                   	push   %ebx
 804eb21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804eb24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804eb28:	83 c0 01             	add    $0x1,%eax
 804eb2b:	50                   	push   %eax
 804eb2c:	e8 8f e2 00 00       	call   805cdc0 <decode_rm_1_l>
 804eb31:	89 c3                	mov    %eax,%ebx
	execute();
 804eb33:	e8 08 ff ff ff       	call   804ea40 <do_shl_l>
 804eb38:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804eb3b:	8d 43 01             	lea    0x1(%ebx),%eax
 804eb3e:	5b                   	pop    %ebx
 804eb3f:	c3                   	ret    

0804eb40 <shl_rm_cl_l>:
make_instr_helper(rm_cl)
 804eb40:	53                   	push   %ebx
 804eb41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804eb44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804eb48:	83 c0 01             	add    $0x1,%eax
 804eb4b:	50                   	push   %eax
 804eb4c:	e8 bf e2 00 00       	call   805ce10 <decode_rm_cl_l>
 804eb51:	89 c3                	mov    %eax,%ebx
	execute();
 804eb53:	e8 e8 fe ff ff       	call   804ea40 <do_shl_l>
 804eb58:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804eb5b:	8d 43 01             	lea    0x1(%ebx),%eax
 804eb5e:	5b                   	pop    %ebx
 804eb5f:	c3                   	ret    

0804eb60 <shl_rm_imm_l>:
make_instr_helper(rm_imm)
 804eb60:	53                   	push   %ebx
 804eb61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804eb64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804eb68:	83 c0 01             	add    $0x1,%eax
 804eb6b:	50                   	push   %eax
 804eb6c:	e8 ff e2 00 00       	call   805ce70 <decode_rm_imm_l>
 804eb71:	89 c3                	mov    %eax,%ebx
	execute();
 804eb73:	e8 c8 fe ff ff       	call   804ea40 <do_shl_l>
 804eb78:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804eb7b:	8d 43 01             	lea    0x1(%ebx),%eax
 804eb7e:	5b                   	pop    %ebx
 804eb7f:	c3                   	ret    

0804eb80 <shl_rm_1_b>:
	 */

	print_asm_template2();
}

make_instr_helper(rm_1)
 804eb80:	53                   	push   %ebx
 804eb81:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804eb84:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804eb88:	83 c0 01             	add    $0x1,%eax
 804eb8b:	50                   	push   %eax
 804eb8c:	e8 cf da 00 00       	call   805c660 <decode_rm_1_b>
 804eb91:	89 c3                	mov    %eax,%ebx
	execute();
 804eb93:	e8 88 fc ff ff       	call   804e820 <do_shl_b>
 804eb98:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804eb9b:	8d 43 01             	lea    0x1(%ebx),%eax
 804eb9e:	5b                   	pop    %ebx
 804eb9f:	c3                   	ret    

0804eba0 <shl_rm_cl_b>:
make_instr_helper(rm_cl)
 804eba0:	53                   	push   %ebx
 804eba1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804eba4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804eba8:	83 c0 01             	add    $0x1,%eax
 804ebab:	50                   	push   %eax
 804ebac:	e8 ff da 00 00       	call   805c6b0 <decode_rm_cl_b>
 804ebb1:	89 c3                	mov    %eax,%ebx
	execute();
 804ebb3:	e8 68 fc ff ff       	call   804e820 <do_shl_b>
 804ebb8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ebbb:	8d 43 01             	lea    0x1(%ebx),%eax
 804ebbe:	5b                   	pop    %ebx
 804ebbf:	c3                   	ret    

0804ebc0 <shl_rm_imm_b>:
make_instr_helper(rm_imm)
 804ebc0:	53                   	push   %ebx
 804ebc1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804ebc4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ebc8:	83 c0 01             	add    $0x1,%eax
 804ebcb:	50                   	push   %eax
 804ebcc:	e8 3f db 00 00       	call   805c710 <decode_rm_imm_b>
 804ebd1:	89 c3                	mov    %eax,%ebx
	execute();
 804ebd3:	e8 48 fc ff ff       	call   804e820 <do_shl_b>
 804ebd8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804ebdb:	8d 43 01             	lea    0x1(%ebx),%eax
 804ebde:	5b                   	pop    %ebx
 804ebdf:	c3                   	ret    

0804ebe0 <shl_rm_1_v>:
#define DATA_BYTE 4
#include "shl-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */
make_helper_v(shl_rm_1)
 804ebe0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804ebe7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804ebeb:	b8 e0 e9 04 08       	mov    $0x804e9e0,%eax
 804ebf0:	75 05                	jne    804ebf7 <shl_rm_1_v+0x17>
 804ebf2:	b8 20 eb 04 08       	mov    $0x804eb20,%eax
 804ebf7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ebfb:	ff e0                	jmp    *%eax
 804ebfd:	8d 76 00             	lea    0x0(%esi),%esi

0804ec00 <shl_rm_cl_v>:
make_helper_v(shl_rm_cl)
 804ec00:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804ec07:	8b 54 24 04          	mov    0x4(%esp),%edx
 804ec0b:	b8 00 ea 04 08       	mov    $0x804ea00,%eax
 804ec10:	75 05                	jne    804ec17 <shl_rm_cl_v+0x17>
 804ec12:	b8 40 eb 04 08       	mov    $0x804eb40,%eax
 804ec17:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ec1b:	ff e0                	jmp    *%eax
 804ec1d:	8d 76 00             	lea    0x0(%esi),%esi

0804ec20 <shl_rm_imm_v>:
make_helper_v(shl_rm_imm)
 804ec20:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804ec27:	8b 54 24 04          	mov    0x4(%esp),%edx
 804ec2b:	b8 20 ea 04 08       	mov    $0x804ea20,%eax
 804ec30:	75 05                	jne    804ec37 <shl_rm_imm_v+0x17>
 804ec32:	b8 60 eb 04 08       	mov    $0x804eb60,%eax
 804ec37:	89 54 24 04          	mov    %edx,0x4(%esp)
 804ec3b:	ff e0                	jmp    *%eax
 804ec3d:	66 90                	xchg   %ax,%ax
 804ec3f:	90                   	nop

0804ec40 <do_shld_w>:
#include "cpu/exec/template-start.h"

#define instr shld

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute () {
 804ec40:	53                   	push   %ebx
 804ec41:	83 ec 08             	sub    $0x8,%esp
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804ec44:	0f b6 15 14 af 0f 10 	movzbl 0x100faf14,%edx

#define instr shld

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute () {
	DATA_TYPE in = op_dest->val;
 804ec4b:	0f b7 0d 4c af 0f 10 	movzwl 0x100faf4c,%ecx
	DATA_TYPE out = op_src2->val;
 804ec52:	0f b7 05 84 af 0f 10 	movzwl 0x100faf84,%eax

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804ec59:	83 e2 1f             	and    $0x1f,%edx
 804ec5c:	74 13                	je     804ec71 <do_shld_w+0x31>
 804ec5e:	66 90                	xchg   %ax,%ax
		out <<= 1;
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
 804ec60:	89 cb                	mov    %ecx,%ebx
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out <<= 1;
 804ec62:	01 c0                	add    %eax,%eax
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
		in <<= 1;
 804ec64:	01 c9                	add    %ecx,%ecx

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out <<= 1;
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
 804ec66:	66 c1 eb 0f          	shr    $0xf,%bx
 804ec6a:	09 d8                	or     %ebx,%eax
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804ec6c:	80 ea 01             	sub    $0x1,%dl
 804ec6f:	75 ef                	jne    804ec60 <do_shld_w+0x20>
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
		in <<= 1;
		count --;
	}

	OPERAND_W(op_src2, out);
 804ec71:	83 ec 08             	sub    $0x8,%esp
 804ec74:	0f b7 c0             	movzwl %ax,%eax
 804ec77:	50                   	push   %eax
 804ec78:	68 78 af 0f 10       	push   $0x100faf78
 804ec7d:	e8 4e de 00 00       	call   805cad0 <write_operand_w>

	print_asm("shld" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804ec82:	58                   	pop    %eax
 804ec83:	5a                   	pop    %edx
 804ec84:	68 88 af 0f 10       	push   $0x100faf88
 804ec89:	68 50 af 0f 10       	push   $0x100faf50
 804ec8e:	68 18 af 0f 10       	push   $0x100faf18
 804ec93:	68 6a 09 06 08       	push   $0x806096a
 804ec98:	6a 50                	push   $0x50
 804ec9a:	68 00 8a 0c 08       	push   $0x80c8a00
 804ec9f:	e8 5c 9e ff ff       	call   8048b00 <snprintf@plt>
 804eca4:	83 c4 20             	add    $0x20,%esp
 804eca7:	83 f8 4f             	cmp    $0x4f,%eax
 804ecaa:	7f 0c                	jg     804ecb8 <do_shld_w+0x78>
}
 804ecac:	83 c4 08             	add    $0x8,%esp
 804ecaf:	5b                   	pop    %ebx
 804ecb0:	c3                   	ret    
 804ecb1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		count --;
	}

	OPERAND_W(op_src2, out);

	print_asm("shld" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804ecb8:	83 ec 0c             	sub    $0xc,%esp
 804ecbb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804ecc1:	e8 9a 9c ff ff       	call   8048960 <fflush@plt>
 804ecc6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804eccc:	6a 07                	push   $0x7
 804ecce:	6a 01                	push   $0x1
 804ecd0:	68 92 e8 05 08       	push   $0x805e892
 804ecd5:	e8 36 9d ff ff       	call   8048a10 <fwrite@plt>
 804ecda:	83 c4 20             	add    $0x20,%esp
 804ecdd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ece3:	6a 10                	push   $0x10
 804ece5:	6a 01                	push   $0x1
 804ece7:	68 b4 f3 05 08       	push   $0x805f3b4
 804ecec:	e8 1f 9d ff ff       	call   8048a10 <fwrite@plt>
 804ecf1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ecf7:	6a 05                	push   $0x5
 804ecf9:	6a 01                	push   $0x1
 804ecfb:	68 42 f3 05 08       	push   $0x805f342
 804ed00:	e8 0b 9d ff ff       	call   8048a10 <fwrite@plt>
 804ed05:	83 c4 18             	add    $0x18,%esp
 804ed08:	68 88 af 0f 10       	push   $0x100faf88
 804ed0d:	68 50 af 0f 10       	push   $0x100faf50
 804ed12:	68 18 af 0f 10       	push   $0x100faf18
 804ed17:	68 6a 09 06 08       	push   $0x806096a
 804ed1c:	6a 50                	push   $0x50
 804ed1e:	68 00 8a 0c 08       	push   $0x80c8a00
 804ed23:	e8 d8 9d ff ff       	call   8048b00 <snprintf@plt>
 804ed28:	83 c4 20             	add    $0x20,%esp
 804ed2b:	83 f8 4f             	cmp    $0x4f,%eax
 804ed2e:	0f 8e 78 ff ff ff    	jle    804ecac <do_shld_w+0x6c>
 804ed34:	68 bf 0a 06 08       	push   $0x8060abf
 804ed39:	6a 15                	push   $0x15
 804ed3b:	68 88 09 06 08       	push   $0x8060988
 804ed40:	68 b0 09 06 08       	push   $0x80609b0
 804ed45:	e8 66 9e ff ff       	call   8048bb0 <__assert_fail@plt>
 804ed4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0804ed50 <shldi_w>:
}

make_helper(concat(shldi_, SUFFIX)) {
 804ed50:	53                   	push   %ebx
 804ed51:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
 804ed54:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ed58:	83 c0 01             	add    $0x1,%eax
 804ed5b:	50                   	push   %eax
 804ed5c:	e8 5f dc 00 00       	call   805c9c0 <decode_si_rm2r_w>
 804ed61:	89 c3                	mov    %eax,%ebx
	op_dest->val = REG(op_dest->reg);
 804ed63:	a1 48 af 0f 10       	mov    0x100faf48,%eax
 804ed68:	83 c4 10             	add    $0x10,%esp
 804ed6b:	83 f8 07             	cmp    $0x7,%eax
 804ed6e:	77 1a                	ja     804ed8a <shldi_w+0x3a>
 804ed70:	0f b7 04 85 c0 af 0f 	movzwl 0x100fafc0(,%eax,4),%eax
 804ed77:	10 
 804ed78:	a3 4c af 0f 10       	mov    %eax,0x100faf4c
	do_execute();
 804ed7d:	e8 be fe ff ff       	call   804ec40 <do_shld_w>
	return len + 1;
}
 804ed82:	83 c4 08             	add    $0x8,%esp

make_helper(concat(shldi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
	do_execute();
	return len + 1;
 804ed85:	8d 43 01             	lea    0x1(%ebx),%eax
}
 804ed88:	5b                   	pop    %ebx
 804ed89:	c3                   	ret    
 804ed8a:	e8 63 9e ff ff       	call   8048bf2 <check_reg_index.part.0>
 804ed8f:	90                   	nop

0804ed90 <shld_w>:

make_helper(concat(shld_, SUFFIX)) {
 804ed90:	53                   	push   %ebx
 804ed91:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
 804ed94:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ed98:	83 c0 01             	add    $0x1,%eax
 804ed9b:	50                   	push   %eax
 804ed9c:	e8 cf da 00 00       	call   805c870 <decode_rm2r_w>
 804eda1:	89 c3                	mov    %eax,%ebx
	op_dest->val = REG(op_dest->reg);
 804eda3:	a1 48 af 0f 10       	mov    0x100faf48,%eax
 804eda8:	83 c4 10             	add    $0x10,%esp
 804edab:	83 f8 07             	cmp    $0x7,%eax
 804edae:	77 4e                	ja     804edfe <shld_w+0x6e>
 804edb0:	0f b7 04 85 c0 af 0f 	movzwl 0x100fafc0(,%eax,4),%eax
 804edb7:	10 
 804edb8:	a3 4c af 0f 10       	mov    %eax,0x100faf4c
	op_src2->val = op_src->val;
 804edbd:	a1 14 af 0f 10       	mov    0x100faf14,%eax
 804edc2:	a3 84 af 0f 10       	mov    %eax,0x100faf84
	op_src2->imm = op_src->imm;
 804edc7:	a1 10 af 0f 10       	mov    0x100faf10,%eax
 804edcc:	a3 80 af 0f 10       	mov    %eax,0x100faf80
	op_src2->type = op_src->type;
 804edd1:	a1 08 af 0f 10       	mov    0x100faf08,%eax
 804edd6:	a3 78 af 0f 10       	mov    %eax,0x100faf78
	op_src2->size = op_src->size;
 804eddb:	a1 0c af 0f 10       	mov    0x100faf0c,%eax
 804ede0:	a3 7c af 0f 10       	mov    %eax,0x100faf7c
	op_src->val = reg_b(R_CL);
 804ede5:	0f b6 05 c4 af 0f 10 	movzbl 0x100fafc4,%eax
 804edec:	a3 14 af 0f 10       	mov    %eax,0x100faf14
	do_execute();
 804edf1:	e8 4a fe ff ff       	call   804ec40 <do_shld_w>
	return len + 1;
}
 804edf6:	83 c4 08             	add    $0x8,%esp
	op_src2->imm = op_src->imm;
	op_src2->type = op_src->type;
	op_src2->size = op_src->size;
	op_src->val = reg_b(R_CL);
	do_execute();
	return len + 1;
 804edf9:	8d 43 01             	lea    0x1(%ebx),%eax
}
 804edfc:	5b                   	pop    %ebx
 804edfd:	c3                   	ret    
 804edfe:	e8 ef 9d ff ff       	call   8048bf2 <check_reg_index.part.0>
 804ee03:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804ee09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804ee10 <do_shld_l>:
#include "cpu/exec/template-start.h"

#define instr shld

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute () {
 804ee10:	53                   	push   %ebx
 804ee11:	83 ec 08             	sub    $0x8,%esp
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804ee14:	0f b6 15 14 af 0f 10 	movzbl 0x100faf14,%edx

#define instr shld

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute () {
	DATA_TYPE in = op_dest->val;
 804ee1b:	8b 0d 4c af 0f 10    	mov    0x100faf4c,%ecx
	DATA_TYPE out = op_src2->val;
 804ee21:	a1 84 af 0f 10       	mov    0x100faf84,%eax

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804ee26:	83 e2 1f             	and    $0x1f,%edx
 804ee29:	74 15                	je     804ee40 <do_shld_l+0x30>
 804ee2b:	90                   	nop
 804ee2c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		out <<= 1;
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
 804ee30:	89 cb                	mov    %ecx,%ebx
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out <<= 1;
 804ee32:	01 c0                	add    %eax,%eax
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
		in <<= 1;
 804ee34:	01 c9                	add    %ecx,%ecx

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
		out <<= 1;
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
 804ee36:	c1 eb 1f             	shr    $0x1f,%ebx
 804ee39:	09 d8                	or     %ebx,%eax
	DATA_TYPE in = op_dest->val;
	DATA_TYPE out = op_src2->val;

	uint8_t count = op_src->val;
	count &= 0x1f;
	while(count != 0) {
 804ee3b:	80 ea 01             	sub    $0x1,%dl
 804ee3e:	75 f0                	jne    804ee30 <do_shld_l+0x20>
		out |= (in >> ((DATA_BYTE << 3) - 1)) & 1; 
		in <<= 1;
		count --;
	}

	OPERAND_W(op_src2, out);
 804ee40:	83 ec 08             	sub    $0x8,%esp
 804ee43:	50                   	push   %eax
 804ee44:	68 78 af 0f 10       	push   $0x100faf78
 804ee49:	e8 52 e0 00 00       	call   805cea0 <write_operand_l>

	print_asm("shld" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804ee4e:	58                   	pop    %eax
 804ee4f:	5a                   	pop    %edx
 804ee50:	68 88 af 0f 10       	push   $0x100faf88
 804ee55:	68 50 af 0f 10       	push   $0x100faf50
 804ee5a:	68 18 af 0f 10       	push   $0x100faf18
 804ee5f:	68 79 09 06 08       	push   $0x8060979
 804ee64:	6a 50                	push   $0x50
 804ee66:	68 00 8a 0c 08       	push   $0x80c8a00
 804ee6b:	e8 90 9c ff ff       	call   8048b00 <snprintf@plt>
 804ee70:	83 c4 20             	add    $0x20,%esp
 804ee73:	83 f8 4f             	cmp    $0x4f,%eax
 804ee76:	7f 08                	jg     804ee80 <do_shld_l+0x70>
}
 804ee78:	83 c4 08             	add    $0x8,%esp
 804ee7b:	5b                   	pop    %ebx
 804ee7c:	c3                   	ret    
 804ee7d:	8d 76 00             	lea    0x0(%esi),%esi
		count --;
	}

	OPERAND_W(op_src2, out);

	print_asm("shld" str(SUFFIX) " %s,%s,%s", op_src->str, op_dest->str, op_src2->str);
 804ee80:	83 ec 0c             	sub    $0xc,%esp
 804ee83:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804ee89:	e8 d2 9a ff ff       	call   8048960 <fflush@plt>
 804ee8e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ee94:	6a 07                	push   $0x7
 804ee96:	6a 01                	push   $0x1
 804ee98:	68 92 e8 05 08       	push   $0x805e892
 804ee9d:	e8 6e 9b ff ff       	call   8048a10 <fwrite@plt>
 804eea2:	83 c4 20             	add    $0x20,%esp
 804eea5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804eeab:	6a 10                	push   $0x10
 804eead:	6a 01                	push   $0x1
 804eeaf:	68 b4 f3 05 08       	push   $0x805f3b4
 804eeb4:	e8 57 9b ff ff       	call   8048a10 <fwrite@plt>
 804eeb9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804eebf:	6a 05                	push   $0x5
 804eec1:	6a 01                	push   $0x1
 804eec3:	68 42 f3 05 08       	push   $0x805f342
 804eec8:	e8 43 9b ff ff       	call   8048a10 <fwrite@plt>
 804eecd:	83 c4 18             	add    $0x18,%esp
 804eed0:	68 88 af 0f 10       	push   $0x100faf88
 804eed5:	68 50 af 0f 10       	push   $0x100faf50
 804eeda:	68 18 af 0f 10       	push   $0x100faf18
 804eedf:	68 79 09 06 08       	push   $0x8060979
 804eee4:	6a 50                	push   $0x50
 804eee6:	68 00 8a 0c 08       	push   $0x80c8a00
 804eeeb:	e8 10 9c ff ff       	call   8048b00 <snprintf@plt>
 804eef0:	83 c4 20             	add    $0x20,%esp
 804eef3:	83 f8 4f             	cmp    $0x4f,%eax
 804eef6:	7e 80                	jle    804ee78 <do_shld_l+0x68>
 804eef8:	68 b5 0a 06 08       	push   $0x8060ab5
 804eefd:	6a 15                	push   $0x15
 804eeff:	68 88 09 06 08       	push   $0x8060988
 804ef04:	68 34 0a 06 08       	push   $0x8060a34
 804ef09:	e8 a2 9c ff ff       	call   8048bb0 <__assert_fail@plt>
 804ef0e:	66 90                	xchg   %ax,%ax

0804ef10 <shldi_l>:
}

make_helper(concat(shldi_, SUFFIX)) {
 804ef10:	53                   	push   %ebx
 804ef11:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
 804ef14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ef18:	83 c0 01             	add    $0x1,%eax
 804ef1b:	50                   	push   %eax
 804ef1c:	e8 6f de 00 00       	call   805cd90 <decode_si_rm2r_l>
 804ef21:	89 c3                	mov    %eax,%ebx
	op_dest->val = REG(op_dest->reg);
 804ef23:	a1 48 af 0f 10       	mov    0x100faf48,%eax
 804ef28:	83 c4 10             	add    $0x10,%esp
 804ef2b:	83 f8 07             	cmp    $0x7,%eax
 804ef2e:	77 19                	ja     804ef49 <shldi_l+0x39>
 804ef30:	8b 04 85 c0 af 0f 10 	mov    0x100fafc0(,%eax,4),%eax
 804ef37:	a3 4c af 0f 10       	mov    %eax,0x100faf4c
	do_execute();
 804ef3c:	e8 cf fe ff ff       	call   804ee10 <do_shld_l>
	return len + 1;
}
 804ef41:	83 c4 08             	add    $0x8,%esp

make_helper(concat(shldi_, SUFFIX)) {
	int len = concat(decode_si_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
	op_dest->val = REG(op_dest->reg);
	do_execute();
	return len + 1;
 804ef44:	8d 43 01             	lea    0x1(%ebx),%eax
}
 804ef47:	5b                   	pop    %ebx
 804ef48:	c3                   	ret    
 804ef49:	e8 a4 9c ff ff       	call   8048bf2 <check_reg_index.part.0>
 804ef4e:	66 90                	xchg   %ax,%ax

0804ef50 <shld_l>:

make_helper(concat(shld_, SUFFIX)) {
 804ef50:	53                   	push   %ebx
 804ef51:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_rm2r_, SUFFIX) (eip + 1);  /* use decode_si_rm2r to read 1 byte immediate */
 804ef54:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ef58:	83 c0 01             	add    $0x1,%eax
 804ef5b:	50                   	push   %eax
 804ef5c:	e8 df dc 00 00       	call   805cc40 <decode_rm2r_l>
 804ef61:	89 c3                	mov    %eax,%ebx
	op_dest->val = REG(op_dest->reg);
 804ef63:	a1 48 af 0f 10       	mov    0x100faf48,%eax
 804ef68:	83 c4 10             	add    $0x10,%esp
 804ef6b:	83 f8 07             	cmp    $0x7,%eax
 804ef6e:	77 4d                	ja     804efbd <shld_l+0x6d>
 804ef70:	8b 04 85 c0 af 0f 10 	mov    0x100fafc0(,%eax,4),%eax
 804ef77:	a3 4c af 0f 10       	mov    %eax,0x100faf4c
	op_src2->val = op_src->val;
 804ef7c:	a1 14 af 0f 10       	mov    0x100faf14,%eax
 804ef81:	a3 84 af 0f 10       	mov    %eax,0x100faf84
	op_src2->imm = op_src->imm;
 804ef86:	a1 10 af 0f 10       	mov    0x100faf10,%eax
 804ef8b:	a3 80 af 0f 10       	mov    %eax,0x100faf80
	op_src2->type = op_src->type;
 804ef90:	a1 08 af 0f 10       	mov    0x100faf08,%eax
 804ef95:	a3 78 af 0f 10       	mov    %eax,0x100faf78
	op_src2->size = op_src->size;
 804ef9a:	a1 0c af 0f 10       	mov    0x100faf0c,%eax
 804ef9f:	a3 7c af 0f 10       	mov    %eax,0x100faf7c
	op_src->val = reg_b(R_CL);
 804efa4:	0f b6 05 c4 af 0f 10 	movzbl 0x100fafc4,%eax
 804efab:	a3 14 af 0f 10       	mov    %eax,0x100faf14
	do_execute();
 804efb0:	e8 5b fe ff ff       	call   804ee10 <do_shld_l>
	return len + 1;
}
 804efb5:	83 c4 08             	add    $0x8,%esp
	op_src2->imm = op_src->imm;
	op_src2->type = op_src->type;
	op_src2->size = op_src->size;
	op_src->val = reg_b(R_CL);
	do_execute();
	return len + 1;
 804efb8:	8d 43 01             	lea    0x1(%ebx),%eax
}
 804efbb:	5b                   	pop    %ebx
 804efbc:	c3                   	ret    
 804efbd:	e8 30 9c ff ff       	call   8048bf2 <check_reg_index.part.0>
 804efc2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 804efc9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0804efd0 <shldi_v>:
#define DATA_BYTE 4
#include "shld-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */
make_helper_v(shldi)
 804efd0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804efd7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804efdb:	b8 50 ed 04 08       	mov    $0x804ed50,%eax
 804efe0:	75 05                	jne    804efe7 <shldi_v+0x17>
 804efe2:	b8 10 ef 04 08       	mov    $0x804ef10,%eax
 804efe7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804efeb:	ff e0                	jmp    *%eax
 804efed:	8d 76 00             	lea    0x0(%esi),%esi

0804eff0 <shld_v>:
make_helper_v(shld)
 804eff0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804eff7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804effb:	b8 90 ed 04 08       	mov    $0x804ed90,%eax
 804f000:	75 05                	jne    804f007 <shld_v+0x17>
 804f002:	b8 50 ef 04 08       	mov    $0x804ef50,%eax
 804f007:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f00b:	ff e0                	jmp    *%eax
 804f00d:	66 90                	xchg   %ax,%ax
 804f00f:	90                   	nop

0804f010 <do_sar_b>:
#include "cpu/exec/template-start.h"

#define instr sar

static void do_execute () {
 804f010:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE_S dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804f013:	0f b6 0d 14 af 0f 10 	movzbl 0x100faf14,%ecx
	dest >>= count;
 804f01a:	0f be 05 4c af 0f 10 	movsbl 0x100faf4c,%eax

static void do_execute () {
	DATA_TYPE src = op_src->val;
	DATA_TYPE_S dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804f021:	83 e1 1f             	and    $0x1f,%ecx
	dest >>= count;
 804f024:	d3 f8                	sar    %cl,%eax
	OPERAND_W(op_dest, dest);
 804f026:	0f b6 c0             	movzbl %al,%eax
 804f029:	50                   	push   %eax
 804f02a:	68 40 af 0f 10       	push   $0x100faf40
 804f02f:	e8 0c d7 00 00       	call   805c740 <write_operand_b>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804f034:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 804f03b:	68 18 af 0f 10       	push   $0x100faf18
 804f040:	68 d9 0a 06 08       	push   $0x8060ad9
 804f045:	6a 50                	push   $0x50
 804f047:	68 00 8a 0c 08       	push   $0x80c8a00
 804f04c:	e8 af 9a ff ff       	call   8048b00 <snprintf@plt>
 804f051:	83 c4 20             	add    $0x20,%esp
 804f054:	83 f8 4f             	cmp    $0x4f,%eax
 804f057:	7f 07                	jg     804f060 <do_sar_b+0x50>
}
 804f059:	83 c4 0c             	add    $0xc,%esp
 804f05c:	c3                   	ret    
 804f05d:	8d 76 00             	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804f060:	83 ec 0c             	sub    $0xc,%esp
 804f063:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804f069:	e8 f2 98 ff ff       	call   8048960 <fflush@plt>
 804f06e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f074:	6a 07                	push   $0x7
 804f076:	6a 01                	push   $0x1
 804f078:	68 92 e8 05 08       	push   $0x805e892
 804f07d:	e8 8e 99 ff ff       	call   8048a10 <fwrite@plt>
 804f082:	83 c4 20             	add    $0x20,%esp
 804f085:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f08b:	6a 10                	push   $0x10
 804f08d:	6a 01                	push   $0x1
 804f08f:	68 b4 f3 05 08       	push   $0x805f3b4
 804f094:	e8 77 99 ff ff       	call   8048a10 <fwrite@plt>
 804f099:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f09f:	6a 05                	push   $0x5
 804f0a1:	6a 01                	push   $0x1
 804f0a3:	68 42 f3 05 08       	push   $0x805f342
 804f0a8:	e8 63 99 ff ff       	call   8048a10 <fwrite@plt>
 804f0ad:	83 c4 14             	add    $0x14,%esp
 804f0b0:	68 50 af 0f 10       	push   $0x100faf50
 804f0b5:	68 18 af 0f 10       	push   $0x100faf18
 804f0ba:	68 d9 0a 06 08       	push   $0x8060ad9
 804f0bf:	6a 50                	push   $0x50
 804f0c1:	68 00 8a 0c 08       	push   $0x80c8a00
 804f0c6:	e8 35 9a ff ff       	call   8048b00 <snprintf@plt>
 804f0cb:	83 c4 20             	add    $0x20,%esp
 804f0ce:	83 f8 4f             	cmp    $0x4f,%eax
 804f0d1:	7e 86                	jle    804f059 <do_sar_b+0x49>
 804f0d3:	68 61 0c 06 08       	push   $0x8060c61
 804f0d8:	6a 11                	push   $0x11
 804f0da:	68 fc 0a 06 08       	push   $0x8060afc
 804f0df:	68 24 0b 06 08       	push   $0x8060b24
 804f0e4:	e8 c7 9a ff ff       	call   8048bb0 <__assert_fail@plt>
 804f0e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804f0f0 <do_sar_w>:
#include "cpu/exec/template-start.h"

#define instr sar

static void do_execute () {
 804f0f0:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE_S dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804f0f3:	0f b6 0d 14 af 0f 10 	movzbl 0x100faf14,%ecx
	dest >>= count;
 804f0fa:	0f bf 05 4c af 0f 10 	movswl 0x100faf4c,%eax

static void do_execute () {
	DATA_TYPE src = op_src->val;
	DATA_TYPE_S dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804f101:	83 e1 1f             	and    $0x1f,%ecx
	dest >>= count;
 804f104:	d3 f8                	sar    %cl,%eax
	OPERAND_W(op_dest, dest);
 804f106:	0f b7 c0             	movzwl %ax,%eax
 804f109:	50                   	push   %eax
 804f10a:	68 40 af 0f 10       	push   $0x100faf40
 804f10f:	e8 bc d9 00 00       	call   805cad0 <write_operand_w>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804f114:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 804f11b:	68 18 af 0f 10       	push   $0x100faf18
 804f120:	68 e4 0a 06 08       	push   $0x8060ae4
 804f125:	6a 50                	push   $0x50
 804f127:	68 00 8a 0c 08       	push   $0x80c8a00
 804f12c:	e8 cf 99 ff ff       	call   8048b00 <snprintf@plt>
 804f131:	83 c4 20             	add    $0x20,%esp
 804f134:	83 f8 4f             	cmp    $0x4f,%eax
 804f137:	7f 07                	jg     804f140 <do_sar_w+0x50>
}
 804f139:	83 c4 0c             	add    $0xc,%esp
 804f13c:	c3                   	ret    
 804f13d:	8d 76 00             	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804f140:	83 ec 0c             	sub    $0xc,%esp
 804f143:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804f149:	e8 12 98 ff ff       	call   8048960 <fflush@plt>
 804f14e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f154:	6a 07                	push   $0x7
 804f156:	6a 01                	push   $0x1
 804f158:	68 92 e8 05 08       	push   $0x805e892
 804f15d:	e8 ae 98 ff ff       	call   8048a10 <fwrite@plt>
 804f162:	83 c4 20             	add    $0x20,%esp
 804f165:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f16b:	6a 10                	push   $0x10
 804f16d:	6a 01                	push   $0x1
 804f16f:	68 b4 f3 05 08       	push   $0x805f3b4
 804f174:	e8 97 98 ff ff       	call   8048a10 <fwrite@plt>
 804f179:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f17f:	6a 05                	push   $0x5
 804f181:	6a 01                	push   $0x1
 804f183:	68 42 f3 05 08       	push   $0x805f342
 804f188:	e8 83 98 ff ff       	call   8048a10 <fwrite@plt>
 804f18d:	83 c4 14             	add    $0x14,%esp
 804f190:	68 50 af 0f 10       	push   $0x100faf50
 804f195:	68 18 af 0f 10       	push   $0x100faf18
 804f19a:	68 e4 0a 06 08       	push   $0x8060ae4
 804f19f:	6a 50                	push   $0x50
 804f1a1:	68 00 8a 0c 08       	push   $0x80c8a00
 804f1a6:	e8 55 99 ff ff       	call   8048b00 <snprintf@plt>
 804f1ab:	83 c4 20             	add    $0x20,%esp
 804f1ae:	83 f8 4f             	cmp    $0x4f,%eax
 804f1b1:	7e 86                	jle    804f139 <do_sar_w+0x49>
 804f1b3:	68 58 0c 06 08       	push   $0x8060c58
 804f1b8:	6a 11                	push   $0x11
 804f1ba:	68 fc 0a 06 08       	push   $0x8060afc
 804f1bf:	68 88 0b 06 08       	push   $0x8060b88
 804f1c4:	e8 e7 99 ff ff       	call   8048bb0 <__assert_fail@plt>
 804f1c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804f1d0 <sar_rm_1_w>:
}

make_instr_helper(rm_1)
 804f1d0:	53                   	push   %ebx
 804f1d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f1d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f1d8:	83 c0 01             	add    $0x1,%eax
 804f1db:	50                   	push   %eax
 804f1dc:	e8 0f d8 00 00       	call   805c9f0 <decode_rm_1_w>
 804f1e1:	89 c3                	mov    %eax,%ebx
	execute();
 804f1e3:	e8 08 ff ff ff       	call   804f0f0 <do_sar_w>
 804f1e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f1eb:	8d 43 01             	lea    0x1(%ebx),%eax
 804f1ee:	5b                   	pop    %ebx
 804f1ef:	c3                   	ret    

0804f1f0 <sar_rm_cl_w>:
make_instr_helper(rm_cl)
 804f1f0:	53                   	push   %ebx
 804f1f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f1f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f1f8:	83 c0 01             	add    $0x1,%eax
 804f1fb:	50                   	push   %eax
 804f1fc:	e8 3f d8 00 00       	call   805ca40 <decode_rm_cl_w>
 804f201:	89 c3                	mov    %eax,%ebx
	execute();
 804f203:	e8 e8 fe ff ff       	call   804f0f0 <do_sar_w>
 804f208:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f20b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f20e:	5b                   	pop    %ebx
 804f20f:	c3                   	ret    

0804f210 <sar_rm_imm_w>:
make_instr_helper(rm_imm)
 804f210:	53                   	push   %ebx
 804f211:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f214:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f218:	83 c0 01             	add    $0x1,%eax
 804f21b:	50                   	push   %eax
 804f21c:	e8 7f d8 00 00       	call   805caa0 <decode_rm_imm_w>
 804f221:	89 c3                	mov    %eax,%ebx
	execute();
 804f223:	e8 c8 fe ff ff       	call   804f0f0 <do_sar_w>
 804f228:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f22b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f22e:	5b                   	pop    %ebx
 804f22f:	c3                   	ret    

0804f230 <do_sar_l>:
#include "cpu/exec/template-start.h"

#define instr sar

static void do_execute () {
 804f230:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE_S dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804f233:	0f b6 0d 14 af 0f 10 	movzbl 0x100faf14,%ecx
	dest >>= count;
 804f23a:	a1 4c af 0f 10       	mov    0x100faf4c,%eax

static void do_execute () {
	DATA_TYPE src = op_src->val;
	DATA_TYPE_S dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804f23f:	83 e1 1f             	and    $0x1f,%ecx
	dest >>= count;
 804f242:	d3 f8                	sar    %cl,%eax
	OPERAND_W(op_dest, dest);
 804f244:	50                   	push   %eax
 804f245:	68 40 af 0f 10       	push   $0x100faf40
 804f24a:	e8 51 dc 00 00       	call   805cea0 <write_operand_l>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804f24f:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 804f256:	68 18 af 0f 10       	push   $0x100faf18
 804f25b:	68 ef 0a 06 08       	push   $0x8060aef
 804f260:	6a 50                	push   $0x50
 804f262:	68 00 8a 0c 08       	push   $0x80c8a00
 804f267:	e8 94 98 ff ff       	call   8048b00 <snprintf@plt>
 804f26c:	83 c4 20             	add    $0x20,%esp
 804f26f:	83 f8 4f             	cmp    $0x4f,%eax
 804f272:	7f 0c                	jg     804f280 <do_sar_l+0x50>
}
 804f274:	83 c4 0c             	add    $0xc,%esp
 804f277:	c3                   	ret    
 804f278:	90                   	nop
 804f279:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804f280:	83 ec 0c             	sub    $0xc,%esp
 804f283:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804f289:	e8 d2 96 ff ff       	call   8048960 <fflush@plt>
 804f28e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f294:	6a 07                	push   $0x7
 804f296:	6a 01                	push   $0x1
 804f298:	68 92 e8 05 08       	push   $0x805e892
 804f29d:	e8 6e 97 ff ff       	call   8048a10 <fwrite@plt>
 804f2a2:	83 c4 20             	add    $0x20,%esp
 804f2a5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f2ab:	6a 10                	push   $0x10
 804f2ad:	6a 01                	push   $0x1
 804f2af:	68 b4 f3 05 08       	push   $0x805f3b4
 804f2b4:	e8 57 97 ff ff       	call   8048a10 <fwrite@plt>
 804f2b9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f2bf:	6a 05                	push   $0x5
 804f2c1:	6a 01                	push   $0x1
 804f2c3:	68 42 f3 05 08       	push   $0x805f342
 804f2c8:	e8 43 97 ff ff       	call   8048a10 <fwrite@plt>
 804f2cd:	83 c4 14             	add    $0x14,%esp
 804f2d0:	68 50 af 0f 10       	push   $0x100faf50
 804f2d5:	68 18 af 0f 10       	push   $0x100faf18
 804f2da:	68 ef 0a 06 08       	push   $0x8060aef
 804f2df:	6a 50                	push   $0x50
 804f2e1:	68 00 8a 0c 08       	push   $0x80c8a00
 804f2e6:	e8 15 98 ff ff       	call   8048b00 <snprintf@plt>
 804f2eb:	83 c4 20             	add    $0x20,%esp
 804f2ee:	83 f8 4f             	cmp    $0x4f,%eax
 804f2f1:	7e 81                	jle    804f274 <do_sar_l+0x44>
 804f2f3:	68 4f 0c 06 08       	push   $0x8060c4f
 804f2f8:	6a 11                	push   $0x11
 804f2fa:	68 fc 0a 06 08       	push   $0x8060afc
 804f2ff:	68 ec 0b 06 08       	push   $0x8060bec
 804f304:	e8 a7 98 ff ff       	call   8048bb0 <__assert_fail@plt>
 804f309:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804f310 <sar_rm_1_l>:
}

make_instr_helper(rm_1)
 804f310:	53                   	push   %ebx
 804f311:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f314:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f318:	83 c0 01             	add    $0x1,%eax
 804f31b:	50                   	push   %eax
 804f31c:	e8 9f da 00 00       	call   805cdc0 <decode_rm_1_l>
 804f321:	89 c3                	mov    %eax,%ebx
	execute();
 804f323:	e8 08 ff ff ff       	call   804f230 <do_sar_l>
 804f328:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f32b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f32e:	5b                   	pop    %ebx
 804f32f:	c3                   	ret    

0804f330 <sar_rm_cl_l>:
make_instr_helper(rm_cl)
 804f330:	53                   	push   %ebx
 804f331:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f334:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f338:	83 c0 01             	add    $0x1,%eax
 804f33b:	50                   	push   %eax
 804f33c:	e8 cf da 00 00       	call   805ce10 <decode_rm_cl_l>
 804f341:	89 c3                	mov    %eax,%ebx
	execute();
 804f343:	e8 e8 fe ff ff       	call   804f230 <do_sar_l>
 804f348:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f34b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f34e:	5b                   	pop    %ebx
 804f34f:	c3                   	ret    

0804f350 <sar_rm_imm_l>:
make_instr_helper(rm_imm)
 804f350:	53                   	push   %ebx
 804f351:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f354:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f358:	83 c0 01             	add    $0x1,%eax
 804f35b:	50                   	push   %eax
 804f35c:	e8 0f db 00 00       	call   805ce70 <decode_rm_imm_l>
 804f361:	89 c3                	mov    %eax,%ebx
	execute();
 804f363:	e8 c8 fe ff ff       	call   804f230 <do_sar_l>
 804f368:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f36b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f36e:	5b                   	pop    %ebx
 804f36f:	c3                   	ret    

0804f370 <sar_rm_1_b>:
	 */

	print_asm_template2();
}

make_instr_helper(rm_1)
 804f370:	53                   	push   %ebx
 804f371:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f374:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f378:	83 c0 01             	add    $0x1,%eax
 804f37b:	50                   	push   %eax
 804f37c:	e8 df d2 00 00       	call   805c660 <decode_rm_1_b>
 804f381:	89 c3                	mov    %eax,%ebx
	execute();
 804f383:	e8 88 fc ff ff       	call   804f010 <do_sar_b>
 804f388:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f38b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f38e:	5b                   	pop    %ebx
 804f38f:	c3                   	ret    

0804f390 <sar_rm_cl_b>:
make_instr_helper(rm_cl)
 804f390:	53                   	push   %ebx
 804f391:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f394:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f398:	83 c0 01             	add    $0x1,%eax
 804f39b:	50                   	push   %eax
 804f39c:	e8 0f d3 00 00       	call   805c6b0 <decode_rm_cl_b>
 804f3a1:	89 c3                	mov    %eax,%ebx
	execute();
 804f3a3:	e8 68 fc ff ff       	call   804f010 <do_sar_b>
 804f3a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f3ab:	8d 43 01             	lea    0x1(%ebx),%eax
 804f3ae:	5b                   	pop    %ebx
 804f3af:	c3                   	ret    

0804f3b0 <sar_rm_imm_b>:
make_instr_helper(rm_imm)
 804f3b0:	53                   	push   %ebx
 804f3b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f3b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f3b8:	83 c0 01             	add    $0x1,%eax
 804f3bb:	50                   	push   %eax
 804f3bc:	e8 4f d3 00 00       	call   805c710 <decode_rm_imm_b>
 804f3c1:	89 c3                	mov    %eax,%ebx
	execute();
 804f3c3:	e8 48 fc ff ff       	call   804f010 <do_sar_b>
 804f3c8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f3cb:	8d 43 01             	lea    0x1(%ebx),%eax
 804f3ce:	5b                   	pop    %ebx
 804f3cf:	c3                   	ret    

0804f3d0 <sar_rm_1_v>:
#define DATA_BYTE 4
#include "sar-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */
make_helper_v(sar_rm_1)
 804f3d0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804f3d7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f3db:	b8 d0 f1 04 08       	mov    $0x804f1d0,%eax
 804f3e0:	75 05                	jne    804f3e7 <sar_rm_1_v+0x17>
 804f3e2:	b8 10 f3 04 08       	mov    $0x804f310,%eax
 804f3e7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f3eb:	ff e0                	jmp    *%eax
 804f3ed:	8d 76 00             	lea    0x0(%esi),%esi

0804f3f0 <sar_rm_cl_v>:
make_helper_v(sar_rm_cl)
 804f3f0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804f3f7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f3fb:	b8 f0 f1 04 08       	mov    $0x804f1f0,%eax
 804f400:	75 05                	jne    804f407 <sar_rm_cl_v+0x17>
 804f402:	b8 30 f3 04 08       	mov    $0x804f330,%eax
 804f407:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f40b:	ff e0                	jmp    *%eax
 804f40d:	8d 76 00             	lea    0x0(%esi),%esi

0804f410 <sar_rm_imm_v>:
make_helper_v(sar_rm_imm)
 804f410:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804f417:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f41b:	b8 10 f2 04 08       	mov    $0x804f210,%eax
 804f420:	75 05                	jne    804f427 <sar_rm_imm_v+0x17>
 804f422:	b8 50 f3 04 08       	mov    $0x804f350,%eax
 804f427:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f42b:	ff e0                	jmp    *%eax
 804f42d:	66 90                	xchg   %ax,%ax
 804f42f:	90                   	nop

0804f430 <do_or_b>:
#include "cpu/exec/template-start.h"

#define instr or

static void do_execute () {
 804f430:	56                   	push   %esi
 804f431:	53                   	push   %ebx
 804f432:	83 ec 0c             	sub    $0xc,%esp
	DATA_TYPE result = op_dest->val | op_src->val;
 804f435:	a1 4c af 0f 10       	mov    0x100faf4c,%eax
 804f43a:	0a 05 14 af 0f 10    	or     0x100faf14,%al
	OPERAND_W(op_dest, result);
 804f440:	0f b6 d8             	movzbl %al,%ebx
#include "cpu/exec/template-start.h"

#define instr or

static void do_execute () {
	DATA_TYPE result = op_dest->val | op_src->val;
 804f443:	89 c6                	mov    %eax,%esi
	OPERAND_W(op_dest, result);
 804f445:	53                   	push   %ebx
 804f446:	68 40 af 0f 10       	push   $0x100faf40
 804f44b:	e8 f0 d2 00 00       	call   805c740 <write_operand_b>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f450:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
	cpu.ZF = !result;
 804f457:	89 f0                	mov    %esi,%eax
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f459:	89 f2                	mov    %esi,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 804f45b:	80 25 e5 af 0f 10 f7 	andb   $0xf7,0x100fafe5
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f462:	83 e2 80             	and    $0xffffff80,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804f465:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 804f46c:	68 18 af 0f 10       	push   $0x100faf18
 804f471:	68 9a 10 06 08       	push   $0x806109a
 804f476:	6a 50                	push   $0x50
 804f478:	68 00 8a 0c 08       	push   $0x80c8a00
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f47d:	83 e1 3e             	and    $0x3e,%ecx
	cpu.ZF = !result;
 804f480:	84 c0                	test   %al,%al
 804f482:	0f 94 c0             	sete   %al
 804f485:	09 ca                	or     %ecx,%edx
 804f487:	c1 e0 06             	shl    $0x6,%eax
 804f48a:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804f48c:	89 d8                	mov    %ebx,%eax
 804f48e:	c1 e8 04             	shr    $0x4,%eax
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 804f491:	83 e2 fb             	and    $0xfffffffb,%edx
	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804f494:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 2) ^ pf;
 804f496:	89 d8                	mov    %ebx,%eax
 804f498:	c1 e8 02             	shr    $0x2,%eax
 804f49b:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 804f49d:	89 d8                	mov    %ebx,%eax
 804f49f:	d1 e8                	shr    %eax
 804f4a1:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 804f4a3:	83 e3 01             	and    $0x1,%ebx
 804f4a6:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 804f4ad:	89 d3                	mov    %edx,%ebx
 804f4af:	09 c3                	or     %eax,%ebx
 804f4b1:	88 1d e4 af 0f 10    	mov    %bl,0x100fafe4

	print_asm_template2();
 804f4b7:	e8 44 96 ff ff       	call   8048b00 <snprintf@plt>
 804f4bc:	83 c4 20             	add    $0x20,%esp
 804f4bf:	83 f8 4f             	cmp    $0x4f,%eax
 804f4c2:	7f 0c                	jg     804f4d0 <do_or_b+0xa0>
}
 804f4c4:	83 c4 04             	add    $0x4,%esp
 804f4c7:	5b                   	pop    %ebx
 804f4c8:	5e                   	pop    %esi
 804f4c9:	c3                   	ret    
 804f4ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804f4d0:	83 ec 0c             	sub    $0xc,%esp
 804f4d3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804f4d9:	e8 82 94 ff ff       	call   8048960 <fflush@plt>
 804f4de:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f4e4:	6a 07                	push   $0x7
 804f4e6:	6a 01                	push   $0x1
 804f4e8:	68 92 e8 05 08       	push   $0x805e892
 804f4ed:	e8 1e 95 ff ff       	call   8048a10 <fwrite@plt>
 804f4f2:	83 c4 20             	add    $0x20,%esp
 804f4f5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f4fb:	6a 10                	push   $0x10
 804f4fd:	6a 01                	push   $0x1
 804f4ff:	68 b4 f3 05 08       	push   $0x805f3b4
 804f504:	e8 07 95 ff ff       	call   8048a10 <fwrite@plt>
 804f509:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f50f:	6a 05                	push   $0x5
 804f511:	6a 01                	push   $0x1
 804f513:	68 42 f3 05 08       	push   $0x805f342
 804f518:	e8 f3 94 ff ff       	call   8048a10 <fwrite@plt>
 804f51d:	83 c4 14             	add    $0x14,%esp
 804f520:	68 50 af 0f 10       	push   $0x100faf50
 804f525:	68 18 af 0f 10       	push   $0x100faf18
 804f52a:	68 9a 10 06 08       	push   $0x806109a
 804f52f:	6a 50                	push   $0x50
 804f531:	68 00 8a 0c 08       	push   $0x80c8a00
 804f536:	e8 c5 95 ff ff       	call   8048b00 <snprintf@plt>
 804f53b:	83 c4 20             	add    $0x20,%esp
 804f53e:	83 f8 4f             	cmp    $0x4f,%eax
 804f541:	7e 81                	jle    804f4c4 <do_or_b+0x94>
 804f543:	68 ce 0d 06 08       	push   $0x8060dce
 804f548:	6a 13                	push   $0x13
 804f54a:	68 6c 0c 06 08       	push   $0x8060c6c
 804f54f:	68 94 0c 06 08       	push   $0x8060c94
 804f554:	e8 57 96 ff ff       	call   8048bb0 <__assert_fail@plt>
 804f559:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804f560 <do_or_w>:
#include "cpu/exec/template-start.h"

#define instr or

static void do_execute () {
 804f560:	53                   	push   %ebx
 804f561:	83 ec 10             	sub    $0x10,%esp
	DATA_TYPE result = op_dest->val | op_src->val;
 804f564:	8b 1d 4c af 0f 10    	mov    0x100faf4c,%ebx
 804f56a:	66 0b 1d 14 af 0f 10 	or     0x100faf14,%bx
	OPERAND_W(op_dest, result);
 804f571:	0f b7 c3             	movzwl %bx,%eax
 804f574:	50                   	push   %eax
 804f575:	68 40 af 0f 10       	push   $0x100faf40
 804f57a:	e8 51 d5 00 00       	call   805cad0 <write_operand_w>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f57f:	89 da                	mov    %ebx,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 804f581:	80 25 e5 af 0f 10 f7 	andb   $0xf7,0x100fafe5
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804f588:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f58f:	66 c1 ea 0f          	shr    $0xf,%dx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804f593:	68 18 af 0f 10       	push   $0x100faf18
 804f598:	68 a5 10 06 08       	push   $0x80610a5
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f59d:	89 d0                	mov    %edx,%eax
 804f59f:	0f b6 15 e4 af 0f 10 	movzbl 0x100fafe4,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804f5a6:	6a 50                	push   $0x50
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f5a8:	c1 e0 07             	shl    $0x7,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804f5ab:	68 00 8a 0c 08       	push   $0x80c8a00
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f5b0:	83 e2 3e             	and    $0x3e,%edx
	cpu.ZF = !result;
 804f5b3:	66 85 db             	test   %bx,%bx
	uint32_t pf = (result & 255);
 804f5b6:	0f b6 db             	movzbl %bl,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804f5b9:	0f 94 c1             	sete   %cl
 804f5bc:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804f5be:	89 d8                	mov    %ebx,%eax
 804f5c0:	c1 e8 04             	shr    $0x4,%eax
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804f5c3:	c1 e1 06             	shl    $0x6,%ecx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804f5c6:	31 c3                	xor    %eax,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804f5c8:	09 ca                	or     %ecx,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804f5ca:	89 d8                	mov    %ebx,%eax
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 804f5cc:	83 e2 fb             	and    $0xfffffffb,%edx
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804f5cf:	c1 e8 02             	shr    $0x2,%eax
 804f5d2:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 804f5d4:	89 d8                	mov    %ebx,%eax
 804f5d6:	d1 e8                	shr    %eax
 804f5d8:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 804f5da:	83 e3 01             	and    $0x1,%ebx
 804f5dd:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 804f5e4:	89 d3                	mov    %edx,%ebx
 804f5e6:	09 c3                	or     %eax,%ebx
 804f5e8:	88 1d e4 af 0f 10    	mov    %bl,0x100fafe4

	print_asm_template2();
 804f5ee:	e8 0d 95 ff ff       	call   8048b00 <snprintf@plt>
 804f5f3:	83 c4 20             	add    $0x20,%esp
 804f5f6:	83 f8 4f             	cmp    $0x4f,%eax
 804f5f9:	7f 05                	jg     804f600 <do_or_w+0xa0>
}
 804f5fb:	83 c4 08             	add    $0x8,%esp
 804f5fe:	5b                   	pop    %ebx
 804f5ff:	c3                   	ret    
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804f600:	83 ec 0c             	sub    $0xc,%esp
 804f603:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804f609:	e8 52 93 ff ff       	call   8048960 <fflush@plt>
 804f60e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f614:	6a 07                	push   $0x7
 804f616:	6a 01                	push   $0x1
 804f618:	68 92 e8 05 08       	push   $0x805e892
 804f61d:	e8 ee 93 ff ff       	call   8048a10 <fwrite@plt>
 804f622:	83 c4 20             	add    $0x20,%esp
 804f625:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f62b:	6a 10                	push   $0x10
 804f62d:	6a 01                	push   $0x1
 804f62f:	68 b4 f3 05 08       	push   $0x805f3b4
 804f634:	e8 d7 93 ff ff       	call   8048a10 <fwrite@plt>
 804f639:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f63f:	6a 05                	push   $0x5
 804f641:	6a 01                	push   $0x1
 804f643:	68 42 f3 05 08       	push   $0x805f342
 804f648:	e8 c3 93 ff ff       	call   8048a10 <fwrite@plt>
 804f64d:	83 c4 14             	add    $0x14,%esp
 804f650:	68 50 af 0f 10       	push   $0x100faf50
 804f655:	68 18 af 0f 10       	push   $0x100faf18
 804f65a:	68 a5 10 06 08       	push   $0x80610a5
 804f65f:	6a 50                	push   $0x50
 804f661:	68 00 8a 0c 08       	push   $0x80c8a00
 804f666:	e8 95 94 ff ff       	call   8048b00 <snprintf@plt>
 804f66b:	83 c4 20             	add    $0x20,%esp
 804f66e:	83 f8 4f             	cmp    $0x4f,%eax
 804f671:	7e 88                	jle    804f5fb <do_or_w+0x9b>
 804f673:	68 c6 0d 06 08       	push   $0x8060dc6
 804f678:	6a 13                	push   $0x13
 804f67a:	68 6c 0c 06 08       	push   $0x8060c6c
 804f67f:	68 f8 0c 06 08       	push   $0x8060cf8
 804f684:	e8 27 95 ff ff       	call   8048bb0 <__assert_fail@plt>
 804f689:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804f690 <or_i2a_w>:
}

make_instr_helper(i2a)
 804f690:	53                   	push   %ebx
 804f691:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f694:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f698:	83 c0 01             	add    $0x1,%eax
 804f69b:	50                   	push   %eax
 804f69c:	e8 ef d1 00 00       	call   805c890 <decode_i2a_w>
 804f6a1:	89 c3                	mov    %eax,%ebx
	execute();
 804f6a3:	e8 b8 fe ff ff       	call   804f560 <do_or_w>
 804f6a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f6ab:	8d 43 01             	lea    0x1(%ebx),%eax
 804f6ae:	5b                   	pop    %ebx
 804f6af:	c3                   	ret    

0804f6b0 <or_i2rm_w>:
make_instr_helper(i2rm)
 804f6b0:	53                   	push   %ebx
 804f6b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f6b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f6b8:	83 c0 01             	add    $0x1,%eax
 804f6bb:	50                   	push   %eax
 804f6bc:	e8 4f d2 00 00       	call   805c910 <decode_i2rm_w>
 804f6c1:	89 c3                	mov    %eax,%ebx
	execute();
 804f6c3:	e8 98 fe ff ff       	call   804f560 <do_or_w>
 804f6c8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f6cb:	8d 43 01             	lea    0x1(%ebx),%eax
 804f6ce:	5b                   	pop    %ebx
 804f6cf:	c3                   	ret    

0804f6d0 <or_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 804f6d0:	53                   	push   %ebx
 804f6d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f6d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f6d8:	83 c0 01             	add    $0x1,%eax
 804f6db:	50                   	push   %eax
 804f6dc:	e8 af d2 00 00       	call   805c990 <decode_si2rm_w>
 804f6e1:	89 c3                	mov    %eax,%ebx
	execute();
 804f6e3:	e8 78 fe ff ff       	call   804f560 <do_or_w>
 804f6e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f6eb:	8d 43 01             	lea    0x1(%ebx),%eax
 804f6ee:	5b                   	pop    %ebx
 804f6ef:	c3                   	ret    

0804f6f0 <or_r2rm_w>:
#endif
make_instr_helper(r2rm)
 804f6f0:	53                   	push   %ebx
 804f6f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f6f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f6f8:	83 c0 01             	add    $0x1,%eax
 804f6fb:	50                   	push   %eax
 804f6fc:	e8 4f d1 00 00       	call   805c850 <decode_r2rm_w>
 804f701:	89 c3                	mov    %eax,%ebx
	execute();
 804f703:	e8 58 fe ff ff       	call   804f560 <do_or_w>
 804f708:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f70b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f70e:	5b                   	pop    %ebx
 804f70f:	c3                   	ret    

0804f710 <or_rm2r_w>:
make_instr_helper(rm2r)
 804f710:	53                   	push   %ebx
 804f711:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f714:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f718:	83 c0 01             	add    $0x1,%eax
 804f71b:	50                   	push   %eax
 804f71c:	e8 4f d1 00 00       	call   805c870 <decode_rm2r_w>
 804f721:	89 c3                	mov    %eax,%ebx
	execute();
 804f723:	e8 38 fe ff ff       	call   804f560 <do_or_w>
 804f728:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f72b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f72e:	5b                   	pop    %ebx
 804f72f:	c3                   	ret    

0804f730 <do_or_l>:
#include "cpu/exec/template-start.h"

#define instr or

static void do_execute () {
 804f730:	53                   	push   %ebx
 804f731:	83 ec 10             	sub    $0x10,%esp
	DATA_TYPE result = op_dest->val | op_src->val;
 804f734:	8b 1d 14 af 0f 10    	mov    0x100faf14,%ebx
 804f73a:	0b 1d 4c af 0f 10    	or     0x100faf4c,%ebx
	OPERAND_W(op_dest, result);
 804f740:	53                   	push   %ebx
 804f741:	68 40 af 0f 10       	push   $0x100faf40
 804f746:	e8 55 d7 00 00       	call   805cea0 <write_operand_l>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f74b:	89 da                	mov    %ebx,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 804f74d:	80 25 e5 af 0f 10 f7 	andb   $0xf7,0x100fafe5
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804f754:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f75b:	c1 ea 1f             	shr    $0x1f,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804f75e:	68 18 af 0f 10       	push   $0x100faf18
 804f763:	68 b0 10 06 08       	push   $0x80610b0
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f768:	89 d0                	mov    %edx,%eax
 804f76a:	0f b6 15 e4 af 0f 10 	movzbl 0x100fafe4,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804f771:	6a 50                	push   $0x50
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f773:	c1 e0 07             	shl    $0x7,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804f776:	68 00 8a 0c 08       	push   $0x80c8a00
	DATA_TYPE result = op_dest->val | op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 804f77b:	83 e2 3e             	and    $0x3e,%edx
	cpu.ZF = !result;
 804f77e:	85 db                	test   %ebx,%ebx
	uint32_t pf = (result & 255);
 804f780:	0f b6 db             	movzbl %bl,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804f783:	0f 94 c1             	sete   %cl
 804f786:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804f788:	89 d8                	mov    %ebx,%eax
 804f78a:	c1 e8 04             	shr    $0x4,%eax
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804f78d:	c1 e1 06             	shl    $0x6,%ecx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 804f790:	31 c3                	xor    %eax,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 804f792:	09 ca                	or     %ecx,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804f794:	89 d8                	mov    %ebx,%eax
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 804f796:	83 e2 fb             	and    $0xfffffffb,%edx
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 804f799:	c1 e8 02             	shr    $0x2,%eax
 804f79c:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 804f79e:	89 d8                	mov    %ebx,%eax
 804f7a0:	d1 e8                	shr    %eax
 804f7a2:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 804f7a4:	83 e3 01             	and    $0x1,%ebx
 804f7a7:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 804f7ae:	89 d3                	mov    %edx,%ebx
 804f7b0:	09 c3                	or     %eax,%ebx
 804f7b2:	88 1d e4 af 0f 10    	mov    %bl,0x100fafe4

	print_asm_template2();
 804f7b8:	e8 43 93 ff ff       	call   8048b00 <snprintf@plt>
 804f7bd:	83 c4 20             	add    $0x20,%esp
 804f7c0:	83 f8 4f             	cmp    $0x4f,%eax
 804f7c3:	7f 0b                	jg     804f7d0 <do_or_l+0xa0>
}
 804f7c5:	83 c4 08             	add    $0x8,%esp
 804f7c8:	5b                   	pop    %ebx
 804f7c9:	c3                   	ret    
 804f7ca:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 804f7d0:	83 ec 0c             	sub    $0xc,%esp
 804f7d3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804f7d9:	e8 82 91 ff ff       	call   8048960 <fflush@plt>
 804f7de:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f7e4:	6a 07                	push   $0x7
 804f7e6:	6a 01                	push   $0x1
 804f7e8:	68 92 e8 05 08       	push   $0x805e892
 804f7ed:	e8 1e 92 ff ff       	call   8048a10 <fwrite@plt>
 804f7f2:	83 c4 20             	add    $0x20,%esp
 804f7f5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f7fb:	6a 10                	push   $0x10
 804f7fd:	6a 01                	push   $0x1
 804f7ff:	68 b4 f3 05 08       	push   $0x805f3b4
 804f804:	e8 07 92 ff ff       	call   8048a10 <fwrite@plt>
 804f809:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804f80f:	6a 05                	push   $0x5
 804f811:	6a 01                	push   $0x1
 804f813:	68 42 f3 05 08       	push   $0x805f342
 804f818:	e8 f3 91 ff ff       	call   8048a10 <fwrite@plt>
 804f81d:	83 c4 14             	add    $0x14,%esp
 804f820:	68 50 af 0f 10       	push   $0x100faf50
 804f825:	68 18 af 0f 10       	push   $0x100faf18
 804f82a:	68 b0 10 06 08       	push   $0x80610b0
 804f82f:	6a 50                	push   $0x50
 804f831:	68 00 8a 0c 08       	push   $0x80c8a00
 804f836:	e8 c5 92 ff ff       	call   8048b00 <snprintf@plt>
 804f83b:	83 c4 20             	add    $0x20,%esp
 804f83e:	83 f8 4f             	cmp    $0x4f,%eax
 804f841:	7e 82                	jle    804f7c5 <do_or_l+0x95>
 804f843:	68 be 0d 06 08       	push   $0x8060dbe
 804f848:	6a 13                	push   $0x13
 804f84a:	68 6c 0c 06 08       	push   $0x8060c6c
 804f84f:	68 5c 0d 06 08       	push   $0x8060d5c
 804f854:	e8 57 93 ff ff       	call   8048bb0 <__assert_fail@plt>
 804f859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804f860 <or_i2a_l>:
}

make_instr_helper(i2a)
 804f860:	53                   	push   %ebx
 804f861:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f864:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f868:	83 c0 01             	add    $0x1,%eax
 804f86b:	50                   	push   %eax
 804f86c:	e8 ef d3 00 00       	call   805cc60 <decode_i2a_l>
 804f871:	89 c3                	mov    %eax,%ebx
	execute();
 804f873:	e8 b8 fe ff ff       	call   804f730 <do_or_l>
 804f878:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f87b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f87e:	5b                   	pop    %ebx
 804f87f:	c3                   	ret    

0804f880 <or_i2rm_l>:
make_instr_helper(i2rm)
 804f880:	53                   	push   %ebx
 804f881:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f884:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f888:	83 c0 01             	add    $0x1,%eax
 804f88b:	50                   	push   %eax
 804f88c:	e8 4f d4 00 00       	call   805cce0 <decode_i2rm_l>
 804f891:	89 c3                	mov    %eax,%ebx
	execute();
 804f893:	e8 98 fe ff ff       	call   804f730 <do_or_l>
 804f898:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f89b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f89e:	5b                   	pop    %ebx
 804f89f:	c3                   	ret    

0804f8a0 <or_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 804f8a0:	53                   	push   %ebx
 804f8a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f8a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f8a8:	83 c0 01             	add    $0x1,%eax
 804f8ab:	50                   	push   %eax
 804f8ac:	e8 af d4 00 00       	call   805cd60 <decode_si2rm_l>
 804f8b1:	89 c3                	mov    %eax,%ebx
	execute();
 804f8b3:	e8 78 fe ff ff       	call   804f730 <do_or_l>
 804f8b8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f8bb:	8d 43 01             	lea    0x1(%ebx),%eax
 804f8be:	5b                   	pop    %ebx
 804f8bf:	c3                   	ret    

0804f8c0 <or_r2rm_l>:
#endif
make_instr_helper(r2rm)
 804f8c0:	53                   	push   %ebx
 804f8c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f8c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f8c8:	83 c0 01             	add    $0x1,%eax
 804f8cb:	50                   	push   %eax
 804f8cc:	e8 4f d3 00 00       	call   805cc20 <decode_r2rm_l>
 804f8d1:	89 c3                	mov    %eax,%ebx
	execute();
 804f8d3:	e8 58 fe ff ff       	call   804f730 <do_or_l>
 804f8d8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f8db:	8d 43 01             	lea    0x1(%ebx),%eax
 804f8de:	5b                   	pop    %ebx
 804f8df:	c3                   	ret    

0804f8e0 <or_rm2r_l>:
make_instr_helper(rm2r)
 804f8e0:	53                   	push   %ebx
 804f8e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f8e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f8e8:	83 c0 01             	add    $0x1,%eax
 804f8eb:	50                   	push   %eax
 804f8ec:	e8 4f d3 00 00       	call   805cc40 <decode_rm2r_l>
 804f8f1:	89 c3                	mov    %eax,%ebx
	execute();
 804f8f3:	e8 38 fe ff ff       	call   804f730 <do_or_l>
 804f8f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f8fb:	8d 43 01             	lea    0x1(%ebx),%eax
 804f8fe:	5b                   	pop    %ebx
 804f8ff:	c3                   	ret    

0804f900 <or_i2a_b>:
	cpu.PF = pf & 1;

	print_asm_template2();
}

make_instr_helper(i2a)
 804f900:	53                   	push   %ebx
 804f901:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f904:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f908:	83 c0 01             	add    $0x1,%eax
 804f90b:	50                   	push   %eax
 804f90c:	e8 4f cc 00 00       	call   805c560 <decode_i2a_b>
 804f911:	89 c3                	mov    %eax,%ebx
	execute();
 804f913:	e8 18 fb ff ff       	call   804f430 <do_or_b>
 804f918:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f91b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f91e:	5b                   	pop    %ebx
 804f91f:	c3                   	ret    

0804f920 <or_i2rm_b>:
make_instr_helper(i2rm)
 804f920:	53                   	push   %ebx
 804f921:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f924:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f928:	83 c0 01             	add    $0x1,%eax
 804f92b:	50                   	push   %eax
 804f92c:	e8 af cc 00 00       	call   805c5e0 <decode_i2rm_b>
 804f931:	89 c3                	mov    %eax,%ebx
	execute();
 804f933:	e8 f8 fa ff ff       	call   804f430 <do_or_b>
 804f938:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f93b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f93e:	5b                   	pop    %ebx
 804f93f:	c3                   	ret    

0804f940 <or_r2rm_b>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
#endif
make_instr_helper(r2rm)
 804f940:	53                   	push   %ebx
 804f941:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f944:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f948:	83 c0 01             	add    $0x1,%eax
 804f94b:	50                   	push   %eax
 804f94c:	e8 cf cb 00 00       	call   805c520 <decode_r2rm_b>
 804f951:	89 c3                	mov    %eax,%ebx
	execute();
 804f953:	e8 d8 fa ff ff       	call   804f430 <do_or_b>
 804f958:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f95b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f95e:	5b                   	pop    %ebx
 804f95f:	c3                   	ret    

0804f960 <or_rm2r_b>:
make_instr_helper(rm2r)
 804f960:	53                   	push   %ebx
 804f961:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804f964:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804f968:	83 c0 01             	add    $0x1,%eax
 804f96b:	50                   	push   %eax
 804f96c:	e8 cf cb 00 00       	call   805c540 <decode_rm2r_b>
 804f971:	89 c3                	mov    %eax,%ebx
	execute();
 804f973:	e8 b8 fa ff ff       	call   804f430 <do_or_b>
 804f978:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804f97b:	8d 43 01             	lea    0x1(%ebx),%eax
 804f97e:	5b                   	pop    %ebx
 804f97f:	c3                   	ret    

0804f980 <or_i2a_v>:
#include "or-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(or_i2a)
 804f980:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804f987:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f98b:	b8 90 f6 04 08       	mov    $0x804f690,%eax
 804f990:	75 05                	jne    804f997 <or_i2a_v+0x17>
 804f992:	b8 60 f8 04 08       	mov    $0x804f860,%eax
 804f997:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f99b:	ff e0                	jmp    *%eax
 804f99d:	8d 76 00             	lea    0x0(%esi),%esi

0804f9a0 <or_i2rm_v>:
make_helper_v(or_i2rm)
 804f9a0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804f9a7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f9ab:	b8 b0 f6 04 08       	mov    $0x804f6b0,%eax
 804f9b0:	75 05                	jne    804f9b7 <or_i2rm_v+0x17>
 804f9b2:	b8 80 f8 04 08       	mov    $0x804f880,%eax
 804f9b7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f9bb:	ff e0                	jmp    *%eax
 804f9bd:	8d 76 00             	lea    0x0(%esi),%esi

0804f9c0 <or_si2rm_v>:
make_helper_v(or_si2rm)
 804f9c0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804f9c7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f9cb:	b8 d0 f6 04 08       	mov    $0x804f6d0,%eax
 804f9d0:	75 05                	jne    804f9d7 <or_si2rm_v+0x17>
 804f9d2:	b8 a0 f8 04 08       	mov    $0x804f8a0,%eax
 804f9d7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f9db:	ff e0                	jmp    *%eax
 804f9dd:	8d 76 00             	lea    0x0(%esi),%esi

0804f9e0 <or_r2rm_v>:
make_helper_v(or_r2rm)
 804f9e0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804f9e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804f9eb:	b8 f0 f6 04 08       	mov    $0x804f6f0,%eax
 804f9f0:	75 05                	jne    804f9f7 <or_r2rm_v+0x17>
 804f9f2:	b8 c0 f8 04 08       	mov    $0x804f8c0,%eax
 804f9f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804f9fb:	ff e0                	jmp    *%eax
 804f9fd:	8d 76 00             	lea    0x0(%esi),%esi

0804fa00 <or_rm2r_v>:
make_helper_v(or_rm2r)
 804fa00:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804fa07:	8b 54 24 04          	mov    0x4(%esp),%edx
 804fa0b:	b8 10 f7 04 08       	mov    $0x804f710,%eax
 804fa10:	75 05                	jne    804fa17 <or_rm2r_v+0x17>
 804fa12:	b8 e0 f8 04 08       	mov    $0x804f8e0,%eax
 804fa17:	89 54 24 04          	mov    %edx,0x4(%esp)
 804fa1b:	ff e0                	jmp    *%eax
 804fa1d:	66 90                	xchg   %ax,%ax
 804fa1f:	90                   	nop

0804fa20 <do_shr_b>:
#include "cpu/exec/template-start.h"

#define instr shr

static void do_execute () {
 804fa20:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804fa23:	0f b6 0d 14 af 0f 10 	movzbl 0x100faf14,%ecx
 804fa2a:	0f b6 05 4c af 0f 10 	movzbl 0x100faf4c,%eax
 804fa31:	83 e1 1f             	and    $0x1f,%ecx
	dest >>= count;
 804fa34:	d3 f8                	sar    %cl,%eax
	OPERAND_W(op_dest, dest);
 804fa36:	50                   	push   %eax
 804fa37:	68 40 af 0f 10       	push   $0x100faf40
 804fa3c:	e8 ff cc 00 00       	call   805c740 <write_operand_b>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804fa41:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 804fa48:	68 18 af 0f 10       	push   $0x100faf18
 804fa4d:	68 d6 0d 06 08       	push   $0x8060dd6
 804fa52:	6a 50                	push   $0x50
 804fa54:	68 00 8a 0c 08       	push   $0x80c8a00
 804fa59:	e8 a2 90 ff ff       	call   8048b00 <snprintf@plt>
 804fa5e:	83 c4 20             	add    $0x20,%esp
 804fa61:	83 f8 4f             	cmp    $0x4f,%eax
 804fa64:	7f 0a                	jg     804fa70 <do_shr_b+0x50>
}
 804fa66:	83 c4 0c             	add    $0xc,%esp
 804fa69:	c3                   	ret    
 804fa6a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804fa70:	83 ec 0c             	sub    $0xc,%esp
 804fa73:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804fa79:	e8 e2 8e ff ff       	call   8048960 <fflush@plt>
 804fa7e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804fa84:	6a 07                	push   $0x7
 804fa86:	6a 01                	push   $0x1
 804fa88:	68 92 e8 05 08       	push   $0x805e892
 804fa8d:	e8 7e 8f ff ff       	call   8048a10 <fwrite@plt>
 804fa92:	83 c4 20             	add    $0x20,%esp
 804fa95:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804fa9b:	6a 10                	push   $0x10
 804fa9d:	6a 01                	push   $0x1
 804fa9f:	68 b4 f3 05 08       	push   $0x805f3b4
 804faa4:	e8 67 8f ff ff       	call   8048a10 <fwrite@plt>
 804faa9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804faaf:	6a 05                	push   $0x5
 804fab1:	6a 01                	push   $0x1
 804fab3:	68 42 f3 05 08       	push   $0x805f342
 804fab8:	e8 53 8f ff ff       	call   8048a10 <fwrite@plt>
 804fabd:	83 c4 14             	add    $0x14,%esp
 804fac0:	68 50 af 0f 10       	push   $0x100faf50
 804fac5:	68 18 af 0f 10       	push   $0x100faf18
 804faca:	68 d6 0d 06 08       	push   $0x8060dd6
 804facf:	6a 50                	push   $0x50
 804fad1:	68 00 8a 0c 08       	push   $0x80c8a00
 804fad6:	e8 25 90 ff ff       	call   8048b00 <snprintf@plt>
 804fadb:	83 c4 20             	add    $0x20,%esp
 804fade:	83 f8 4f             	cmp    $0x4f,%eax
 804fae1:	7e 83                	jle    804fa66 <do_shr_b+0x46>
 804fae3:	68 5d 0f 06 08       	push   $0x8060f5d
 804fae8:	6a 11                	push   $0x11
 804faea:	68 f8 0d 06 08       	push   $0x8060df8
 804faef:	68 20 0e 06 08       	push   $0x8060e20
 804faf4:	e8 b7 90 ff ff       	call   8048bb0 <__assert_fail@plt>
 804faf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804fb00 <do_shr_w>:
#include "cpu/exec/template-start.h"

#define instr shr

static void do_execute () {
 804fb00:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804fb03:	0f b6 0d 14 af 0f 10 	movzbl 0x100faf14,%ecx
 804fb0a:	0f b7 05 4c af 0f 10 	movzwl 0x100faf4c,%eax
 804fb11:	83 e1 1f             	and    $0x1f,%ecx
	dest >>= count;
 804fb14:	d3 f8                	sar    %cl,%eax
	OPERAND_W(op_dest, dest);
 804fb16:	50                   	push   %eax
 804fb17:	68 40 af 0f 10       	push   $0x100faf40
 804fb1c:	e8 af cf 00 00       	call   805cad0 <write_operand_w>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804fb21:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 804fb28:	68 18 af 0f 10       	push   $0x100faf18
 804fb2d:	68 e1 0d 06 08       	push   $0x8060de1
 804fb32:	6a 50                	push   $0x50
 804fb34:	68 00 8a 0c 08       	push   $0x80c8a00
 804fb39:	e8 c2 8f ff ff       	call   8048b00 <snprintf@plt>
 804fb3e:	83 c4 20             	add    $0x20,%esp
 804fb41:	83 f8 4f             	cmp    $0x4f,%eax
 804fb44:	7f 0a                	jg     804fb50 <do_shr_w+0x50>
}
 804fb46:	83 c4 0c             	add    $0xc,%esp
 804fb49:	c3                   	ret    
 804fb4a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804fb50:	83 ec 0c             	sub    $0xc,%esp
 804fb53:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804fb59:	e8 02 8e ff ff       	call   8048960 <fflush@plt>
 804fb5e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804fb64:	6a 07                	push   $0x7
 804fb66:	6a 01                	push   $0x1
 804fb68:	68 92 e8 05 08       	push   $0x805e892
 804fb6d:	e8 9e 8e ff ff       	call   8048a10 <fwrite@plt>
 804fb72:	83 c4 20             	add    $0x20,%esp
 804fb75:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804fb7b:	6a 10                	push   $0x10
 804fb7d:	6a 01                	push   $0x1
 804fb7f:	68 b4 f3 05 08       	push   $0x805f3b4
 804fb84:	e8 87 8e ff ff       	call   8048a10 <fwrite@plt>
 804fb89:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804fb8f:	6a 05                	push   $0x5
 804fb91:	6a 01                	push   $0x1
 804fb93:	68 42 f3 05 08       	push   $0x805f342
 804fb98:	e8 73 8e ff ff       	call   8048a10 <fwrite@plt>
 804fb9d:	83 c4 14             	add    $0x14,%esp
 804fba0:	68 50 af 0f 10       	push   $0x100faf50
 804fba5:	68 18 af 0f 10       	push   $0x100faf18
 804fbaa:	68 e1 0d 06 08       	push   $0x8060de1
 804fbaf:	6a 50                	push   $0x50
 804fbb1:	68 00 8a 0c 08       	push   $0x80c8a00
 804fbb6:	e8 45 8f ff ff       	call   8048b00 <snprintf@plt>
 804fbbb:	83 c4 20             	add    $0x20,%esp
 804fbbe:	83 f8 4f             	cmp    $0x4f,%eax
 804fbc1:	7e 83                	jle    804fb46 <do_shr_w+0x46>
 804fbc3:	68 54 0f 06 08       	push   $0x8060f54
 804fbc8:	6a 11                	push   $0x11
 804fbca:	68 f8 0d 06 08       	push   $0x8060df8
 804fbcf:	68 84 0e 06 08       	push   $0x8060e84
 804fbd4:	e8 d7 8f ff ff       	call   8048bb0 <__assert_fail@plt>
 804fbd9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804fbe0 <shr_rm_1_w>:
}

make_instr_helper(rm_1)
 804fbe0:	53                   	push   %ebx
 804fbe1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fbe4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fbe8:	83 c0 01             	add    $0x1,%eax
 804fbeb:	50                   	push   %eax
 804fbec:	e8 ff cd 00 00       	call   805c9f0 <decode_rm_1_w>
 804fbf1:	89 c3                	mov    %eax,%ebx
	execute();
 804fbf3:	e8 08 ff ff ff       	call   804fb00 <do_shr_w>
 804fbf8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fbfb:	8d 43 01             	lea    0x1(%ebx),%eax
 804fbfe:	5b                   	pop    %ebx
 804fbff:	c3                   	ret    

0804fc00 <shr_rm_cl_w>:
make_instr_helper(rm_cl)
 804fc00:	53                   	push   %ebx
 804fc01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fc04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fc08:	83 c0 01             	add    $0x1,%eax
 804fc0b:	50                   	push   %eax
 804fc0c:	e8 2f ce 00 00       	call   805ca40 <decode_rm_cl_w>
 804fc11:	89 c3                	mov    %eax,%ebx
	execute();
 804fc13:	e8 e8 fe ff ff       	call   804fb00 <do_shr_w>
 804fc18:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fc1b:	8d 43 01             	lea    0x1(%ebx),%eax
 804fc1e:	5b                   	pop    %ebx
 804fc1f:	c3                   	ret    

0804fc20 <shr_rm_imm_w>:
make_instr_helper(rm_imm)
 804fc20:	53                   	push   %ebx
 804fc21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fc24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fc28:	83 c0 01             	add    $0x1,%eax
 804fc2b:	50                   	push   %eax
 804fc2c:	e8 6f ce 00 00       	call   805caa0 <decode_rm_imm_w>
 804fc31:	89 c3                	mov    %eax,%ebx
	execute();
 804fc33:	e8 c8 fe ff ff       	call   804fb00 <do_shr_w>
 804fc38:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fc3b:	8d 43 01             	lea    0x1(%ebx),%eax
 804fc3e:	5b                   	pop    %ebx
 804fc3f:	c3                   	ret    

0804fc40 <do_shr_l>:
#include "cpu/exec/template-start.h"

#define instr shr

static void do_execute () {
 804fc40:	83 ec 14             	sub    $0x14,%esp
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804fc43:	0f b6 0d 14 af 0f 10 	movzbl 0x100faf14,%ecx
	dest >>= count;
 804fc4a:	a1 4c af 0f 10       	mov    0x100faf4c,%eax

static void do_execute () {
	DATA_TYPE src = op_src->val;
	DATA_TYPE dest = op_dest->val;

	uint8_t count = src & 0x1f;
 804fc4f:	83 e1 1f             	and    $0x1f,%ecx
	dest >>= count;
 804fc52:	d3 e8                	shr    %cl,%eax
	OPERAND_W(op_dest, dest);
 804fc54:	50                   	push   %eax
 804fc55:	68 40 af 0f 10       	push   $0x100faf40
 804fc5a:	e8 41 d2 00 00       	call   805cea0 <write_operand_l>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804fc5f:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 804fc66:	68 18 af 0f 10       	push   $0x100faf18
 804fc6b:	68 ec 0d 06 08       	push   $0x8060dec
 804fc70:	6a 50                	push   $0x50
 804fc72:	68 00 8a 0c 08       	push   $0x80c8a00
 804fc77:	e8 84 8e ff ff       	call   8048b00 <snprintf@plt>
 804fc7c:	83 c4 20             	add    $0x20,%esp
 804fc7f:	83 f8 4f             	cmp    $0x4f,%eax
 804fc82:	7f 0c                	jg     804fc90 <do_shr_l+0x50>
}
 804fc84:	83 c4 0c             	add    $0xc,%esp
 804fc87:	c3                   	ret    
 804fc88:	90                   	nop
 804fc89:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template2();
 804fc90:	83 ec 0c             	sub    $0xc,%esp
 804fc93:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804fc99:	e8 c2 8c ff ff       	call   8048960 <fflush@plt>
 804fc9e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804fca4:	6a 07                	push   $0x7
 804fca6:	6a 01                	push   $0x1
 804fca8:	68 92 e8 05 08       	push   $0x805e892
 804fcad:	e8 5e 8d ff ff       	call   8048a10 <fwrite@plt>
 804fcb2:	83 c4 20             	add    $0x20,%esp
 804fcb5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804fcbb:	6a 10                	push   $0x10
 804fcbd:	6a 01                	push   $0x1
 804fcbf:	68 b4 f3 05 08       	push   $0x805f3b4
 804fcc4:	e8 47 8d ff ff       	call   8048a10 <fwrite@plt>
 804fcc9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804fccf:	6a 05                	push   $0x5
 804fcd1:	6a 01                	push   $0x1
 804fcd3:	68 42 f3 05 08       	push   $0x805f342
 804fcd8:	e8 33 8d ff ff       	call   8048a10 <fwrite@plt>
 804fcdd:	83 c4 14             	add    $0x14,%esp
 804fce0:	68 50 af 0f 10       	push   $0x100faf50
 804fce5:	68 18 af 0f 10       	push   $0x100faf18
 804fcea:	68 ec 0d 06 08       	push   $0x8060dec
 804fcef:	6a 50                	push   $0x50
 804fcf1:	68 00 8a 0c 08       	push   $0x80c8a00
 804fcf6:	e8 05 8e ff ff       	call   8048b00 <snprintf@plt>
 804fcfb:	83 c4 20             	add    $0x20,%esp
 804fcfe:	83 f8 4f             	cmp    $0x4f,%eax
 804fd01:	7e 81                	jle    804fc84 <do_shr_l+0x44>
 804fd03:	68 4b 0f 06 08       	push   $0x8060f4b
 804fd08:	6a 11                	push   $0x11
 804fd0a:	68 f8 0d 06 08       	push   $0x8060df8
 804fd0f:	68 e8 0e 06 08       	push   $0x8060ee8
 804fd14:	e8 97 8e ff ff       	call   8048bb0 <__assert_fail@plt>
 804fd19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0804fd20 <shr_rm_1_l>:
}

make_instr_helper(rm_1)
 804fd20:	53                   	push   %ebx
 804fd21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fd24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fd28:	83 c0 01             	add    $0x1,%eax
 804fd2b:	50                   	push   %eax
 804fd2c:	e8 8f d0 00 00       	call   805cdc0 <decode_rm_1_l>
 804fd31:	89 c3                	mov    %eax,%ebx
	execute();
 804fd33:	e8 08 ff ff ff       	call   804fc40 <do_shr_l>
 804fd38:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fd3b:	8d 43 01             	lea    0x1(%ebx),%eax
 804fd3e:	5b                   	pop    %ebx
 804fd3f:	c3                   	ret    

0804fd40 <shr_rm_cl_l>:
make_instr_helper(rm_cl)
 804fd40:	53                   	push   %ebx
 804fd41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fd44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fd48:	83 c0 01             	add    $0x1,%eax
 804fd4b:	50                   	push   %eax
 804fd4c:	e8 bf d0 00 00       	call   805ce10 <decode_rm_cl_l>
 804fd51:	89 c3                	mov    %eax,%ebx
	execute();
 804fd53:	e8 e8 fe ff ff       	call   804fc40 <do_shr_l>
 804fd58:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fd5b:	8d 43 01             	lea    0x1(%ebx),%eax
 804fd5e:	5b                   	pop    %ebx
 804fd5f:	c3                   	ret    

0804fd60 <shr_rm_imm_l>:
make_instr_helper(rm_imm)
 804fd60:	53                   	push   %ebx
 804fd61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fd64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fd68:	83 c0 01             	add    $0x1,%eax
 804fd6b:	50                   	push   %eax
 804fd6c:	e8 ff d0 00 00       	call   805ce70 <decode_rm_imm_l>
 804fd71:	89 c3                	mov    %eax,%ebx
	execute();
 804fd73:	e8 c8 fe ff ff       	call   804fc40 <do_shr_l>
 804fd78:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fd7b:	8d 43 01             	lea    0x1(%ebx),%eax
 804fd7e:	5b                   	pop    %ebx
 804fd7f:	c3                   	ret    

0804fd80 <shr_rm_1_b>:
	 */

	print_asm_template2();
}

make_instr_helper(rm_1)
 804fd80:	53                   	push   %ebx
 804fd81:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fd84:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fd88:	83 c0 01             	add    $0x1,%eax
 804fd8b:	50                   	push   %eax
 804fd8c:	e8 cf c8 00 00       	call   805c660 <decode_rm_1_b>
 804fd91:	89 c3                	mov    %eax,%ebx
	execute();
 804fd93:	e8 88 fc ff ff       	call   804fa20 <do_shr_b>
 804fd98:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fd9b:	8d 43 01             	lea    0x1(%ebx),%eax
 804fd9e:	5b                   	pop    %ebx
 804fd9f:	c3                   	ret    

0804fda0 <shr_rm_cl_b>:
make_instr_helper(rm_cl)
 804fda0:	53                   	push   %ebx
 804fda1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fda4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fda8:	83 c0 01             	add    $0x1,%eax
 804fdab:	50                   	push   %eax
 804fdac:	e8 ff c8 00 00       	call   805c6b0 <decode_rm_cl_b>
 804fdb1:	89 c3                	mov    %eax,%ebx
	execute();
 804fdb3:	e8 68 fc ff ff       	call   804fa20 <do_shr_b>
 804fdb8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fdbb:	8d 43 01             	lea    0x1(%ebx),%eax
 804fdbe:	5b                   	pop    %ebx
 804fdbf:	c3                   	ret    

0804fdc0 <shr_rm_imm_b>:
make_instr_helper(rm_imm)
 804fdc0:	53                   	push   %ebx
 804fdc1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fdc4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fdc8:	83 c0 01             	add    $0x1,%eax
 804fdcb:	50                   	push   %eax
 804fdcc:	e8 3f c9 00 00       	call   805c710 <decode_rm_imm_b>
 804fdd1:	89 c3                	mov    %eax,%ebx
	execute();
 804fdd3:	e8 48 fc ff ff       	call   804fa20 <do_shr_b>
 804fdd8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 804fddb:	8d 43 01             	lea    0x1(%ebx),%eax
 804fdde:	5b                   	pop    %ebx
 804fddf:	c3                   	ret    

0804fde0 <shr_rm_1_v>:
#define DATA_BYTE 4
#include "shr-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */
make_helper_v(shr_rm_1)
 804fde0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804fde7:	8b 54 24 04          	mov    0x4(%esp),%edx
 804fdeb:	b8 e0 fb 04 08       	mov    $0x804fbe0,%eax
 804fdf0:	75 05                	jne    804fdf7 <shr_rm_1_v+0x17>
 804fdf2:	b8 20 fd 04 08       	mov    $0x804fd20,%eax
 804fdf7:	89 54 24 04          	mov    %edx,0x4(%esp)
 804fdfb:	ff e0                	jmp    *%eax
 804fdfd:	8d 76 00             	lea    0x0(%esi),%esi

0804fe00 <shr_rm_cl_v>:
make_helper_v(shr_rm_cl)
 804fe00:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804fe07:	8b 54 24 04          	mov    0x4(%esp),%edx
 804fe0b:	b8 00 fc 04 08       	mov    $0x804fc00,%eax
 804fe10:	75 05                	jne    804fe17 <shr_rm_cl_v+0x17>
 804fe12:	b8 40 fd 04 08       	mov    $0x804fd40,%eax
 804fe17:	89 54 24 04          	mov    %edx,0x4(%esp)
 804fe1b:	ff e0                	jmp    *%eax
 804fe1d:	8d 76 00             	lea    0x0(%esi),%esi

0804fe20 <shr_rm_imm_v>:
make_helper_v(shr_rm_imm)
 804fe20:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 804fe27:	8b 54 24 04          	mov    0x4(%esp),%edx
 804fe2b:	b8 20 fc 04 08       	mov    $0x804fc20,%eax
 804fe30:	75 05                	jne    804fe37 <shr_rm_imm_v+0x17>
 804fe32:	b8 60 fd 04 08       	mov    $0x804fd60,%eax
 804fe37:	89 54 24 04          	mov    %edx,0x4(%esp)
 804fe3b:	ff e0                	jmp    *%eax
 804fe3d:	66 90                	xchg   %ax,%ax
 804fe3f:	90                   	nop

0804fe40 <not_rm_l>:
	DATA_TYPE result = ~op_src->val;
	OPERAND_W(op_src, result);
	print_asm_template1();
}

make_instr_helper(rm)
 804fe40:	53                   	push   %ebx
 804fe41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804fe44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804fe48:	83 c0 01             	add    $0x1,%eax
 804fe4b:	50                   	push   %eax
 804fe4c:	e8 df ce 00 00       	call   805cd30 <decode_rm_l>
 804fe51:	89 c3                	mov    %eax,%ebx

#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
	OPERAND_W(op_src, result);
 804fe53:	58                   	pop    %eax
 804fe54:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
 804fe55:	8b 15 14 af 0f 10    	mov    0x100faf14,%edx
 804fe5b:	f7 d2                	not    %edx
	OPERAND_W(op_src, result);
 804fe5d:	52                   	push   %edx
 804fe5e:	68 08 af 0f 10       	push   $0x100faf08
 804fe63:	e8 38 d0 00 00       	call   805cea0 <write_operand_l>
	print_asm_template1();
 804fe68:	68 18 af 0f 10       	push   $0x100faf18
 804fe6d:	68 66 0f 06 08       	push   $0x8060f66
 804fe72:	6a 50                	push   $0x50
 804fe74:	68 00 8a 0c 08       	push   $0x80c8a00
 804fe79:	e8 82 8c ff ff       	call   8048b00 <snprintf@plt>
 804fe7e:	83 c4 20             	add    $0x20,%esp
 804fe81:	83 f8 4f             	cmp    $0x4f,%eax
 804fe84:	7f 0a                	jg     804fe90 <not_rm_l+0x50>
}

make_instr_helper(rm)
 804fe86:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804fe89:	8d 43 01             	lea    0x1(%ebx),%eax
 804fe8c:	5b                   	pop    %ebx
 804fe8d:	c3                   	ret    
 804fe8e:	66 90                	xchg   %ax,%ax
#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
	OPERAND_W(op_src, result);
	print_asm_template1();
 804fe90:	83 ec 0c             	sub    $0xc,%esp
 804fe93:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804fe99:	e8 c2 8a ff ff       	call   8048960 <fflush@plt>
 804fe9e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804fea4:	6a 07                	push   $0x7
 804fea6:	6a 01                	push   $0x1
 804fea8:	68 92 e8 05 08       	push   $0x805e892
 804fead:	e8 5e 8b ff ff       	call   8048a10 <fwrite@plt>
 804feb2:	83 c4 20             	add    $0x20,%esp
 804feb5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804febb:	6a 10                	push   $0x10
 804febd:	6a 01                	push   $0x1
 804febf:	68 b4 f3 05 08       	push   $0x805f3b4
 804fec4:	e8 47 8b ff ff       	call   8048a10 <fwrite@plt>
 804fec9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804fecf:	6a 05                	push   $0x5
 804fed1:	6a 01                	push   $0x1
 804fed3:	68 42 f3 05 08       	push   $0x805f342
 804fed8:	e8 33 8b ff ff       	call   8048a10 <fwrite@plt>
 804fedd:	83 c4 20             	add    $0x20,%esp
 804fee0:	68 18 af 0f 10       	push   $0x100faf18
 804fee5:	68 66 0f 06 08       	push   $0x8060f66
 804feea:	6a 50                	push   $0x50
 804feec:	68 00 8a 0c 08       	push   $0x80c8a00
 804fef1:	e8 0a 8c ff ff       	call   8048b00 <snprintf@plt>
 804fef6:	83 c4 10             	add    $0x10,%esp
 804fef9:	83 f8 4f             	cmp    $0x4f,%eax
 804fefc:	7e 88                	jle    804fe86 <not_rm_l+0x46>
 804fefe:	68 7e 10 06 08       	push   $0x806107e
 804ff03:	6a 08                	push   $0x8
 804ff05:	68 80 0f 06 08       	push   $0x8060f80
 804ff0a:	68 a8 0f 06 08       	push   $0x8060fa8
 804ff0f:	e8 9c 8c ff ff       	call   8048bb0 <__assert_fail@plt>
 804ff14:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 804ff1a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0804ff20 <not_rm_w>:
}

make_instr_helper(rm)
 804ff20:	53                   	push   %ebx
 804ff21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 804ff24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 804ff28:	83 c0 01             	add    $0x1,%eax
 804ff2b:	50                   	push   %eax
 804ff2c:	e8 2f ca 00 00       	call   805c960 <decode_rm_w>
 804ff31:	89 c3                	mov    %eax,%ebx

#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
	OPERAND_W(op_src, result);
 804ff33:	58                   	pop    %eax
 804ff34:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
 804ff35:	0f b7 15 14 af 0f 10 	movzwl 0x100faf14,%edx
 804ff3c:	f7 d2                	not    %edx
	OPERAND_W(op_src, result);
 804ff3e:	0f b7 d2             	movzwl %dx,%edx
 804ff41:	52                   	push   %edx
 804ff42:	68 08 af 0f 10       	push   $0x100faf08
 804ff47:	e8 84 cb 00 00       	call   805cad0 <write_operand_w>
	print_asm_template1();
 804ff4c:	68 18 af 0f 10       	push   $0x100faf18
 804ff51:	68 6e 0f 06 08       	push   $0x8060f6e
 804ff56:	6a 50                	push   $0x50
 804ff58:	68 00 8a 0c 08       	push   $0x80c8a00
 804ff5d:	e8 9e 8b ff ff       	call   8048b00 <snprintf@plt>
 804ff62:	83 c4 20             	add    $0x20,%esp
 804ff65:	83 f8 4f             	cmp    $0x4f,%eax
 804ff68:	7f 0e                	jg     804ff78 <not_rm_w+0x58>
}

make_instr_helper(rm)
 804ff6a:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 804ff6d:	8d 43 01             	lea    0x1(%ebx),%eax
 804ff70:	5b                   	pop    %ebx
 804ff71:	c3                   	ret    
 804ff72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
	OPERAND_W(op_src, result);
	print_asm_template1();
 804ff78:	83 ec 0c             	sub    $0xc,%esp
 804ff7b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 804ff81:	e8 da 89 ff ff       	call   8048960 <fflush@plt>
 804ff86:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ff8c:	6a 07                	push   $0x7
 804ff8e:	6a 01                	push   $0x1
 804ff90:	68 92 e8 05 08       	push   $0x805e892
 804ff95:	e8 76 8a ff ff       	call   8048a10 <fwrite@plt>
 804ff9a:	83 c4 20             	add    $0x20,%esp
 804ff9d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ffa3:	6a 10                	push   $0x10
 804ffa5:	6a 01                	push   $0x1
 804ffa7:	68 b4 f3 05 08       	push   $0x805f3b4
 804ffac:	e8 5f 8a ff ff       	call   8048a10 <fwrite@plt>
 804ffb1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 804ffb7:	6a 05                	push   $0x5
 804ffb9:	6a 01                	push   $0x1
 804ffbb:	68 42 f3 05 08       	push   $0x805f342
 804ffc0:	e8 4b 8a ff ff       	call   8048a10 <fwrite@plt>
 804ffc5:	83 c4 20             	add    $0x20,%esp
 804ffc8:	68 18 af 0f 10       	push   $0x100faf18
 804ffcd:	68 6e 0f 06 08       	push   $0x8060f6e
 804ffd2:	6a 50                	push   $0x50
 804ffd4:	68 00 8a 0c 08       	push   $0x80c8a00
 804ffd9:	e8 22 8b ff ff       	call   8048b00 <snprintf@plt>
 804ffde:	83 c4 10             	add    $0x10,%esp
 804ffe1:	83 f8 4f             	cmp    $0x4f,%eax
 804ffe4:	7e 84                	jle    804ff6a <not_rm_w+0x4a>
 804ffe6:	68 87 10 06 08       	push   $0x8061087
 804ffeb:	6a 08                	push   $0x8
 804ffed:	68 80 0f 06 08       	push   $0x8060f80
 804fff2:	68 f0 0f 06 08       	push   $0x8060ff0
 804fff7:	e8 b4 8b ff ff       	call   8048bb0 <__assert_fail@plt>
 804fffc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08050000 <not_rm_b>:
}

make_instr_helper(rm)
 8050000:	53                   	push   %ebx
 8050001:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050004:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050008:	83 c0 01             	add    $0x1,%eax
 805000b:	50                   	push   %eax
 805000c:	e8 1f c6 00 00       	call   805c630 <decode_rm_b>
 8050011:	89 c3                	mov    %eax,%ebx

#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
	OPERAND_W(op_src, result);
 8050013:	58                   	pop    %eax
 8050014:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
 8050015:	0f b6 15 14 af 0f 10 	movzbl 0x100faf14,%edx
 805001c:	f7 d2                	not    %edx
	OPERAND_W(op_src, result);
 805001e:	0f b6 d2             	movzbl %dl,%edx
 8050021:	52                   	push   %edx
 8050022:	68 08 af 0f 10       	push   $0x100faf08
 8050027:	e8 14 c7 00 00       	call   805c740 <write_operand_b>
	print_asm_template1();
 805002c:	68 18 af 0f 10       	push   $0x100faf18
 8050031:	68 76 0f 06 08       	push   $0x8060f76
 8050036:	6a 50                	push   $0x50
 8050038:	68 00 8a 0c 08       	push   $0x80c8a00
 805003d:	e8 be 8a ff ff       	call   8048b00 <snprintf@plt>
 8050042:	83 c4 20             	add    $0x20,%esp
 8050045:	83 f8 4f             	cmp    $0x4f,%eax
 8050048:	7f 0e                	jg     8050058 <not_rm_b+0x58>
}

make_instr_helper(rm)
 805004a:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805004d:	8d 43 01             	lea    0x1(%ebx),%eax
 8050050:	5b                   	pop    %ebx
 8050051:	c3                   	ret    
 8050052:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#define instr not

static void do_execute() {
	DATA_TYPE result = ~op_src->val;
	OPERAND_W(op_src, result);
	print_asm_template1();
 8050058:	83 ec 0c             	sub    $0xc,%esp
 805005b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8050061:	e8 fa 88 ff ff       	call   8048960 <fflush@plt>
 8050066:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805006c:	6a 07                	push   $0x7
 805006e:	6a 01                	push   $0x1
 8050070:	68 92 e8 05 08       	push   $0x805e892
 8050075:	e8 96 89 ff ff       	call   8048a10 <fwrite@plt>
 805007a:	83 c4 20             	add    $0x20,%esp
 805007d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050083:	6a 10                	push   $0x10
 8050085:	6a 01                	push   $0x1
 8050087:	68 b4 f3 05 08       	push   $0x805f3b4
 805008c:	e8 7f 89 ff ff       	call   8048a10 <fwrite@plt>
 8050091:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050097:	6a 05                	push   $0x5
 8050099:	6a 01                	push   $0x1
 805009b:	68 42 f3 05 08       	push   $0x805f342
 80500a0:	e8 6b 89 ff ff       	call   8048a10 <fwrite@plt>
 80500a5:	83 c4 20             	add    $0x20,%esp
 80500a8:	68 18 af 0f 10       	push   $0x100faf18
 80500ad:	68 76 0f 06 08       	push   $0x8060f76
 80500b2:	6a 50                	push   $0x50
 80500b4:	68 00 8a 0c 08       	push   $0x80c8a00
 80500b9:	e8 42 8a ff ff       	call   8048b00 <snprintf@plt>
 80500be:	83 c4 10             	add    $0x10,%esp
 80500c1:	83 f8 4f             	cmp    $0x4f,%eax
 80500c4:	7e 84                	jle    805004a <not_rm_b+0x4a>
 80500c6:	68 90 10 06 08       	push   $0x8061090
 80500cb:	6a 08                	push   $0x8
 80500cd:	68 80 0f 06 08       	push   $0x8060f80
 80500d2:	68 38 10 06 08       	push   $0x8061038
 80500d7:	e8 d4 8a ff ff       	call   8048bb0 <__assert_fail@plt>
 80500dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080500e0 <not_rm_v>:
#define DATA_BYTE 4
#include "not-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */
make_helper_v(not_rm)
 80500e0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80500e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80500eb:	b8 20 ff 04 08       	mov    $0x804ff20,%eax
 80500f0:	75 05                	jne    80500f7 <not_rm_v+0x17>
 80500f2:	b8 40 fe 04 08       	mov    $0x804fe40,%eax
 80500f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80500fb:	ff e0                	jmp    *%eax
 80500fd:	66 90                	xchg   %ax,%ax
 80500ff:	90                   	nop

08050100 <do_xor_b>:
#include "cpu/exec/template-start.h"

#define instr xor

static void do_execute () {
 8050100:	56                   	push   %esi
 8050101:	53                   	push   %ebx
 8050102:	83 ec 0c             	sub    $0xc,%esp
	DATA_TYPE result = op_dest->val ^ op_src->val;
 8050105:	a1 4c af 0f 10       	mov    0x100faf4c,%eax
 805010a:	32 05 14 af 0f 10    	xor    0x100faf14,%al
	OPERAND_W(op_dest, result);
 8050110:	0f b6 d8             	movzbl %al,%ebx
#include "cpu/exec/template-start.h"

#define instr xor

static void do_execute () {
	DATA_TYPE result = op_dest->val ^ op_src->val;
 8050113:	89 c6                	mov    %eax,%esi
	OPERAND_W(op_dest, result);
 8050115:	53                   	push   %ebx
 8050116:	68 40 af 0f 10       	push   $0x100faf40
 805011b:	e8 20 c6 00 00       	call   805c740 <write_operand_b>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 8050120:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
	cpu.ZF = !result;
 8050127:	89 f0                	mov    %esi,%eax
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 8050129:	89 f2                	mov    %esi,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 805012b:	80 25 e5 af 0f 10 f7 	andb   $0xf7,0x100fafe5
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 8050132:	83 e2 80             	and    $0xffffff80,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 8050135:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 805013c:	68 18 af 0f 10       	push   $0x100faf18
 8050141:	68 99 10 06 08       	push   $0x8061099
 8050146:	6a 50                	push   $0x50
 8050148:	68 00 8a 0c 08       	push   $0x80c8a00
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 805014d:	83 e1 3e             	and    $0x3e,%ecx
	cpu.ZF = !result;
 8050150:	84 c0                	test   %al,%al
 8050152:	0f 94 c0             	sete   %al
 8050155:	09 ca                	or     %ecx,%edx
 8050157:	c1 e0 06             	shl    $0x6,%eax
 805015a:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805015c:	89 d8                	mov    %ebx,%eax
 805015e:	c1 e8 04             	shr    $0x4,%eax
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 8050161:	83 e2 fb             	and    $0xfffffffb,%edx
	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 8050164:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 2) ^ pf;
 8050166:	89 d8                	mov    %ebx,%eax
 8050168:	c1 e8 02             	shr    $0x2,%eax
 805016b:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 805016d:	89 d8                	mov    %ebx,%eax
 805016f:	d1 e8                	shr    %eax
 8050171:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 8050173:	83 e3 01             	and    $0x1,%ebx
 8050176:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 805017d:	89 d3                	mov    %edx,%ebx
 805017f:	09 c3                	or     %eax,%ebx
 8050181:	88 1d e4 af 0f 10    	mov    %bl,0x100fafe4

	print_asm_template2();
 8050187:	e8 74 89 ff ff       	call   8048b00 <snprintf@plt>
 805018c:	83 c4 20             	add    $0x20,%esp
 805018f:	83 f8 4f             	cmp    $0x4f,%eax
 8050192:	7f 0c                	jg     80501a0 <do_xor_b+0xa0>
}
 8050194:	83 c4 04             	add    $0x4,%esp
 8050197:	5b                   	pop    %ebx
 8050198:	5e                   	pop    %esi
 8050199:	c3                   	ret    
 805019a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 80501a0:	83 ec 0c             	sub    $0xc,%esp
 80501a3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80501a9:	e8 b2 87 ff ff       	call   8048960 <fflush@plt>
 80501ae:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80501b4:	6a 07                	push   $0x7
 80501b6:	6a 01                	push   $0x1
 80501b8:	68 92 e8 05 08       	push   $0x805e892
 80501bd:	e8 4e 88 ff ff       	call   8048a10 <fwrite@plt>
 80501c2:	83 c4 20             	add    $0x20,%esp
 80501c5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80501cb:	6a 10                	push   $0x10
 80501cd:	6a 01                	push   $0x1
 80501cf:	68 b4 f3 05 08       	push   $0x805f3b4
 80501d4:	e8 37 88 ff ff       	call   8048a10 <fwrite@plt>
 80501d9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80501df:	6a 05                	push   $0x5
 80501e1:	6a 01                	push   $0x1
 80501e3:	68 42 f3 05 08       	push   $0x805f342
 80501e8:	e8 23 88 ff ff       	call   8048a10 <fwrite@plt>
 80501ed:	83 c4 14             	add    $0x14,%esp
 80501f0:	68 50 af 0f 10       	push   $0x100faf50
 80501f5:	68 18 af 0f 10       	push   $0x100faf18
 80501fa:	68 99 10 06 08       	push   $0x8061099
 80501ff:	6a 50                	push   $0x50
 8050201:	68 00 8a 0c 08       	push   $0x80c8a00
 8050206:	e8 f5 88 ff ff       	call   8048b00 <snprintf@plt>
 805020b:	83 c4 20             	add    $0x20,%esp
 805020e:	83 f8 4f             	cmp    $0x4f,%eax
 8050211:	7e 81                	jle    8050194 <do_xor_b+0x94>
 8050213:	68 21 12 06 08       	push   $0x8061221
 8050218:	6a 13                	push   $0x13
 805021a:	68 bc 10 06 08       	push   $0x80610bc
 805021f:	68 e4 10 06 08       	push   $0x80610e4
 8050224:	e8 87 89 ff ff       	call   8048bb0 <__assert_fail@plt>
 8050229:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08050230 <do_xor_w>:
#include "cpu/exec/template-start.h"

#define instr xor

static void do_execute () {
 8050230:	53                   	push   %ebx
 8050231:	83 ec 10             	sub    $0x10,%esp
	DATA_TYPE result = op_dest->val ^ op_src->val;
 8050234:	8b 1d 4c af 0f 10    	mov    0x100faf4c,%ebx
 805023a:	66 33 1d 14 af 0f 10 	xor    0x100faf14,%bx
	OPERAND_W(op_dest, result);
 8050241:	0f b7 c3             	movzwl %bx,%eax
 8050244:	50                   	push   %eax
 8050245:	68 40 af 0f 10       	push   $0x100faf40
 805024a:	e8 81 c8 00 00       	call   805cad0 <write_operand_w>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 805024f:	89 da                	mov    %ebx,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 8050251:	80 25 e5 af 0f 10 f7 	andb   $0xf7,0x100fafe5
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 8050258:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 805025f:	66 c1 ea 0f          	shr    $0xf,%dx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 8050263:	68 18 af 0f 10       	push   $0x100faf18
 8050268:	68 a4 10 06 08       	push   $0x80610a4
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 805026d:	89 d0                	mov    %edx,%eax
 805026f:	0f b6 15 e4 af 0f 10 	movzbl 0x100fafe4,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 8050276:	6a 50                	push   $0x50
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 8050278:	c1 e0 07             	shl    $0x7,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 805027b:	68 00 8a 0c 08       	push   $0x80c8a00
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 8050280:	83 e2 3e             	and    $0x3e,%edx
	cpu.ZF = !result;
 8050283:	66 85 db             	test   %bx,%bx
	uint32_t pf = (result & 255);
 8050286:	0f b6 db             	movzbl %bl,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 8050289:	0f 94 c1             	sete   %cl
 805028c:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805028e:	89 d8                	mov    %ebx,%eax
 8050290:	c1 e8 04             	shr    $0x4,%eax
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 8050293:	c1 e1 06             	shl    $0x6,%ecx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 8050296:	31 c3                	xor    %eax,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 8050298:	09 ca                	or     %ecx,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 805029a:	89 d8                	mov    %ebx,%eax
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 805029c:	83 e2 fb             	and    $0xfffffffb,%edx
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 805029f:	c1 e8 02             	shr    $0x2,%eax
 80502a2:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 80502a4:	89 d8                	mov    %ebx,%eax
 80502a6:	d1 e8                	shr    %eax
 80502a8:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 80502aa:	83 e3 01             	and    $0x1,%ebx
 80502ad:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 80502b4:	89 d3                	mov    %edx,%ebx
 80502b6:	09 c3                	or     %eax,%ebx
 80502b8:	88 1d e4 af 0f 10    	mov    %bl,0x100fafe4

	print_asm_template2();
 80502be:	e8 3d 88 ff ff       	call   8048b00 <snprintf@plt>
 80502c3:	83 c4 20             	add    $0x20,%esp
 80502c6:	83 f8 4f             	cmp    $0x4f,%eax
 80502c9:	7f 05                	jg     80502d0 <do_xor_w+0xa0>
}
 80502cb:	83 c4 08             	add    $0x8,%esp
 80502ce:	5b                   	pop    %ebx
 80502cf:	c3                   	ret    
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 80502d0:	83 ec 0c             	sub    $0xc,%esp
 80502d3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80502d9:	e8 82 86 ff ff       	call   8048960 <fflush@plt>
 80502de:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80502e4:	6a 07                	push   $0x7
 80502e6:	6a 01                	push   $0x1
 80502e8:	68 92 e8 05 08       	push   $0x805e892
 80502ed:	e8 1e 87 ff ff       	call   8048a10 <fwrite@plt>
 80502f2:	83 c4 20             	add    $0x20,%esp
 80502f5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80502fb:	6a 10                	push   $0x10
 80502fd:	6a 01                	push   $0x1
 80502ff:	68 b4 f3 05 08       	push   $0x805f3b4
 8050304:	e8 07 87 ff ff       	call   8048a10 <fwrite@plt>
 8050309:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805030f:	6a 05                	push   $0x5
 8050311:	6a 01                	push   $0x1
 8050313:	68 42 f3 05 08       	push   $0x805f342
 8050318:	e8 f3 86 ff ff       	call   8048a10 <fwrite@plt>
 805031d:	83 c4 14             	add    $0x14,%esp
 8050320:	68 50 af 0f 10       	push   $0x100faf50
 8050325:	68 18 af 0f 10       	push   $0x100faf18
 805032a:	68 a4 10 06 08       	push   $0x80610a4
 805032f:	6a 50                	push   $0x50
 8050331:	68 00 8a 0c 08       	push   $0x80c8a00
 8050336:	e8 c5 87 ff ff       	call   8048b00 <snprintf@plt>
 805033b:	83 c4 20             	add    $0x20,%esp
 805033e:	83 f8 4f             	cmp    $0x4f,%eax
 8050341:	7e 88                	jle    80502cb <do_xor_w+0x9b>
 8050343:	68 18 12 06 08       	push   $0x8061218
 8050348:	6a 13                	push   $0x13
 805034a:	68 bc 10 06 08       	push   $0x80610bc
 805034f:	68 48 11 06 08       	push   $0x8061148
 8050354:	e8 57 88 ff ff       	call   8048bb0 <__assert_fail@plt>
 8050359:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08050360 <xor_i2a_w>:
}

make_instr_helper(i2a)
 8050360:	53                   	push   %ebx
 8050361:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050364:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050368:	83 c0 01             	add    $0x1,%eax
 805036b:	50                   	push   %eax
 805036c:	e8 1f c5 00 00       	call   805c890 <decode_i2a_w>
 8050371:	89 c3                	mov    %eax,%ebx
	execute();
 8050373:	e8 b8 fe ff ff       	call   8050230 <do_xor_w>
 8050378:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805037b:	8d 43 01             	lea    0x1(%ebx),%eax
 805037e:	5b                   	pop    %ebx
 805037f:	c3                   	ret    

08050380 <xor_i2rm_w>:
make_instr_helper(i2rm)
 8050380:	53                   	push   %ebx
 8050381:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050384:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050388:	83 c0 01             	add    $0x1,%eax
 805038b:	50                   	push   %eax
 805038c:	e8 7f c5 00 00       	call   805c910 <decode_i2rm_w>
 8050391:	89 c3                	mov    %eax,%ebx
	execute();
 8050393:	e8 98 fe ff ff       	call   8050230 <do_xor_w>
 8050398:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805039b:	8d 43 01             	lea    0x1(%ebx),%eax
 805039e:	5b                   	pop    %ebx
 805039f:	c3                   	ret    

080503a0 <xor_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 80503a0:	53                   	push   %ebx
 80503a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80503a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80503a8:	83 c0 01             	add    $0x1,%eax
 80503ab:	50                   	push   %eax
 80503ac:	e8 df c5 00 00       	call   805c990 <decode_si2rm_w>
 80503b1:	89 c3                	mov    %eax,%ebx
	execute();
 80503b3:	e8 78 fe ff ff       	call   8050230 <do_xor_w>
 80503b8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80503bb:	8d 43 01             	lea    0x1(%ebx),%eax
 80503be:	5b                   	pop    %ebx
 80503bf:	c3                   	ret    

080503c0 <xor_r2rm_w>:
#endif
make_instr_helper(r2rm)
 80503c0:	53                   	push   %ebx
 80503c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80503c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80503c8:	83 c0 01             	add    $0x1,%eax
 80503cb:	50                   	push   %eax
 80503cc:	e8 7f c4 00 00       	call   805c850 <decode_r2rm_w>
 80503d1:	89 c3                	mov    %eax,%ebx
	execute();
 80503d3:	e8 58 fe ff ff       	call   8050230 <do_xor_w>
 80503d8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80503db:	8d 43 01             	lea    0x1(%ebx),%eax
 80503de:	5b                   	pop    %ebx
 80503df:	c3                   	ret    

080503e0 <xor_rm2r_w>:
make_instr_helper(rm2r)
 80503e0:	53                   	push   %ebx
 80503e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80503e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80503e8:	83 c0 01             	add    $0x1,%eax
 80503eb:	50                   	push   %eax
 80503ec:	e8 7f c4 00 00       	call   805c870 <decode_rm2r_w>
 80503f1:	89 c3                	mov    %eax,%ebx
	execute();
 80503f3:	e8 38 fe ff ff       	call   8050230 <do_xor_w>
 80503f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80503fb:	8d 43 01             	lea    0x1(%ebx),%eax
 80503fe:	5b                   	pop    %ebx
 80503ff:	c3                   	ret    

08050400 <do_xor_l>:
#include "cpu/exec/template-start.h"

#define instr xor

static void do_execute () {
 8050400:	53                   	push   %ebx
 8050401:	83 ec 10             	sub    $0x10,%esp
	DATA_TYPE result = op_dest->val ^ op_src->val;
 8050404:	8b 1d 14 af 0f 10    	mov    0x100faf14,%ebx
 805040a:	33 1d 4c af 0f 10    	xor    0x100faf4c,%ebx
	OPERAND_W(op_dest, result);
 8050410:	53                   	push   %ebx
 8050411:	68 40 af 0f 10       	push   $0x100faf40
 8050416:	e8 85 ca 00 00       	call   805cea0 <write_operand_l>

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 805041b:	89 da                	mov    %ebx,%edx
static void do_execute () {
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
 805041d:	80 25 e5 af 0f 10 f7 	andb   $0xf7,0x100fafe5
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 8050424:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 805042b:	c1 ea 1f             	shr    $0x1f,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 805042e:	68 18 af 0f 10       	push   $0x100faf18
 8050433:	68 af 10 06 08       	push   $0x80610af
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 8050438:	89 d0                	mov    %edx,%eax
 805043a:	0f b6 15 e4 af 0f 10 	movzbl 0x100fafe4,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 8050441:	6a 50                	push   $0x50
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 8050443:	c1 e0 07             	shl    $0x7,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 8050446:	68 00 8a 0c 08       	push   $0x80c8a00
	DATA_TYPE result = op_dest->val ^ op_src->val;
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
 805044b:	83 e2 3e             	and    $0x3e,%edx
	cpu.ZF = !result;
 805044e:	85 db                	test   %ebx,%ebx
	uint32_t pf = (result & 255);
 8050450:	0f b6 db             	movzbl %bl,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 8050453:	0f 94 c1             	sete   %cl
 8050456:	09 c2                	or     %eax,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 8050458:	89 d8                	mov    %ebx,%eax
 805045a:	c1 e8 04             	shr    $0x4,%eax
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 805045d:	c1 e1 06             	shl    $0x6,%ecx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 8050460:	31 c3                	xor    %eax,%ebx
	OPERAND_W(op_dest, result);

	/* TODO: Update EFLAGS. */
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
 8050462:	09 ca                	or     %ecx,%edx
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 8050464:	89 d8                	mov    %ebx,%eax
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 8050466:	83 e2 fb             	and    $0xfffffffb,%edx
	cpu.CF = cpu.OF = 0;
	cpu.SF = (result >> ((DATA_BYTE << 3) - 1)) & 1;
	cpu.ZF = !result;
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 8050469:	c1 e8 02             	shr    $0x2,%eax
 805046c:	31 c3                	xor    %eax,%ebx
	pf = (pf >> 1) ^ pf;
 805046e:	89 d8                	mov    %ebx,%eax
 8050470:	d1 e8                	shr    %eax
 8050472:	31 c3                	xor    %eax,%ebx
	cpu.PF = pf & 1;
 8050474:	83 e3 01             	and    $0x1,%ebx
 8050477:	8d 04 9d 00 00 00 00 	lea    0x0(,%ebx,4),%eax
 805047e:	89 d3                	mov    %edx,%ebx
 8050480:	09 c3                	or     %eax,%ebx
 8050482:	88 1d e4 af 0f 10    	mov    %bl,0x100fafe4

	print_asm_template2();
 8050488:	e8 73 86 ff ff       	call   8048b00 <snprintf@plt>
 805048d:	83 c4 20             	add    $0x20,%esp
 8050490:	83 f8 4f             	cmp    $0x4f,%eax
 8050493:	7f 0b                	jg     80504a0 <do_xor_l+0xa0>
}
 8050495:	83 c4 08             	add    $0x8,%esp
 8050498:	5b                   	pop    %ebx
 8050499:	c3                   	ret    
 805049a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;

	print_asm_template2();
 80504a0:	83 ec 0c             	sub    $0xc,%esp
 80504a3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80504a9:	e8 b2 84 ff ff       	call   8048960 <fflush@plt>
 80504ae:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80504b4:	6a 07                	push   $0x7
 80504b6:	6a 01                	push   $0x1
 80504b8:	68 92 e8 05 08       	push   $0x805e892
 80504bd:	e8 4e 85 ff ff       	call   8048a10 <fwrite@plt>
 80504c2:	83 c4 20             	add    $0x20,%esp
 80504c5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80504cb:	6a 10                	push   $0x10
 80504cd:	6a 01                	push   $0x1
 80504cf:	68 b4 f3 05 08       	push   $0x805f3b4
 80504d4:	e8 37 85 ff ff       	call   8048a10 <fwrite@plt>
 80504d9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80504df:	6a 05                	push   $0x5
 80504e1:	6a 01                	push   $0x1
 80504e3:	68 42 f3 05 08       	push   $0x805f342
 80504e8:	e8 23 85 ff ff       	call   8048a10 <fwrite@plt>
 80504ed:	83 c4 14             	add    $0x14,%esp
 80504f0:	68 50 af 0f 10       	push   $0x100faf50
 80504f5:	68 18 af 0f 10       	push   $0x100faf18
 80504fa:	68 af 10 06 08       	push   $0x80610af
 80504ff:	6a 50                	push   $0x50
 8050501:	68 00 8a 0c 08       	push   $0x80c8a00
 8050506:	e8 f5 85 ff ff       	call   8048b00 <snprintf@plt>
 805050b:	83 c4 20             	add    $0x20,%esp
 805050e:	83 f8 4f             	cmp    $0x4f,%eax
 8050511:	7e 82                	jle    8050495 <do_xor_l+0x95>
 8050513:	68 0f 12 06 08       	push   $0x806120f
 8050518:	6a 13                	push   $0x13
 805051a:	68 bc 10 06 08       	push   $0x80610bc
 805051f:	68 ac 11 06 08       	push   $0x80611ac
 8050524:	e8 87 86 ff ff       	call   8048bb0 <__assert_fail@plt>
 8050529:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08050530 <xor_i2a_l>:
}

make_instr_helper(i2a)
 8050530:	53                   	push   %ebx
 8050531:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050534:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050538:	83 c0 01             	add    $0x1,%eax
 805053b:	50                   	push   %eax
 805053c:	e8 1f c7 00 00       	call   805cc60 <decode_i2a_l>
 8050541:	89 c3                	mov    %eax,%ebx
	execute();
 8050543:	e8 b8 fe ff ff       	call   8050400 <do_xor_l>
 8050548:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805054b:	8d 43 01             	lea    0x1(%ebx),%eax
 805054e:	5b                   	pop    %ebx
 805054f:	c3                   	ret    

08050550 <xor_i2rm_l>:
make_instr_helper(i2rm)
 8050550:	53                   	push   %ebx
 8050551:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050554:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050558:	83 c0 01             	add    $0x1,%eax
 805055b:	50                   	push   %eax
 805055c:	e8 7f c7 00 00       	call   805cce0 <decode_i2rm_l>
 8050561:	89 c3                	mov    %eax,%ebx
	execute();
 8050563:	e8 98 fe ff ff       	call   8050400 <do_xor_l>
 8050568:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805056b:	8d 43 01             	lea    0x1(%ebx),%eax
 805056e:	5b                   	pop    %ebx
 805056f:	c3                   	ret    

08050570 <xor_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8050570:	53                   	push   %ebx
 8050571:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050574:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050578:	83 c0 01             	add    $0x1,%eax
 805057b:	50                   	push   %eax
 805057c:	e8 df c7 00 00       	call   805cd60 <decode_si2rm_l>
 8050581:	89 c3                	mov    %eax,%ebx
	execute();
 8050583:	e8 78 fe ff ff       	call   8050400 <do_xor_l>
 8050588:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805058b:	8d 43 01             	lea    0x1(%ebx),%eax
 805058e:	5b                   	pop    %ebx
 805058f:	c3                   	ret    

08050590 <xor_r2rm_l>:
#endif
make_instr_helper(r2rm)
 8050590:	53                   	push   %ebx
 8050591:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050594:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050598:	83 c0 01             	add    $0x1,%eax
 805059b:	50                   	push   %eax
 805059c:	e8 7f c6 00 00       	call   805cc20 <decode_r2rm_l>
 80505a1:	89 c3                	mov    %eax,%ebx
	execute();
 80505a3:	e8 58 fe ff ff       	call   8050400 <do_xor_l>
 80505a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80505ab:	8d 43 01             	lea    0x1(%ebx),%eax
 80505ae:	5b                   	pop    %ebx
 80505af:	c3                   	ret    

080505b0 <xor_rm2r_l>:
make_instr_helper(rm2r)
 80505b0:	53                   	push   %ebx
 80505b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80505b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80505b8:	83 c0 01             	add    $0x1,%eax
 80505bb:	50                   	push   %eax
 80505bc:	e8 7f c6 00 00       	call   805cc40 <decode_rm2r_l>
 80505c1:	89 c3                	mov    %eax,%ebx
	execute();
 80505c3:	e8 38 fe ff ff       	call   8050400 <do_xor_l>
 80505c8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80505cb:	8d 43 01             	lea    0x1(%ebx),%eax
 80505ce:	5b                   	pop    %ebx
 80505cf:	c3                   	ret    

080505d0 <xor_i2a_b>:
	cpu.PF = pf & 1;

	print_asm_template2();
}

make_instr_helper(i2a)
 80505d0:	53                   	push   %ebx
 80505d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80505d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80505d8:	83 c0 01             	add    $0x1,%eax
 80505db:	50                   	push   %eax
 80505dc:	e8 7f bf 00 00       	call   805c560 <decode_i2a_b>
 80505e1:	89 c3                	mov    %eax,%ebx
	execute();
 80505e3:	e8 18 fb ff ff       	call   8050100 <do_xor_b>
 80505e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80505eb:	8d 43 01             	lea    0x1(%ebx),%eax
 80505ee:	5b                   	pop    %ebx
 80505ef:	c3                   	ret    

080505f0 <xor_i2rm_b>:
make_instr_helper(i2rm)
 80505f0:	53                   	push   %ebx
 80505f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80505f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80505f8:	83 c0 01             	add    $0x1,%eax
 80505fb:	50                   	push   %eax
 80505fc:	e8 df bf 00 00       	call   805c5e0 <decode_i2rm_b>
 8050601:	89 c3                	mov    %eax,%ebx
	execute();
 8050603:	e8 f8 fa ff ff       	call   8050100 <do_xor_b>
 8050608:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805060b:	8d 43 01             	lea    0x1(%ebx),%eax
 805060e:	5b                   	pop    %ebx
 805060f:	c3                   	ret    

08050610 <xor_r2rm_b>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
#endif
make_instr_helper(r2rm)
 8050610:	53                   	push   %ebx
 8050611:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050614:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050618:	83 c0 01             	add    $0x1,%eax
 805061b:	50                   	push   %eax
 805061c:	e8 ff be 00 00       	call   805c520 <decode_r2rm_b>
 8050621:	89 c3                	mov    %eax,%ebx
	execute();
 8050623:	e8 d8 fa ff ff       	call   8050100 <do_xor_b>
 8050628:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805062b:	8d 43 01             	lea    0x1(%ebx),%eax
 805062e:	5b                   	pop    %ebx
 805062f:	c3                   	ret    

08050630 <xor_rm2r_b>:
make_instr_helper(rm2r)
 8050630:	53                   	push   %ebx
 8050631:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050634:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050638:	83 c0 01             	add    $0x1,%eax
 805063b:	50                   	push   %eax
 805063c:	e8 ff be 00 00       	call   805c540 <decode_rm2r_b>
 8050641:	89 c3                	mov    %eax,%ebx
	execute();
 8050643:	e8 b8 fa ff ff       	call   8050100 <do_xor_b>
 8050648:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805064b:	8d 43 01             	lea    0x1(%ebx),%eax
 805064e:	5b                   	pop    %ebx
 805064f:	c3                   	ret    

08050650 <xor_i2a_v>:
#include "xor-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(xor_i2a)
 8050650:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8050657:	8b 54 24 04          	mov    0x4(%esp),%edx
 805065b:	b8 60 03 05 08       	mov    $0x8050360,%eax
 8050660:	75 05                	jne    8050667 <xor_i2a_v+0x17>
 8050662:	b8 30 05 05 08       	mov    $0x8050530,%eax
 8050667:	89 54 24 04          	mov    %edx,0x4(%esp)
 805066b:	ff e0                	jmp    *%eax
 805066d:	8d 76 00             	lea    0x0(%esi),%esi

08050670 <xor_i2rm_v>:
make_helper_v(xor_i2rm)
 8050670:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8050677:	8b 54 24 04          	mov    0x4(%esp),%edx
 805067b:	b8 80 03 05 08       	mov    $0x8050380,%eax
 8050680:	75 05                	jne    8050687 <xor_i2rm_v+0x17>
 8050682:	b8 50 05 05 08       	mov    $0x8050550,%eax
 8050687:	89 54 24 04          	mov    %edx,0x4(%esp)
 805068b:	ff e0                	jmp    *%eax
 805068d:	8d 76 00             	lea    0x0(%esi),%esi

08050690 <xor_si2rm_v>:
make_helper_v(xor_si2rm)
 8050690:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8050697:	8b 54 24 04          	mov    0x4(%esp),%edx
 805069b:	b8 a0 03 05 08       	mov    $0x80503a0,%eax
 80506a0:	75 05                	jne    80506a7 <xor_si2rm_v+0x17>
 80506a2:	b8 70 05 05 08       	mov    $0x8050570,%eax
 80506a7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80506ab:	ff e0                	jmp    *%eax
 80506ad:	8d 76 00             	lea    0x0(%esi),%esi

080506b0 <xor_r2rm_v>:
make_helper_v(xor_r2rm)
 80506b0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80506b7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80506bb:	b8 c0 03 05 08       	mov    $0x80503c0,%eax
 80506c0:	75 05                	jne    80506c7 <xor_r2rm_v+0x17>
 80506c2:	b8 90 05 05 08       	mov    $0x8050590,%eax
 80506c7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80506cb:	ff e0                	jmp    *%eax
 80506cd:	8d 76 00             	lea    0x0(%esi),%esi

080506d0 <xor_rm2r_v>:
make_helper_v(xor_rm2r)
 80506d0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80506d7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80506db:	b8 e0 03 05 08       	mov    $0x80503e0,%eax
 80506e0:	75 05                	jne    80506e7 <xor_rm2r_v+0x17>
 80506e2:	b8 b0 05 05 08       	mov    $0x80505b0,%eax
 80506e7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80506eb:	ff e0                	jmp    *%eax
 80506ed:	66 90                	xchg   %ax,%ax
 80506ef:	90                   	nop

080506f0 <rep>:
#include "cpu/exec/helper.h"

make_helper(exec);

make_helper(rep) {
 80506f0:	57                   	push   %edi
 80506f1:	56                   	push   %esi
 80506f2:	53                   	push   %ebx
 80506f3:	83 ec 58             	sub    $0x58,%esp
 80506f6:	8b 7c 24 68          	mov    0x68(%esp),%edi

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 80506fa:	6a 01                	push   $0x1
	int len;
	int count = 0;
	if(instr_fetch(eip + 1, 1) == 0xc3) {
 80506fc:	8d 77 01             	lea    0x1(%edi),%esi
 80506ff:	56                   	push   %esi
 8050700:	e8 4b a8 ff ff       	call   804af50 <swaddr_read>
 8050705:	83 c4 10             	add    $0x10,%esp
 8050708:	3d c3 00 00 00       	cmp    $0xc3,%eax
 805070d:	0f 84 d4 00 00 00    	je     80507e7 <rep+0xf7>
 8050713:	8b 15 c4 af 0f 10    	mov    0x100fafc4,%edx
 8050719:	31 db                	xor    %ebx,%ebx
 805071b:	90                   	nop
 805071c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		/* repz ret */
		exec(eip + 1);
		len = 0;
	}
	else {
		while(cpu.ecx) {
 8050720:	85 d2                	test   %edx,%edx
 8050722:	74 76                	je     805079a <rep+0xaa>
			exec(eip + 1);
 8050724:	83 ec 0c             	sub    $0xc,%esp
		//	if(ops_decoded.opcode == 0) {
		//		return 2;
		//	}
		//	printf("eip = %u, opcode = %u\n", eip, ops_decoded.opcode);
			count ++;
 8050727:	83 c3 01             	add    $0x1,%ebx
		exec(eip + 1);
		len = 0;
	}
	else {
		while(cpu.ecx) {
			exec(eip + 1);
 805072a:	56                   	push   %esi
 805072b:	e8 20 c4 ff ff       	call   804cb50 <exec>
		//	if(ops_decoded.opcode == 0) {
		//		return 2;
		//	}
		//	printf("eip = %u, opcode = %u\n", eip, ops_decoded.opcode);
			count ++;
			cpu.ecx --;
 8050730:	a1 c4 af 0f 10       	mov    0x100fafc4,%eax
			assert(ops_decoded.opcode == 0xa4	// movsb
 8050735:	83 c4 10             	add    $0x10,%esp
		//	if(ops_decoded.opcode == 0) {
		//		return 2;
		//	}
		//	printf("eip = %u, opcode = %u\n", eip, ops_decoded.opcode);
			count ++;
			cpu.ecx --;
 8050738:	8d 50 ff             	lea    -0x1(%eax),%edx
			assert(ops_decoded.opcode == 0xa4	// movsb
 805073b:	a1 00 af 0f 10       	mov    0x100faf00,%eax
		//	if(ops_decoded.opcode == 0) {
		//		return 2;
		//	}
		//	printf("eip = %u, opcode = %u\n", eip, ops_decoded.opcode);
			count ++;
			cpu.ecx --;
 8050740:	89 15 c4 af 0f 10    	mov    %edx,0x100fafc4
			assert(ops_decoded.opcode == 0xa4	// movsb
 8050746:	89 c1                	mov    %eax,%ecx
 8050748:	83 e1 fb             	and    $0xfffffffb,%ecx
 805074b:	81 e9 aa 00 00 00    	sub    $0xaa,%ecx
 8050751:	83 f9 01             	cmp    $0x1,%ecx
 8050754:	76 0f                	jbe    8050765 <rep+0x75>
 8050756:	8d 88 5c ff ff ff    	lea    -0xa4(%eax),%ecx
 805075c:	83 f9 03             	cmp    $0x3,%ecx
 805075f:	0f 87 97 00 00 00    	ja     80507fc <rep+0x10c>
				);

			/* TODO: Jump out of the while loop if necessary. */
			if(ops_decoded.opcode == 0xa6		// cmpsb
				|| ops_decoded.opcode == 0xa7	// cmpsw
				|| ops_decoded.opcode == 0xae	// scasb
 8050765:	83 e0 f7             	and    $0xfffffff7,%eax
 8050768:	2d a6 00 00 00       	sub    $0xa6,%eax
				|| ops_decoded.opcode == 0xaf	// scasw
 805076d:	83 f8 01             	cmp    $0x1,%eax
 8050770:	77 ae                	ja     8050720 <rep+0x30>
			  ) {
				if(cpu.ZF) {
 8050772:	f6 05 e4 af 0f 10 40 	testb  $0x40,0x100fafe4
 8050779:	74 55                	je     80507d0 <rep+0xe0>
 805077b:	83 ec 08             	sub    $0x8,%esp
 805077e:	6a 01                	push   $0x1
 8050780:	57                   	push   %edi
 8050781:	e8 ca a7 ff ff       	call   804af50 <swaddr_read>
					if(instr_fetch(eip, 1) == 0xf3) break;
 8050786:	83 c4 10             	add    $0x10,%esp
 8050789:	3d f3 00 00 00       	cmp    $0xf3,%eax
 805078e:	74 0a                	je     805079a <rep+0xaa>
 8050790:	8b 15 c4 af 0f 10    	mov    0x100fafc4,%edx
		/* repz ret */
		exec(eip + 1);
		len = 0;
	}
	else {
		while(cpu.ecx) {
 8050796:	85 d2                	test   %edx,%edx
 8050798:	75 8a                	jne    8050724 <rep+0x34>
 805079a:	bf 02 00 00 00       	mov    $0x2,%edi
		len = 1;
	}

#ifdef DEBUG
	char temp[80];
	sprintf(temp, "rep %s", assembly);
 805079f:	83 ec 04             	sub    $0x4,%esp
 80507a2:	68 00 8a 0c 08       	push   $0x80c8a00
 80507a7:	68 39 13 06 08       	push   $0x8061339
 80507ac:	8d 74 24 0c          	lea    0xc(%esp),%esi
 80507b0:	56                   	push   %esi
 80507b1:	e8 da 83 ff ff       	call   8048b90 <sprintf@plt>
	sprintf(assembly, "%s[cnt = %d]", temp, count);
 80507b6:	53                   	push   %ebx
 80507b7:	56                   	push   %esi
 80507b8:	68 40 13 06 08       	push   $0x8061340
 80507bd:	68 00 8a 0c 08       	push   $0x80c8a00
 80507c2:	e8 c9 83 ff ff       	call   8048b90 <sprintf@plt>
#endif
	
	return len + 1;
}
 80507c7:	83 c4 70             	add    $0x70,%esp
 80507ca:	89 f8                	mov    %edi,%eax
 80507cc:	5b                   	pop    %ebx
 80507cd:	5e                   	pop    %esi
 80507ce:	5f                   	pop    %edi
 80507cf:	c3                   	ret    
 80507d0:	83 ec 08             	sub    $0x8,%esp
 80507d3:	6a 01                	push   $0x1
 80507d5:	57                   	push   %edi
 80507d6:	e8 75 a7 ff ff       	call   804af50 <swaddr_read>
			  ) {
				if(cpu.ZF) {
					if(instr_fetch(eip, 1) == 0xf3) break;
				}
				else {
					if(instr_fetch(eip, 1) == 0xf2) break;
 80507db:	83 c4 10             	add    $0x10,%esp
 80507de:	3d f2 00 00 00       	cmp    $0xf2,%eax
 80507e3:	75 ab                	jne    8050790 <rep+0xa0>
 80507e5:	eb b3                	jmp    805079a <rep+0xaa>
make_helper(rep) {
	int len;
	int count = 0;
	if(instr_fetch(eip + 1, 1) == 0xc3) {
		/* repz ret */
		exec(eip + 1);
 80507e7:	83 ec 0c             	sub    $0xc,%esp
 80507ea:	bf 01 00 00 00       	mov    $0x1,%edi

make_helper(exec);

make_helper(rep) {
	int len;
	int count = 0;
 80507ef:	31 db                	xor    %ebx,%ebx
	if(instr_fetch(eip + 1, 1) == 0xc3) {
		/* repz ret */
		exec(eip + 1);
 80507f1:	56                   	push   %esi
 80507f2:	e8 59 c3 ff ff       	call   804cb50 <exec>
 80507f7:	83 c4 10             	add    $0x10,%esp
 80507fa:	eb a3                	jmp    805079f <rep+0xaf>
		//		return 2;
		//	}
		//	printf("eip = %u, opcode = %u\n", eip, ops_decoded.opcode);
			count ++;
			cpu.ecx --;
			assert(ops_decoded.opcode == 0xa4	// movsb
 80507fc:	68 4d 13 06 08       	push   $0x806134d
 8050801:	6a 1e                	push   $0x1e
 8050803:	68 2c 12 06 08       	push   $0x806122c
 8050808:	68 4c 12 06 08       	push   $0x806124c
 805080d:	e8 9e 83 ff ff       	call   8048bb0 <__assert_fail@plt>
 8050812:	66 90                	xchg   %ax,%ax
 8050814:	66 90                	xchg   %ax,%ax
 8050816:	66 90                	xchg   %ax,%ax
 8050818:	66 90                	xchg   %ax,%ax
 805081a:	66 90                	xchg   %ax,%ax
 805081c:	66 90                	xchg   %ax,%ax
 805081e:	66 90                	xchg   %ax,%ax

08050820 <do_pop_b>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr pop

static void do_execute() {
 8050820:	83 ec 14             	sub    $0x14,%esp
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
 8050823:	6a 01                	push   $0x1
 8050825:	ff 35 d0 af 0f 10    	pushl  0x100fafd0
 805082b:	e8 20 a7 ff ff       	call   804af50 <swaddr_read>
 8050830:	5a                   	pop    %edx
 8050831:	59                   	pop    %ecx
 8050832:	0f b6 c0             	movzbl %al,%eax
 8050835:	50                   	push   %eax
 8050836:	68 08 af 0f 10       	push   $0x100faf08
 805083b:	e8 00 bf 00 00       	call   805c740 <write_operand_b>
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
	print_asm_template1();
 8050840:	68 18 af 0f 10       	push   $0x100faf18
 8050845:	68 51 13 06 08       	push   $0x8061351
 805084a:	6a 50                	push   $0x50
 805084c:	68 00 8a 0c 08       	push   $0x80c8a00
#endif
#define instr pop

static void do_execute() {
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
 8050851:	83 05 d0 af 0f 10 01 	addl   $0x1,0x100fafd0
	print_asm_template1();
 8050858:	e8 a3 82 ff ff       	call   8048b00 <snprintf@plt>
 805085d:	83 c4 20             	add    $0x20,%esp
 8050860:	83 f8 4f             	cmp    $0x4f,%eax
 8050863:	7f 0b                	jg     8050870 <do_pop_b+0x50>
}
 8050865:	83 c4 0c             	add    $0xc,%esp
 8050868:	c3                   	ret    
 8050869:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#define instr pop

static void do_execute() {
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
	print_asm_template1();
 8050870:	83 ec 0c             	sub    $0xc,%esp
 8050873:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8050879:	e8 e2 80 ff ff       	call   8048960 <fflush@plt>
 805087e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050884:	6a 07                	push   $0x7
 8050886:	6a 01                	push   $0x1
 8050888:	68 92 e8 05 08       	push   $0x805e892
 805088d:	e8 7e 81 ff ff       	call   8048a10 <fwrite@plt>
 8050892:	83 c4 20             	add    $0x20,%esp
 8050895:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805089b:	6a 10                	push   $0x10
 805089d:	6a 01                	push   $0x1
 805089f:	68 b4 f3 05 08       	push   $0x805f3b4
 80508a4:	e8 67 81 ff ff       	call   8048a10 <fwrite@plt>
 80508a9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80508af:	6a 05                	push   $0x5
 80508b1:	6a 01                	push   $0x1
 80508b3:	68 42 f3 05 08       	push   $0x805f342
 80508b8:	e8 53 81 ff ff       	call   8048a10 <fwrite@plt>
 80508bd:	83 c4 20             	add    $0x20,%esp
 80508c0:	68 18 af 0f 10       	push   $0x100faf18
 80508c5:	68 51 13 06 08       	push   $0x8061351
 80508ca:	6a 50                	push   $0x50
 80508cc:	68 00 8a 0c 08       	push   $0x80c8a00
 80508d1:	e8 2a 82 ff ff       	call   8048b00 <snprintf@plt>
 80508d6:	83 c4 10             	add    $0x10,%esp
 80508d9:	83 f8 4f             	cmp    $0x4f,%eax
 80508dc:	7e 87                	jle    8050865 <do_pop_b+0x45>
 80508de:	68 7c 14 06 08       	push   $0x806147c
 80508e3:	6a 0f                	push   $0xf
 80508e5:	68 6c 13 06 08       	push   $0x806136c
 80508ea:	68 94 13 06 08       	push   $0x8061394
 80508ef:	e8 bc 82 ff ff       	call   8048bb0 <__assert_fail@plt>
 80508f4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80508fa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08050900 <do_pop_w>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr pop

static void do_execute() {
 8050900:	83 ec 14             	sub    $0x14,%esp
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
 8050903:	6a 02                	push   $0x2
 8050905:	ff 35 d0 af 0f 10    	pushl  0x100fafd0
 805090b:	e8 40 a6 ff ff       	call   804af50 <swaddr_read>
 8050910:	5a                   	pop    %edx
 8050911:	59                   	pop    %ecx
 8050912:	0f b7 c0             	movzwl %ax,%eax
 8050915:	50                   	push   %eax
 8050916:	68 08 af 0f 10       	push   $0x100faf08
 805091b:	e8 b0 c1 00 00       	call   805cad0 <write_operand_w>
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
	print_asm_template1();
 8050920:	68 18 af 0f 10       	push   $0x100faf18
 8050925:	68 59 13 06 08       	push   $0x8061359
 805092a:	6a 50                	push   $0x50
 805092c:	68 00 8a 0c 08       	push   $0x80c8a00
#endif
#define instr pop

static void do_execute() {
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
 8050931:	83 05 d0 af 0f 10 02 	addl   $0x2,0x100fafd0
	print_asm_template1();
 8050938:	e8 c3 81 ff ff       	call   8048b00 <snprintf@plt>
 805093d:	83 c4 20             	add    $0x20,%esp
 8050940:	83 f8 4f             	cmp    $0x4f,%eax
 8050943:	7f 0b                	jg     8050950 <do_pop_w+0x50>
}
 8050945:	83 c4 0c             	add    $0xc,%esp
 8050948:	c3                   	ret    
 8050949:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#define instr pop

static void do_execute() {
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
	print_asm_template1();
 8050950:	83 ec 0c             	sub    $0xc,%esp
 8050953:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8050959:	e8 02 80 ff ff       	call   8048960 <fflush@plt>
 805095e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050964:	6a 07                	push   $0x7
 8050966:	6a 01                	push   $0x1
 8050968:	68 92 e8 05 08       	push   $0x805e892
 805096d:	e8 9e 80 ff ff       	call   8048a10 <fwrite@plt>
 8050972:	83 c4 20             	add    $0x20,%esp
 8050975:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805097b:	6a 10                	push   $0x10
 805097d:	6a 01                	push   $0x1
 805097f:	68 b4 f3 05 08       	push   $0x805f3b4
 8050984:	e8 87 80 ff ff       	call   8048a10 <fwrite@plt>
 8050989:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805098f:	6a 05                	push   $0x5
 8050991:	6a 01                	push   $0x1
 8050993:	68 42 f3 05 08       	push   $0x805f342
 8050998:	e8 73 80 ff ff       	call   8048a10 <fwrite@plt>
 805099d:	83 c4 20             	add    $0x20,%esp
 80509a0:	68 18 af 0f 10       	push   $0x100faf18
 80509a5:	68 59 13 06 08       	push   $0x8061359
 80509aa:	6a 50                	push   $0x50
 80509ac:	68 00 8a 0c 08       	push   $0x80c8a00
 80509b1:	e8 4a 81 ff ff       	call   8048b00 <snprintf@plt>
 80509b6:	83 c4 10             	add    $0x10,%esp
 80509b9:	83 f8 4f             	cmp    $0x4f,%eax
 80509bc:	7e 87                	jle    8050945 <do_pop_w+0x45>
 80509be:	68 73 14 06 08       	push   $0x8061473
 80509c3:	6a 0f                	push   $0xf
 80509c5:	68 6c 13 06 08       	push   $0x806136c
 80509ca:	68 dc 13 06 08       	push   $0x80613dc
 80509cf:	e8 dc 81 ff ff       	call   8048bb0 <__assert_fail@plt>
 80509d4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80509da:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080509e0 <pop_r_w>:
}

make_instr_helper(r)
 80509e0:	53                   	push   %ebx
 80509e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80509e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80509e8:	83 c0 01             	add    $0x1,%eax
 80509eb:	50                   	push   %eax
 80509ec:	e8 8f bf 00 00       	call   805c980 <decode_r_w>
 80509f1:	89 c3                	mov    %eax,%ebx
	execute();
 80509f3:	e8 08 ff ff ff       	call   8050900 <do_pop_w>
 80509f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80509fb:	8d 43 01             	lea    0x1(%ebx),%eax
 80509fe:	5b                   	pop    %ebx
 80509ff:	c3                   	ret    

08050a00 <pop_m_w>:
make_instr_helper(m)
 8050a00:	53                   	push   %ebx
 8050a01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050a04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050a08:	83 c0 01             	add    $0x1,%eax
 8050a0b:	50                   	push   %eax
 8050a0c:	e8 2f be 00 00       	call   805c840 <decode_m_w>
 8050a11:	89 c3                	mov    %eax,%ebx
	execute();
 8050a13:	e8 e8 fe ff ff       	call   8050900 <do_pop_w>
 8050a18:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050a1b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050a1e:	5b                   	pop    %ebx
 8050a1f:	c3                   	ret    

08050a20 <do_pop_l>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr pop

static void do_execute() {
 8050a20:	83 ec 14             	sub    $0x14,%esp
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
 8050a23:	6a 04                	push   $0x4
 8050a25:	ff 35 d0 af 0f 10    	pushl  0x100fafd0
 8050a2b:	e8 20 a5 ff ff       	call   804af50 <swaddr_read>
 8050a30:	5a                   	pop    %edx
 8050a31:	59                   	pop    %ecx
 8050a32:	50                   	push   %eax
 8050a33:	68 08 af 0f 10       	push   $0x100faf08
 8050a38:	e8 63 c4 00 00       	call   805cea0 <write_operand_l>
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
	print_asm_template1();
 8050a3d:	68 18 af 0f 10       	push   $0x100faf18
 8050a42:	68 61 13 06 08       	push   $0x8061361
 8050a47:	6a 50                	push   $0x50
 8050a49:	68 00 8a 0c 08       	push   $0x80c8a00
#endif
#define instr pop

static void do_execute() {
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
 8050a4e:	83 05 d0 af 0f 10 04 	addl   $0x4,0x100fafd0
	print_asm_template1();
 8050a55:	e8 a6 80 ff ff       	call   8048b00 <snprintf@plt>
 8050a5a:	83 c4 20             	add    $0x20,%esp
 8050a5d:	83 f8 4f             	cmp    $0x4f,%eax
 8050a60:	7f 0e                	jg     8050a70 <do_pop_l+0x50>
}
 8050a62:	83 c4 0c             	add    $0xc,%esp
 8050a65:	c3                   	ret    
 8050a66:	8d 76 00             	lea    0x0(%esi),%esi
 8050a69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#define instr pop

static void do_execute() {
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
	print_asm_template1();
 8050a70:	83 ec 0c             	sub    $0xc,%esp
 8050a73:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8050a79:	e8 e2 7e ff ff       	call   8048960 <fflush@plt>
 8050a7e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050a84:	6a 07                	push   $0x7
 8050a86:	6a 01                	push   $0x1
 8050a88:	68 92 e8 05 08       	push   $0x805e892
 8050a8d:	e8 7e 7f ff ff       	call   8048a10 <fwrite@plt>
 8050a92:	83 c4 20             	add    $0x20,%esp
 8050a95:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050a9b:	6a 10                	push   $0x10
 8050a9d:	6a 01                	push   $0x1
 8050a9f:	68 b4 f3 05 08       	push   $0x805f3b4
 8050aa4:	e8 67 7f ff ff       	call   8048a10 <fwrite@plt>
 8050aa9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050aaf:	6a 05                	push   $0x5
 8050ab1:	6a 01                	push   $0x1
 8050ab3:	68 42 f3 05 08       	push   $0x805f342
 8050ab8:	e8 53 7f ff ff       	call   8048a10 <fwrite@plt>
 8050abd:	83 c4 20             	add    $0x20,%esp
 8050ac0:	68 18 af 0f 10       	push   $0x100faf18
 8050ac5:	68 61 13 06 08       	push   $0x8061361
 8050aca:	6a 50                	push   $0x50
 8050acc:	68 00 8a 0c 08       	push   $0x80c8a00
 8050ad1:	e8 2a 80 ff ff       	call   8048b00 <snprintf@plt>
 8050ad6:	83 c4 10             	add    $0x10,%esp
 8050ad9:	83 f8 4f             	cmp    $0x4f,%eax
 8050adc:	7e 84                	jle    8050a62 <do_pop_l+0x42>
 8050ade:	68 6a 14 06 08       	push   $0x806146a
 8050ae3:	6a 0f                	push   $0xf
 8050ae5:	68 6c 13 06 08       	push   $0x806136c
 8050aea:	68 24 14 06 08       	push   $0x8061424
 8050aef:	e8 bc 80 ff ff       	call   8048bb0 <__assert_fail@plt>
 8050af4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8050afa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08050b00 <pop_r_l>:
}

make_instr_helper(r)
 8050b00:	53                   	push   %ebx
 8050b01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050b04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050b08:	83 c0 01             	add    $0x1,%eax
 8050b0b:	50                   	push   %eax
 8050b0c:	e8 3f c2 00 00       	call   805cd50 <decode_r_l>
 8050b11:	89 c3                	mov    %eax,%ebx
	execute();
 8050b13:	e8 08 ff ff ff       	call   8050a20 <do_pop_l>
 8050b18:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050b1b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050b1e:	5b                   	pop    %ebx
 8050b1f:	c3                   	ret    

08050b20 <pop_m_l>:
make_instr_helper(m)
 8050b20:	53                   	push   %ebx
 8050b21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050b24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050b28:	83 c0 01             	add    $0x1,%eax
 8050b2b:	50                   	push   %eax
 8050b2c:	e8 df c0 00 00       	call   805cc10 <decode_m_l>
 8050b31:	89 c3                	mov    %eax,%ebx
	execute();
 8050b33:	e8 e8 fe ff ff       	call   8050a20 <do_pop_l>
 8050b38:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050b3b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050b3e:	5b                   	pop    %ebx
 8050b3f:	c3                   	ret    

08050b40 <pop_r_b>:
	OPERAND_W(op_src, (RET_DATA_TYPE) swaddr_read(reg_l(R_ESP), DATA_BYTE)); 
	reg_l(R_ESP) = reg_l(R_ESP) + DATA_BYTE;
	print_asm_template1();
}

make_instr_helper(r)
 8050b40:	53                   	push   %ebx
 8050b41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050b44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050b48:	83 c0 01             	add    $0x1,%eax
 8050b4b:	50                   	push   %eax
 8050b4c:	e8 ff ba 00 00       	call   805c650 <decode_r_b>
 8050b51:	89 c3                	mov    %eax,%ebx
	execute();
 8050b53:	e8 c8 fc ff ff       	call   8050820 <do_pop_b>
 8050b58:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050b5b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050b5e:	5b                   	pop    %ebx
 8050b5f:	c3                   	ret    

08050b60 <pop_m_b>:
make_instr_helper(m)
 8050b60:	53                   	push   %ebx
 8050b61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050b64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050b68:	83 c0 01             	add    $0x1,%eax
 8050b6b:	50                   	push   %eax
 8050b6c:	e8 9f b9 00 00       	call   805c510 <decode_m_b>
 8050b71:	89 c3                	mov    %eax,%ebx
	execute();
 8050b73:	e8 a8 fc ff ff       	call   8050820 <do_pop_b>
 8050b78:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050b7b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050b7e:	5b                   	pop    %ebx
 8050b7f:	c3                   	ret    

08050b80 <pop_r_v>:
#include "pop-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(pop_r)
 8050b80:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8050b87:	8b 54 24 04          	mov    0x4(%esp),%edx
 8050b8b:	b8 e0 09 05 08       	mov    $0x80509e0,%eax
 8050b90:	75 05                	jne    8050b97 <pop_r_v+0x17>
 8050b92:	b8 00 0b 05 08       	mov    $0x8050b00,%eax
 8050b97:	89 54 24 04          	mov    %edx,0x4(%esp)
 8050b9b:	ff e0                	jmp    *%eax
 8050b9d:	8d 76 00             	lea    0x0(%esi),%esi

08050ba0 <pop_m_v>:
make_helper_v(pop_m)
 8050ba0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8050ba7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8050bab:	b8 00 0a 05 08       	mov    $0x8050a00,%eax
 8050bb0:	75 05                	jne    8050bb7 <pop_m_v+0x17>
 8050bb2:	b8 20 0b 05 08       	mov    $0x8050b20,%eax
 8050bb7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8050bbb:	ff e0                	jmp    *%eax
 8050bbd:	66 90                	xchg   %ax,%ax
 8050bbf:	90                   	nop

08050bc0 <do_push_b>:
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
 8050bc0:	83 ec 10             	sub    $0x10,%esp
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 8050bc3:	a1 d0 af 0f 10       	mov    0x100fafd0,%eax
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 8050bc8:	ff 35 14 af 0f 10    	pushl  0x100faf14
 8050bce:	6a 04                	push   $0x4
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 8050bd0:	83 e8 04             	sub    $0x4,%eax
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 8050bd3:	50                   	push   %eax
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 8050bd4:	a3 d0 af 0f 10       	mov    %eax,0x100fafd0
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 8050bd9:	e8 c2 a3 ff ff       	call   804afa0 <swaddr_write>
	print_asm_template1();
 8050bde:	68 18 af 0f 10       	push   $0x100faf18
 8050be3:	68 85 14 06 08       	push   $0x8061485
 8050be8:	6a 50                	push   $0x50
 8050bea:	68 00 8a 0c 08       	push   $0x80c8a00
 8050bef:	e8 0c 7f ff ff       	call   8048b00 <snprintf@plt>
 8050bf4:	83 c4 20             	add    $0x20,%esp
 8050bf7:	83 f8 4f             	cmp    $0x4f,%eax
 8050bfa:	7f 04                	jg     8050c00 <do_push_b+0x40>
}
 8050bfc:	83 c4 0c             	add    $0xc,%esp
 8050bff:	c3                   	ret    
#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
	print_asm_template1();
 8050c00:	83 ec 0c             	sub    $0xc,%esp
 8050c03:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8050c09:	e8 52 7d ff ff       	call   8048960 <fflush@plt>
 8050c0e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050c14:	6a 07                	push   $0x7
 8050c16:	6a 01                	push   $0x1
 8050c18:	68 92 e8 05 08       	push   $0x805e892
 8050c1d:	e8 ee 7d ff ff       	call   8048a10 <fwrite@plt>
 8050c22:	83 c4 20             	add    $0x20,%esp
 8050c25:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050c2b:	6a 10                	push   $0x10
 8050c2d:	6a 01                	push   $0x1
 8050c2f:	68 b4 f3 05 08       	push   $0x805f3b4
 8050c34:	e8 d7 7d ff ff       	call   8048a10 <fwrite@plt>
 8050c39:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050c3f:	6a 05                	push   $0x5
 8050c41:	6a 01                	push   $0x1
 8050c43:	68 42 f3 05 08       	push   $0x805f342
 8050c48:	e8 c3 7d ff ff       	call   8048a10 <fwrite@plt>
 8050c4d:	83 c4 20             	add    $0x20,%esp
 8050c50:	68 18 af 0f 10       	push   $0x100faf18
 8050c55:	68 85 14 06 08       	push   $0x8061485
 8050c5a:	6a 50                	push   $0x50
 8050c5c:	68 00 8a 0c 08       	push   $0x80c8a00
 8050c61:	e8 9a 7e ff ff       	call   8048b00 <snprintf@plt>
 8050c66:	83 c4 10             	add    $0x10,%esp
 8050c69:	83 f8 4f             	cmp    $0x4f,%eax
 8050c6c:	7e 8e                	jle    8050bfc <do_push_b+0x3c>
 8050c6e:	68 b3 15 06 08       	push   $0x80615b3
 8050c73:	6a 08                	push   $0x8
 8050c75:	68 a0 14 06 08       	push   $0x80614a0
 8050c7a:	68 c8 14 06 08       	push   $0x80614c8
 8050c7f:	e8 2c 7f ff ff       	call   8048bb0 <__assert_fail@plt>
 8050c84:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8050c8a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08050c90 <do_push_w>:
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
 8050c90:	83 ec 10             	sub    $0x10,%esp
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 8050c93:	a1 d0 af 0f 10       	mov    0x100fafd0,%eax
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 8050c98:	ff 35 14 af 0f 10    	pushl  0x100faf14
 8050c9e:	6a 02                	push   $0x2
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 8050ca0:	83 e8 02             	sub    $0x2,%eax
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 8050ca3:	50                   	push   %eax
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 8050ca4:	a3 d0 af 0f 10       	mov    %eax,0x100fafd0
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 8050ca9:	e8 f2 a2 ff ff       	call   804afa0 <swaddr_write>
	print_asm_template1();
 8050cae:	68 18 af 0f 10       	push   $0x100faf18
 8050cb3:	68 8e 14 06 08       	push   $0x806148e
 8050cb8:	6a 50                	push   $0x50
 8050cba:	68 00 8a 0c 08       	push   $0x80c8a00
 8050cbf:	e8 3c 7e ff ff       	call   8048b00 <snprintf@plt>
 8050cc4:	83 c4 20             	add    $0x20,%esp
 8050cc7:	83 f8 4f             	cmp    $0x4f,%eax
 8050cca:	7f 04                	jg     8050cd0 <do_push_w+0x40>
}
 8050ccc:	83 c4 0c             	add    $0xc,%esp
 8050ccf:	c3                   	ret    
#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
	print_asm_template1();
 8050cd0:	83 ec 0c             	sub    $0xc,%esp
 8050cd3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8050cd9:	e8 82 7c ff ff       	call   8048960 <fflush@plt>
 8050cde:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050ce4:	6a 07                	push   $0x7
 8050ce6:	6a 01                	push   $0x1
 8050ce8:	68 92 e8 05 08       	push   $0x805e892
 8050ced:	e8 1e 7d ff ff       	call   8048a10 <fwrite@plt>
 8050cf2:	83 c4 20             	add    $0x20,%esp
 8050cf5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050cfb:	6a 10                	push   $0x10
 8050cfd:	6a 01                	push   $0x1
 8050cff:	68 b4 f3 05 08       	push   $0x805f3b4
 8050d04:	e8 07 7d ff ff       	call   8048a10 <fwrite@plt>
 8050d09:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050d0f:	6a 05                	push   $0x5
 8050d11:	6a 01                	push   $0x1
 8050d13:	68 42 f3 05 08       	push   $0x805f342
 8050d18:	e8 f3 7c ff ff       	call   8048a10 <fwrite@plt>
 8050d1d:	83 c4 20             	add    $0x20,%esp
 8050d20:	68 18 af 0f 10       	push   $0x100faf18
 8050d25:	68 8e 14 06 08       	push   $0x806148e
 8050d2a:	6a 50                	push   $0x50
 8050d2c:	68 00 8a 0c 08       	push   $0x80c8a00
 8050d31:	e8 ca 7d ff ff       	call   8048b00 <snprintf@plt>
 8050d36:	83 c4 10             	add    $0x10,%esp
 8050d39:	83 f8 4f             	cmp    $0x4f,%eax
 8050d3c:	7e 8e                	jle    8050ccc <do_push_w+0x3c>
 8050d3e:	68 a9 15 06 08       	push   $0x80615a9
 8050d43:	6a 08                	push   $0x8
 8050d45:	68 a0 14 06 08       	push   $0x80614a0
 8050d4a:	68 10 15 06 08       	push   $0x8061510
 8050d4f:	e8 5c 7e ff ff       	call   8048bb0 <__assert_fail@plt>
 8050d54:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8050d5a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08050d60 <push_i_w>:
}

make_instr_helper(i)
 8050d60:	53                   	push   %ebx
 8050d61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050d64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050d68:	83 c0 01             	add    $0x1,%eax
 8050d6b:	50                   	push   %eax
 8050d6c:	e8 3f ba 00 00       	call   805c7b0 <decode_i_w>
 8050d71:	89 c3                	mov    %eax,%ebx
	execute();
 8050d73:	e8 18 ff ff ff       	call   8050c90 <do_push_w>
 8050d78:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050d7b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050d7e:	5b                   	pop    %ebx
 8050d7f:	c3                   	ret    

08050d80 <push_r_w>:
make_instr_helper(r)
 8050d80:	53                   	push   %ebx
 8050d81:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050d84:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050d88:	83 c0 01             	add    $0x1,%eax
 8050d8b:	50                   	push   %eax
 8050d8c:	e8 ef bb 00 00       	call   805c980 <decode_r_w>
 8050d91:	89 c3                	mov    %eax,%ebx
	execute();
 8050d93:	e8 f8 fe ff ff       	call   8050c90 <do_push_w>
 8050d98:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050d9b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050d9e:	5b                   	pop    %ebx
 8050d9f:	c3                   	ret    

08050da0 <push_rm_w>:
make_instr_helper(rm)
 8050da0:	53                   	push   %ebx
 8050da1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050da4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050da8:	83 c0 01             	add    $0x1,%eax
 8050dab:	50                   	push   %eax
 8050dac:	e8 af bb 00 00       	call   805c960 <decode_rm_w>
 8050db1:	89 c3                	mov    %eax,%ebx
	execute();
 8050db3:	e8 d8 fe ff ff       	call   8050c90 <do_push_w>
 8050db8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050dbb:	8d 43 01             	lea    0x1(%ebx),%eax
 8050dbe:	5b                   	pop    %ebx
 8050dbf:	c3                   	ret    

08050dc0 <do_push_l>:
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
 8050dc0:	83 ec 10             	sub    $0x10,%esp
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 8050dc3:	a1 d0 af 0f 10       	mov    0x100fafd0,%eax
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 8050dc8:	ff 35 14 af 0f 10    	pushl  0x100faf14
 8050dce:	6a 04                	push   $0x4
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 8050dd0:	83 e8 04             	sub    $0x4,%eax
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 8050dd3:	50                   	push   %eax
#include "cpu/exec/template-start.h"

#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
 8050dd4:	a3 d0 af 0f 10       	mov    %eax,0x100fafd0
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
 8050dd9:	e8 c2 a1 ff ff       	call   804afa0 <swaddr_write>
	print_asm_template1();
 8050dde:	68 18 af 0f 10       	push   $0x100faf18
 8050de3:	68 97 14 06 08       	push   $0x8061497
 8050de8:	6a 50                	push   $0x50
 8050dea:	68 00 8a 0c 08       	push   $0x80c8a00
 8050def:	e8 0c 7d ff ff       	call   8048b00 <snprintf@plt>
 8050df4:	83 c4 20             	add    $0x20,%esp
 8050df7:	83 f8 4f             	cmp    $0x4f,%eax
 8050dfa:	7f 04                	jg     8050e00 <do_push_l+0x40>
}
 8050dfc:	83 c4 0c             	add    $0xc,%esp
 8050dff:	c3                   	ret    
#define instr push

static void do_execute() {
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
	print_asm_template1();
 8050e00:	83 ec 0c             	sub    $0xc,%esp
 8050e03:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8050e09:	e8 52 7b ff ff       	call   8048960 <fflush@plt>
 8050e0e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050e14:	6a 07                	push   $0x7
 8050e16:	6a 01                	push   $0x1
 8050e18:	68 92 e8 05 08       	push   $0x805e892
 8050e1d:	e8 ee 7b ff ff       	call   8048a10 <fwrite@plt>
 8050e22:	83 c4 20             	add    $0x20,%esp
 8050e25:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050e2b:	6a 10                	push   $0x10
 8050e2d:	6a 01                	push   $0x1
 8050e2f:	68 b4 f3 05 08       	push   $0x805f3b4
 8050e34:	e8 d7 7b ff ff       	call   8048a10 <fwrite@plt>
 8050e39:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8050e3f:	6a 05                	push   $0x5
 8050e41:	6a 01                	push   $0x1
 8050e43:	68 42 f3 05 08       	push   $0x805f342
 8050e48:	e8 c3 7b ff ff       	call   8048a10 <fwrite@plt>
 8050e4d:	83 c4 20             	add    $0x20,%esp
 8050e50:	68 18 af 0f 10       	push   $0x100faf18
 8050e55:	68 97 14 06 08       	push   $0x8061497
 8050e5a:	6a 50                	push   $0x50
 8050e5c:	68 00 8a 0c 08       	push   $0x80c8a00
 8050e61:	e8 9a 7c ff ff       	call   8048b00 <snprintf@plt>
 8050e66:	83 c4 10             	add    $0x10,%esp
 8050e69:	83 f8 4f             	cmp    $0x4f,%eax
 8050e6c:	7e 8e                	jle    8050dfc <do_push_l+0x3c>
 8050e6e:	68 9f 15 06 08       	push   $0x806159f
 8050e73:	6a 08                	push   $0x8
 8050e75:	68 a0 14 06 08       	push   $0x80614a0
 8050e7a:	68 58 15 06 08       	push   $0x8061558
 8050e7f:	e8 2c 7d ff ff       	call   8048bb0 <__assert_fail@plt>
 8050e84:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8050e8a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08050e90 <push_i_l>:
}

make_instr_helper(i)
 8050e90:	53                   	push   %ebx
 8050e91:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050e94:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050e98:	83 c0 01             	add    $0x1,%eax
 8050e9b:	50                   	push   %eax
 8050e9c:	e8 9f bc 00 00       	call   805cb40 <decode_i_l>
 8050ea1:	89 c3                	mov    %eax,%ebx
	execute();
 8050ea3:	e8 18 ff ff ff       	call   8050dc0 <do_push_l>
 8050ea8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050eab:	8d 43 01             	lea    0x1(%ebx),%eax
 8050eae:	5b                   	pop    %ebx
 8050eaf:	c3                   	ret    

08050eb0 <push_r_l>:
make_instr_helper(r)
 8050eb0:	53                   	push   %ebx
 8050eb1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050eb4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050eb8:	83 c0 01             	add    $0x1,%eax
 8050ebb:	50                   	push   %eax
 8050ebc:	e8 8f be 00 00       	call   805cd50 <decode_r_l>
 8050ec1:	89 c3                	mov    %eax,%ebx
	execute();
 8050ec3:	e8 f8 fe ff ff       	call   8050dc0 <do_push_l>
 8050ec8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050ecb:	8d 43 01             	lea    0x1(%ebx),%eax
 8050ece:	5b                   	pop    %ebx
 8050ecf:	c3                   	ret    

08050ed0 <push_rm_l>:
make_instr_helper(rm)
 8050ed0:	53                   	push   %ebx
 8050ed1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050ed4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050ed8:	83 c0 01             	add    $0x1,%eax
 8050edb:	50                   	push   %eax
 8050edc:	e8 4f be 00 00       	call   805cd30 <decode_rm_l>
 8050ee1:	89 c3                	mov    %eax,%ebx
	execute();
 8050ee3:	e8 d8 fe ff ff       	call   8050dc0 <do_push_l>
 8050ee8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050eeb:	8d 43 01             	lea    0x1(%ebx),%eax
 8050eee:	5b                   	pop    %ebx
 8050eef:	c3                   	ret    

08050ef0 <push_i_b>:
	reg_l(R_ESP) = reg_l(R_ESP) - (DATA_BYTE == 2 ? 2 : 4);
	swaddr_write(reg_l(R_ESP), (DATA_BYTE == 2 ? 2 : 4), op_src->val);
	print_asm_template1();
}

make_instr_helper(i)
 8050ef0:	53                   	push   %ebx
 8050ef1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050ef4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050ef8:	83 c0 01             	add    $0x1,%eax
 8050efb:	50                   	push   %eax
 8050efc:	e8 3f b5 00 00       	call   805c440 <decode_i_b>
 8050f01:	89 c3                	mov    %eax,%ebx
	execute();
 8050f03:	e8 b8 fc ff ff       	call   8050bc0 <do_push_b>
 8050f08:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050f0b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050f0e:	5b                   	pop    %ebx
 8050f0f:	c3                   	ret    

08050f10 <push_r_b>:
make_instr_helper(r)
 8050f10:	53                   	push   %ebx
 8050f11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050f14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050f18:	83 c0 01             	add    $0x1,%eax
 8050f1b:	50                   	push   %eax
 8050f1c:	e8 2f b7 00 00       	call   805c650 <decode_r_b>
 8050f21:	89 c3                	mov    %eax,%ebx
	execute();
 8050f23:	e8 98 fc ff ff       	call   8050bc0 <do_push_b>
 8050f28:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050f2b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050f2e:	5b                   	pop    %ebx
 8050f2f:	c3                   	ret    

08050f30 <push_rm_b>:
make_instr_helper(rm)
 8050f30:	53                   	push   %ebx
 8050f31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050f34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050f38:	83 c0 01             	add    $0x1,%eax
 8050f3b:	50                   	push   %eax
 8050f3c:	e8 ef b6 00 00       	call   805c630 <decode_rm_b>
 8050f41:	89 c3                	mov    %eax,%ebx
	execute();
 8050f43:	e8 78 fc ff ff       	call   8050bc0 <do_push_b>
 8050f48:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8050f4b:	8d 43 01             	lea    0x1(%ebx),%eax
 8050f4e:	5b                   	pop    %ebx
 8050f4f:	c3                   	ret    

08050f50 <push_i_v>:
#include "push-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(push_i)
 8050f50:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8050f57:	8b 54 24 04          	mov    0x4(%esp),%edx
 8050f5b:	b8 60 0d 05 08       	mov    $0x8050d60,%eax
 8050f60:	75 05                	jne    8050f67 <push_i_v+0x17>
 8050f62:	b8 90 0e 05 08       	mov    $0x8050e90,%eax
 8050f67:	89 54 24 04          	mov    %edx,0x4(%esp)
 8050f6b:	ff e0                	jmp    *%eax
 8050f6d:	8d 76 00             	lea    0x0(%esi),%esi

08050f70 <push_r_v>:
make_helper_v(push_r)
 8050f70:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8050f77:	8b 54 24 04          	mov    0x4(%esp),%edx
 8050f7b:	b8 80 0d 05 08       	mov    $0x8050d80,%eax
 8050f80:	75 05                	jne    8050f87 <push_r_v+0x17>
 8050f82:	b8 b0 0e 05 08       	mov    $0x8050eb0,%eax
 8050f87:	89 54 24 04          	mov    %edx,0x4(%esp)
 8050f8b:	ff e0                	jmp    *%eax
 8050f8d:	8d 76 00             	lea    0x0(%esi),%esi

08050f90 <push_rm_v>:
make_helper_v(push_rm)
 8050f90:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8050f97:	8b 54 24 04          	mov    0x4(%esp),%edx
 8050f9b:	b8 a0 0d 05 08       	mov    $0x8050da0,%eax
 8050fa0:	75 05                	jne    8050fa7 <push_rm_v+0x17>
 8050fa2:	b8 d0 0e 05 08       	mov    $0x8050ed0,%eax
 8050fa7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8050fab:	ff e0                	jmp    *%eax
 8050fad:	66 90                	xchg   %ax,%ax
 8050faf:	90                   	nop

08050fb0 <cmovge_rm2r_l>:
static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
}

make_instr_helper(rm2r)
 8050fb0:	53                   	push   %ebx
 8050fb1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8050fb4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8050fb8:	83 c0 01             	add    $0x1,%eax
 8050fbb:	50                   	push   %eax
 8050fbc:	e8 7f bc 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8050fc1:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8050fc8:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 8050fcf:	83 c4 10             	add    $0x10,%esp
 8050fd2:	89 c3                	mov    %eax,%ebx
 8050fd4:	c0 ea 03             	shr    $0x3,%dl
 8050fd7:	c0 e9 07             	shr    $0x7,%cl
 8050fda:	83 e2 01             	and    $0x1,%edx
 8050fdd:	38 d1                	cmp    %dl,%cl
 8050fdf:	0f 84 c3 00 00 00    	je     80510a8 <cmovge_rm2r_l+0xf8>
	print_asm_template2();
 8050fe5:	83 ec 0c             	sub    $0xc,%esp
 8050fe8:	68 50 af 0f 10       	push   $0x100faf50
 8050fed:	68 18 af 0f 10       	push   $0x100faf18
 8050ff2:	68 bd 15 06 08       	push   $0x80615bd
 8050ff7:	6a 50                	push   $0x50
 8050ff9:	68 00 8a 0c 08       	push   $0x80c8a00
 8050ffe:	e8 fd 7a ff ff       	call   8048b00 <snprintf@plt>
 8051003:	83 c4 20             	add    $0x20,%esp
 8051006:	83 f8 4f             	cmp    $0x4f,%eax
 8051009:	7f 0d                	jg     8051018 <cmovge_rm2r_l+0x68>
}

make_instr_helper(rm2r)
 805100b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805100e:	8d 43 01             	lea    0x1(%ebx),%eax
 8051011:	5b                   	pop    %ebx
 8051012:	c3                   	ret    
 8051013:	90                   	nop
 8051014:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051018:	83 ec 0c             	sub    $0xc,%esp
 805101b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8051021:	e8 3a 79 ff ff       	call   8048960 <fflush@plt>
 8051026:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805102c:	6a 07                	push   $0x7
 805102e:	6a 01                	push   $0x1
 8051030:	68 92 e8 05 08       	push   $0x805e892
 8051035:	e8 d6 79 ff ff       	call   8048a10 <fwrite@plt>
 805103a:	83 c4 20             	add    $0x20,%esp
 805103d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051043:	6a 10                	push   $0x10
 8051045:	6a 01                	push   $0x1
 8051047:	68 b4 f3 05 08       	push   $0x805f3b4
 805104c:	e8 bf 79 ff ff       	call   8048a10 <fwrite@plt>
 8051051:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051057:	6a 05                	push   $0x5
 8051059:	6a 01                	push   $0x1
 805105b:	68 42 f3 05 08       	push   $0x805f342
 8051060:	e8 ab 79 ff ff       	call   8048a10 <fwrite@plt>
 8051065:	83 c4 14             	add    $0x14,%esp
 8051068:	68 50 af 0f 10       	push   $0x100faf50
 805106d:	68 18 af 0f 10       	push   $0x100faf18
 8051072:	68 bd 15 06 08       	push   $0x80615bd
 8051077:	6a 50                	push   $0x50
 8051079:	68 00 8a 0c 08       	push   $0x80c8a00
 805107e:	e8 7d 7a ff ff       	call   8048b00 <snprintf@plt>
 8051083:	83 c4 20             	add    $0x20,%esp
 8051086:	83 f8 4f             	cmp    $0x4f,%eax
 8051089:	7e 80                	jle    805100b <cmovge_rm2r_l+0x5b>
 805108b:	68 02 25 06 08       	push   $0x8062502
 8051090:	6a 06                	push   $0x6
 8051092:	68 70 17 06 08       	push   $0x8061770
 8051097:	68 9c 17 06 08       	push   $0x806179c
 805109c:	e8 0f 7b ff ff       	call   8048bb0 <__assert_fail@plt>
 80510a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80510a8:	83 ec 08             	sub    $0x8,%esp
 80510ab:	ff 35 14 af 0f 10    	pushl  0x100faf14
 80510b1:	68 40 af 0f 10       	push   $0x100faf40
 80510b6:	e8 e5 bd 00 00       	call   805cea0 <write_operand_l>
 80510bb:	83 c4 10             	add    $0x10,%esp
 80510be:	e9 22 ff ff ff       	jmp    8050fe5 <cmovge_rm2r_l+0x35>
 80510c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80510c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080510d0 <cmovne_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80510d0:	53                   	push   %ebx
 80510d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80510d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80510d8:	83 c0 01             	add    $0x1,%eax
 80510db:	50                   	push   %eax
 80510dc:	e8 5f bb 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80510e1:	83 c4 10             	add    $0x10,%esp
 80510e4:	f6 05 e4 af 0f 10 40 	testb  $0x40,0x100fafe4
 80510eb:	89 c3                	mov    %eax,%ebx
 80510ed:	0f 84 c5 00 00 00    	je     80511b8 <cmovne_rm2r_l+0xe8>
	print_asm_template2();
 80510f3:	83 ec 0c             	sub    $0xc,%esp
 80510f6:	68 50 af 0f 10       	push   $0x100faf50
 80510fb:	68 18 af 0f 10       	push   $0x100faf18
 8051100:	68 cb 15 06 08       	push   $0x80615cb
 8051105:	6a 50                	push   $0x50
 8051107:	68 00 8a 0c 08       	push   $0x80c8a00
 805110c:	e8 ef 79 ff ff       	call   8048b00 <snprintf@plt>
 8051111:	83 c4 20             	add    $0x20,%esp
 8051114:	83 f8 4f             	cmp    $0x4f,%eax
 8051117:	7f 0f                	jg     8051128 <cmovne_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051119:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805111c:	8d 43 01             	lea    0x1(%ebx),%eax
 805111f:	5b                   	pop    %ebx
 8051120:	c3                   	ret    
 8051121:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051128:	83 ec 0c             	sub    $0xc,%esp
 805112b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8051131:	e8 2a 78 ff ff       	call   8048960 <fflush@plt>
 8051136:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805113c:	6a 07                	push   $0x7
 805113e:	6a 01                	push   $0x1
 8051140:	68 92 e8 05 08       	push   $0x805e892
 8051145:	e8 c6 78 ff ff       	call   8048a10 <fwrite@plt>
 805114a:	83 c4 20             	add    $0x20,%esp
 805114d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051153:	6a 10                	push   $0x10
 8051155:	6a 01                	push   $0x1
 8051157:	68 b4 f3 05 08       	push   $0x805f3b4
 805115c:	e8 af 78 ff ff       	call   8048a10 <fwrite@plt>
 8051161:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051167:	6a 05                	push   $0x5
 8051169:	6a 01                	push   $0x1
 805116b:	68 42 f3 05 08       	push   $0x805f342
 8051170:	e8 9b 78 ff ff       	call   8048a10 <fwrite@plt>
 8051175:	83 c4 14             	add    $0x14,%esp
 8051178:	68 50 af 0f 10       	push   $0x100faf50
 805117d:	68 18 af 0f 10       	push   $0x100faf18
 8051182:	68 cb 15 06 08       	push   $0x80615cb
 8051187:	6a 50                	push   $0x50
 8051189:	68 00 8a 0c 08       	push   $0x80c8a00
 805118e:	e8 6d 79 ff ff       	call   8048b00 <snprintf@plt>
 8051193:	83 c4 20             	add    $0x20,%esp
 8051196:	83 f8 4f             	cmp    $0x4f,%eax
 8051199:	0f 8e 7a ff ff ff    	jle    8051119 <cmovne_rm2r_l+0x49>
 805119f:	68 df 24 06 08       	push   $0x80624df
 80511a4:	6a 06                	push   $0x6
 80511a6:	68 70 17 06 08       	push   $0x8061770
 80511ab:	68 04 18 06 08       	push   $0x8061804
 80511b0:	e8 fb 79 ff ff       	call   8048bb0 <__assert_fail@plt>
 80511b5:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80511b8:	83 ec 08             	sub    $0x8,%esp
 80511bb:	ff 35 14 af 0f 10    	pushl  0x100faf14
 80511c1:	68 40 af 0f 10       	push   $0x100faf40
 80511c6:	e8 d5 bc 00 00       	call   805cea0 <write_operand_l>
 80511cb:	83 c4 10             	add    $0x10,%esp
 80511ce:	e9 20 ff ff ff       	jmp    80510f3 <cmovne_rm2r_l+0x23>
 80511d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80511d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080511e0 <cmovno_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80511e0:	53                   	push   %ebx
 80511e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80511e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80511e8:	83 c0 01             	add    $0x1,%eax
 80511eb:	50                   	push   %eax
 80511ec:	e8 4f ba 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80511f1:	83 c4 10             	add    $0x10,%esp
 80511f4:	f6 05 e5 af 0f 10 08 	testb  $0x8,0x100fafe5
 80511fb:	89 c3                	mov    %eax,%ebx
 80511fd:	0f 84 c5 00 00 00    	je     80512c8 <cmovno_rm2r_l+0xe8>
	print_asm_template2();
 8051203:	83 ec 0c             	sub    $0xc,%esp
 8051206:	68 50 af 0f 10       	push   $0x100faf50
 805120b:	68 18 af 0f 10       	push   $0x100faf18
 8051210:	68 d9 15 06 08       	push   $0x80615d9
 8051215:	6a 50                	push   $0x50
 8051217:	68 00 8a 0c 08       	push   $0x80c8a00
 805121c:	e8 df 78 ff ff       	call   8048b00 <snprintf@plt>
 8051221:	83 c4 20             	add    $0x20,%esp
 8051224:	83 f8 4f             	cmp    $0x4f,%eax
 8051227:	7f 0f                	jg     8051238 <cmovno_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051229:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805122c:	8d 43 01             	lea    0x1(%ebx),%eax
 805122f:	5b                   	pop    %ebx
 8051230:	c3                   	ret    
 8051231:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051238:	83 ec 0c             	sub    $0xc,%esp
 805123b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8051241:	e8 1a 77 ff ff       	call   8048960 <fflush@plt>
 8051246:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805124c:	6a 07                	push   $0x7
 805124e:	6a 01                	push   $0x1
 8051250:	68 92 e8 05 08       	push   $0x805e892
 8051255:	e8 b6 77 ff ff       	call   8048a10 <fwrite@plt>
 805125a:	83 c4 20             	add    $0x20,%esp
 805125d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051263:	6a 10                	push   $0x10
 8051265:	6a 01                	push   $0x1
 8051267:	68 b4 f3 05 08       	push   $0x805f3b4
 805126c:	e8 9f 77 ff ff       	call   8048a10 <fwrite@plt>
 8051271:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051277:	6a 05                	push   $0x5
 8051279:	6a 01                	push   $0x1
 805127b:	68 42 f3 05 08       	push   $0x805f342
 8051280:	e8 8b 77 ff ff       	call   8048a10 <fwrite@plt>
 8051285:	83 c4 14             	add    $0x14,%esp
 8051288:	68 50 af 0f 10       	push   $0x100faf50
 805128d:	68 18 af 0f 10       	push   $0x100faf18
 8051292:	68 d9 15 06 08       	push   $0x80615d9
 8051297:	6a 50                	push   $0x50
 8051299:	68 00 8a 0c 08       	push   $0x80c8a00
 805129e:	e8 5d 78 ff ff       	call   8048b00 <snprintf@plt>
 80512a3:	83 c4 20             	add    $0x20,%esp
 80512a6:	83 f8 4f             	cmp    $0x4f,%eax
 80512a9:	0f 8e 7a ff ff ff    	jle    8051229 <cmovno_rm2r_l+0x49>
 80512af:	68 d3 24 06 08       	push   $0x80624d3
 80512b4:	6a 06                	push   $0x6
 80512b6:	68 70 17 06 08       	push   $0x8061770
 80512bb:	68 6c 18 06 08       	push   $0x806186c
 80512c0:	e8 eb 78 ff ff       	call   8048bb0 <__assert_fail@plt>
 80512c5:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80512c8:	83 ec 08             	sub    $0x8,%esp
 80512cb:	ff 35 14 af 0f 10    	pushl  0x100faf14
 80512d1:	68 40 af 0f 10       	push   $0x100faf40
 80512d6:	e8 c5 bb 00 00       	call   805cea0 <write_operand_l>
 80512db:	83 c4 10             	add    $0x10,%esp
 80512de:	e9 20 ff ff ff       	jmp    8051203 <cmovno_rm2r_l+0x23>
 80512e3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80512e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080512f0 <cmovns_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80512f0:	53                   	push   %ebx
 80512f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80512f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80512f8:	83 c0 01             	add    $0x1,%eax
 80512fb:	50                   	push   %eax
 80512fc:	e8 3f b9 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051301:	83 c4 10             	add    $0x10,%esp
 8051304:	80 3d e4 af 0f 10 00 	cmpb   $0x0,0x100fafe4
 805130b:	89 c3                	mov    %eax,%ebx
 805130d:	0f 89 c5 00 00 00    	jns    80513d8 <cmovns_rm2r_l+0xe8>
	print_asm_template2();
 8051313:	83 ec 0c             	sub    $0xc,%esp
 8051316:	68 50 af 0f 10       	push   $0x100faf50
 805131b:	68 18 af 0f 10       	push   $0x100faf18
 8051320:	68 e7 15 06 08       	push   $0x80615e7
 8051325:	6a 50                	push   $0x50
 8051327:	68 00 8a 0c 08       	push   $0x80c8a00
 805132c:	e8 cf 77 ff ff       	call   8048b00 <snprintf@plt>
 8051331:	83 c4 20             	add    $0x20,%esp
 8051334:	83 f8 4f             	cmp    $0x4f,%eax
 8051337:	7f 0f                	jg     8051348 <cmovns_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051339:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805133c:	8d 43 01             	lea    0x1(%ebx),%eax
 805133f:	5b                   	pop    %ebx
 8051340:	c3                   	ret    
 8051341:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051348:	83 ec 0c             	sub    $0xc,%esp
 805134b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8051351:	e8 0a 76 ff ff       	call   8048960 <fflush@plt>
 8051356:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805135c:	6a 07                	push   $0x7
 805135e:	6a 01                	push   $0x1
 8051360:	68 92 e8 05 08       	push   $0x805e892
 8051365:	e8 a6 76 ff ff       	call   8048a10 <fwrite@plt>
 805136a:	83 c4 20             	add    $0x20,%esp
 805136d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051373:	6a 10                	push   $0x10
 8051375:	6a 01                	push   $0x1
 8051377:	68 b4 f3 05 08       	push   $0x805f3b4
 805137c:	e8 8f 76 ff ff       	call   8048a10 <fwrite@plt>
 8051381:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051387:	6a 05                	push   $0x5
 8051389:	6a 01                	push   $0x1
 805138b:	68 42 f3 05 08       	push   $0x805f342
 8051390:	e8 7b 76 ff ff       	call   8048a10 <fwrite@plt>
 8051395:	83 c4 14             	add    $0x14,%esp
 8051398:	68 50 af 0f 10       	push   $0x100faf50
 805139d:	68 18 af 0f 10       	push   $0x100faf18
 80513a2:	68 e7 15 06 08       	push   $0x80615e7
 80513a7:	6a 50                	push   $0x50
 80513a9:	68 00 8a 0c 08       	push   $0x80c8a00
 80513ae:	e8 4d 77 ff ff       	call   8048b00 <snprintf@plt>
 80513b3:	83 c4 20             	add    $0x20,%esp
 80513b6:	83 f8 4f             	cmp    $0x4f,%eax
 80513b9:	0f 8e 7a ff ff ff    	jle    8051339 <cmovns_rm2r_l+0x49>
 80513bf:	68 bb 24 06 08       	push   $0x80624bb
 80513c4:	6a 06                	push   $0x6
 80513c6:	68 70 17 06 08       	push   $0x8061770
 80513cb:	68 d4 18 06 08       	push   $0x80618d4
 80513d0:	e8 db 77 ff ff       	call   8048bb0 <__assert_fail@plt>
 80513d5:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80513d8:	83 ec 08             	sub    $0x8,%esp
 80513db:	ff 35 14 af 0f 10    	pushl  0x100faf14
 80513e1:	68 40 af 0f 10       	push   $0x100faf40
 80513e6:	e8 b5 ba 00 00       	call   805cea0 <write_operand_l>
 80513eb:	83 c4 10             	add    $0x10,%esp
 80513ee:	e9 20 ff ff ff       	jmp    8051313 <cmovns_rm2r_l+0x23>
 80513f3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80513f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051400 <cmovnp_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051400:	53                   	push   %ebx
 8051401:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051404:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051408:	83 c0 01             	add    $0x1,%eax
 805140b:	50                   	push   %eax
 805140c:	e8 2f b8 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051411:	83 c4 10             	add    $0x10,%esp
 8051414:	f6 05 e4 af 0f 10 04 	testb  $0x4,0x100fafe4
 805141b:	89 c3                	mov    %eax,%ebx
 805141d:	0f 84 c5 00 00 00    	je     80514e8 <cmovnp_rm2r_l+0xe8>
	print_asm_template2();
 8051423:	83 ec 0c             	sub    $0xc,%esp
 8051426:	68 50 af 0f 10       	push   $0x100faf50
 805142b:	68 18 af 0f 10       	push   $0x100faf18
 8051430:	68 f5 15 06 08       	push   $0x80615f5
 8051435:	6a 50                	push   $0x50
 8051437:	68 00 8a 0c 08       	push   $0x80c8a00
 805143c:	e8 bf 76 ff ff       	call   8048b00 <snprintf@plt>
 8051441:	83 c4 20             	add    $0x20,%esp
 8051444:	83 f8 4f             	cmp    $0x4f,%eax
 8051447:	7f 0f                	jg     8051458 <cmovnp_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051449:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805144c:	8d 43 01             	lea    0x1(%ebx),%eax
 805144f:	5b                   	pop    %ebx
 8051450:	c3                   	ret    
 8051451:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051458:	83 ec 0c             	sub    $0xc,%esp
 805145b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8051461:	e8 fa 74 ff ff       	call   8048960 <fflush@plt>
 8051466:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805146c:	6a 07                	push   $0x7
 805146e:	6a 01                	push   $0x1
 8051470:	68 92 e8 05 08       	push   $0x805e892
 8051475:	e8 96 75 ff ff       	call   8048a10 <fwrite@plt>
 805147a:	83 c4 20             	add    $0x20,%esp
 805147d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051483:	6a 10                	push   $0x10
 8051485:	6a 01                	push   $0x1
 8051487:	68 b4 f3 05 08       	push   $0x805f3b4
 805148c:	e8 7f 75 ff ff       	call   8048a10 <fwrite@plt>
 8051491:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051497:	6a 05                	push   $0x5
 8051499:	6a 01                	push   $0x1
 805149b:	68 42 f3 05 08       	push   $0x805f342
 80514a0:	e8 6b 75 ff ff       	call   8048a10 <fwrite@plt>
 80514a5:	83 c4 14             	add    $0x14,%esp
 80514a8:	68 50 af 0f 10       	push   $0x100faf50
 80514ad:	68 18 af 0f 10       	push   $0x100faf18
 80514b2:	68 f5 15 06 08       	push   $0x80615f5
 80514b7:	6a 50                	push   $0x50
 80514b9:	68 00 8a 0c 08       	push   $0x80c8a00
 80514be:	e8 3d 76 ff ff       	call   8048b00 <snprintf@plt>
 80514c3:	83 c4 20             	add    $0x20,%esp
 80514c6:	83 f8 4f             	cmp    $0x4f,%eax
 80514c9:	0f 8e 7a ff ff ff    	jle    8051449 <cmovnp_rm2r_l+0x49>
 80514cf:	68 c7 24 06 08       	push   $0x80624c7
 80514d4:	6a 06                	push   $0x6
 80514d6:	68 70 17 06 08       	push   $0x8061770
 80514db:	68 3c 19 06 08       	push   $0x806193c
 80514e0:	e8 cb 76 ff ff       	call   8048bb0 <__assert_fail@plt>
 80514e5:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80514e8:	83 ec 08             	sub    $0x8,%esp
 80514eb:	ff 35 14 af 0f 10    	pushl  0x100faf14
 80514f1:	68 40 af 0f 10       	push   $0x100faf40
 80514f6:	e8 a5 b9 00 00       	call   805cea0 <write_operand_l>
 80514fb:	83 c4 10             	add    $0x10,%esp
 80514fe:	e9 20 ff ff ff       	jmp    8051423 <cmovnp_rm2r_l+0x23>
 8051503:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051509:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051510 <cmovo_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051510:	53                   	push   %ebx
 8051511:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051514:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051518:	83 c0 01             	add    $0x1,%eax
 805151b:	50                   	push   %eax
 805151c:	e8 1f b7 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051521:	83 c4 10             	add    $0x10,%esp
 8051524:	f6 05 e5 af 0f 10 08 	testb  $0x8,0x100fafe5
 805152b:	89 c3                	mov    %eax,%ebx
 805152d:	0f 85 c5 00 00 00    	jne    80515f8 <cmovo_rm2r_l+0xe8>
	print_asm_template2();
 8051533:	83 ec 0c             	sub    $0xc,%esp
 8051536:	68 50 af 0f 10       	push   $0x100faf50
 805153b:	68 18 af 0f 10       	push   $0x100faf18
 8051540:	68 03 16 06 08       	push   $0x8061603
 8051545:	6a 50                	push   $0x50
 8051547:	68 00 8a 0c 08       	push   $0x80c8a00
 805154c:	e8 af 75 ff ff       	call   8048b00 <snprintf@plt>
 8051551:	83 c4 20             	add    $0x20,%esp
 8051554:	83 f8 4f             	cmp    $0x4f,%eax
 8051557:	7f 0f                	jg     8051568 <cmovo_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051559:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805155c:	8d 43 01             	lea    0x1(%ebx),%eax
 805155f:	5b                   	pop    %ebx
 8051560:	c3                   	ret    
 8051561:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051568:	83 ec 0c             	sub    $0xc,%esp
 805156b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8051571:	e8 ea 73 ff ff       	call   8048960 <fflush@plt>
 8051576:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805157c:	6a 07                	push   $0x7
 805157e:	6a 01                	push   $0x1
 8051580:	68 92 e8 05 08       	push   $0x805e892
 8051585:	e8 86 74 ff ff       	call   8048a10 <fwrite@plt>
 805158a:	83 c4 20             	add    $0x20,%esp
 805158d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051593:	6a 10                	push   $0x10
 8051595:	6a 01                	push   $0x1
 8051597:	68 b4 f3 05 08       	push   $0x805f3b4
 805159c:	e8 6f 74 ff ff       	call   8048a10 <fwrite@plt>
 80515a1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80515a7:	6a 05                	push   $0x5
 80515a9:	6a 01                	push   $0x1
 80515ab:	68 42 f3 05 08       	push   $0x805f342
 80515b0:	e8 5b 74 ff ff       	call   8048a10 <fwrite@plt>
 80515b5:	83 c4 14             	add    $0x14,%esp
 80515b8:	68 50 af 0f 10       	push   $0x100faf50
 80515bd:	68 18 af 0f 10       	push   $0x100faf18
 80515c2:	68 03 16 06 08       	push   $0x8061603
 80515c7:	6a 50                	push   $0x50
 80515c9:	68 00 8a 0c 08       	push   $0x80c8a00
 80515ce:	e8 2d 75 ff ff       	call   8048b00 <snprintf@plt>
 80515d3:	83 c4 20             	add    $0x20,%esp
 80515d6:	83 f8 4f             	cmp    $0x4f,%eax
 80515d9:	0f 8e 7a ff ff ff    	jle    8051559 <cmovo_rm2r_l+0x49>
 80515df:	68 b0 24 06 08       	push   $0x80624b0
 80515e4:	6a 06                	push   $0x6
 80515e6:	68 70 17 06 08       	push   $0x8061770
 80515eb:	68 a4 19 06 08       	push   $0x80619a4
 80515f0:	e8 bb 75 ff ff       	call   8048bb0 <__assert_fail@plt>
 80515f5:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80515f8:	83 ec 08             	sub    $0x8,%esp
 80515fb:	ff 35 14 af 0f 10    	pushl  0x100faf14
 8051601:	68 40 af 0f 10       	push   $0x100faf40
 8051606:	e8 95 b8 00 00       	call   805cea0 <write_operand_l>
 805160b:	83 c4 10             	add    $0x10,%esp
 805160e:	e9 20 ff ff ff       	jmp    8051533 <cmovo_rm2r_l+0x23>
 8051613:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051619:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051620 <cmovp_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051620:	53                   	push   %ebx
 8051621:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051624:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051628:	83 c0 01             	add    $0x1,%eax
 805162b:	50                   	push   %eax
 805162c:	e8 0f b6 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051631:	83 c4 10             	add    $0x10,%esp
 8051634:	f6 05 e4 af 0f 10 04 	testb  $0x4,0x100fafe4
 805163b:	89 c3                	mov    %eax,%ebx
 805163d:	0f 85 c5 00 00 00    	jne    8051708 <cmovp_rm2r_l+0xe8>
	print_asm_template2();
 8051643:	83 ec 0c             	sub    $0xc,%esp
 8051646:	68 50 af 0f 10       	push   $0x100faf50
 805164b:	68 18 af 0f 10       	push   $0x100faf18
 8051650:	68 10 16 06 08       	push   $0x8061610
 8051655:	6a 50                	push   $0x50
 8051657:	68 00 8a 0c 08       	push   $0x80c8a00
 805165c:	e8 9f 74 ff ff       	call   8048b00 <snprintf@plt>
 8051661:	83 c4 20             	add    $0x20,%esp
 8051664:	83 f8 4f             	cmp    $0x4f,%eax
 8051667:	7f 0f                	jg     8051678 <cmovp_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051669:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805166c:	8d 43 01             	lea    0x1(%ebx),%eax
 805166f:	5b                   	pop    %ebx
 8051670:	c3                   	ret    
 8051671:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051678:	83 ec 0c             	sub    $0xc,%esp
 805167b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8051681:	e8 da 72 ff ff       	call   8048960 <fflush@plt>
 8051686:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805168c:	6a 07                	push   $0x7
 805168e:	6a 01                	push   $0x1
 8051690:	68 92 e8 05 08       	push   $0x805e892
 8051695:	e8 76 73 ff ff       	call   8048a10 <fwrite@plt>
 805169a:	83 c4 20             	add    $0x20,%esp
 805169d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80516a3:	6a 10                	push   $0x10
 80516a5:	6a 01                	push   $0x1
 80516a7:	68 b4 f3 05 08       	push   $0x805f3b4
 80516ac:	e8 5f 73 ff ff       	call   8048a10 <fwrite@plt>
 80516b1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80516b7:	6a 05                	push   $0x5
 80516b9:	6a 01                	push   $0x1
 80516bb:	68 42 f3 05 08       	push   $0x805f342
 80516c0:	e8 4b 73 ff ff       	call   8048a10 <fwrite@plt>
 80516c5:	83 c4 14             	add    $0x14,%esp
 80516c8:	68 50 af 0f 10       	push   $0x100faf50
 80516cd:	68 18 af 0f 10       	push   $0x100faf18
 80516d2:	68 10 16 06 08       	push   $0x8061610
 80516d7:	6a 50                	push   $0x50
 80516d9:	68 00 8a 0c 08       	push   $0x80c8a00
 80516de:	e8 1d 74 ff ff       	call   8048b00 <snprintf@plt>
 80516e3:	83 c4 20             	add    $0x20,%esp
 80516e6:	83 f8 4f             	cmp    $0x4f,%eax
 80516e9:	0f 8e 7a ff ff ff    	jle    8051669 <cmovp_rm2r_l+0x49>
 80516ef:	68 a5 24 06 08       	push   $0x80624a5
 80516f4:	6a 06                	push   $0x6
 80516f6:	68 70 17 06 08       	push   $0x8061770
 80516fb:	68 0c 1a 06 08       	push   $0x8061a0c
 8051700:	e8 ab 74 ff ff       	call   8048bb0 <__assert_fail@plt>
 8051705:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051708:	83 ec 08             	sub    $0x8,%esp
 805170b:	ff 35 14 af 0f 10    	pushl  0x100faf14
 8051711:	68 40 af 0f 10       	push   $0x100faf40
 8051716:	e8 85 b7 00 00       	call   805cea0 <write_operand_l>
 805171b:	83 c4 10             	add    $0x10,%esp
 805171e:	e9 20 ff ff ff       	jmp    8051643 <cmovp_rm2r_l+0x23>
 8051723:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051729:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051730 <cmovs_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051730:	53                   	push   %ebx
 8051731:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051734:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051738:	83 c0 01             	add    $0x1,%eax
 805173b:	50                   	push   %eax
 805173c:	e8 ff b4 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051741:	83 c4 10             	add    $0x10,%esp
 8051744:	80 3d e4 af 0f 10 00 	cmpb   $0x0,0x100fafe4
 805174b:	89 c3                	mov    %eax,%ebx
 805174d:	0f 88 c5 00 00 00    	js     8051818 <cmovs_rm2r_l+0xe8>
	print_asm_template2();
 8051753:	83 ec 0c             	sub    $0xc,%esp
 8051756:	68 50 af 0f 10       	push   $0x100faf50
 805175b:	68 18 af 0f 10       	push   $0x100faf18
 8051760:	68 1d 16 06 08       	push   $0x806161d
 8051765:	6a 50                	push   $0x50
 8051767:	68 00 8a 0c 08       	push   $0x80c8a00
 805176c:	e8 8f 73 ff ff       	call   8048b00 <snprintf@plt>
 8051771:	83 c4 20             	add    $0x20,%esp
 8051774:	83 f8 4f             	cmp    $0x4f,%eax
 8051777:	7f 0f                	jg     8051788 <cmovs_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051779:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805177c:	8d 43 01             	lea    0x1(%ebx),%eax
 805177f:	5b                   	pop    %ebx
 8051780:	c3                   	ret    
 8051781:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051788:	83 ec 0c             	sub    $0xc,%esp
 805178b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8051791:	e8 ca 71 ff ff       	call   8048960 <fflush@plt>
 8051796:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805179c:	6a 07                	push   $0x7
 805179e:	6a 01                	push   $0x1
 80517a0:	68 92 e8 05 08       	push   $0x805e892
 80517a5:	e8 66 72 ff ff       	call   8048a10 <fwrite@plt>
 80517aa:	83 c4 20             	add    $0x20,%esp
 80517ad:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80517b3:	6a 10                	push   $0x10
 80517b5:	6a 01                	push   $0x1
 80517b7:	68 b4 f3 05 08       	push   $0x805f3b4
 80517bc:	e8 4f 72 ff ff       	call   8048a10 <fwrite@plt>
 80517c1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80517c7:	6a 05                	push   $0x5
 80517c9:	6a 01                	push   $0x1
 80517cb:	68 42 f3 05 08       	push   $0x805f342
 80517d0:	e8 3b 72 ff ff       	call   8048a10 <fwrite@plt>
 80517d5:	83 c4 14             	add    $0x14,%esp
 80517d8:	68 50 af 0f 10       	push   $0x100faf50
 80517dd:	68 18 af 0f 10       	push   $0x100faf18
 80517e2:	68 1d 16 06 08       	push   $0x806161d
 80517e7:	6a 50                	push   $0x50
 80517e9:	68 00 8a 0c 08       	push   $0x80c8a00
 80517ee:	e8 0d 73 ff ff       	call   8048b00 <snprintf@plt>
 80517f3:	83 c4 20             	add    $0x20,%esp
 80517f6:	83 f8 4f             	cmp    $0x4f,%eax
 80517f9:	0f 8e 7a ff ff ff    	jle    8051779 <cmovs_rm2r_l+0x49>
 80517ff:	68 9a 24 06 08       	push   $0x806249a
 8051804:	6a 06                	push   $0x6
 8051806:	68 70 17 06 08       	push   $0x8061770
 805180b:	68 74 1a 06 08       	push   $0x8061a74
 8051810:	e8 9b 73 ff ff       	call   8048bb0 <__assert_fail@plt>
 8051815:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051818:	83 ec 08             	sub    $0x8,%esp
 805181b:	ff 35 14 af 0f 10    	pushl  0x100faf14
 8051821:	68 40 af 0f 10       	push   $0x100faf40
 8051826:	e8 75 b6 00 00       	call   805cea0 <write_operand_l>
 805182b:	83 c4 10             	add    $0x10,%esp
 805182e:	e9 20 ff ff ff       	jmp    8051753 <cmovs_rm2r_l+0x23>
 8051833:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051839:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051840 <cmova_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051840:	53                   	push   %ebx
 8051841:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051844:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051848:	83 c0 01             	add    $0x1,%eax
 805184b:	50                   	push   %eax
 805184c:	e8 ef b3 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051851:	83 c4 10             	add    $0x10,%esp
 8051854:	f6 05 e4 af 0f 10 41 	testb  $0x41,0x100fafe4
 805185b:	89 c3                	mov    %eax,%ebx
 805185d:	0f 84 c5 00 00 00    	je     8051928 <cmova_rm2r_l+0xe8>
	print_asm_template2();
 8051863:	83 ec 0c             	sub    $0xc,%esp
 8051866:	68 50 af 0f 10       	push   $0x100faf50
 805186b:	68 18 af 0f 10       	push   $0x100faf18
 8051870:	68 2a 16 06 08       	push   $0x806162a
 8051875:	6a 50                	push   $0x50
 8051877:	68 00 8a 0c 08       	push   $0x80c8a00
 805187c:	e8 7f 72 ff ff       	call   8048b00 <snprintf@plt>
 8051881:	83 c4 20             	add    $0x20,%esp
 8051884:	83 f8 4f             	cmp    $0x4f,%eax
 8051887:	7f 0f                	jg     8051898 <cmova_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051889:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805188c:	8d 43 01             	lea    0x1(%ebx),%eax
 805188f:	5b                   	pop    %ebx
 8051890:	c3                   	ret    
 8051891:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051898:	83 ec 0c             	sub    $0xc,%esp
 805189b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80518a1:	e8 ba 70 ff ff       	call   8048960 <fflush@plt>
 80518a6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80518ac:	6a 07                	push   $0x7
 80518ae:	6a 01                	push   $0x1
 80518b0:	68 92 e8 05 08       	push   $0x805e892
 80518b5:	e8 56 71 ff ff       	call   8048a10 <fwrite@plt>
 80518ba:	83 c4 20             	add    $0x20,%esp
 80518bd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80518c3:	6a 10                	push   $0x10
 80518c5:	6a 01                	push   $0x1
 80518c7:	68 b4 f3 05 08       	push   $0x805f3b4
 80518cc:	e8 3f 71 ff ff       	call   8048a10 <fwrite@plt>
 80518d1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80518d7:	6a 05                	push   $0x5
 80518d9:	6a 01                	push   $0x1
 80518db:	68 42 f3 05 08       	push   $0x805f342
 80518e0:	e8 2b 71 ff ff       	call   8048a10 <fwrite@plt>
 80518e5:	83 c4 14             	add    $0x14,%esp
 80518e8:	68 50 af 0f 10       	push   $0x100faf50
 80518ed:	68 18 af 0f 10       	push   $0x100faf18
 80518f2:	68 2a 16 06 08       	push   $0x806162a
 80518f7:	6a 50                	push   $0x50
 80518f9:	68 00 8a 0c 08       	push   $0x80c8a00
 80518fe:	e8 fd 71 ff ff       	call   8048b00 <snprintf@plt>
 8051903:	83 c4 20             	add    $0x20,%esp
 8051906:	83 f8 4f             	cmp    $0x4f,%eax
 8051909:	0f 8e 7a ff ff ff    	jle    8051889 <cmova_rm2r_l+0x49>
 805190f:	68 47 25 06 08       	push   $0x8062547
 8051914:	6a 06                	push   $0x6
 8051916:	68 70 17 06 08       	push   $0x8061770
 805191b:	68 dc 1a 06 08       	push   $0x8061adc
 8051920:	e8 8b 72 ff ff       	call   8048bb0 <__assert_fail@plt>
 8051925:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051928:	83 ec 08             	sub    $0x8,%esp
 805192b:	ff 35 14 af 0f 10    	pushl  0x100faf14
 8051931:	68 40 af 0f 10       	push   $0x100faf40
 8051936:	e8 65 b5 00 00       	call   805cea0 <write_operand_l>
 805193b:	83 c4 10             	add    $0x10,%esp
 805193e:	e9 20 ff ff ff       	jmp    8051863 <cmova_rm2r_l+0x23>
 8051943:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051949:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051950 <cmovb_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051950:	53                   	push   %ebx
 8051951:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051954:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051958:	83 c0 01             	add    $0x1,%eax
 805195b:	50                   	push   %eax
 805195c:	e8 df b2 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051961:	83 c4 10             	add    $0x10,%esp
 8051964:	f6 05 e4 af 0f 10 01 	testb  $0x1,0x100fafe4
 805196b:	89 c3                	mov    %eax,%ebx
 805196d:	0f 85 c5 00 00 00    	jne    8051a38 <cmovb_rm2r_l+0xe8>
	print_asm_template2();
 8051973:	83 ec 0c             	sub    $0xc,%esp
 8051976:	68 50 af 0f 10       	push   $0x100faf50
 805197b:	68 18 af 0f 10       	push   $0x100faf18
 8051980:	68 37 16 06 08       	push   $0x8061637
 8051985:	6a 50                	push   $0x50
 8051987:	68 00 8a 0c 08       	push   $0x80c8a00
 805198c:	e8 6f 71 ff ff       	call   8048b00 <snprintf@plt>
 8051991:	83 c4 20             	add    $0x20,%esp
 8051994:	83 f8 4f             	cmp    $0x4f,%eax
 8051997:	7f 0f                	jg     80519a8 <cmovb_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051999:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805199c:	8d 43 01             	lea    0x1(%ebx),%eax
 805199f:	5b                   	pop    %ebx
 80519a0:	c3                   	ret    
 80519a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 80519a8:	83 ec 0c             	sub    $0xc,%esp
 80519ab:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80519b1:	e8 aa 6f ff ff       	call   8048960 <fflush@plt>
 80519b6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80519bc:	6a 07                	push   $0x7
 80519be:	6a 01                	push   $0x1
 80519c0:	68 92 e8 05 08       	push   $0x805e892
 80519c5:	e8 46 70 ff ff       	call   8048a10 <fwrite@plt>
 80519ca:	83 c4 20             	add    $0x20,%esp
 80519cd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80519d3:	6a 10                	push   $0x10
 80519d5:	6a 01                	push   $0x1
 80519d7:	68 b4 f3 05 08       	push   $0x805f3b4
 80519dc:	e8 2f 70 ff ff       	call   8048a10 <fwrite@plt>
 80519e1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80519e7:	6a 05                	push   $0x5
 80519e9:	6a 01                	push   $0x1
 80519eb:	68 42 f3 05 08       	push   $0x805f342
 80519f0:	e8 1b 70 ff ff       	call   8048a10 <fwrite@plt>
 80519f5:	83 c4 14             	add    $0x14,%esp
 80519f8:	68 50 af 0f 10       	push   $0x100faf50
 80519fd:	68 18 af 0f 10       	push   $0x100faf18
 8051a02:	68 37 16 06 08       	push   $0x8061637
 8051a07:	6a 50                	push   $0x50
 8051a09:	68 00 8a 0c 08       	push   $0x80c8a00
 8051a0e:	e8 ed 70 ff ff       	call   8048b00 <snprintf@plt>
 8051a13:	83 c4 20             	add    $0x20,%esp
 8051a16:	83 f8 4f             	cmp    $0x4f,%eax
 8051a19:	0f 8e 7a ff ff ff    	jle    8051999 <cmovb_rm2r_l+0x49>
 8051a1f:	68 30 25 06 08       	push   $0x8062530
 8051a24:	6a 06                	push   $0x6
 8051a26:	68 70 17 06 08       	push   $0x8061770
 8051a2b:	68 44 1b 06 08       	push   $0x8061b44
 8051a30:	e8 7b 71 ff ff       	call   8048bb0 <__assert_fail@plt>
 8051a35:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051a38:	83 ec 08             	sub    $0x8,%esp
 8051a3b:	ff 35 14 af 0f 10    	pushl  0x100faf14
 8051a41:	68 40 af 0f 10       	push   $0x100faf40
 8051a46:	e8 55 b4 00 00       	call   805cea0 <write_operand_l>
 8051a4b:	83 c4 10             	add    $0x10,%esp
 8051a4e:	e9 20 ff ff ff       	jmp    8051973 <cmovb_rm2r_l+0x23>
 8051a53:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051a59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051a60 <cmovae_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051a60:	53                   	push   %ebx
 8051a61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051a64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051a68:	83 c0 01             	add    $0x1,%eax
 8051a6b:	50                   	push   %eax
 8051a6c:	e8 cf b1 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051a71:	83 c4 10             	add    $0x10,%esp
 8051a74:	f6 05 e4 af 0f 10 01 	testb  $0x1,0x100fafe4
 8051a7b:	89 c3                	mov    %eax,%ebx
 8051a7d:	0f 84 c5 00 00 00    	je     8051b48 <cmovae_rm2r_l+0xe8>
	print_asm_template2();
 8051a83:	83 ec 0c             	sub    $0xc,%esp
 8051a86:	68 50 af 0f 10       	push   $0x100faf50
 8051a8b:	68 18 af 0f 10       	push   $0x100faf18
 8051a90:	68 44 16 06 08       	push   $0x8061644
 8051a95:	6a 50                	push   $0x50
 8051a97:	68 00 8a 0c 08       	push   $0x80c8a00
 8051a9c:	e8 5f 70 ff ff       	call   8048b00 <snprintf@plt>
 8051aa1:	83 c4 20             	add    $0x20,%esp
 8051aa4:	83 f8 4f             	cmp    $0x4f,%eax
 8051aa7:	7f 0f                	jg     8051ab8 <cmovae_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051aa9:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8051aac:	8d 43 01             	lea    0x1(%ebx),%eax
 8051aaf:	5b                   	pop    %ebx
 8051ab0:	c3                   	ret    
 8051ab1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051ab8:	83 ec 0c             	sub    $0xc,%esp
 8051abb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8051ac1:	e8 9a 6e ff ff       	call   8048960 <fflush@plt>
 8051ac6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051acc:	6a 07                	push   $0x7
 8051ace:	6a 01                	push   $0x1
 8051ad0:	68 92 e8 05 08       	push   $0x805e892
 8051ad5:	e8 36 6f ff ff       	call   8048a10 <fwrite@plt>
 8051ada:	83 c4 20             	add    $0x20,%esp
 8051add:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051ae3:	6a 10                	push   $0x10
 8051ae5:	6a 01                	push   $0x1
 8051ae7:	68 b4 f3 05 08       	push   $0x805f3b4
 8051aec:	e8 1f 6f ff ff       	call   8048a10 <fwrite@plt>
 8051af1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051af7:	6a 05                	push   $0x5
 8051af9:	6a 01                	push   $0x1
 8051afb:	68 42 f3 05 08       	push   $0x805f342
 8051b00:	e8 0b 6f ff ff       	call   8048a10 <fwrite@plt>
 8051b05:	83 c4 14             	add    $0x14,%esp
 8051b08:	68 50 af 0f 10       	push   $0x100faf50
 8051b0d:	68 18 af 0f 10       	push   $0x100faf18
 8051b12:	68 44 16 06 08       	push   $0x8061644
 8051b17:	6a 50                	push   $0x50
 8051b19:	68 00 8a 0c 08       	push   $0x80c8a00
 8051b1e:	e8 dd 6f ff ff       	call   8048b00 <snprintf@plt>
 8051b23:	83 c4 20             	add    $0x20,%esp
 8051b26:	83 f8 4f             	cmp    $0x4f,%eax
 8051b29:	0f 8e 7a ff ff ff    	jle    8051aa9 <cmovae_rm2r_l+0x49>
 8051b2f:	68 3b 25 06 08       	push   $0x806253b
 8051b34:	6a 06                	push   $0x6
 8051b36:	68 70 17 06 08       	push   $0x8061770
 8051b3b:	68 ac 1b 06 08       	push   $0x8061bac
 8051b40:	e8 6b 70 ff ff       	call   8048bb0 <__assert_fail@plt>
 8051b45:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051b48:	83 ec 08             	sub    $0x8,%esp
 8051b4b:	ff 35 14 af 0f 10    	pushl  0x100faf14
 8051b51:	68 40 af 0f 10       	push   $0x100faf40
 8051b56:	e8 45 b3 00 00       	call   805cea0 <write_operand_l>
 8051b5b:	83 c4 10             	add    $0x10,%esp
 8051b5e:	e9 20 ff ff ff       	jmp    8051a83 <cmovae_rm2r_l+0x23>
 8051b63:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051b69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051b70 <cmove_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051b70:	53                   	push   %ebx
 8051b71:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051b74:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051b78:	83 c0 01             	add    $0x1,%eax
 8051b7b:	50                   	push   %eax
 8051b7c:	e8 bf b0 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051b81:	83 c4 10             	add    $0x10,%esp
 8051b84:	f6 05 e4 af 0f 10 40 	testb  $0x40,0x100fafe4
 8051b8b:	89 c3                	mov    %eax,%ebx
 8051b8d:	0f 85 c5 00 00 00    	jne    8051c58 <cmove_rm2r_l+0xe8>
	print_asm_template2();
 8051b93:	83 ec 0c             	sub    $0xc,%esp
 8051b96:	68 50 af 0f 10       	push   $0x100faf50
 8051b9b:	68 18 af 0f 10       	push   $0x100faf18
 8051ba0:	68 52 16 06 08       	push   $0x8061652
 8051ba5:	6a 50                	push   $0x50
 8051ba7:	68 00 8a 0c 08       	push   $0x80c8a00
 8051bac:	e8 4f 6f ff ff       	call   8048b00 <snprintf@plt>
 8051bb1:	83 c4 20             	add    $0x20,%esp
 8051bb4:	83 f8 4f             	cmp    $0x4f,%eax
 8051bb7:	7f 0f                	jg     8051bc8 <cmove_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051bb9:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8051bbc:	8d 43 01             	lea    0x1(%ebx),%eax
 8051bbf:	5b                   	pop    %ebx
 8051bc0:	c3                   	ret    
 8051bc1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051bc8:	83 ec 0c             	sub    $0xc,%esp
 8051bcb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8051bd1:	e8 8a 6d ff ff       	call   8048960 <fflush@plt>
 8051bd6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051bdc:	6a 07                	push   $0x7
 8051bde:	6a 01                	push   $0x1
 8051be0:	68 92 e8 05 08       	push   $0x805e892
 8051be5:	e8 26 6e ff ff       	call   8048a10 <fwrite@plt>
 8051bea:	83 c4 20             	add    $0x20,%esp
 8051bed:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051bf3:	6a 10                	push   $0x10
 8051bf5:	6a 01                	push   $0x1
 8051bf7:	68 b4 f3 05 08       	push   $0x805f3b4
 8051bfc:	e8 0f 6e ff ff       	call   8048a10 <fwrite@plt>
 8051c01:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051c07:	6a 05                	push   $0x5
 8051c09:	6a 01                	push   $0x1
 8051c0b:	68 42 f3 05 08       	push   $0x805f342
 8051c10:	e8 fb 6d ff ff       	call   8048a10 <fwrite@plt>
 8051c15:	83 c4 14             	add    $0x14,%esp
 8051c18:	68 50 af 0f 10       	push   $0x100faf50
 8051c1d:	68 18 af 0f 10       	push   $0x100faf18
 8051c22:	68 52 16 06 08       	push   $0x8061652
 8051c27:	6a 50                	push   $0x50
 8051c29:	68 00 8a 0c 08       	push   $0x80c8a00
 8051c2e:	e8 cd 6e ff ff       	call   8048b00 <snprintf@plt>
 8051c33:	83 c4 20             	add    $0x20,%esp
 8051c36:	83 f8 4f             	cmp    $0x4f,%eax
 8051c39:	0f 8e 7a ff ff ff    	jle    8051bb9 <cmove_rm2r_l+0x49>
 8051c3f:	68 19 25 06 08       	push   $0x8062519
 8051c44:	6a 06                	push   $0x6
 8051c46:	68 70 17 06 08       	push   $0x8061770
 8051c4b:	68 14 1c 06 08       	push   $0x8061c14
 8051c50:	e8 5b 6f ff ff       	call   8048bb0 <__assert_fail@plt>
 8051c55:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051c58:	83 ec 08             	sub    $0x8,%esp
 8051c5b:	ff 35 14 af 0f 10    	pushl  0x100faf14
 8051c61:	68 40 af 0f 10       	push   $0x100faf40
 8051c66:	e8 35 b2 00 00       	call   805cea0 <write_operand_l>
 8051c6b:	83 c4 10             	add    $0x10,%esp
 8051c6e:	e9 20 ff ff ff       	jmp    8051b93 <cmove_rm2r_l+0x23>
 8051c73:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051c79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051c80 <cmovbe_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051c80:	53                   	push   %ebx
 8051c81:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051c84:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051c88:	83 c0 01             	add    $0x1,%eax
 8051c8b:	50                   	push   %eax
 8051c8c:	e8 af af 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051c91:	83 c4 10             	add    $0x10,%esp
 8051c94:	f6 05 e4 af 0f 10 41 	testb  $0x41,0x100fafe4
 8051c9b:	89 c3                	mov    %eax,%ebx
 8051c9d:	0f 85 c5 00 00 00    	jne    8051d68 <cmovbe_rm2r_l+0xe8>
	print_asm_template2();
 8051ca3:	83 ec 0c             	sub    $0xc,%esp
 8051ca6:	68 50 af 0f 10       	push   $0x100faf50
 8051cab:	68 18 af 0f 10       	push   $0x100faf18
 8051cb0:	68 5f 16 06 08       	push   $0x806165f
 8051cb5:	6a 50                	push   $0x50
 8051cb7:	68 00 8a 0c 08       	push   $0x80c8a00
 8051cbc:	e8 3f 6e ff ff       	call   8048b00 <snprintf@plt>
 8051cc1:	83 c4 20             	add    $0x20,%esp
 8051cc4:	83 f8 4f             	cmp    $0x4f,%eax
 8051cc7:	7f 0f                	jg     8051cd8 <cmovbe_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8051cc9:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8051ccc:	8d 43 01             	lea    0x1(%ebx),%eax
 8051ccf:	5b                   	pop    %ebx
 8051cd0:	c3                   	ret    
 8051cd1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051cd8:	83 ec 0c             	sub    $0xc,%esp
 8051cdb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8051ce1:	e8 7a 6c ff ff       	call   8048960 <fflush@plt>
 8051ce6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051cec:	6a 07                	push   $0x7
 8051cee:	6a 01                	push   $0x1
 8051cf0:	68 92 e8 05 08       	push   $0x805e892
 8051cf5:	e8 16 6d ff ff       	call   8048a10 <fwrite@plt>
 8051cfa:	83 c4 20             	add    $0x20,%esp
 8051cfd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051d03:	6a 10                	push   $0x10
 8051d05:	6a 01                	push   $0x1
 8051d07:	68 b4 f3 05 08       	push   $0x805f3b4
 8051d0c:	e8 ff 6c ff ff       	call   8048a10 <fwrite@plt>
 8051d11:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051d17:	6a 05                	push   $0x5
 8051d19:	6a 01                	push   $0x1
 8051d1b:	68 42 f3 05 08       	push   $0x805f342
 8051d20:	e8 eb 6c ff ff       	call   8048a10 <fwrite@plt>
 8051d25:	83 c4 14             	add    $0x14,%esp
 8051d28:	68 50 af 0f 10       	push   $0x100faf50
 8051d2d:	68 18 af 0f 10       	push   $0x100faf18
 8051d32:	68 5f 16 06 08       	push   $0x806165f
 8051d37:	6a 50                	push   $0x50
 8051d39:	68 00 8a 0c 08       	push   $0x80c8a00
 8051d3e:	e8 bd 6d ff ff       	call   8048b00 <snprintf@plt>
 8051d43:	83 c4 20             	add    $0x20,%esp
 8051d46:	83 f8 4f             	cmp    $0x4f,%eax
 8051d49:	0f 8e 7a ff ff ff    	jle    8051cc9 <cmovbe_rm2r_l+0x49>
 8051d4f:	68 24 25 06 08       	push   $0x8062524
 8051d54:	6a 06                	push   $0x6
 8051d56:	68 70 17 06 08       	push   $0x8061770
 8051d5b:	68 7c 1c 06 08       	push   $0x8061c7c
 8051d60:	e8 4b 6e ff ff       	call   8048bb0 <__assert_fail@plt>
 8051d65:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051d68:	83 ec 08             	sub    $0x8,%esp
 8051d6b:	ff 35 14 af 0f 10    	pushl  0x100faf14
 8051d71:	68 40 af 0f 10       	push   $0x100faf40
 8051d76:	e8 25 b1 00 00       	call   805cea0 <write_operand_l>
 8051d7b:	83 c4 10             	add    $0x10,%esp
 8051d7e:	e9 20 ff ff ff       	jmp    8051ca3 <cmovbe_rm2r_l+0x23>
 8051d83:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8051d89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051d90 <cmovge_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051d90:	53                   	push   %ebx
 8051d91:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051d94:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051d98:	83 c0 01             	add    $0x1,%eax
 8051d9b:	50                   	push   %eax
 8051d9c:	e8 cf aa 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051da1:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8051da8:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 8051daf:	83 c4 10             	add    $0x10,%esp
 8051db2:	89 c3                	mov    %eax,%ebx
 8051db4:	c0 ea 03             	shr    $0x3,%dl
 8051db7:	c0 e9 07             	shr    $0x7,%cl
 8051dba:	83 e2 01             	and    $0x1,%edx
 8051dbd:	38 d1                	cmp    %dl,%cl
 8051dbf:	0f 84 c3 00 00 00    	je     8051e88 <cmovge_rm2r_w+0xf8>
	print_asm_template2();
 8051dc5:	83 ec 0c             	sub    $0xc,%esp
 8051dc8:	68 50 af 0f 10       	push   $0x100faf50
 8051dcd:	68 18 af 0f 10       	push   $0x100faf18
 8051dd2:	68 6d 16 06 08       	push   $0x806166d
 8051dd7:	6a 50                	push   $0x50
 8051dd9:	68 00 8a 0c 08       	push   $0x80c8a00
 8051dde:	e8 1d 6d ff ff       	call   8048b00 <snprintf@plt>
 8051de3:	83 c4 20             	add    $0x20,%esp
 8051de6:	83 f8 4f             	cmp    $0x4f,%eax
 8051de9:	7f 0d                	jg     8051df8 <cmovge_rm2r_w+0x68>
}

make_instr_helper(rm2r)
 8051deb:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8051dee:	8d 43 01             	lea    0x1(%ebx),%eax
 8051df1:	5b                   	pop    %ebx
 8051df2:	c3                   	ret    
 8051df3:	90                   	nop
 8051df4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051df8:	83 ec 0c             	sub    $0xc,%esp
 8051dfb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8051e01:	e8 5a 6b ff ff       	call   8048960 <fflush@plt>
 8051e06:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051e0c:	6a 07                	push   $0x7
 8051e0e:	6a 01                	push   $0x1
 8051e10:	68 92 e8 05 08       	push   $0x805e892
 8051e15:	e8 f6 6b ff ff       	call   8048a10 <fwrite@plt>
 8051e1a:	83 c4 20             	add    $0x20,%esp
 8051e1d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051e23:	6a 10                	push   $0x10
 8051e25:	6a 01                	push   $0x1
 8051e27:	68 b4 f3 05 08       	push   $0x805f3b4
 8051e2c:	e8 df 6b ff ff       	call   8048a10 <fwrite@plt>
 8051e31:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051e37:	6a 05                	push   $0x5
 8051e39:	6a 01                	push   $0x1
 8051e3b:	68 42 f3 05 08       	push   $0x805f342
 8051e40:	e8 cb 6b ff ff       	call   8048a10 <fwrite@plt>
 8051e45:	83 c4 14             	add    $0x14,%esp
 8051e48:	68 50 af 0f 10       	push   $0x100faf50
 8051e4d:	68 18 af 0f 10       	push   $0x100faf18
 8051e52:	68 6d 16 06 08       	push   $0x806166d
 8051e57:	6a 50                	push   $0x50
 8051e59:	68 00 8a 0c 08       	push   $0x80c8a00
 8051e5e:	e8 9d 6c ff ff       	call   8048b00 <snprintf@plt>
 8051e63:	83 c4 20             	add    $0x20,%esp
 8051e66:	83 f8 4f             	cmp    $0x4f,%eax
 8051e69:	7e 80                	jle    8051deb <cmovge_rm2r_w+0x5b>
 8051e6b:	68 ba 25 06 08       	push   $0x80625ba
 8051e70:	6a 06                	push   $0x6
 8051e72:	68 70 17 06 08       	push   $0x8061770
 8051e77:	68 e4 1c 06 08       	push   $0x8061ce4
 8051e7c:	e8 2f 6d ff ff       	call   8048bb0 <__assert_fail@plt>
 8051e81:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8051e88:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051e8f:	83 ec 08             	sub    $0x8,%esp
 8051e92:	50                   	push   %eax
 8051e93:	68 40 af 0f 10       	push   $0x100faf40
 8051e98:	e8 33 ac 00 00       	call   805cad0 <write_operand_w>
 8051e9d:	83 c4 10             	add    $0x10,%esp
 8051ea0:	e9 20 ff ff ff       	jmp    8051dc5 <cmovge_rm2r_w+0x35>
 8051ea5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8051ea9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08051eb0 <cmovl_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8051eb0:	53                   	push   %ebx
 8051eb1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051eb4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051eb8:	83 c0 01             	add    $0x1,%eax
 8051ebb:	50                   	push   %eax
 8051ebc:	e8 7f ad 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051ec1:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8051ec8:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 8051ecf:	83 c4 10             	add    $0x10,%esp
 8051ed2:	89 c3                	mov    %eax,%ebx
 8051ed4:	c0 ea 03             	shr    $0x3,%dl
 8051ed7:	c0 e9 07             	shr    $0x7,%cl
 8051eda:	83 e2 01             	and    $0x1,%edx
 8051edd:	38 d1                	cmp    %dl,%cl
 8051edf:	74 16                	je     8051ef7 <cmovl_rm2r_l+0x47>
 8051ee1:	83 ec 08             	sub    $0x8,%esp
 8051ee4:	ff 35 14 af 0f 10    	pushl  0x100faf14
 8051eea:	68 40 af 0f 10       	push   $0x100faf40
 8051eef:	e8 ac af 00 00       	call   805cea0 <write_operand_l>
 8051ef4:	83 c4 10             	add    $0x10,%esp
	print_asm_template2();
 8051ef7:	83 ec 0c             	sub    $0xc,%esp
 8051efa:	68 50 af 0f 10       	push   $0x100faf50
 8051eff:	68 18 af 0f 10       	push   $0x100faf18
 8051f04:	68 7b 16 06 08       	push   $0x806167b
 8051f09:	6a 50                	push   $0x50
 8051f0b:	68 00 8a 0c 08       	push   $0x80c8a00
 8051f10:	e8 eb 6b ff ff       	call   8048b00 <snprintf@plt>
 8051f15:	83 c4 20             	add    $0x20,%esp
 8051f18:	83 f8 4f             	cmp    $0x4f,%eax
 8051f1b:	7f 0b                	jg     8051f28 <cmovl_rm2r_l+0x78>
}

make_instr_helper(rm2r)
 8051f1d:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8051f20:	8d 43 01             	lea    0x1(%ebx),%eax
 8051f23:	5b                   	pop    %ebx
 8051f24:	c3                   	ret    
 8051f25:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8051f28:	83 ec 0c             	sub    $0xc,%esp
 8051f2b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8051f31:	e8 2a 6a ff ff       	call   8048960 <fflush@plt>
 8051f36:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051f3c:	6a 07                	push   $0x7
 8051f3e:	6a 01                	push   $0x1
 8051f40:	68 92 e8 05 08       	push   $0x805e892
 8051f45:	e8 c6 6a ff ff       	call   8048a10 <fwrite@plt>
 8051f4a:	83 c4 20             	add    $0x20,%esp
 8051f4d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051f53:	6a 10                	push   $0x10
 8051f55:	6a 01                	push   $0x1
 8051f57:	68 b4 f3 05 08       	push   $0x805f3b4
 8051f5c:	e8 af 6a ff ff       	call   8048a10 <fwrite@plt>
 8051f61:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8051f67:	6a 05                	push   $0x5
 8051f69:	6a 01                	push   $0x1
 8051f6b:	68 42 f3 05 08       	push   $0x805f342
 8051f70:	e8 9b 6a ff ff       	call   8048a10 <fwrite@plt>
 8051f75:	83 c4 14             	add    $0x14,%esp
 8051f78:	68 50 af 0f 10       	push   $0x100faf50
 8051f7d:	68 18 af 0f 10       	push   $0x100faf18
 8051f82:	68 7b 16 06 08       	push   $0x806167b
 8051f87:	6a 50                	push   $0x50
 8051f89:	68 00 8a 0c 08       	push   $0x80c8a00
 8051f8e:	e8 6d 6b ff ff       	call   8048b00 <snprintf@plt>
 8051f93:	83 c4 20             	add    $0x20,%esp
 8051f96:	83 f8 4f             	cmp    $0x4f,%eax
 8051f99:	7e 82                	jle    8051f1d <cmovl_rm2r_l+0x6d>
 8051f9b:	68 f7 24 06 08       	push   $0x80624f7
 8051fa0:	6a 06                	push   $0x6
 8051fa2:	68 70 17 06 08       	push   $0x8061770
 8051fa7:	68 4c 1d 06 08       	push   $0x8061d4c
 8051fac:	e8 ff 6b ff ff       	call   8048bb0 <__assert_fail@plt>
 8051fb1:	eb 0d                	jmp    8051fc0 <cmovb_rm2r_w>
 8051fb3:	90                   	nop
 8051fb4:	90                   	nop
 8051fb5:	90                   	nop
 8051fb6:	90                   	nop
 8051fb7:	90                   	nop
 8051fb8:	90                   	nop
 8051fb9:	90                   	nop
 8051fba:	90                   	nop
 8051fbb:	90                   	nop
 8051fbc:	90                   	nop
 8051fbd:	90                   	nop
 8051fbe:	90                   	nop
 8051fbf:	90                   	nop

08051fc0 <cmovb_rm2r_w>:
}

make_instr_helper(rm2r)
 8051fc0:	53                   	push   %ebx
 8051fc1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8051fc4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8051fc8:	83 c0 01             	add    $0x1,%eax
 8051fcb:	50                   	push   %eax
 8051fcc:	e8 9f a8 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8051fd1:	83 c4 10             	add    $0x10,%esp
 8051fd4:	f6 05 e4 af 0f 10 01 	testb  $0x1,0x100fafe4
 8051fdb:	89 c3                	mov    %eax,%ebx
 8051fdd:	0f 85 c5 00 00 00    	jne    80520a8 <cmovb_rm2r_w+0xe8>
	print_asm_template2();
 8051fe3:	83 ec 0c             	sub    $0xc,%esp
 8051fe6:	68 50 af 0f 10       	push   $0x100faf50
 8051feb:	68 18 af 0f 10       	push   $0x100faf18
 8051ff0:	68 88 16 06 08       	push   $0x8061688
 8051ff5:	6a 50                	push   $0x50
 8051ff7:	68 00 8a 0c 08       	push   $0x80c8a00
 8051ffc:	e8 ff 6a ff ff       	call   8048b00 <snprintf@plt>
 8052001:	83 c4 20             	add    $0x20,%esp
 8052004:	83 f8 4f             	cmp    $0x4f,%eax
 8052007:	7f 0f                	jg     8052018 <cmovb_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052009:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805200c:	8d 43 01             	lea    0x1(%ebx),%eax
 805200f:	5b                   	pop    %ebx
 8052010:	c3                   	ret    
 8052011:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052018:	83 ec 0c             	sub    $0xc,%esp
 805201b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8052021:	e8 3a 69 ff ff       	call   8048960 <fflush@plt>
 8052026:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805202c:	6a 07                	push   $0x7
 805202e:	6a 01                	push   $0x1
 8052030:	68 92 e8 05 08       	push   $0x805e892
 8052035:	e8 d6 69 ff ff       	call   8048a10 <fwrite@plt>
 805203a:	83 c4 20             	add    $0x20,%esp
 805203d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052043:	6a 10                	push   $0x10
 8052045:	6a 01                	push   $0x1
 8052047:	68 b4 f3 05 08       	push   $0x805f3b4
 805204c:	e8 bf 69 ff ff       	call   8048a10 <fwrite@plt>
 8052051:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052057:	6a 05                	push   $0x5
 8052059:	6a 01                	push   $0x1
 805205b:	68 42 f3 05 08       	push   $0x805f342
 8052060:	e8 ab 69 ff ff       	call   8048a10 <fwrite@plt>
 8052065:	83 c4 14             	add    $0x14,%esp
 8052068:	68 50 af 0f 10       	push   $0x100faf50
 805206d:	68 18 af 0f 10       	push   $0x100faf18
 8052072:	68 88 16 06 08       	push   $0x8061688
 8052077:	6a 50                	push   $0x50
 8052079:	68 00 8a 0c 08       	push   $0x80c8a00
 805207e:	e8 7d 6a ff ff       	call   8048b00 <snprintf@plt>
 8052083:	83 c4 20             	add    $0x20,%esp
 8052086:	83 f8 4f             	cmp    $0x4f,%eax
 8052089:	0f 8e 7a ff ff ff    	jle    8052009 <cmovb_rm2r_w+0x49>
 805208f:	68 e8 25 06 08       	push   $0x80625e8
 8052094:	6a 06                	push   $0x6
 8052096:	68 70 17 06 08       	push   $0x8061770
 805209b:	68 b4 1d 06 08       	push   $0x8061db4
 80520a0:	e8 0b 6b ff ff       	call   8048bb0 <__assert_fail@plt>
 80520a5:	8d 76 00             	lea    0x0(%esi),%esi
 80520a8:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80520af:	83 ec 08             	sub    $0x8,%esp
 80520b2:	50                   	push   %eax
 80520b3:	68 40 af 0f 10       	push   $0x100faf40
 80520b8:	e8 13 aa 00 00       	call   805cad0 <write_operand_w>
 80520bd:	83 c4 10             	add    $0x10,%esp
 80520c0:	e9 1e ff ff ff       	jmp    8051fe3 <cmovb_rm2r_w+0x23>
 80520c5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80520c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080520d0 <cmova_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80520d0:	53                   	push   %ebx
 80520d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80520d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80520d8:	83 c0 01             	add    $0x1,%eax
 80520db:	50                   	push   %eax
 80520dc:	e8 8f a7 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80520e1:	83 c4 10             	add    $0x10,%esp
 80520e4:	f6 05 e4 af 0f 10 41 	testb  $0x41,0x100fafe4
 80520eb:	89 c3                	mov    %eax,%ebx
 80520ed:	0f 84 c5 00 00 00    	je     80521b8 <cmova_rm2r_w+0xe8>
	print_asm_template2();
 80520f3:	83 ec 0c             	sub    $0xc,%esp
 80520f6:	68 50 af 0f 10       	push   $0x100faf50
 80520fb:	68 18 af 0f 10       	push   $0x100faf18
 8052100:	68 95 16 06 08       	push   $0x8061695
 8052105:	6a 50                	push   $0x50
 8052107:	68 00 8a 0c 08       	push   $0x80c8a00
 805210c:	e8 ef 69 ff ff       	call   8048b00 <snprintf@plt>
 8052111:	83 c4 20             	add    $0x20,%esp
 8052114:	83 f8 4f             	cmp    $0x4f,%eax
 8052117:	7f 0f                	jg     8052128 <cmova_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052119:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805211c:	8d 43 01             	lea    0x1(%ebx),%eax
 805211f:	5b                   	pop    %ebx
 8052120:	c3                   	ret    
 8052121:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052128:	83 ec 0c             	sub    $0xc,%esp
 805212b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8052131:	e8 2a 68 ff ff       	call   8048960 <fflush@plt>
 8052136:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805213c:	6a 07                	push   $0x7
 805213e:	6a 01                	push   $0x1
 8052140:	68 92 e8 05 08       	push   $0x805e892
 8052145:	e8 c6 68 ff ff       	call   8048a10 <fwrite@plt>
 805214a:	83 c4 20             	add    $0x20,%esp
 805214d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052153:	6a 10                	push   $0x10
 8052155:	6a 01                	push   $0x1
 8052157:	68 b4 f3 05 08       	push   $0x805f3b4
 805215c:	e8 af 68 ff ff       	call   8048a10 <fwrite@plt>
 8052161:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052167:	6a 05                	push   $0x5
 8052169:	6a 01                	push   $0x1
 805216b:	68 42 f3 05 08       	push   $0x805f342
 8052170:	e8 9b 68 ff ff       	call   8048a10 <fwrite@plt>
 8052175:	83 c4 14             	add    $0x14,%esp
 8052178:	68 50 af 0f 10       	push   $0x100faf50
 805217d:	68 18 af 0f 10       	push   $0x100faf18
 8052182:	68 95 16 06 08       	push   $0x8061695
 8052187:	6a 50                	push   $0x50
 8052189:	68 00 8a 0c 08       	push   $0x80c8a00
 805218e:	e8 6d 69 ff ff       	call   8048b00 <snprintf@plt>
 8052193:	83 c4 20             	add    $0x20,%esp
 8052196:	83 f8 4f             	cmp    $0x4f,%eax
 8052199:	0f 8e 7a ff ff ff    	jle    8052119 <cmova_rm2r_w+0x49>
 805219f:	68 ff 25 06 08       	push   $0x80625ff
 80521a4:	6a 06                	push   $0x6
 80521a6:	68 70 17 06 08       	push   $0x8061770
 80521ab:	68 1c 1e 06 08       	push   $0x8061e1c
 80521b0:	e8 fb 69 ff ff       	call   8048bb0 <__assert_fail@plt>
 80521b5:	8d 76 00             	lea    0x0(%esi),%esi
 80521b8:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80521bf:	83 ec 08             	sub    $0x8,%esp
 80521c2:	50                   	push   %eax
 80521c3:	68 40 af 0f 10       	push   $0x100faf40
 80521c8:	e8 03 a9 00 00       	call   805cad0 <write_operand_w>
 80521cd:	83 c4 10             	add    $0x10,%esp
 80521d0:	e9 1e ff ff ff       	jmp    80520f3 <cmova_rm2r_w+0x23>
 80521d5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80521d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080521e0 <cmove_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80521e0:	53                   	push   %ebx
 80521e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80521e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80521e8:	83 c0 01             	add    $0x1,%eax
 80521eb:	50                   	push   %eax
 80521ec:	e8 7f a6 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80521f1:	83 c4 10             	add    $0x10,%esp
 80521f4:	f6 05 e4 af 0f 10 40 	testb  $0x40,0x100fafe4
 80521fb:	89 c3                	mov    %eax,%ebx
 80521fd:	0f 85 c5 00 00 00    	jne    80522c8 <cmove_rm2r_w+0xe8>
	print_asm_template2();
 8052203:	83 ec 0c             	sub    $0xc,%esp
 8052206:	68 50 af 0f 10       	push   $0x100faf50
 805220b:	68 18 af 0f 10       	push   $0x100faf18
 8052210:	68 a2 16 06 08       	push   $0x80616a2
 8052215:	6a 50                	push   $0x50
 8052217:	68 00 8a 0c 08       	push   $0x80c8a00
 805221c:	e8 df 68 ff ff       	call   8048b00 <snprintf@plt>
 8052221:	83 c4 20             	add    $0x20,%esp
 8052224:	83 f8 4f             	cmp    $0x4f,%eax
 8052227:	7f 0f                	jg     8052238 <cmove_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052229:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805222c:	8d 43 01             	lea    0x1(%ebx),%eax
 805222f:	5b                   	pop    %ebx
 8052230:	c3                   	ret    
 8052231:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052238:	83 ec 0c             	sub    $0xc,%esp
 805223b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8052241:	e8 1a 67 ff ff       	call   8048960 <fflush@plt>
 8052246:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805224c:	6a 07                	push   $0x7
 805224e:	6a 01                	push   $0x1
 8052250:	68 92 e8 05 08       	push   $0x805e892
 8052255:	e8 b6 67 ff ff       	call   8048a10 <fwrite@plt>
 805225a:	83 c4 20             	add    $0x20,%esp
 805225d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052263:	6a 10                	push   $0x10
 8052265:	6a 01                	push   $0x1
 8052267:	68 b4 f3 05 08       	push   $0x805f3b4
 805226c:	e8 9f 67 ff ff       	call   8048a10 <fwrite@plt>
 8052271:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052277:	6a 05                	push   $0x5
 8052279:	6a 01                	push   $0x1
 805227b:	68 42 f3 05 08       	push   $0x805f342
 8052280:	e8 8b 67 ff ff       	call   8048a10 <fwrite@plt>
 8052285:	83 c4 14             	add    $0x14,%esp
 8052288:	68 50 af 0f 10       	push   $0x100faf50
 805228d:	68 18 af 0f 10       	push   $0x100faf18
 8052292:	68 a2 16 06 08       	push   $0x80616a2
 8052297:	6a 50                	push   $0x50
 8052299:	68 00 8a 0c 08       	push   $0x80c8a00
 805229e:	e8 5d 68 ff ff       	call   8048b00 <snprintf@plt>
 80522a3:	83 c4 20             	add    $0x20,%esp
 80522a6:	83 f8 4f             	cmp    $0x4f,%eax
 80522a9:	0f 8e 7a ff ff ff    	jle    8052229 <cmove_rm2r_w+0x49>
 80522af:	68 d1 25 06 08       	push   $0x80625d1
 80522b4:	6a 06                	push   $0x6
 80522b6:	68 70 17 06 08       	push   $0x8061770
 80522bb:	68 84 1e 06 08       	push   $0x8061e84
 80522c0:	e8 eb 68 ff ff       	call   8048bb0 <__assert_fail@plt>
 80522c5:	8d 76 00             	lea    0x0(%esi),%esi
 80522c8:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80522cf:	83 ec 08             	sub    $0x8,%esp
 80522d2:	50                   	push   %eax
 80522d3:	68 40 af 0f 10       	push   $0x100faf40
 80522d8:	e8 f3 a7 00 00       	call   805cad0 <write_operand_w>
 80522dd:	83 c4 10             	add    $0x10,%esp
 80522e0:	e9 1e ff ff ff       	jmp    8052203 <cmove_rm2r_w+0x23>
 80522e5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80522e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080522f0 <cmovae_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80522f0:	53                   	push   %ebx
 80522f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80522f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80522f8:	83 c0 01             	add    $0x1,%eax
 80522fb:	50                   	push   %eax
 80522fc:	e8 6f a5 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052301:	83 c4 10             	add    $0x10,%esp
 8052304:	f6 05 e4 af 0f 10 01 	testb  $0x1,0x100fafe4
 805230b:	89 c3                	mov    %eax,%ebx
 805230d:	0f 84 c5 00 00 00    	je     80523d8 <cmovae_rm2r_w+0xe8>
	print_asm_template2();
 8052313:	83 ec 0c             	sub    $0xc,%esp
 8052316:	68 50 af 0f 10       	push   $0x100faf50
 805231b:	68 18 af 0f 10       	push   $0x100faf18
 8052320:	68 af 16 06 08       	push   $0x80616af
 8052325:	6a 50                	push   $0x50
 8052327:	68 00 8a 0c 08       	push   $0x80c8a00
 805232c:	e8 cf 67 ff ff       	call   8048b00 <snprintf@plt>
 8052331:	83 c4 20             	add    $0x20,%esp
 8052334:	83 f8 4f             	cmp    $0x4f,%eax
 8052337:	7f 0f                	jg     8052348 <cmovae_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052339:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805233c:	8d 43 01             	lea    0x1(%ebx),%eax
 805233f:	5b                   	pop    %ebx
 8052340:	c3                   	ret    
 8052341:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052348:	83 ec 0c             	sub    $0xc,%esp
 805234b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8052351:	e8 0a 66 ff ff       	call   8048960 <fflush@plt>
 8052356:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805235c:	6a 07                	push   $0x7
 805235e:	6a 01                	push   $0x1
 8052360:	68 92 e8 05 08       	push   $0x805e892
 8052365:	e8 a6 66 ff ff       	call   8048a10 <fwrite@plt>
 805236a:	83 c4 20             	add    $0x20,%esp
 805236d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052373:	6a 10                	push   $0x10
 8052375:	6a 01                	push   $0x1
 8052377:	68 b4 f3 05 08       	push   $0x805f3b4
 805237c:	e8 8f 66 ff ff       	call   8048a10 <fwrite@plt>
 8052381:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052387:	6a 05                	push   $0x5
 8052389:	6a 01                	push   $0x1
 805238b:	68 42 f3 05 08       	push   $0x805f342
 8052390:	e8 7b 66 ff ff       	call   8048a10 <fwrite@plt>
 8052395:	83 c4 14             	add    $0x14,%esp
 8052398:	68 50 af 0f 10       	push   $0x100faf50
 805239d:	68 18 af 0f 10       	push   $0x100faf18
 80523a2:	68 af 16 06 08       	push   $0x80616af
 80523a7:	6a 50                	push   $0x50
 80523a9:	68 00 8a 0c 08       	push   $0x80c8a00
 80523ae:	e8 4d 67 ff ff       	call   8048b00 <snprintf@plt>
 80523b3:	83 c4 20             	add    $0x20,%esp
 80523b6:	83 f8 4f             	cmp    $0x4f,%eax
 80523b9:	0f 8e 7a ff ff ff    	jle    8052339 <cmovae_rm2r_w+0x49>
 80523bf:	68 f3 25 06 08       	push   $0x80625f3
 80523c4:	6a 06                	push   $0x6
 80523c6:	68 70 17 06 08       	push   $0x8061770
 80523cb:	68 ec 1e 06 08       	push   $0x8061eec
 80523d0:	e8 db 67 ff ff       	call   8048bb0 <__assert_fail@plt>
 80523d5:	8d 76 00             	lea    0x0(%esi),%esi
 80523d8:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80523df:	83 ec 08             	sub    $0x8,%esp
 80523e2:	50                   	push   %eax
 80523e3:	68 40 af 0f 10       	push   $0x100faf40
 80523e8:	e8 e3 a6 00 00       	call   805cad0 <write_operand_w>
 80523ed:	83 c4 10             	add    $0x10,%esp
 80523f0:	e9 1e ff ff ff       	jmp    8052313 <cmovae_rm2r_w+0x23>
 80523f5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80523f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052400 <cmovbe_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052400:	53                   	push   %ebx
 8052401:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052404:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052408:	83 c0 01             	add    $0x1,%eax
 805240b:	50                   	push   %eax
 805240c:	e8 5f a4 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052411:	83 c4 10             	add    $0x10,%esp
 8052414:	f6 05 e4 af 0f 10 41 	testb  $0x41,0x100fafe4
 805241b:	89 c3                	mov    %eax,%ebx
 805241d:	0f 85 c5 00 00 00    	jne    80524e8 <cmovbe_rm2r_w+0xe8>
	print_asm_template2();
 8052423:	83 ec 0c             	sub    $0xc,%esp
 8052426:	68 50 af 0f 10       	push   $0x100faf50
 805242b:	68 18 af 0f 10       	push   $0x100faf18
 8052430:	68 bd 16 06 08       	push   $0x80616bd
 8052435:	6a 50                	push   $0x50
 8052437:	68 00 8a 0c 08       	push   $0x80c8a00
 805243c:	e8 bf 66 ff ff       	call   8048b00 <snprintf@plt>
 8052441:	83 c4 20             	add    $0x20,%esp
 8052444:	83 f8 4f             	cmp    $0x4f,%eax
 8052447:	7f 0f                	jg     8052458 <cmovbe_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052449:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805244c:	8d 43 01             	lea    0x1(%ebx),%eax
 805244f:	5b                   	pop    %ebx
 8052450:	c3                   	ret    
 8052451:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052458:	83 ec 0c             	sub    $0xc,%esp
 805245b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8052461:	e8 fa 64 ff ff       	call   8048960 <fflush@plt>
 8052466:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805246c:	6a 07                	push   $0x7
 805246e:	6a 01                	push   $0x1
 8052470:	68 92 e8 05 08       	push   $0x805e892
 8052475:	e8 96 65 ff ff       	call   8048a10 <fwrite@plt>
 805247a:	83 c4 20             	add    $0x20,%esp
 805247d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052483:	6a 10                	push   $0x10
 8052485:	6a 01                	push   $0x1
 8052487:	68 b4 f3 05 08       	push   $0x805f3b4
 805248c:	e8 7f 65 ff ff       	call   8048a10 <fwrite@plt>
 8052491:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052497:	6a 05                	push   $0x5
 8052499:	6a 01                	push   $0x1
 805249b:	68 42 f3 05 08       	push   $0x805f342
 80524a0:	e8 6b 65 ff ff       	call   8048a10 <fwrite@plt>
 80524a5:	83 c4 14             	add    $0x14,%esp
 80524a8:	68 50 af 0f 10       	push   $0x100faf50
 80524ad:	68 18 af 0f 10       	push   $0x100faf18
 80524b2:	68 bd 16 06 08       	push   $0x80616bd
 80524b7:	6a 50                	push   $0x50
 80524b9:	68 00 8a 0c 08       	push   $0x80c8a00
 80524be:	e8 3d 66 ff ff       	call   8048b00 <snprintf@plt>
 80524c3:	83 c4 20             	add    $0x20,%esp
 80524c6:	83 f8 4f             	cmp    $0x4f,%eax
 80524c9:	0f 8e 7a ff ff ff    	jle    8052449 <cmovbe_rm2r_w+0x49>
 80524cf:	68 dc 25 06 08       	push   $0x80625dc
 80524d4:	6a 06                	push   $0x6
 80524d6:	68 70 17 06 08       	push   $0x8061770
 80524db:	68 54 1f 06 08       	push   $0x8061f54
 80524e0:	e8 cb 66 ff ff       	call   8048bb0 <__assert_fail@plt>
 80524e5:	8d 76 00             	lea    0x0(%esi),%esi
 80524e8:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80524ef:	83 ec 08             	sub    $0x8,%esp
 80524f2:	50                   	push   %eax
 80524f3:	68 40 af 0f 10       	push   $0x100faf40
 80524f8:	e8 d3 a5 00 00       	call   805cad0 <write_operand_w>
 80524fd:	83 c4 10             	add    $0x10,%esp
 8052500:	e9 1e ff ff ff       	jmp    8052423 <cmovbe_rm2r_w+0x23>
 8052505:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8052509:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052510 <cmovp_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052510:	53                   	push   %ebx
 8052511:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052514:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052518:	83 c0 01             	add    $0x1,%eax
 805251b:	50                   	push   %eax
 805251c:	e8 4f a3 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052521:	83 c4 10             	add    $0x10,%esp
 8052524:	f6 05 e4 af 0f 10 04 	testb  $0x4,0x100fafe4
 805252b:	89 c3                	mov    %eax,%ebx
 805252d:	0f 85 c5 00 00 00    	jne    80525f8 <cmovp_rm2r_w+0xe8>
	print_asm_template2();
 8052533:	83 ec 0c             	sub    $0xc,%esp
 8052536:	68 50 af 0f 10       	push   $0x100faf50
 805253b:	68 18 af 0f 10       	push   $0x100faf18
 8052540:	68 cb 16 06 08       	push   $0x80616cb
 8052545:	6a 50                	push   $0x50
 8052547:	68 00 8a 0c 08       	push   $0x80c8a00
 805254c:	e8 af 65 ff ff       	call   8048b00 <snprintf@plt>
 8052551:	83 c4 20             	add    $0x20,%esp
 8052554:	83 f8 4f             	cmp    $0x4f,%eax
 8052557:	7f 0f                	jg     8052568 <cmovp_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052559:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805255c:	8d 43 01             	lea    0x1(%ebx),%eax
 805255f:	5b                   	pop    %ebx
 8052560:	c3                   	ret    
 8052561:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052568:	83 ec 0c             	sub    $0xc,%esp
 805256b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8052571:	e8 ea 63 ff ff       	call   8048960 <fflush@plt>
 8052576:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805257c:	6a 07                	push   $0x7
 805257e:	6a 01                	push   $0x1
 8052580:	68 92 e8 05 08       	push   $0x805e892
 8052585:	e8 86 64 ff ff       	call   8048a10 <fwrite@plt>
 805258a:	83 c4 20             	add    $0x20,%esp
 805258d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052593:	6a 10                	push   $0x10
 8052595:	6a 01                	push   $0x1
 8052597:	68 b4 f3 05 08       	push   $0x805f3b4
 805259c:	e8 6f 64 ff ff       	call   8048a10 <fwrite@plt>
 80525a1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80525a7:	6a 05                	push   $0x5
 80525a9:	6a 01                	push   $0x1
 80525ab:	68 42 f3 05 08       	push   $0x805f342
 80525b0:	e8 5b 64 ff ff       	call   8048a10 <fwrite@plt>
 80525b5:	83 c4 14             	add    $0x14,%esp
 80525b8:	68 50 af 0f 10       	push   $0x100faf50
 80525bd:	68 18 af 0f 10       	push   $0x100faf18
 80525c2:	68 cb 16 06 08       	push   $0x80616cb
 80525c7:	6a 50                	push   $0x50
 80525c9:	68 00 8a 0c 08       	push   $0x80c8a00
 80525ce:	e8 2d 65 ff ff       	call   8048b00 <snprintf@plt>
 80525d3:	83 c4 20             	add    $0x20,%esp
 80525d6:	83 f8 4f             	cmp    $0x4f,%eax
 80525d9:	0f 8e 7a ff ff ff    	jle    8052559 <cmovp_rm2r_w+0x49>
 80525df:	68 5d 25 06 08       	push   $0x806255d
 80525e4:	6a 06                	push   $0x6
 80525e6:	68 70 17 06 08       	push   $0x8061770
 80525eb:	68 bc 1f 06 08       	push   $0x8061fbc
 80525f0:	e8 bb 65 ff ff       	call   8048bb0 <__assert_fail@plt>
 80525f5:	8d 76 00             	lea    0x0(%esi),%esi
 80525f8:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80525ff:	83 ec 08             	sub    $0x8,%esp
 8052602:	50                   	push   %eax
 8052603:	68 40 af 0f 10       	push   $0x100faf40
 8052608:	e8 c3 a4 00 00       	call   805cad0 <write_operand_w>
 805260d:	83 c4 10             	add    $0x10,%esp
 8052610:	e9 1e ff ff ff       	jmp    8052533 <cmovp_rm2r_w+0x23>
 8052615:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8052619:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052620 <cmovno_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052620:	53                   	push   %ebx
 8052621:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052624:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052628:	83 c0 01             	add    $0x1,%eax
 805262b:	50                   	push   %eax
 805262c:	e8 3f a2 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052631:	83 c4 10             	add    $0x10,%esp
 8052634:	f6 05 e5 af 0f 10 08 	testb  $0x8,0x100fafe5
 805263b:	89 c3                	mov    %eax,%ebx
 805263d:	0f 84 c5 00 00 00    	je     8052708 <cmovno_rm2r_w+0xe8>
	print_asm_template2();
 8052643:	83 ec 0c             	sub    $0xc,%esp
 8052646:	68 50 af 0f 10       	push   $0x100faf50
 805264b:	68 18 af 0f 10       	push   $0x100faf18
 8052650:	68 d8 16 06 08       	push   $0x80616d8
 8052655:	6a 50                	push   $0x50
 8052657:	68 00 8a 0c 08       	push   $0x80c8a00
 805265c:	e8 9f 64 ff ff       	call   8048b00 <snprintf@plt>
 8052661:	83 c4 20             	add    $0x20,%esp
 8052664:	83 f8 4f             	cmp    $0x4f,%eax
 8052667:	7f 0f                	jg     8052678 <cmovno_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052669:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805266c:	8d 43 01             	lea    0x1(%ebx),%eax
 805266f:	5b                   	pop    %ebx
 8052670:	c3                   	ret    
 8052671:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052678:	83 ec 0c             	sub    $0xc,%esp
 805267b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8052681:	e8 da 62 ff ff       	call   8048960 <fflush@plt>
 8052686:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805268c:	6a 07                	push   $0x7
 805268e:	6a 01                	push   $0x1
 8052690:	68 92 e8 05 08       	push   $0x805e892
 8052695:	e8 76 63 ff ff       	call   8048a10 <fwrite@plt>
 805269a:	83 c4 20             	add    $0x20,%esp
 805269d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80526a3:	6a 10                	push   $0x10
 80526a5:	6a 01                	push   $0x1
 80526a7:	68 b4 f3 05 08       	push   $0x805f3b4
 80526ac:	e8 5f 63 ff ff       	call   8048a10 <fwrite@plt>
 80526b1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80526b7:	6a 05                	push   $0x5
 80526b9:	6a 01                	push   $0x1
 80526bb:	68 42 f3 05 08       	push   $0x805f342
 80526c0:	e8 4b 63 ff ff       	call   8048a10 <fwrite@plt>
 80526c5:	83 c4 14             	add    $0x14,%esp
 80526c8:	68 50 af 0f 10       	push   $0x100faf50
 80526cd:	68 18 af 0f 10       	push   $0x100faf18
 80526d2:	68 d8 16 06 08       	push   $0x80616d8
 80526d7:	6a 50                	push   $0x50
 80526d9:	68 00 8a 0c 08       	push   $0x80c8a00
 80526de:	e8 1d 64 ff ff       	call   8048b00 <snprintf@plt>
 80526e3:	83 c4 20             	add    $0x20,%esp
 80526e6:	83 f8 4f             	cmp    $0x4f,%eax
 80526e9:	0f 8e 7a ff ff ff    	jle    8052669 <cmovno_rm2r_w+0x49>
 80526ef:	68 8b 25 06 08       	push   $0x806258b
 80526f4:	6a 06                	push   $0x6
 80526f6:	68 70 17 06 08       	push   $0x8061770
 80526fb:	68 24 20 06 08       	push   $0x8062024
 8052700:	e8 ab 64 ff ff       	call   8048bb0 <__assert_fail@plt>
 8052705:	8d 76 00             	lea    0x0(%esi),%esi
 8052708:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 805270f:	83 ec 08             	sub    $0x8,%esp
 8052712:	50                   	push   %eax
 8052713:	68 40 af 0f 10       	push   $0x100faf40
 8052718:	e8 b3 a3 00 00       	call   805cad0 <write_operand_w>
 805271d:	83 c4 10             	add    $0x10,%esp
 8052720:	e9 1e ff ff ff       	jmp    8052643 <cmovno_rm2r_w+0x23>
 8052725:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8052729:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052730 <cmovs_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052730:	53                   	push   %ebx
 8052731:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052734:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052738:	83 c0 01             	add    $0x1,%eax
 805273b:	50                   	push   %eax
 805273c:	e8 2f a1 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052741:	83 c4 10             	add    $0x10,%esp
 8052744:	80 3d e4 af 0f 10 00 	cmpb   $0x0,0x100fafe4
 805274b:	89 c3                	mov    %eax,%ebx
 805274d:	0f 88 c5 00 00 00    	js     8052818 <cmovs_rm2r_w+0xe8>
	print_asm_template2();
 8052753:	83 ec 0c             	sub    $0xc,%esp
 8052756:	68 50 af 0f 10       	push   $0x100faf50
 805275b:	68 18 af 0f 10       	push   $0x100faf18
 8052760:	68 e6 16 06 08       	push   $0x80616e6
 8052765:	6a 50                	push   $0x50
 8052767:	68 00 8a 0c 08       	push   $0x80c8a00
 805276c:	e8 8f 63 ff ff       	call   8048b00 <snprintf@plt>
 8052771:	83 c4 20             	add    $0x20,%esp
 8052774:	83 f8 4f             	cmp    $0x4f,%eax
 8052777:	7f 0f                	jg     8052788 <cmovs_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052779:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805277c:	8d 43 01             	lea    0x1(%ebx),%eax
 805277f:	5b                   	pop    %ebx
 8052780:	c3                   	ret    
 8052781:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052788:	83 ec 0c             	sub    $0xc,%esp
 805278b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8052791:	e8 ca 61 ff ff       	call   8048960 <fflush@plt>
 8052796:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805279c:	6a 07                	push   $0x7
 805279e:	6a 01                	push   $0x1
 80527a0:	68 92 e8 05 08       	push   $0x805e892
 80527a5:	e8 66 62 ff ff       	call   8048a10 <fwrite@plt>
 80527aa:	83 c4 20             	add    $0x20,%esp
 80527ad:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80527b3:	6a 10                	push   $0x10
 80527b5:	6a 01                	push   $0x1
 80527b7:	68 b4 f3 05 08       	push   $0x805f3b4
 80527bc:	e8 4f 62 ff ff       	call   8048a10 <fwrite@plt>
 80527c1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80527c7:	6a 05                	push   $0x5
 80527c9:	6a 01                	push   $0x1
 80527cb:	68 42 f3 05 08       	push   $0x805f342
 80527d0:	e8 3b 62 ff ff       	call   8048a10 <fwrite@plt>
 80527d5:	83 c4 14             	add    $0x14,%esp
 80527d8:	68 50 af 0f 10       	push   $0x100faf50
 80527dd:	68 18 af 0f 10       	push   $0x100faf18
 80527e2:	68 e6 16 06 08       	push   $0x80616e6
 80527e7:	6a 50                	push   $0x50
 80527e9:	68 00 8a 0c 08       	push   $0x80c8a00
 80527ee:	e8 0d 63 ff ff       	call   8048b00 <snprintf@plt>
 80527f3:	83 c4 20             	add    $0x20,%esp
 80527f6:	83 f8 4f             	cmp    $0x4f,%eax
 80527f9:	0f 8e 7a ff ff ff    	jle    8052779 <cmovs_rm2r_w+0x49>
 80527ff:	68 52 25 06 08       	push   $0x8062552
 8052804:	6a 06                	push   $0x6
 8052806:	68 70 17 06 08       	push   $0x8061770
 805280b:	68 8c 20 06 08       	push   $0x806208c
 8052810:	e8 9b 63 ff ff       	call   8048bb0 <__assert_fail@plt>
 8052815:	8d 76 00             	lea    0x0(%esi),%esi
 8052818:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 805281f:	83 ec 08             	sub    $0x8,%esp
 8052822:	50                   	push   %eax
 8052823:	68 40 af 0f 10       	push   $0x100faf40
 8052828:	e8 a3 a2 00 00       	call   805cad0 <write_operand_w>
 805282d:	83 c4 10             	add    $0x10,%esp
 8052830:	e9 1e ff ff ff       	jmp    8052753 <cmovs_rm2r_w+0x23>
 8052835:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8052839:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052840 <cmovne_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052840:	53                   	push   %ebx
 8052841:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052844:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052848:	83 c0 01             	add    $0x1,%eax
 805284b:	50                   	push   %eax
 805284c:	e8 1f a0 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052851:	83 c4 10             	add    $0x10,%esp
 8052854:	f6 05 e4 af 0f 10 40 	testb  $0x40,0x100fafe4
 805285b:	89 c3                	mov    %eax,%ebx
 805285d:	0f 84 c5 00 00 00    	je     8052928 <cmovne_rm2r_w+0xe8>
	print_asm_template2();
 8052863:	83 ec 0c             	sub    $0xc,%esp
 8052866:	68 50 af 0f 10       	push   $0x100faf50
 805286b:	68 18 af 0f 10       	push   $0x100faf18
 8052870:	68 f3 16 06 08       	push   $0x80616f3
 8052875:	6a 50                	push   $0x50
 8052877:	68 00 8a 0c 08       	push   $0x80c8a00
 805287c:	e8 7f 62 ff ff       	call   8048b00 <snprintf@plt>
 8052881:	83 c4 20             	add    $0x20,%esp
 8052884:	83 f8 4f             	cmp    $0x4f,%eax
 8052887:	7f 0f                	jg     8052898 <cmovne_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052889:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805288c:	8d 43 01             	lea    0x1(%ebx),%eax
 805288f:	5b                   	pop    %ebx
 8052890:	c3                   	ret    
 8052891:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052898:	83 ec 0c             	sub    $0xc,%esp
 805289b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80528a1:	e8 ba 60 ff ff       	call   8048960 <fflush@plt>
 80528a6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80528ac:	6a 07                	push   $0x7
 80528ae:	6a 01                	push   $0x1
 80528b0:	68 92 e8 05 08       	push   $0x805e892
 80528b5:	e8 56 61 ff ff       	call   8048a10 <fwrite@plt>
 80528ba:	83 c4 20             	add    $0x20,%esp
 80528bd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80528c3:	6a 10                	push   $0x10
 80528c5:	6a 01                	push   $0x1
 80528c7:	68 b4 f3 05 08       	push   $0x805f3b4
 80528cc:	e8 3f 61 ff ff       	call   8048a10 <fwrite@plt>
 80528d1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80528d7:	6a 05                	push   $0x5
 80528d9:	6a 01                	push   $0x1
 80528db:	68 42 f3 05 08       	push   $0x805f342
 80528e0:	e8 2b 61 ff ff       	call   8048a10 <fwrite@plt>
 80528e5:	83 c4 14             	add    $0x14,%esp
 80528e8:	68 50 af 0f 10       	push   $0x100faf50
 80528ed:	68 18 af 0f 10       	push   $0x100faf18
 80528f2:	68 f3 16 06 08       	push   $0x80616f3
 80528f7:	6a 50                	push   $0x50
 80528f9:	68 00 8a 0c 08       	push   $0x80c8a00
 80528fe:	e8 fd 61 ff ff       	call   8048b00 <snprintf@plt>
 8052903:	83 c4 20             	add    $0x20,%esp
 8052906:	83 f8 4f             	cmp    $0x4f,%eax
 8052909:	0f 8e 7a ff ff ff    	jle    8052889 <cmovne_rm2r_w+0x49>
 805290f:	68 97 25 06 08       	push   $0x8062597
 8052914:	6a 06                	push   $0x6
 8052916:	68 70 17 06 08       	push   $0x8061770
 805291b:	68 f4 20 06 08       	push   $0x80620f4
 8052920:	e8 8b 62 ff ff       	call   8048bb0 <__assert_fail@plt>
 8052925:	8d 76 00             	lea    0x0(%esi),%esi
 8052928:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 805292f:	83 ec 08             	sub    $0x8,%esp
 8052932:	50                   	push   %eax
 8052933:	68 40 af 0f 10       	push   $0x100faf40
 8052938:	e8 93 a1 00 00       	call   805cad0 <write_operand_w>
 805293d:	83 c4 10             	add    $0x10,%esp
 8052940:	e9 1e ff ff ff       	jmp    8052863 <cmovne_rm2r_w+0x23>
 8052945:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8052949:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052950 <cmovns_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052950:	53                   	push   %ebx
 8052951:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052954:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052958:	83 c0 01             	add    $0x1,%eax
 805295b:	50                   	push   %eax
 805295c:	e8 0f 9f 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052961:	83 c4 10             	add    $0x10,%esp
 8052964:	80 3d e4 af 0f 10 00 	cmpb   $0x0,0x100fafe4
 805296b:	89 c3                	mov    %eax,%ebx
 805296d:	0f 89 c5 00 00 00    	jns    8052a38 <cmovns_rm2r_w+0xe8>
	print_asm_template2();
 8052973:	83 ec 0c             	sub    $0xc,%esp
 8052976:	68 50 af 0f 10       	push   $0x100faf50
 805297b:	68 18 af 0f 10       	push   $0x100faf18
 8052980:	68 01 17 06 08       	push   $0x8061701
 8052985:	6a 50                	push   $0x50
 8052987:	68 00 8a 0c 08       	push   $0x80c8a00
 805298c:	e8 6f 61 ff ff       	call   8048b00 <snprintf@plt>
 8052991:	83 c4 20             	add    $0x20,%esp
 8052994:	83 f8 4f             	cmp    $0x4f,%eax
 8052997:	7f 0f                	jg     80529a8 <cmovns_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052999:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805299c:	8d 43 01             	lea    0x1(%ebx),%eax
 805299f:	5b                   	pop    %ebx
 80529a0:	c3                   	ret    
 80529a1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 80529a8:	83 ec 0c             	sub    $0xc,%esp
 80529ab:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80529b1:	e8 aa 5f ff ff       	call   8048960 <fflush@plt>
 80529b6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80529bc:	6a 07                	push   $0x7
 80529be:	6a 01                	push   $0x1
 80529c0:	68 92 e8 05 08       	push   $0x805e892
 80529c5:	e8 46 60 ff ff       	call   8048a10 <fwrite@plt>
 80529ca:	83 c4 20             	add    $0x20,%esp
 80529cd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80529d3:	6a 10                	push   $0x10
 80529d5:	6a 01                	push   $0x1
 80529d7:	68 b4 f3 05 08       	push   $0x805f3b4
 80529dc:	e8 2f 60 ff ff       	call   8048a10 <fwrite@plt>
 80529e1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80529e7:	6a 05                	push   $0x5
 80529e9:	6a 01                	push   $0x1
 80529eb:	68 42 f3 05 08       	push   $0x805f342
 80529f0:	e8 1b 60 ff ff       	call   8048a10 <fwrite@plt>
 80529f5:	83 c4 14             	add    $0x14,%esp
 80529f8:	68 50 af 0f 10       	push   $0x100faf50
 80529fd:	68 18 af 0f 10       	push   $0x100faf18
 8052a02:	68 01 17 06 08       	push   $0x8061701
 8052a07:	6a 50                	push   $0x50
 8052a09:	68 00 8a 0c 08       	push   $0x80c8a00
 8052a0e:	e8 ed 60 ff ff       	call   8048b00 <snprintf@plt>
 8052a13:	83 c4 20             	add    $0x20,%esp
 8052a16:	83 f8 4f             	cmp    $0x4f,%eax
 8052a19:	0f 8e 7a ff ff ff    	jle    8052999 <cmovns_rm2r_w+0x49>
 8052a1f:	68 73 25 06 08       	push   $0x8062573
 8052a24:	6a 06                	push   $0x6
 8052a26:	68 70 17 06 08       	push   $0x8061770
 8052a2b:	68 5c 21 06 08       	push   $0x806215c
 8052a30:	e8 7b 61 ff ff       	call   8048bb0 <__assert_fail@plt>
 8052a35:	8d 76 00             	lea    0x0(%esi),%esi
 8052a38:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052a3f:	83 ec 08             	sub    $0x8,%esp
 8052a42:	50                   	push   %eax
 8052a43:	68 40 af 0f 10       	push   $0x100faf40
 8052a48:	e8 83 a0 00 00       	call   805cad0 <write_operand_w>
 8052a4d:	83 c4 10             	add    $0x10,%esp
 8052a50:	e9 1e ff ff ff       	jmp    8052973 <cmovns_rm2r_w+0x23>
 8052a55:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8052a59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052a60 <cmovnp_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052a60:	53                   	push   %ebx
 8052a61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052a64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052a68:	83 c0 01             	add    $0x1,%eax
 8052a6b:	50                   	push   %eax
 8052a6c:	e8 ff 9d 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052a71:	83 c4 10             	add    $0x10,%esp
 8052a74:	f6 05 e4 af 0f 10 04 	testb  $0x4,0x100fafe4
 8052a7b:	89 c3                	mov    %eax,%ebx
 8052a7d:	0f 84 c5 00 00 00    	je     8052b48 <cmovnp_rm2r_w+0xe8>
	print_asm_template2();
 8052a83:	83 ec 0c             	sub    $0xc,%esp
 8052a86:	68 50 af 0f 10       	push   $0x100faf50
 8052a8b:	68 18 af 0f 10       	push   $0x100faf18
 8052a90:	68 0f 17 06 08       	push   $0x806170f
 8052a95:	6a 50                	push   $0x50
 8052a97:	68 00 8a 0c 08       	push   $0x80c8a00
 8052a9c:	e8 5f 60 ff ff       	call   8048b00 <snprintf@plt>
 8052aa1:	83 c4 20             	add    $0x20,%esp
 8052aa4:	83 f8 4f             	cmp    $0x4f,%eax
 8052aa7:	7f 0f                	jg     8052ab8 <cmovnp_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052aa9:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8052aac:	8d 43 01             	lea    0x1(%ebx),%eax
 8052aaf:	5b                   	pop    %ebx
 8052ab0:	c3                   	ret    
 8052ab1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052ab8:	83 ec 0c             	sub    $0xc,%esp
 8052abb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8052ac1:	e8 9a 5e ff ff       	call   8048960 <fflush@plt>
 8052ac6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052acc:	6a 07                	push   $0x7
 8052ace:	6a 01                	push   $0x1
 8052ad0:	68 92 e8 05 08       	push   $0x805e892
 8052ad5:	e8 36 5f ff ff       	call   8048a10 <fwrite@plt>
 8052ada:	83 c4 20             	add    $0x20,%esp
 8052add:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052ae3:	6a 10                	push   $0x10
 8052ae5:	6a 01                	push   $0x1
 8052ae7:	68 b4 f3 05 08       	push   $0x805f3b4
 8052aec:	e8 1f 5f ff ff       	call   8048a10 <fwrite@plt>
 8052af1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052af7:	6a 05                	push   $0x5
 8052af9:	6a 01                	push   $0x1
 8052afb:	68 42 f3 05 08       	push   $0x805f342
 8052b00:	e8 0b 5f ff ff       	call   8048a10 <fwrite@plt>
 8052b05:	83 c4 14             	add    $0x14,%esp
 8052b08:	68 50 af 0f 10       	push   $0x100faf50
 8052b0d:	68 18 af 0f 10       	push   $0x100faf18
 8052b12:	68 0f 17 06 08       	push   $0x806170f
 8052b17:	6a 50                	push   $0x50
 8052b19:	68 00 8a 0c 08       	push   $0x80c8a00
 8052b1e:	e8 dd 5f ff ff       	call   8048b00 <snprintf@plt>
 8052b23:	83 c4 20             	add    $0x20,%esp
 8052b26:	83 f8 4f             	cmp    $0x4f,%eax
 8052b29:	0f 8e 7a ff ff ff    	jle    8052aa9 <cmovnp_rm2r_w+0x49>
 8052b2f:	68 7f 25 06 08       	push   $0x806257f
 8052b34:	6a 06                	push   $0x6
 8052b36:	68 70 17 06 08       	push   $0x8061770
 8052b3b:	68 c4 21 06 08       	push   $0x80621c4
 8052b40:	e8 6b 60 ff ff       	call   8048bb0 <__assert_fail@plt>
 8052b45:	8d 76 00             	lea    0x0(%esi),%esi
 8052b48:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052b4f:	83 ec 08             	sub    $0x8,%esp
 8052b52:	50                   	push   %eax
 8052b53:	68 40 af 0f 10       	push   $0x100faf40
 8052b58:	e8 73 9f 00 00       	call   805cad0 <write_operand_w>
 8052b5d:	83 c4 10             	add    $0x10,%esp
 8052b60:	e9 1e ff ff ff       	jmp    8052a83 <cmovnp_rm2r_w+0x23>
 8052b65:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8052b69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052b70 <cmovo_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052b70:	53                   	push   %ebx
 8052b71:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052b74:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052b78:	83 c0 01             	add    $0x1,%eax
 8052b7b:	50                   	push   %eax
 8052b7c:	e8 ef 9c 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052b81:	83 c4 10             	add    $0x10,%esp
 8052b84:	f6 05 e5 af 0f 10 08 	testb  $0x8,0x100fafe5
 8052b8b:	89 c3                	mov    %eax,%ebx
 8052b8d:	0f 85 c5 00 00 00    	jne    8052c58 <cmovo_rm2r_w+0xe8>
	print_asm_template2();
 8052b93:	83 ec 0c             	sub    $0xc,%esp
 8052b96:	68 50 af 0f 10       	push   $0x100faf50
 8052b9b:	68 18 af 0f 10       	push   $0x100faf18
 8052ba0:	68 1d 17 06 08       	push   $0x806171d
 8052ba5:	6a 50                	push   $0x50
 8052ba7:	68 00 8a 0c 08       	push   $0x80c8a00
 8052bac:	e8 4f 5f ff ff       	call   8048b00 <snprintf@plt>
 8052bb1:	83 c4 20             	add    $0x20,%esp
 8052bb4:	83 f8 4f             	cmp    $0x4f,%eax
 8052bb7:	7f 0f                	jg     8052bc8 <cmovo_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8052bb9:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8052bbc:	8d 43 01             	lea    0x1(%ebx),%eax
 8052bbf:	5b                   	pop    %ebx
 8052bc0:	c3                   	ret    
 8052bc1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052bc8:	83 ec 0c             	sub    $0xc,%esp
 8052bcb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8052bd1:	e8 8a 5d ff ff       	call   8048960 <fflush@plt>
 8052bd6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052bdc:	6a 07                	push   $0x7
 8052bde:	6a 01                	push   $0x1
 8052be0:	68 92 e8 05 08       	push   $0x805e892
 8052be5:	e8 26 5e ff ff       	call   8048a10 <fwrite@plt>
 8052bea:	83 c4 20             	add    $0x20,%esp
 8052bed:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052bf3:	6a 10                	push   $0x10
 8052bf5:	6a 01                	push   $0x1
 8052bf7:	68 b4 f3 05 08       	push   $0x805f3b4
 8052bfc:	e8 0f 5e ff ff       	call   8048a10 <fwrite@plt>
 8052c01:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052c07:	6a 05                	push   $0x5
 8052c09:	6a 01                	push   $0x1
 8052c0b:	68 42 f3 05 08       	push   $0x805f342
 8052c10:	e8 fb 5d ff ff       	call   8048a10 <fwrite@plt>
 8052c15:	83 c4 14             	add    $0x14,%esp
 8052c18:	68 50 af 0f 10       	push   $0x100faf50
 8052c1d:	68 18 af 0f 10       	push   $0x100faf18
 8052c22:	68 1d 17 06 08       	push   $0x806171d
 8052c27:	6a 50                	push   $0x50
 8052c29:	68 00 8a 0c 08       	push   $0x80c8a00
 8052c2e:	e8 cd 5e ff ff       	call   8048b00 <snprintf@plt>
 8052c33:	83 c4 20             	add    $0x20,%esp
 8052c36:	83 f8 4f             	cmp    $0x4f,%eax
 8052c39:	0f 8e 7a ff ff ff    	jle    8052bb9 <cmovo_rm2r_w+0x49>
 8052c3f:	68 68 25 06 08       	push   $0x8062568
 8052c44:	6a 06                	push   $0x6
 8052c46:	68 70 17 06 08       	push   $0x8061770
 8052c4b:	68 2c 22 06 08       	push   $0x806222c
 8052c50:	e8 5b 5f ff ff       	call   8048bb0 <__assert_fail@plt>
 8052c55:	8d 76 00             	lea    0x0(%esi),%esi
 8052c58:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052c5f:	83 ec 08             	sub    $0x8,%esp
 8052c62:	50                   	push   %eax
 8052c63:	68 40 af 0f 10       	push   $0x100faf40
 8052c68:	e8 63 9e 00 00       	call   805cad0 <write_operand_w>
 8052c6d:	83 c4 10             	add    $0x10,%esp
 8052c70:	e9 1e ff ff ff       	jmp    8052b93 <cmovo_rm2r_w+0x23>
 8052c75:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8052c79:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08052c80 <cmovl_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052c80:	53                   	push   %ebx
 8052c81:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052c84:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052c88:	83 c0 01             	add    $0x1,%eax
 8052c8b:	50                   	push   %eax
 8052c8c:	e8 df 9b 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052c91:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8052c98:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 8052c9f:	83 c4 10             	add    $0x10,%esp
 8052ca2:	89 c3                	mov    %eax,%ebx
 8052ca4:	c0 ea 03             	shr    $0x3,%dl
 8052ca7:	c0 e9 07             	shr    $0x7,%cl
 8052caa:	83 e2 01             	and    $0x1,%edx
 8052cad:	38 d1                	cmp    %dl,%cl
 8052caf:	74 18                	je     8052cc9 <cmovl_rm2r_w+0x49>
 8052cb1:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
 8052cb8:	83 ec 08             	sub    $0x8,%esp
 8052cbb:	50                   	push   %eax
 8052cbc:	68 40 af 0f 10       	push   $0x100faf40
 8052cc1:	e8 0a 9e 00 00       	call   805cad0 <write_operand_w>
 8052cc6:	83 c4 10             	add    $0x10,%esp
	print_asm_template2();
 8052cc9:	83 ec 0c             	sub    $0xc,%esp
 8052ccc:	68 50 af 0f 10       	push   $0x100faf50
 8052cd1:	68 18 af 0f 10       	push   $0x100faf18
 8052cd6:	68 2a 17 06 08       	push   $0x806172a
 8052cdb:	6a 50                	push   $0x50
 8052cdd:	68 00 8a 0c 08       	push   $0x80c8a00
 8052ce2:	e8 19 5e ff ff       	call   8048b00 <snprintf@plt>
 8052ce7:	83 c4 20             	add    $0x20,%esp
 8052cea:	83 f8 4f             	cmp    $0x4f,%eax
 8052ced:	7f 11                	jg     8052d00 <cmovl_rm2r_w+0x80>
}

make_instr_helper(rm2r)
 8052cef:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8052cf2:	8d 43 01             	lea    0x1(%ebx),%eax
 8052cf5:	5b                   	pop    %ebx
 8052cf6:	c3                   	ret    
 8052cf7:	89 f6                	mov    %esi,%esi
 8052cf9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052d00:	83 ec 0c             	sub    $0xc,%esp
 8052d03:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8052d09:	e8 52 5c ff ff       	call   8048960 <fflush@plt>
 8052d0e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052d14:	6a 07                	push   $0x7
 8052d16:	6a 01                	push   $0x1
 8052d18:	68 92 e8 05 08       	push   $0x805e892
 8052d1d:	e8 ee 5c ff ff       	call   8048a10 <fwrite@plt>
 8052d22:	83 c4 20             	add    $0x20,%esp
 8052d25:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052d2b:	6a 10                	push   $0x10
 8052d2d:	6a 01                	push   $0x1
 8052d2f:	68 b4 f3 05 08       	push   $0x805f3b4
 8052d34:	e8 d7 5c ff ff       	call   8048a10 <fwrite@plt>
 8052d39:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052d3f:	6a 05                	push   $0x5
 8052d41:	6a 01                	push   $0x1
 8052d43:	68 42 f3 05 08       	push   $0x805f342
 8052d48:	e8 c3 5c ff ff       	call   8048a10 <fwrite@plt>
 8052d4d:	83 c4 14             	add    $0x14,%esp
 8052d50:	68 50 af 0f 10       	push   $0x100faf50
 8052d55:	68 18 af 0f 10       	push   $0x100faf18
 8052d5a:	68 2a 17 06 08       	push   $0x806172a
 8052d5f:	6a 50                	push   $0x50
 8052d61:	68 00 8a 0c 08       	push   $0x80c8a00
 8052d66:	e8 95 5d ff ff       	call   8048b00 <snprintf@plt>
 8052d6b:	83 c4 20             	add    $0x20,%esp
 8052d6e:	83 f8 4f             	cmp    $0x4f,%eax
 8052d71:	0f 8e 78 ff ff ff    	jle    8052cef <cmovl_rm2r_w+0x6f>
 8052d77:	68 af 25 06 08       	push   $0x80625af
 8052d7c:	6a 06                	push   $0x6
 8052d7e:	68 70 17 06 08       	push   $0x8061770
 8052d83:	68 94 22 06 08       	push   $0x8062294
 8052d88:	e8 23 5e ff ff       	call   8048bb0 <__assert_fail@plt>
 8052d8d:	8d 76 00             	lea    0x0(%esi),%esi

08052d90 <cmovg_rm2r_l>:
}

make_instr_helper(rm2r)
 8052d90:	53                   	push   %ebx
 8052d91:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052d94:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052d98:	83 c0 01             	add    $0x1,%eax
 8052d9b:	50                   	push   %eax
 8052d9c:	e8 9f 9e 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052da1:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8052da8:	89 c3                	mov    %eax,%ebx
 8052daa:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 8052db1:	83 c4 10             	add    $0x10,%esp
 8052db4:	c0 ea 03             	shr    $0x3,%dl
 8052db7:	89 c1                	mov    %eax,%ecx
 8052db9:	c0 e9 07             	shr    $0x7,%cl
 8052dbc:	83 e2 01             	and    $0x1,%edx
 8052dbf:	38 d1                	cmp    %dl,%cl
 8052dc1:	0f 84 c1 00 00 00    	je     8052e88 <cmovg_rm2r_l+0xf8>
	print_asm_template2();
 8052dc7:	83 ec 0c             	sub    $0xc,%esp
 8052dca:	68 50 af 0f 10       	push   $0x100faf50
 8052dcf:	68 18 af 0f 10       	push   $0x100faf18
 8052dd4:	68 37 17 06 08       	push   $0x8061737
 8052dd9:	6a 50                	push   $0x50
 8052ddb:	68 00 8a 0c 08       	push   $0x80c8a00
 8052de0:	e8 1b 5d ff ff       	call   8048b00 <snprintf@plt>
 8052de5:	83 c4 20             	add    $0x20,%esp
 8052de8:	83 f8 4f             	cmp    $0x4f,%eax
 8052deb:	7f 0b                	jg     8052df8 <cmovg_rm2r_l+0x68>
}

make_instr_helper(rm2r)
 8052ded:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8052df0:	8d 43 01             	lea    0x1(%ebx),%eax
 8052df3:	5b                   	pop    %ebx
 8052df4:	c3                   	ret    
 8052df5:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052df8:	83 ec 0c             	sub    $0xc,%esp
 8052dfb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8052e01:	e8 5a 5b ff ff       	call   8048960 <fflush@plt>
 8052e06:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052e0c:	6a 07                	push   $0x7
 8052e0e:	6a 01                	push   $0x1
 8052e10:	68 92 e8 05 08       	push   $0x805e892
 8052e15:	e8 f6 5b ff ff       	call   8048a10 <fwrite@plt>
 8052e1a:	83 c4 20             	add    $0x20,%esp
 8052e1d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052e23:	6a 10                	push   $0x10
 8052e25:	6a 01                	push   $0x1
 8052e27:	68 b4 f3 05 08       	push   $0x805f3b4
 8052e2c:	e8 df 5b ff ff       	call   8048a10 <fwrite@plt>
 8052e31:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052e37:	6a 05                	push   $0x5
 8052e39:	6a 01                	push   $0x1
 8052e3b:	68 42 f3 05 08       	push   $0x805f342
 8052e40:	e8 cb 5b ff ff       	call   8048a10 <fwrite@plt>
 8052e45:	83 c4 14             	add    $0x14,%esp
 8052e48:	68 50 af 0f 10       	push   $0x100faf50
 8052e4d:	68 18 af 0f 10       	push   $0x100faf18
 8052e52:	68 37 17 06 08       	push   $0x8061737
 8052e57:	6a 50                	push   $0x50
 8052e59:	68 00 8a 0c 08       	push   $0x80c8a00
 8052e5e:	e8 9d 5c ff ff       	call   8048b00 <snprintf@plt>
 8052e63:	83 c4 20             	add    $0x20,%esp
 8052e66:	83 f8 4f             	cmp    $0x4f,%eax
 8052e69:	0f 8e 7e ff ff ff    	jle    8052ded <cmovg_rm2r_l+0x5d>
 8052e6f:	68 0e 25 06 08       	push   $0x806250e
 8052e74:	6a 06                	push   $0x6
 8052e76:	68 70 17 06 08       	push   $0x8061770
 8052e7b:	68 fc 22 06 08       	push   $0x80622fc
 8052e80:	e8 2b 5d ff ff       	call   8048bb0 <__assert_fail@plt>
 8052e85:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052e88:	a8 40                	test   $0x40,%al
 8052e8a:	0f 85 37 ff ff ff    	jne    8052dc7 <cmovg_rm2r_l+0x37>
 8052e90:	83 ec 08             	sub    $0x8,%esp
 8052e93:	ff 35 14 af 0f 10    	pushl  0x100faf14
 8052e99:	68 40 af 0f 10       	push   $0x100faf40
 8052e9e:	e8 fd 9f 00 00       	call   805cea0 <write_operand_l>
 8052ea3:	83 c4 10             	add    $0x10,%esp
 8052ea6:	e9 1c ff ff ff       	jmp    8052dc7 <cmovg_rm2r_l+0x37>
 8052eab:	90                   	nop
 8052eac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08052eb0 <cmovg_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052eb0:	53                   	push   %ebx
 8052eb1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052eb4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052eb8:	83 c0 01             	add    $0x1,%eax
 8052ebb:	50                   	push   %eax
 8052ebc:	e8 af 99 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052ec1:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8052ec8:	89 c3                	mov    %eax,%ebx
 8052eca:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 8052ed1:	83 c4 10             	add    $0x10,%esp
 8052ed4:	c0 ea 03             	shr    $0x3,%dl
 8052ed7:	89 c1                	mov    %eax,%ecx
 8052ed9:	c0 e9 07             	shr    $0x7,%cl
 8052edc:	83 e2 01             	and    $0x1,%edx
 8052edf:	38 d1                	cmp    %dl,%cl
 8052ee1:	0f 84 c1 00 00 00    	je     8052fa8 <cmovg_rm2r_w+0xf8>
	print_asm_template2();
 8052ee7:	83 ec 0c             	sub    $0xc,%esp
 8052eea:	68 50 af 0f 10       	push   $0x100faf50
 8052eef:	68 18 af 0f 10       	push   $0x100faf18
 8052ef4:	68 44 17 06 08       	push   $0x8061744
 8052ef9:	6a 50                	push   $0x50
 8052efb:	68 00 8a 0c 08       	push   $0x80c8a00
 8052f00:	e8 fb 5b ff ff       	call   8048b00 <snprintf@plt>
 8052f05:	83 c4 20             	add    $0x20,%esp
 8052f08:	83 f8 4f             	cmp    $0x4f,%eax
 8052f0b:	7f 0b                	jg     8052f18 <cmovg_rm2r_w+0x68>
}

make_instr_helper(rm2r)
 8052f0d:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8052f10:	8d 43 01             	lea    0x1(%ebx),%eax
 8052f13:	5b                   	pop    %ebx
 8052f14:	c3                   	ret    
 8052f15:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8052f18:	83 ec 0c             	sub    $0xc,%esp
 8052f1b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8052f21:	e8 3a 5a ff ff       	call   8048960 <fflush@plt>
 8052f26:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052f2c:	6a 07                	push   $0x7
 8052f2e:	6a 01                	push   $0x1
 8052f30:	68 92 e8 05 08       	push   $0x805e892
 8052f35:	e8 d6 5a ff ff       	call   8048a10 <fwrite@plt>
 8052f3a:	83 c4 20             	add    $0x20,%esp
 8052f3d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052f43:	6a 10                	push   $0x10
 8052f45:	6a 01                	push   $0x1
 8052f47:	68 b4 f3 05 08       	push   $0x805f3b4
 8052f4c:	e8 bf 5a ff ff       	call   8048a10 <fwrite@plt>
 8052f51:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8052f57:	6a 05                	push   $0x5
 8052f59:	6a 01                	push   $0x1
 8052f5b:	68 42 f3 05 08       	push   $0x805f342
 8052f60:	e8 ab 5a ff ff       	call   8048a10 <fwrite@plt>
 8052f65:	83 c4 14             	add    $0x14,%esp
 8052f68:	68 50 af 0f 10       	push   $0x100faf50
 8052f6d:	68 18 af 0f 10       	push   $0x100faf18
 8052f72:	68 44 17 06 08       	push   $0x8061744
 8052f77:	6a 50                	push   $0x50
 8052f79:	68 00 8a 0c 08       	push   $0x80c8a00
 8052f7e:	e8 7d 5b ff ff       	call   8048b00 <snprintf@plt>
 8052f83:	83 c4 20             	add    $0x20,%esp
 8052f86:	83 f8 4f             	cmp    $0x4f,%eax
 8052f89:	0f 8e 7e ff ff ff    	jle    8052f0d <cmovg_rm2r_w+0x5d>
 8052f8f:	68 c6 25 06 08       	push   $0x80625c6
 8052f94:	6a 06                	push   $0x6
 8052f96:	68 70 17 06 08       	push   $0x8061770
 8052f9b:	68 64 23 06 08       	push   $0x8062364
 8052fa0:	e8 0b 5c ff ff       	call   8048bb0 <__assert_fail@plt>
 8052fa5:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052fa8:	a8 40                	test   $0x40,%al
 8052faa:	0f 85 37 ff ff ff    	jne    8052ee7 <cmovg_rm2r_w+0x37>
 8052fb0:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
 8052fb7:	83 ec 08             	sub    $0x8,%esp
 8052fba:	50                   	push   %eax
 8052fbb:	68 40 af 0f 10       	push   $0x100faf40
 8052fc0:	e8 0b 9b 00 00       	call   805cad0 <write_operand_w>
 8052fc5:	83 c4 10             	add    $0x10,%esp
 8052fc8:	e9 1a ff ff ff       	jmp    8052ee7 <cmovg_rm2r_w+0x37>
 8052fcd:	8d 76 00             	lea    0x0(%esi),%esi

08052fd0 <cmovle_rm2r_l>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 8052fd0:	53                   	push   %ebx
 8052fd1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8052fd4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8052fd8:	83 c0 01             	add    $0x1,%eax
 8052fdb:	50                   	push   %eax
 8052fdc:	e8 5f 9c 00 00       	call   805cc40 <decode_rm2r_l>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8052fe1:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8052fe8:	89 c3                	mov    %eax,%ebx
 8052fea:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 8052ff1:	83 c4 10             	add    $0x10,%esp
 8052ff4:	c0 ea 03             	shr    $0x3,%dl
 8052ff7:	89 c1                	mov    %eax,%ecx
 8052ff9:	c0 e9 07             	shr    $0x7,%cl
 8052ffc:	83 e2 01             	and    $0x1,%edx
 8052fff:	38 d1                	cmp    %dl,%cl
 8053001:	74 08                	je     805300b <cmovle_rm2r_l+0x3b>
 8053003:	a8 40                	test   $0x40,%al
 8053005:	0f 85 c5 00 00 00    	jne    80530d0 <cmovle_rm2r_l+0x100>
	print_asm_template2();
 805300b:	83 ec 0c             	sub    $0xc,%esp
 805300e:	68 50 af 0f 10       	push   $0x100faf50
 8053013:	68 18 af 0f 10       	push   $0x100faf18
 8053018:	68 51 17 06 08       	push   $0x8061751
 805301d:	6a 50                	push   $0x50
 805301f:	68 00 8a 0c 08       	push   $0x80c8a00
 8053024:	e8 d7 5a ff ff       	call   8048b00 <snprintf@plt>
 8053029:	83 c4 20             	add    $0x20,%esp
 805302c:	83 f8 4f             	cmp    $0x4f,%eax
 805302f:	7f 0f                	jg     8053040 <cmovle_rm2r_l+0x70>
}

make_instr_helper(rm2r)
 8053031:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8053034:	8d 43 01             	lea    0x1(%ebx),%eax
 8053037:	5b                   	pop    %ebx
 8053038:	c3                   	ret    
 8053039:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8053040:	83 ec 0c             	sub    $0xc,%esp
 8053043:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8053049:	e8 12 59 ff ff       	call   8048960 <fflush@plt>
 805304e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8053054:	6a 07                	push   $0x7
 8053056:	6a 01                	push   $0x1
 8053058:	68 92 e8 05 08       	push   $0x805e892
 805305d:	e8 ae 59 ff ff       	call   8048a10 <fwrite@plt>
 8053062:	83 c4 20             	add    $0x20,%esp
 8053065:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805306b:	6a 10                	push   $0x10
 805306d:	6a 01                	push   $0x1
 805306f:	68 b4 f3 05 08       	push   $0x805f3b4
 8053074:	e8 97 59 ff ff       	call   8048a10 <fwrite@plt>
 8053079:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805307f:	6a 05                	push   $0x5
 8053081:	6a 01                	push   $0x1
 8053083:	68 42 f3 05 08       	push   $0x805f342
 8053088:	e8 83 59 ff ff       	call   8048a10 <fwrite@plt>
 805308d:	83 c4 14             	add    $0x14,%esp
 8053090:	68 50 af 0f 10       	push   $0x100faf50
 8053095:	68 18 af 0f 10       	push   $0x100faf18
 805309a:	68 51 17 06 08       	push   $0x8061751
 805309f:	6a 50                	push   $0x50
 80530a1:	68 00 8a 0c 08       	push   $0x80c8a00
 80530a6:	e8 55 5a ff ff       	call   8048b00 <snprintf@plt>
 80530ab:	83 c4 20             	add    $0x20,%esp
 80530ae:	83 f8 4f             	cmp    $0x4f,%eax
 80530b1:	0f 8e 7a ff ff ff    	jle    8053031 <cmovle_rm2r_l+0x61>
 80530b7:	68 eb 24 06 08       	push   $0x80624eb
 80530bc:	6a 06                	push   $0x6
 80530be:	68 70 17 06 08       	push   $0x8061770
 80530c3:	68 cc 23 06 08       	push   $0x80623cc
 80530c8:	e8 e3 5a ff ff       	call   8048bb0 <__assert_fail@plt>
 80530cd:	8d 76 00             	lea    0x0(%esi),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80530d0:	83 ec 08             	sub    $0x8,%esp
 80530d3:	ff 35 14 af 0f 10    	pushl  0x100faf14
 80530d9:	68 40 af 0f 10       	push   $0x100faf40
 80530de:	e8 bd 9d 00 00       	call   805cea0 <write_operand_l>
 80530e3:	83 c4 10             	add    $0x10,%esp
 80530e6:	e9 20 ff ff ff       	jmp    805300b <cmovle_rm2r_l+0x3b>
 80530eb:	90                   	nop
 80530ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080530f0 <cmovle_rm2r_w>:
	print_asm_template2();
}

make_instr_helper(rm2r)
 80530f0:	53                   	push   %ebx
 80530f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80530f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80530f8:	83 c0 01             	add    $0x1,%eax
 80530fb:	50                   	push   %eax
 80530fc:	e8 6f 97 00 00       	call   805c870 <decode_rm2r_w>
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 8053101:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8053108:	89 c3                	mov    %eax,%ebx
 805310a:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 8053111:	83 c4 10             	add    $0x10,%esp
 8053114:	c0 ea 03             	shr    $0x3,%dl
 8053117:	89 c1                	mov    %eax,%ecx
 8053119:	c0 e9 07             	shr    $0x7,%cl
 805311c:	83 e2 01             	and    $0x1,%edx
 805311f:	38 d1                	cmp    %dl,%cl
 8053121:	74 08                	je     805312b <cmovle_rm2r_w+0x3b>
 8053123:	a8 40                	test   $0x40,%al
 8053125:	0f 85 c5 00 00 00    	jne    80531f0 <cmovle_rm2r_w+0x100>
	print_asm_template2();
 805312b:	83 ec 0c             	sub    $0xc,%esp
 805312e:	68 50 af 0f 10       	push   $0x100faf50
 8053133:	68 18 af 0f 10       	push   $0x100faf18
 8053138:	68 5f 17 06 08       	push   $0x806175f
 805313d:	6a 50                	push   $0x50
 805313f:	68 00 8a 0c 08       	push   $0x80c8a00
 8053144:	e8 b7 59 ff ff       	call   8048b00 <snprintf@plt>
 8053149:	83 c4 20             	add    $0x20,%esp
 805314c:	83 f8 4f             	cmp    $0x4f,%eax
 805314f:	7f 0f                	jg     8053160 <cmovle_rm2r_w+0x70>
}

make_instr_helper(rm2r)
 8053151:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8053154:	8d 43 01             	lea    0x1(%ebx),%eax
 8053157:	5b                   	pop    %ebx
 8053158:	c3                   	ret    
 8053159:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8053160:	83 ec 0c             	sub    $0xc,%esp
 8053163:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8053169:	e8 f2 57 ff ff       	call   8048960 <fflush@plt>
 805316e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8053174:	6a 07                	push   $0x7
 8053176:	6a 01                	push   $0x1
 8053178:	68 92 e8 05 08       	push   $0x805e892
 805317d:	e8 8e 58 ff ff       	call   8048a10 <fwrite@plt>
 8053182:	83 c4 20             	add    $0x20,%esp
 8053185:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805318b:	6a 10                	push   $0x10
 805318d:	6a 01                	push   $0x1
 805318f:	68 b4 f3 05 08       	push   $0x805f3b4
 8053194:	e8 77 58 ff ff       	call   8048a10 <fwrite@plt>
 8053199:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805319f:	6a 05                	push   $0x5
 80531a1:	6a 01                	push   $0x1
 80531a3:	68 42 f3 05 08       	push   $0x805f342
 80531a8:	e8 63 58 ff ff       	call   8048a10 <fwrite@plt>
 80531ad:	83 c4 14             	add    $0x14,%esp
 80531b0:	68 50 af 0f 10       	push   $0x100faf50
 80531b5:	68 18 af 0f 10       	push   $0x100faf18
 80531ba:	68 5f 17 06 08       	push   $0x806175f
 80531bf:	6a 50                	push   $0x50
 80531c1:	68 00 8a 0c 08       	push   $0x80c8a00
 80531c6:	e8 35 59 ff ff       	call   8048b00 <snprintf@plt>
 80531cb:	83 c4 20             	add    $0x20,%esp
 80531ce:	83 f8 4f             	cmp    $0x4f,%eax
 80531d1:	0f 8e 7a ff ff ff    	jle    8053151 <cmovle_rm2r_w+0x61>
 80531d7:	68 a3 25 06 08       	push   $0x80625a3
 80531dc:	6a 06                	push   $0x6
 80531de:	68 70 17 06 08       	push   $0x8061770
 80531e3:	68 34 24 06 08       	push   $0x8062434
 80531e8:	e8 c3 59 ff ff       	call   8048bb0 <__assert_fail@plt>
 80531ed:	8d 76 00             	lea    0x0(%esi),%esi
 80531f0:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
#include "cpu/exec/template-start.h"


static void do_execute() {
	if(expr)OPERAND_W(op_dest, op_src->val);
 80531f7:	83 ec 08             	sub    $0x8,%esp
 80531fa:	50                   	push   %eax
 80531fb:	68 40 af 0f 10       	push   $0x100faf40
 8053200:	e8 cb 98 00 00       	call   805cad0 <write_operand_w>
 8053205:	83 c4 10             	add    $0x10,%esp
 8053208:	e9 1e ff ff ff       	jmp    805312b <cmovle_rm2r_w+0x3b>
 805320d:	8d 76 00             	lea    0x0(%esi),%esi

08053210 <cmovo_rm2r_v>:

#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(cmovo_rm2r)
 8053210:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053217:	8b 54 24 04          	mov    0x4(%esp),%edx
 805321b:	b8 70 2b 05 08       	mov    $0x8052b70,%eax
 8053220:	75 05                	jne    8053227 <cmovo_rm2r_v+0x17>
 8053222:	b8 10 15 05 08       	mov    $0x8051510,%eax
 8053227:	89 54 24 04          	mov    %edx,0x4(%esp)
 805322b:	ff e0                	jmp    *%eax
 805322d:	8d 76 00             	lea    0x0(%esi),%esi

08053230 <cmovno_rm2r_v>:
make_helper_v(cmovno_rm2r)
 8053230:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053237:	8b 54 24 04          	mov    0x4(%esp),%edx
 805323b:	b8 20 26 05 08       	mov    $0x8052620,%eax
 8053240:	75 05                	jne    8053247 <cmovno_rm2r_v+0x17>
 8053242:	b8 e0 11 05 08       	mov    $0x80511e0,%eax
 8053247:	89 54 24 04          	mov    %edx,0x4(%esp)
 805324b:	ff e0                	jmp    *%eax
 805324d:	8d 76 00             	lea    0x0(%esi),%esi

08053250 <cmovb_rm2r_v>:
make_helper_v(cmovb_rm2r)
 8053250:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053257:	8b 54 24 04          	mov    0x4(%esp),%edx
 805325b:	b8 c0 1f 05 08       	mov    $0x8051fc0,%eax
 8053260:	75 05                	jne    8053267 <cmovb_rm2r_v+0x17>
 8053262:	b8 50 19 05 08       	mov    $0x8051950,%eax
 8053267:	89 54 24 04          	mov    %edx,0x4(%esp)
 805326b:	ff e0                	jmp    *%eax
 805326d:	8d 76 00             	lea    0x0(%esi),%esi

08053270 <cmovae_rm2r_v>:
make_helper_v(cmovae_rm2r)
 8053270:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053277:	8b 54 24 04          	mov    0x4(%esp),%edx
 805327b:	b8 f0 22 05 08       	mov    $0x80522f0,%eax
 8053280:	75 05                	jne    8053287 <cmovae_rm2r_v+0x17>
 8053282:	b8 60 1a 05 08       	mov    $0x8051a60,%eax
 8053287:	89 54 24 04          	mov    %edx,0x4(%esp)
 805328b:	ff e0                	jmp    *%eax
 805328d:	8d 76 00             	lea    0x0(%esi),%esi

08053290 <cmove_rm2r_v>:
make_helper_v(cmove_rm2r)
 8053290:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053297:	8b 54 24 04          	mov    0x4(%esp),%edx
 805329b:	b8 e0 21 05 08       	mov    $0x80521e0,%eax
 80532a0:	75 05                	jne    80532a7 <cmove_rm2r_v+0x17>
 80532a2:	b8 70 1b 05 08       	mov    $0x8051b70,%eax
 80532a7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80532ab:	ff e0                	jmp    *%eax
 80532ad:	8d 76 00             	lea    0x0(%esi),%esi

080532b0 <cmovne_rm2r_v>:
make_helper_v(cmovne_rm2r)
 80532b0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80532b7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80532bb:	b8 40 28 05 08       	mov    $0x8052840,%eax
 80532c0:	75 05                	jne    80532c7 <cmovne_rm2r_v+0x17>
 80532c2:	b8 d0 10 05 08       	mov    $0x80510d0,%eax
 80532c7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80532cb:	ff e0                	jmp    *%eax
 80532cd:	8d 76 00             	lea    0x0(%esi),%esi

080532d0 <cmovbe_rm2r_v>:
make_helper_v(cmovbe_rm2r)
 80532d0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80532d7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80532db:	b8 00 24 05 08       	mov    $0x8052400,%eax
 80532e0:	75 05                	jne    80532e7 <cmovbe_rm2r_v+0x17>
 80532e2:	b8 80 1c 05 08       	mov    $0x8051c80,%eax
 80532e7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80532eb:	ff e0                	jmp    *%eax
 80532ed:	8d 76 00             	lea    0x0(%esi),%esi

080532f0 <cmova_rm2r_v>:
make_helper_v(cmova_rm2r)
 80532f0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80532f7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80532fb:	b8 d0 20 05 08       	mov    $0x80520d0,%eax
 8053300:	75 05                	jne    8053307 <cmova_rm2r_v+0x17>
 8053302:	b8 40 18 05 08       	mov    $0x8051840,%eax
 8053307:	89 54 24 04          	mov    %edx,0x4(%esp)
 805330b:	ff e0                	jmp    *%eax
 805330d:	8d 76 00             	lea    0x0(%esi),%esi

08053310 <cmovs_rm2r_v>:
make_helper_v(cmovs_rm2r)
 8053310:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053317:	8b 54 24 04          	mov    0x4(%esp),%edx
 805331b:	b8 30 27 05 08       	mov    $0x8052730,%eax
 8053320:	75 05                	jne    8053327 <cmovs_rm2r_v+0x17>
 8053322:	b8 30 17 05 08       	mov    $0x8051730,%eax
 8053327:	89 54 24 04          	mov    %edx,0x4(%esp)
 805332b:	ff e0                	jmp    *%eax
 805332d:	8d 76 00             	lea    0x0(%esi),%esi

08053330 <cmovns_rm2r_v>:
make_helper_v(cmovns_rm2r)
 8053330:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053337:	8b 54 24 04          	mov    0x4(%esp),%edx
 805333b:	b8 50 29 05 08       	mov    $0x8052950,%eax
 8053340:	75 05                	jne    8053347 <cmovns_rm2r_v+0x17>
 8053342:	b8 f0 12 05 08       	mov    $0x80512f0,%eax
 8053347:	89 54 24 04          	mov    %edx,0x4(%esp)
 805334b:	ff e0                	jmp    *%eax
 805334d:	8d 76 00             	lea    0x0(%esi),%esi

08053350 <cmovp_rm2r_v>:
make_helper_v(cmovp_rm2r)
 8053350:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053357:	8b 54 24 04          	mov    0x4(%esp),%edx
 805335b:	b8 10 25 05 08       	mov    $0x8052510,%eax
 8053360:	75 05                	jne    8053367 <cmovp_rm2r_v+0x17>
 8053362:	b8 20 16 05 08       	mov    $0x8051620,%eax
 8053367:	89 54 24 04          	mov    %edx,0x4(%esp)
 805336b:	ff e0                	jmp    *%eax
 805336d:	8d 76 00             	lea    0x0(%esi),%esi

08053370 <cmovnp_rm2r_v>:
make_helper_v(cmovnp_rm2r)
 8053370:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053377:	8b 54 24 04          	mov    0x4(%esp),%edx
 805337b:	b8 60 2a 05 08       	mov    $0x8052a60,%eax
 8053380:	75 05                	jne    8053387 <cmovnp_rm2r_v+0x17>
 8053382:	b8 00 14 05 08       	mov    $0x8051400,%eax
 8053387:	89 54 24 04          	mov    %edx,0x4(%esp)
 805338b:	ff e0                	jmp    *%eax
 805338d:	8d 76 00             	lea    0x0(%esi),%esi

08053390 <cmovl_rm2r_v>:
make_helper_v(cmovl_rm2r)
 8053390:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053397:	8b 54 24 04          	mov    0x4(%esp),%edx
 805339b:	b8 80 2c 05 08       	mov    $0x8052c80,%eax
 80533a0:	75 05                	jne    80533a7 <cmovl_rm2r_v+0x17>
 80533a2:	b8 b0 1e 05 08       	mov    $0x8051eb0,%eax
 80533a7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80533ab:	ff e0                	jmp    *%eax
 80533ad:	8d 76 00             	lea    0x0(%esi),%esi

080533b0 <cmovge_rm2r_v>:
make_helper_v(cmovge_rm2r)
 80533b0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80533b7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80533bb:	b8 90 1d 05 08       	mov    $0x8051d90,%eax
 80533c0:	75 05                	jne    80533c7 <cmovge_rm2r_v+0x17>
 80533c2:	b8 b0 0f 05 08       	mov    $0x8050fb0,%eax
 80533c7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80533cb:	ff e0                	jmp    *%eax
 80533cd:	8d 76 00             	lea    0x0(%esi),%esi

080533d0 <cmovle_rm2r_v>:
make_helper_v(cmovle_rm2r)
 80533d0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80533d7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80533db:	b8 f0 30 05 08       	mov    $0x80530f0,%eax
 80533e0:	75 05                	jne    80533e7 <cmovle_rm2r_v+0x17>
 80533e2:	b8 d0 2f 05 08       	mov    $0x8052fd0,%eax
 80533e7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80533eb:	ff e0                	jmp    *%eax
 80533ed:	8d 76 00             	lea    0x0(%esi),%esi

080533f0 <cmovg_rm2r_v>:
make_helper_v(cmovg_rm2r)
 80533f0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80533f7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80533fb:	b8 b0 2e 05 08       	mov    $0x8052eb0,%eax
 8053400:	75 05                	jne    8053407 <cmovg_rm2r_v+0x17>
 8053402:	b8 90 2d 05 08       	mov    $0x8052d90,%eax
 8053407:	89 54 24 04          	mov    %edx,0x4(%esp)
 805340b:	ff e0                	jmp    *%eax
 805340d:	66 90                	xchg   %ax,%ax
 805340f:	90                   	nop

08053410 <do_test_b>:
#include "cpu/exec/template-start.h"

#define instr test

static void do_execute() {
 8053410:	53                   	push   %ebx
 8053411:	83 ec 14             	sub    $0x14,%esp
	uint32_t res = op_src->val & op_dest->val;
 8053414:	a1 4c af 0f 10       	mov    0x100faf4c,%eax
 8053419:	23 05 14 af 0f 10    	and    0x100faf14,%eax
	cpu.CF = cpu.OF = 0;
 805341f:	80 25 e5 af 0f 10 f7 	andb   $0xf7,0x100fafe5
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	print_asm_template2();
 8053426:	68 50 af 0f 10       	push   $0x100faf50
 805342b:	68 18 af 0f 10       	push   $0x100faf18
 8053430:	68 0a 26 06 08       	push   $0x806260a
 8053435:	6a 50                	push   $0x50
 8053437:	68 00 8a 0c 08       	push   $0x80c8a00
#define instr test

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
 805343c:	89 c1                	mov    %eax,%ecx
 805343e:	c1 e9 1f             	shr    $0x1f,%ecx
 8053441:	89 ca                	mov    %ecx,%edx
 8053443:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 805344a:	c1 e2 07             	shl    $0x7,%edx
 805344d:	83 e1 3e             	and    $0x3e,%ecx
	cpu.ZF = (res == 0);
 8053450:	85 c0                	test   %eax,%eax
	uint32_t pf = (res & 255);
 8053452:	0f b6 c0             	movzbl %al,%eax

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 8053455:	0f 94 c3             	sete   %bl
 8053458:	09 d1                	or     %edx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 805345a:	89 c2                	mov    %eax,%edx
 805345c:	c1 ea 04             	shr    $0x4,%edx

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 805345f:	c1 e3 06             	shl    $0x6,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 8053462:	31 d0                	xor    %edx,%eax

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 8053464:	09 d9                	or     %ebx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 8053466:	89 c2                	mov    %eax,%edx
 8053468:	c1 ea 02             	shr    $0x2,%edx
 805346b:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 805346d:	89 c2                	mov    %eax,%edx
 805346f:	d1 ea                	shr    %edx
 8053471:	31 d0                	xor    %edx,%eax
	cpu.PF = pf & 1;
 8053473:	83 e0 01             	and    $0x1,%eax
 8053476:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805347d:	89 c8                	mov    %ecx,%eax
 805347f:	83 e0 fb             	and    $0xfffffffb,%eax
 8053482:	09 d0                	or     %edx,%eax
 8053484:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	print_asm_template2();
 8053489:	e8 72 56 ff ff       	call   8048b00 <snprintf@plt>
 805348e:	83 c4 20             	add    $0x20,%esp
 8053491:	83 f8 4f             	cmp    $0x4f,%eax
 8053494:	7f 0a                	jg     80534a0 <do_test_b+0x90>
}
 8053496:	83 c4 08             	add    $0x8,%esp
 8053499:	5b                   	pop    %ebx
 805349a:	c3                   	ret    
 805349b:	90                   	nop
 805349c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	print_asm_template2();
 80534a0:	83 ec 0c             	sub    $0xc,%esp
 80534a3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80534a9:	e8 b2 54 ff ff       	call   8048960 <fflush@plt>
 80534ae:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80534b4:	6a 07                	push   $0x7
 80534b6:	6a 01                	push   $0x1
 80534b8:	68 92 e8 05 08       	push   $0x805e892
 80534bd:	e8 4e 55 ff ff       	call   8048a10 <fwrite@plt>
 80534c2:	83 c4 20             	add    $0x20,%esp
 80534c5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80534cb:	6a 10                	push   $0x10
 80534cd:	6a 01                	push   $0x1
 80534cf:	68 b4 f3 05 08       	push   $0x805f3b4
 80534d4:	e8 37 55 ff ff       	call   8048a10 <fwrite@plt>
 80534d9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80534df:	6a 05                	push   $0x5
 80534e1:	6a 01                	push   $0x1
 80534e3:	68 42 f3 05 08       	push   $0x805f342
 80534e8:	e8 23 55 ff ff       	call   8048a10 <fwrite@plt>
 80534ed:	83 c4 14             	add    $0x14,%esp
 80534f0:	68 50 af 0f 10       	push   $0x100faf50
 80534f5:	68 18 af 0f 10       	push   $0x100faf18
 80534fa:	68 0a 26 06 08       	push   $0x806260a
 80534ff:	6a 50                	push   $0x50
 8053501:	68 00 8a 0c 08       	push   $0x80c8a00
 8053506:	e8 f5 55 ff ff       	call   8048b00 <snprintf@plt>
 805350b:	83 c4 20             	add    $0x20,%esp
 805350e:	83 f8 4f             	cmp    $0x4f,%eax
 8053511:	7e 83                	jle    8053496 <do_test_b+0x86>
 8053513:	68 98 27 06 08       	push   $0x8062798
 8053518:	6a 0f                	push   $0xf
 805351a:	68 30 26 06 08       	push   $0x8062630
 805351f:	68 58 26 06 08       	push   $0x8062658
 8053524:	e8 87 56 ff ff       	call   8048bb0 <__assert_fail@plt>
 8053529:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08053530 <do_test_w>:
#include "cpu/exec/template-start.h"

#define instr test

static void do_execute() {
 8053530:	53                   	push   %ebx
 8053531:	83 ec 14             	sub    $0x14,%esp
	uint32_t res = op_src->val & op_dest->val;
 8053534:	a1 4c af 0f 10       	mov    0x100faf4c,%eax
 8053539:	23 05 14 af 0f 10    	and    0x100faf14,%eax
	cpu.CF = cpu.OF = 0;
 805353f:	80 25 e5 af 0f 10 f7 	andb   $0xf7,0x100fafe5
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	print_asm_template2();
 8053546:	68 50 af 0f 10       	push   $0x100faf50
 805354b:	68 18 af 0f 10       	push   $0x100faf18
 8053550:	68 16 26 06 08       	push   $0x8062616
 8053555:	6a 50                	push   $0x50
 8053557:	68 00 8a 0c 08       	push   $0x80c8a00
#define instr test

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
 805355c:	89 c1                	mov    %eax,%ecx
 805355e:	c1 e9 1f             	shr    $0x1f,%ecx
 8053561:	89 ca                	mov    %ecx,%edx
 8053563:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 805356a:	c1 e2 07             	shl    $0x7,%edx
 805356d:	83 e1 3e             	and    $0x3e,%ecx
	cpu.ZF = (res == 0);
 8053570:	85 c0                	test   %eax,%eax
	uint32_t pf = (res & 255);
 8053572:	0f b6 c0             	movzbl %al,%eax

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 8053575:	0f 94 c3             	sete   %bl
 8053578:	09 d1                	or     %edx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 805357a:	89 c2                	mov    %eax,%edx
 805357c:	c1 ea 04             	shr    $0x4,%edx

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 805357f:	c1 e3 06             	shl    $0x6,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 8053582:	31 d0                	xor    %edx,%eax

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 8053584:	09 d9                	or     %ebx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 8053586:	89 c2                	mov    %eax,%edx
 8053588:	c1 ea 02             	shr    $0x2,%edx
 805358b:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 805358d:	89 c2                	mov    %eax,%edx
 805358f:	d1 ea                	shr    %edx
 8053591:	31 d0                	xor    %edx,%eax
	cpu.PF = pf & 1;
 8053593:	83 e0 01             	and    $0x1,%eax
 8053596:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805359d:	89 c8                	mov    %ecx,%eax
 805359f:	83 e0 fb             	and    $0xfffffffb,%eax
 80535a2:	09 d0                	or     %edx,%eax
 80535a4:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	print_asm_template2();
 80535a9:	e8 52 55 ff ff       	call   8048b00 <snprintf@plt>
 80535ae:	83 c4 20             	add    $0x20,%esp
 80535b1:	83 f8 4f             	cmp    $0x4f,%eax
 80535b4:	7f 0a                	jg     80535c0 <do_test_w+0x90>
}
 80535b6:	83 c4 08             	add    $0x8,%esp
 80535b9:	5b                   	pop    %ebx
 80535ba:	c3                   	ret    
 80535bb:	90                   	nop
 80535bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	print_asm_template2();
 80535c0:	83 ec 0c             	sub    $0xc,%esp
 80535c3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80535c9:	e8 92 53 ff ff       	call   8048960 <fflush@plt>
 80535ce:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80535d4:	6a 07                	push   $0x7
 80535d6:	6a 01                	push   $0x1
 80535d8:	68 92 e8 05 08       	push   $0x805e892
 80535dd:	e8 2e 54 ff ff       	call   8048a10 <fwrite@plt>
 80535e2:	83 c4 20             	add    $0x20,%esp
 80535e5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80535eb:	6a 10                	push   $0x10
 80535ed:	6a 01                	push   $0x1
 80535ef:	68 b4 f3 05 08       	push   $0x805f3b4
 80535f4:	e8 17 54 ff ff       	call   8048a10 <fwrite@plt>
 80535f9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80535ff:	6a 05                	push   $0x5
 8053601:	6a 01                	push   $0x1
 8053603:	68 42 f3 05 08       	push   $0x805f342
 8053608:	e8 03 54 ff ff       	call   8048a10 <fwrite@plt>
 805360d:	83 c4 14             	add    $0x14,%esp
 8053610:	68 50 af 0f 10       	push   $0x100faf50
 8053615:	68 18 af 0f 10       	push   $0x100faf18
 805361a:	68 16 26 06 08       	push   $0x8062616
 805361f:	6a 50                	push   $0x50
 8053621:	68 00 8a 0c 08       	push   $0x80c8a00
 8053626:	e8 d5 54 ff ff       	call   8048b00 <snprintf@plt>
 805362b:	83 c4 20             	add    $0x20,%esp
 805362e:	83 f8 4f             	cmp    $0x4f,%eax
 8053631:	7e 83                	jle    80535b6 <do_test_w+0x86>
 8053633:	68 8e 27 06 08       	push   $0x806278e
 8053638:	6a 0f                	push   $0xf
 805363a:	68 30 26 06 08       	push   $0x8062630
 805363f:	68 bc 26 06 08       	push   $0x80626bc
 8053644:	e8 67 55 ff ff       	call   8048bb0 <__assert_fail@plt>
 8053649:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08053650 <test_r2rm_w>:
}

make_instr_helper(r2rm)
 8053650:	53                   	push   %ebx
 8053651:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053654:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053658:	83 c0 01             	add    $0x1,%eax
 805365b:	50                   	push   %eax
 805365c:	e8 ef 91 00 00       	call   805c850 <decode_r2rm_w>
 8053661:	89 c3                	mov    %eax,%ebx
	execute();
 8053663:	e8 c8 fe ff ff       	call   8053530 <do_test_w>
 8053668:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805366b:	8d 43 01             	lea    0x1(%ebx),%eax
 805366e:	5b                   	pop    %ebx
 805366f:	c3                   	ret    

08053670 <test_i2rm_w>:
make_instr_helper(i2rm)
 8053670:	53                   	push   %ebx
 8053671:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053674:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053678:	83 c0 01             	add    $0x1,%eax
 805367b:	50                   	push   %eax
 805367c:	e8 8f 92 00 00       	call   805c910 <decode_i2rm_w>
 8053681:	89 c3                	mov    %eax,%ebx
	execute();
 8053683:	e8 a8 fe ff ff       	call   8053530 <do_test_w>
 8053688:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805368b:	8d 43 01             	lea    0x1(%ebx),%eax
 805368e:	5b                   	pop    %ebx
 805368f:	c3                   	ret    

08053690 <test_i2a_w>:
make_instr_helper(i2a)
 8053690:	53                   	push   %ebx
 8053691:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053694:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053698:	83 c0 01             	add    $0x1,%eax
 805369b:	50                   	push   %eax
 805369c:	e8 ef 91 00 00       	call   805c890 <decode_i2a_w>
 80536a1:	89 c3                	mov    %eax,%ebx
	execute();
 80536a3:	e8 88 fe ff ff       	call   8053530 <do_test_w>
 80536a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80536ab:	8d 43 01             	lea    0x1(%ebx),%eax
 80536ae:	5b                   	pop    %ebx
 80536af:	c3                   	ret    

080536b0 <do_test_l>:
#include "cpu/exec/template-start.h"

#define instr test

static void do_execute() {
 80536b0:	53                   	push   %ebx
 80536b1:	83 ec 14             	sub    $0x14,%esp
	uint32_t res = op_src->val & op_dest->val;
 80536b4:	a1 4c af 0f 10       	mov    0x100faf4c,%eax
 80536b9:	23 05 14 af 0f 10    	and    0x100faf14,%eax
	cpu.CF = cpu.OF = 0;
 80536bf:	80 25 e5 af 0f 10 f7 	andb   $0xf7,0x100fafe5
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	print_asm_template2();
 80536c6:	68 50 af 0f 10       	push   $0x100faf50
 80536cb:	68 18 af 0f 10       	push   $0x100faf18
 80536d0:	68 22 26 06 08       	push   $0x8062622
 80536d5:	6a 50                	push   $0x50
 80536d7:	68 00 8a 0c 08       	push   $0x80c8a00
#define instr test

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
 80536dc:	89 c1                	mov    %eax,%ecx
 80536de:	c1 e9 1f             	shr    $0x1f,%ecx
 80536e1:	89 ca                	mov    %ecx,%edx
 80536e3:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 80536ea:	c1 e2 07             	shl    $0x7,%edx
 80536ed:	83 e1 3e             	and    $0x3e,%ecx
	cpu.ZF = (res == 0);
 80536f0:	85 c0                	test   %eax,%eax
	uint32_t pf = (res & 255);
 80536f2:	0f b6 c0             	movzbl %al,%eax

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 80536f5:	0f 94 c3             	sete   %bl
 80536f8:	09 d1                	or     %edx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 80536fa:	89 c2                	mov    %eax,%edx
 80536fc:	c1 ea 04             	shr    $0x4,%edx

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 80536ff:	c1 e3 06             	shl    $0x6,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 8053702:	31 d0                	xor    %edx,%eax

static void do_execute() {
	uint32_t res = op_src->val & op_dest->val;
	cpu.CF = cpu.OF = 0;
	cpu.SF = (res >> 31) & 1;
	cpu.ZF = (res == 0);
 8053704:	09 d9                	or     %ebx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 8053706:	89 c2                	mov    %eax,%edx
 8053708:	c1 ea 02             	shr    $0x2,%edx
 805370b:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 805370d:	89 c2                	mov    %eax,%edx
 805370f:	d1 ea                	shr    %edx
 8053711:	31 d0                	xor    %edx,%eax
	cpu.PF = pf & 1;
 8053713:	83 e0 01             	and    $0x1,%eax
 8053716:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805371d:	89 c8                	mov    %ecx,%eax
 805371f:	83 e0 fb             	and    $0xfffffffb,%eax
 8053722:	09 d0                	or     %edx,%eax
 8053724:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	print_asm_template2();
 8053729:	e8 d2 53 ff ff       	call   8048b00 <snprintf@plt>
 805372e:	83 c4 20             	add    $0x20,%esp
 8053731:	83 f8 4f             	cmp    $0x4f,%eax
 8053734:	7f 0a                	jg     8053740 <do_test_l+0x90>
}
 8053736:	83 c4 08             	add    $0x8,%esp
 8053739:	5b                   	pop    %ebx
 805373a:	c3                   	ret    
 805373b:	90                   	nop
 805373c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	print_asm_template2();
 8053740:	83 ec 0c             	sub    $0xc,%esp
 8053743:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8053749:	e8 12 52 ff ff       	call   8048960 <fflush@plt>
 805374e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8053754:	6a 07                	push   $0x7
 8053756:	6a 01                	push   $0x1
 8053758:	68 92 e8 05 08       	push   $0x805e892
 805375d:	e8 ae 52 ff ff       	call   8048a10 <fwrite@plt>
 8053762:	83 c4 20             	add    $0x20,%esp
 8053765:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805376b:	6a 10                	push   $0x10
 805376d:	6a 01                	push   $0x1
 805376f:	68 b4 f3 05 08       	push   $0x805f3b4
 8053774:	e8 97 52 ff ff       	call   8048a10 <fwrite@plt>
 8053779:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805377f:	6a 05                	push   $0x5
 8053781:	6a 01                	push   $0x1
 8053783:	68 42 f3 05 08       	push   $0x805f342
 8053788:	e8 83 52 ff ff       	call   8048a10 <fwrite@plt>
 805378d:	83 c4 14             	add    $0x14,%esp
 8053790:	68 50 af 0f 10       	push   $0x100faf50
 8053795:	68 18 af 0f 10       	push   $0x100faf18
 805379a:	68 22 26 06 08       	push   $0x8062622
 805379f:	6a 50                	push   $0x50
 80537a1:	68 00 8a 0c 08       	push   $0x80c8a00
 80537a6:	e8 55 53 ff ff       	call   8048b00 <snprintf@plt>
 80537ab:	83 c4 20             	add    $0x20,%esp
 80537ae:	83 f8 4f             	cmp    $0x4f,%eax
 80537b1:	7e 83                	jle    8053736 <do_test_l+0x86>
 80537b3:	68 84 27 06 08       	push   $0x8062784
 80537b8:	6a 0f                	push   $0xf
 80537ba:	68 30 26 06 08       	push   $0x8062630
 80537bf:	68 20 27 06 08       	push   $0x8062720
 80537c4:	e8 e7 53 ff ff       	call   8048bb0 <__assert_fail@plt>
 80537c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

080537d0 <test_r2rm_l>:
}

make_instr_helper(r2rm)
 80537d0:	53                   	push   %ebx
 80537d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80537d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80537d8:	83 c0 01             	add    $0x1,%eax
 80537db:	50                   	push   %eax
 80537dc:	e8 3f 94 00 00       	call   805cc20 <decode_r2rm_l>
 80537e1:	89 c3                	mov    %eax,%ebx
	execute();
 80537e3:	e8 c8 fe ff ff       	call   80536b0 <do_test_l>
 80537e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80537eb:	8d 43 01             	lea    0x1(%ebx),%eax
 80537ee:	5b                   	pop    %ebx
 80537ef:	c3                   	ret    

080537f0 <test_i2rm_l>:
make_instr_helper(i2rm)
 80537f0:	53                   	push   %ebx
 80537f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80537f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80537f8:	83 c0 01             	add    $0x1,%eax
 80537fb:	50                   	push   %eax
 80537fc:	e8 df 94 00 00       	call   805cce0 <decode_i2rm_l>
 8053801:	89 c3                	mov    %eax,%ebx
	execute();
 8053803:	e8 a8 fe ff ff       	call   80536b0 <do_test_l>
 8053808:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805380b:	8d 43 01             	lea    0x1(%ebx),%eax
 805380e:	5b                   	pop    %ebx
 805380f:	c3                   	ret    

08053810 <test_i2a_l>:
make_instr_helper(i2a)
 8053810:	53                   	push   %ebx
 8053811:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053814:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053818:	83 c0 01             	add    $0x1,%eax
 805381b:	50                   	push   %eax
 805381c:	e8 3f 94 00 00       	call   805cc60 <decode_i2a_l>
 8053821:	89 c3                	mov    %eax,%ebx
	execute();
 8053823:	e8 88 fe ff ff       	call   80536b0 <do_test_l>
 8053828:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805382b:	8d 43 01             	lea    0x1(%ebx),%eax
 805382e:	5b                   	pop    %ebx
 805382f:	c3                   	ret    

08053830 <test_r2rm_b>:
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	print_asm_template2();
}

make_instr_helper(r2rm)
 8053830:	53                   	push   %ebx
 8053831:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053834:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053838:	83 c0 01             	add    $0x1,%eax
 805383b:	50                   	push   %eax
 805383c:	e8 df 8c 00 00       	call   805c520 <decode_r2rm_b>
 8053841:	89 c3                	mov    %eax,%ebx
	execute();
 8053843:	e8 c8 fb ff ff       	call   8053410 <do_test_b>
 8053848:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805384b:	8d 43 01             	lea    0x1(%ebx),%eax
 805384e:	5b                   	pop    %ebx
 805384f:	c3                   	ret    

08053850 <test_i2rm_b>:
make_instr_helper(i2rm)
 8053850:	53                   	push   %ebx
 8053851:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053854:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053858:	83 c0 01             	add    $0x1,%eax
 805385b:	50                   	push   %eax
 805385c:	e8 7f 8d 00 00       	call   805c5e0 <decode_i2rm_b>
 8053861:	89 c3                	mov    %eax,%ebx
	execute();
 8053863:	e8 a8 fb ff ff       	call   8053410 <do_test_b>
 8053868:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805386b:	8d 43 01             	lea    0x1(%ebx),%eax
 805386e:	5b                   	pop    %ebx
 805386f:	c3                   	ret    

08053870 <test_i2a_b>:
make_instr_helper(i2a)
 8053870:	53                   	push   %ebx
 8053871:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053874:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053878:	83 c0 01             	add    $0x1,%eax
 805387b:	50                   	push   %eax
 805387c:	e8 df 8c 00 00       	call   805c560 <decode_i2a_b>
 8053881:	89 c3                	mov    %eax,%ebx
	execute();
 8053883:	e8 88 fb ff ff       	call   8053410 <do_test_b>
 8053888:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805388b:	8d 43 01             	lea    0x1(%ebx),%eax
 805388e:	5b                   	pop    %ebx
 805388f:	c3                   	ret    

08053890 <test_r2rm_v>:
#include "test-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(test_r2rm)
 8053890:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053897:	8b 54 24 04          	mov    0x4(%esp),%edx
 805389b:	b8 50 36 05 08       	mov    $0x8053650,%eax
 80538a0:	75 05                	jne    80538a7 <test_r2rm_v+0x17>
 80538a2:	b8 d0 37 05 08       	mov    $0x80537d0,%eax
 80538a7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80538ab:	ff e0                	jmp    *%eax
 80538ad:	8d 76 00             	lea    0x0(%esi),%esi

080538b0 <test_i2rm_v>:
make_helper_v(test_i2rm)
 80538b0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80538b7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80538bb:	b8 70 36 05 08       	mov    $0x8053670,%eax
 80538c0:	75 05                	jne    80538c7 <test_i2rm_v+0x17>
 80538c2:	b8 f0 37 05 08       	mov    $0x80537f0,%eax
 80538c7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80538cb:	ff e0                	jmp    *%eax
 80538cd:	8d 76 00             	lea    0x0(%esi),%esi

080538d0 <test_i2a_v>:
make_helper_v(test_i2a)
 80538d0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80538d7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80538db:	b8 90 36 05 08       	mov    $0x8053690,%eax
 80538e0:	75 05                	jne    80538e7 <test_i2a_v+0x17>
 80538e2:	b8 10 38 05 08       	mov    $0x8053810,%eax
 80538e7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80538eb:	ff e0                	jmp    *%eax
 80538ed:	66 90                	xchg   %ax,%ax
 80538ef:	90                   	nop

080538f0 <do_sbb_b>:
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
 80538f0:	55                   	push   %ebp
 80538f1:	57                   	push   %edi
 80538f2:	56                   	push   %esi
 80538f3:	53                   	push   %ebx
 80538f4:	83 ec 24             	sub    $0x24,%esp
	op_src->val = op_src->val + cpu.CF;
 80538f7:	0f b6 3d e4 af 0f 10 	movzbl 0x100fafe4,%edi
	uint32_t res = op_dest->val - op_src->val;
 80538fe:	8b 0d 4c af 0f 10    	mov    0x100faf4c,%ecx
 8053904:	89 cb                	mov    %ecx,%ebx
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
	op_src->val = op_src->val + cpu.CF;
 8053906:	89 fe                	mov    %edi,%esi
 8053908:	83 e6 01             	and    $0x1,%esi
 805390b:	03 35 14 af 0f 10    	add    0x100faf14,%esi
	uint32_t res = op_dest->val - op_src->val;
 8053911:	29 f3                	sub    %esi,%ebx
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
	op_src->val = op_src->val + cpu.CF;
 8053913:	89 35 14 af 0f 10    	mov    %esi,0x100faf14
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
 8053919:	0f b6 c3             	movzbl %bl,%eax
	pf = (pf >> 4) ^ pf;
 805391c:	89 c2                	mov    %eax,%edx
 805391e:	c1 ea 04             	shr    $0x4,%edx
 8053921:	31 d0                	xor    %edx,%eax
	pf = (pf >> 2) ^ pf;
 8053923:	89 c2                	mov    %eax,%edx
 8053925:	c1 ea 02             	shr    $0x2,%edx
 8053928:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 805392a:	89 c2                	mov    %eax,%edx
 805392c:	d1 ea                	shr    %edx
	cpu.CF = op_dest->val < op_src->val;
 805392e:	39 ce                	cmp    %ecx,%esi
	op_src->val = op_src->val + cpu.CF;
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 8053930:	89 54 24 14          	mov    %edx,0x14(%esp)
	cpu.CF = op_dest->val < op_src->val;
 8053934:	0f 97 c2             	seta   %dl
	op_src->val = op_src->val + cpu.CF;
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 8053937:	33 44 24 14          	xor    0x14(%esp),%eax
	cpu.CF = op_dest->val < op_src->val;
 805393b:	83 e7 fa             	and    $0xfffffffa,%edi
 805393e:	89 d5                	mov    %edx,%ebp
	cpu.PF = (pf & 1);
 8053940:	83 e0 01             	and    $0x1,%eax
 8053943:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805394a:	89 f8                	mov    %edi,%eax
 805394c:	09 e8                	or     %ebp,%eax
 805394e:	09 d0                	or     %edx,%eax
	cpu.ZF = (res == 0);
 8053950:	85 db                	test   %ebx,%ebx
 8053952:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 8053955:	c1 eb 1f             	shr    $0x1f,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 8053958:	83 e0 3f             	and    $0x3f,%eax
 805395b:	c1 e2 06             	shl    $0x6,%edx
	cpu.SF = (res >> 31) & 1;
 805395e:	89 df                	mov    %ebx,%edi
 8053960:	09 d0                	or     %edx,%eax
 8053962:	c1 e7 07             	shl    $0x7,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053965:	89 ca                	mov    %ecx,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 8053967:	09 f8                	or     %edi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053969:	c1 ea 1f             	shr    $0x1f,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 805396c:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053971:	89 f0                	mov    %esi,%eax
 8053973:	31 d3                	xor    %edx,%ebx
 8053975:	c1 e8 1f             	shr    $0x1f,%eax
 8053978:	31 d0                	xor    %edx,%eax
 805397a:	21 c3                	and    %eax,%ebx
 805397c:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
 8053983:	c1 e3 03             	shl    $0x3,%ebx
 8053986:	83 e0 f7             	and    $0xfffffff7,%eax
 8053989:	09 c3                	or     %eax,%ebx
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 805398b:	89 f0                	mov    %esi,%eax
 805398d:	29 c1                	sub    %eax,%ecx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805398f:	88 1d e5 af 0f 10    	mov    %bl,0x100fafe5
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8053995:	0f b6 c9             	movzbl %cl,%ecx
 8053998:	51                   	push   %ecx
 8053999:	68 40 af 0f 10       	push   $0x100faf40
 805399e:	e8 9d 8d 00 00       	call   805c740 <write_operand_b>
	print_asm_template2();
 80539a3:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 80539aa:	68 18 af 0f 10       	push   $0x100faf18
 80539af:	68 a2 27 06 08       	push   $0x80627a2
 80539b4:	6a 50                	push   $0x50
 80539b6:	68 00 8a 0c 08       	push   $0x80c8a00
 80539bb:	e8 40 51 ff ff       	call   8048b00 <snprintf@plt>
 80539c0:	83 c4 20             	add    $0x20,%esp
 80539c3:	83 f8 4f             	cmp    $0x4f,%eax
 80539c6:	7f 08                	jg     80539d0 <do_sbb_b+0xe0>
}
 80539c8:	83 c4 1c             	add    $0x1c,%esp
 80539cb:	5b                   	pop    %ebx
 80539cc:	5e                   	pop    %esi
 80539cd:	5f                   	pop    %edi
 80539ce:	5d                   	pop    %ebp
 80539cf:	c3                   	ret    
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
 80539d0:	83 ec 0c             	sub    $0xc,%esp
 80539d3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80539d9:	e8 82 4f ff ff       	call   8048960 <fflush@plt>
 80539de:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80539e4:	6a 07                	push   $0x7
 80539e6:	6a 01                	push   $0x1
 80539e8:	68 92 e8 05 08       	push   $0x805e892
 80539ed:	e8 1e 50 ff ff       	call   8048a10 <fwrite@plt>
 80539f2:	83 c4 20             	add    $0x20,%esp
 80539f5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80539fb:	6a 10                	push   $0x10
 80539fd:	6a 01                	push   $0x1
 80539ff:	68 b4 f3 05 08       	push   $0x805f3b4
 8053a04:	e8 07 50 ff ff       	call   8048a10 <fwrite@plt>
 8053a09:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8053a0f:	6a 05                	push   $0x5
 8053a11:	6a 01                	push   $0x1
 8053a13:	68 42 f3 05 08       	push   $0x805f342
 8053a18:	e8 f3 4f ff ff       	call   8048a10 <fwrite@plt>
 8053a1d:	83 c4 14             	add    $0x14,%esp
 8053a20:	68 50 af 0f 10       	push   $0x100faf50
 8053a25:	68 18 af 0f 10       	push   $0x100faf18
 8053a2a:	68 a2 27 06 08       	push   $0x80627a2
 8053a2f:	6a 50                	push   $0x50
 8053a31:	68 00 8a 0c 08       	push   $0x80c8a00
 8053a36:	e8 c5 50 ff ff       	call   8048b00 <snprintf@plt>
 8053a3b:	83 c4 20             	add    $0x20,%esp
 8053a3e:	83 f8 4f             	cmp    $0x4f,%eax
 8053a41:	7e 85                	jle    80539c8 <do_sbb_b+0xd8>
 8053a43:	68 29 29 06 08       	push   $0x8062929
 8053a48:	6a 12                	push   $0x12
 8053a4a:	68 c4 27 06 08       	push   $0x80627c4
 8053a4f:	68 ec 27 06 08       	push   $0x80627ec
 8053a54:	e8 57 51 ff ff       	call   8048bb0 <__assert_fail@plt>
 8053a59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08053a60 <do_sbb_w>:
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
 8053a60:	55                   	push   %ebp
 8053a61:	57                   	push   %edi
 8053a62:	56                   	push   %esi
 8053a63:	53                   	push   %ebx
 8053a64:	83 ec 24             	sub    $0x24,%esp
	op_src->val = op_src->val + cpu.CF;
 8053a67:	0f b6 3d e4 af 0f 10 	movzbl 0x100fafe4,%edi
	uint32_t res = op_dest->val - op_src->val;
 8053a6e:	8b 0d 4c af 0f 10    	mov    0x100faf4c,%ecx
 8053a74:	89 cb                	mov    %ecx,%ebx
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
	op_src->val = op_src->val + cpu.CF;
 8053a76:	89 fe                	mov    %edi,%esi
 8053a78:	83 e6 01             	and    $0x1,%esi
 8053a7b:	03 35 14 af 0f 10    	add    0x100faf14,%esi
	uint32_t res = op_dest->val - op_src->val;
 8053a81:	29 f3                	sub    %esi,%ebx
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
	op_src->val = op_src->val + cpu.CF;
 8053a83:	89 35 14 af 0f 10    	mov    %esi,0x100faf14
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
 8053a89:	0f b6 c3             	movzbl %bl,%eax
	pf = (pf >> 4) ^ pf;
 8053a8c:	89 c2                	mov    %eax,%edx
 8053a8e:	c1 ea 04             	shr    $0x4,%edx
 8053a91:	31 d0                	xor    %edx,%eax
	pf = (pf >> 2) ^ pf;
 8053a93:	89 c2                	mov    %eax,%edx
 8053a95:	c1 ea 02             	shr    $0x2,%edx
 8053a98:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 8053a9a:	89 c2                	mov    %eax,%edx
 8053a9c:	d1 ea                	shr    %edx
	cpu.CF = op_dest->val < op_src->val;
 8053a9e:	39 ce                	cmp    %ecx,%esi
	op_src->val = op_src->val + cpu.CF;
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 8053aa0:	89 54 24 14          	mov    %edx,0x14(%esp)
	cpu.CF = op_dest->val < op_src->val;
 8053aa4:	0f 97 c2             	seta   %dl
	op_src->val = op_src->val + cpu.CF;
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 8053aa7:	33 44 24 14          	xor    0x14(%esp),%eax
	cpu.CF = op_dest->val < op_src->val;
 8053aab:	83 e7 fa             	and    $0xfffffffa,%edi
 8053aae:	89 d5                	mov    %edx,%ebp
	cpu.PF = (pf & 1);
 8053ab0:	83 e0 01             	and    $0x1,%eax
 8053ab3:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 8053aba:	89 f8                	mov    %edi,%eax
 8053abc:	09 e8                	or     %ebp,%eax
 8053abe:	09 d0                	or     %edx,%eax
	cpu.ZF = (res == 0);
 8053ac0:	85 db                	test   %ebx,%ebx
 8053ac2:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 8053ac5:	c1 eb 1f             	shr    $0x1f,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 8053ac8:	83 e0 3f             	and    $0x3f,%eax
 8053acb:	c1 e2 06             	shl    $0x6,%edx
	cpu.SF = (res >> 31) & 1;
 8053ace:	89 df                	mov    %ebx,%edi
 8053ad0:	09 d0                	or     %edx,%eax
 8053ad2:	c1 e7 07             	shl    $0x7,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053ad5:	89 ca                	mov    %ecx,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 8053ad7:	09 f8                	or     %edi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053ad9:	c1 ea 1f             	shr    $0x1f,%edx
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8053adc:	29 f1                	sub    %esi,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 8053ade:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053ae3:	89 f0                	mov    %esi,%eax
 8053ae5:	31 d3                	xor    %edx,%ebx
 8053ae7:	c1 e8 1f             	shr    $0x1f,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8053aea:	0f b7 c9             	movzwl %cx,%ecx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053aed:	31 d0                	xor    %edx,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8053aef:	51                   	push   %ecx
 8053af0:	68 40 af 0f 10       	push   $0x100faf40
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053af5:	21 c3                	and    %eax,%ebx
 8053af7:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
 8053afe:	c1 e3 03             	shl    $0x3,%ebx
 8053b01:	83 e0 f7             	and    $0xfffffff7,%eax
 8053b04:	09 c3                	or     %eax,%ebx
 8053b06:	88 1d e5 af 0f 10    	mov    %bl,0x100fafe5
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8053b0c:	e8 bf 8f 00 00       	call   805cad0 <write_operand_w>
	print_asm_template2();
 8053b11:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 8053b18:	68 18 af 0f 10       	push   $0x100faf18
 8053b1d:	68 ad 27 06 08       	push   $0x80627ad
 8053b22:	6a 50                	push   $0x50
 8053b24:	68 00 8a 0c 08       	push   $0x80c8a00
 8053b29:	e8 d2 4f ff ff       	call   8048b00 <snprintf@plt>
 8053b2e:	83 c4 20             	add    $0x20,%esp
 8053b31:	83 f8 4f             	cmp    $0x4f,%eax
 8053b34:	7f 0a                	jg     8053b40 <do_sbb_w+0xe0>
}
 8053b36:	83 c4 1c             	add    $0x1c,%esp
 8053b39:	5b                   	pop    %ebx
 8053b3a:	5e                   	pop    %esi
 8053b3b:	5f                   	pop    %edi
 8053b3c:	5d                   	pop    %ebp
 8053b3d:	c3                   	ret    
 8053b3e:	66 90                	xchg   %ax,%ax
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
 8053b40:	83 ec 0c             	sub    $0xc,%esp
 8053b43:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8053b49:	e8 12 4e ff ff       	call   8048960 <fflush@plt>
 8053b4e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8053b54:	6a 07                	push   $0x7
 8053b56:	6a 01                	push   $0x1
 8053b58:	68 92 e8 05 08       	push   $0x805e892
 8053b5d:	e8 ae 4e ff ff       	call   8048a10 <fwrite@plt>
 8053b62:	83 c4 20             	add    $0x20,%esp
 8053b65:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8053b6b:	6a 10                	push   $0x10
 8053b6d:	6a 01                	push   $0x1
 8053b6f:	68 b4 f3 05 08       	push   $0x805f3b4
 8053b74:	e8 97 4e ff ff       	call   8048a10 <fwrite@plt>
 8053b79:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8053b7f:	6a 05                	push   $0x5
 8053b81:	6a 01                	push   $0x1
 8053b83:	68 42 f3 05 08       	push   $0x805f342
 8053b88:	e8 83 4e ff ff       	call   8048a10 <fwrite@plt>
 8053b8d:	83 c4 14             	add    $0x14,%esp
 8053b90:	68 50 af 0f 10       	push   $0x100faf50
 8053b95:	68 18 af 0f 10       	push   $0x100faf18
 8053b9a:	68 ad 27 06 08       	push   $0x80627ad
 8053b9f:	6a 50                	push   $0x50
 8053ba1:	68 00 8a 0c 08       	push   $0x80c8a00
 8053ba6:	e8 55 4f ff ff       	call   8048b00 <snprintf@plt>
 8053bab:	83 c4 20             	add    $0x20,%esp
 8053bae:	83 f8 4f             	cmp    $0x4f,%eax
 8053bb1:	7e 83                	jle    8053b36 <do_sbb_w+0xd6>
 8053bb3:	68 20 29 06 08       	push   $0x8062920
 8053bb8:	6a 12                	push   $0x12
 8053bba:	68 c4 27 06 08       	push   $0x80627c4
 8053bbf:	68 50 28 06 08       	push   $0x8062850
 8053bc4:	e8 e7 4f ff ff       	call   8048bb0 <__assert_fail@plt>
 8053bc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08053bd0 <sbb_i2a_w>:
}

make_instr_helper(i2a)
 8053bd0:	53                   	push   %ebx
 8053bd1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053bd4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053bd8:	83 c0 01             	add    $0x1,%eax
 8053bdb:	50                   	push   %eax
 8053bdc:	e8 af 8c 00 00       	call   805c890 <decode_i2a_w>
 8053be1:	89 c3                	mov    %eax,%ebx
	execute();
 8053be3:	e8 78 fe ff ff       	call   8053a60 <do_sbb_w>
 8053be8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053beb:	8d 43 01             	lea    0x1(%ebx),%eax
 8053bee:	5b                   	pop    %ebx
 8053bef:	c3                   	ret    

08053bf0 <sbb_i2rm_w>:
make_instr_helper(i2rm)
 8053bf0:	53                   	push   %ebx
 8053bf1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053bf4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053bf8:	83 c0 01             	add    $0x1,%eax
 8053bfb:	50                   	push   %eax
 8053bfc:	e8 0f 8d 00 00       	call   805c910 <decode_i2rm_w>
 8053c01:	89 c3                	mov    %eax,%ebx
	execute();
 8053c03:	e8 58 fe ff ff       	call   8053a60 <do_sbb_w>
 8053c08:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053c0b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053c0e:	5b                   	pop    %ebx
 8053c0f:	c3                   	ret    

08053c10 <sbb_r2rm_w>:
make_instr_helper(r2rm)
 8053c10:	53                   	push   %ebx
 8053c11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053c14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053c18:	83 c0 01             	add    $0x1,%eax
 8053c1b:	50                   	push   %eax
 8053c1c:	e8 2f 8c 00 00       	call   805c850 <decode_r2rm_w>
 8053c21:	89 c3                	mov    %eax,%ebx
	execute();
 8053c23:	e8 38 fe ff ff       	call   8053a60 <do_sbb_w>
 8053c28:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053c2b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053c2e:	5b                   	pop    %ebx
 8053c2f:	c3                   	ret    

08053c30 <sbb_rm2r_w>:
make_instr_helper(rm2r)
 8053c30:	53                   	push   %ebx
 8053c31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053c34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053c38:	83 c0 01             	add    $0x1,%eax
 8053c3b:	50                   	push   %eax
 8053c3c:	e8 2f 8c 00 00       	call   805c870 <decode_rm2r_w>
 8053c41:	89 c3                	mov    %eax,%ebx
	execute();
 8053c43:	e8 18 fe ff ff       	call   8053a60 <do_sbb_w>
 8053c48:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053c4b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053c4e:	5b                   	pop    %ebx
 8053c4f:	c3                   	ret    

08053c50 <sbb_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8053c50:	53                   	push   %ebx
 8053c51:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053c54:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053c58:	83 c0 01             	add    $0x1,%eax
 8053c5b:	50                   	push   %eax
 8053c5c:	e8 2f 8d 00 00       	call   805c990 <decode_si2rm_w>
 8053c61:	89 c3                	mov    %eax,%ebx
	execute();
 8053c63:	e8 f8 fd ff ff       	call   8053a60 <do_sbb_w>
 8053c68:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053c6b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053c6e:	5b                   	pop    %ebx
 8053c6f:	c3                   	ret    

08053c70 <do_sbb_l>:
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
 8053c70:	55                   	push   %ebp
 8053c71:	57                   	push   %edi
 8053c72:	56                   	push   %esi
 8053c73:	53                   	push   %ebx
 8053c74:	83 ec 14             	sub    $0x14,%esp
	op_src->val = op_src->val + cpu.CF;
 8053c77:	0f b6 2d e4 af 0f 10 	movzbl 0x100fafe4,%ebp
	uint32_t res = op_dest->val - op_src->val;
 8053c7e:	8b 3d 4c af 0f 10    	mov    0x100faf4c,%edi
 8053c84:	89 f9                	mov    %edi,%ecx
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
	op_src->val = op_src->val + cpu.CF;
 8053c86:	89 ea                	mov    %ebp,%edx
 8053c88:	83 e2 01             	and    $0x1,%edx
 8053c8b:	03 15 14 af 0f 10    	add    0x100faf14,%edx
	uint32_t res = op_dest->val - op_src->val;
 8053c91:	29 d1                	sub    %edx,%ecx
#include "cpu/exec/template-start.h"

#define instr sbb

static void do_execute() {
	op_src->val = op_src->val + cpu.CF;
 8053c93:	89 15 14 af 0f 10    	mov    %edx,0x100faf14
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
 8053c99:	0f b6 c1             	movzbl %cl,%eax
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8053c9c:	51                   	push   %ecx
 8053c9d:	68 40 af 0f 10       	push   $0x100faf40

static void do_execute() {
	op_src->val = op_src->val + cpu.CF;
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 8053ca2:	89 c3                	mov    %eax,%ebx
 8053ca4:	c1 eb 04             	shr    $0x4,%ebx
 8053ca7:	31 d8                	xor    %ebx,%eax
	pf = (pf >> 2) ^ pf;
 8053ca9:	89 c3                	mov    %eax,%ebx
 8053cab:	c1 eb 02             	shr    $0x2,%ebx
 8053cae:	31 d8                	xor    %ebx,%eax
	pf = (pf >> 1) ^ pf;
 8053cb0:	89 c6                	mov    %eax,%esi
 8053cb2:	d1 ee                	shr    %esi
	cpu.CF = op_dest->val < op_src->val;
 8053cb4:	39 fa                	cmp    %edi,%edx
 8053cb6:	0f 97 c3             	seta   %bl
	op_src->val = op_src->val + cpu.CF;
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 8053cb9:	31 f0                	xor    %esi,%eax
	cpu.CF = op_dest->val < op_src->val;
 8053cbb:	83 e5 fa             	and    $0xfffffffa,%ebp
	cpu.PF = (pf & 1);
 8053cbe:	83 e0 01             	and    $0x1,%eax
 8053cc1:	09 eb                	or     %ebp,%ebx
 8053cc3:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 8053cca:	09 f3                	or     %esi,%ebx
	cpu.ZF = (res == 0);
 8053ccc:	85 c9                	test   %ecx,%ecx
 8053cce:	0f 94 c0             	sete   %al
 8053cd1:	83 e3 3f             	and    $0x3f,%ebx
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053cd4:	c1 ef 1f             	shr    $0x1f,%edi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 8053cd7:	c1 e0 06             	shl    $0x6,%eax
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053cda:	c1 ea 1f             	shr    $0x1f,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 8053cdd:	89 c6                	mov    %eax,%esi
	cpu.SF = (res >> 31) & 1;
 8053cdf:	89 c8                	mov    %ecx,%eax
 8053ce1:	c1 e8 1f             	shr    $0x1f,%eax
 8053ce4:	09 f3                	or     %esi,%ebx
 8053ce6:	89 c5                	mov    %eax,%ebp
 8053ce8:	c1 e5 07             	shl    $0x7,%ebp
 8053ceb:	09 eb                	or     %ebp,%ebx
 8053ced:	88 1d e4 af 0f 10    	mov    %bl,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8053cf3:	89 c3                	mov    %eax,%ebx
 8053cf5:	89 f8                	mov    %edi,%eax
 8053cf7:	31 d0                	xor    %edx,%eax
 8053cf9:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8053d00:	31 fb                	xor    %edi,%ebx
 8053d02:	21 d8                	and    %ebx,%eax
 8053d04:	c1 e0 03             	shl    $0x3,%eax
 8053d07:	83 e2 f7             	and    $0xfffffff7,%edx
 8053d0a:	09 d0                	or     %edx,%eax
 8053d0c:	a2 e5 af 0f 10       	mov    %al,0x100fafe5
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8053d11:	e8 8a 91 00 00       	call   805cea0 <write_operand_l>
	print_asm_template2();
 8053d16:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 8053d1d:	68 18 af 0f 10       	push   $0x100faf18
 8053d22:	68 b8 27 06 08       	push   $0x80627b8
 8053d27:	6a 50                	push   $0x50
 8053d29:	68 00 8a 0c 08       	push   $0x80c8a00
 8053d2e:	e8 cd 4d ff ff       	call   8048b00 <snprintf@plt>
 8053d33:	83 c4 20             	add    $0x20,%esp
 8053d36:	83 f8 4f             	cmp    $0x4f,%eax
 8053d39:	7f 0d                	jg     8053d48 <do_sbb_l+0xd8>
}
 8053d3b:	83 c4 0c             	add    $0xc,%esp
 8053d3e:	5b                   	pop    %ebx
 8053d3f:	5e                   	pop    %esi
 8053d40:	5f                   	pop    %edi
 8053d41:	5d                   	pop    %ebp
 8053d42:	c3                   	ret    
 8053d43:	90                   	nop
 8053d44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
 8053d48:	83 ec 0c             	sub    $0xc,%esp
 8053d4b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8053d51:	e8 0a 4c ff ff       	call   8048960 <fflush@plt>
 8053d56:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8053d5c:	6a 07                	push   $0x7
 8053d5e:	6a 01                	push   $0x1
 8053d60:	68 92 e8 05 08       	push   $0x805e892
 8053d65:	e8 a6 4c ff ff       	call   8048a10 <fwrite@plt>
 8053d6a:	83 c4 20             	add    $0x20,%esp
 8053d6d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8053d73:	6a 10                	push   $0x10
 8053d75:	6a 01                	push   $0x1
 8053d77:	68 b4 f3 05 08       	push   $0x805f3b4
 8053d7c:	e8 8f 4c ff ff       	call   8048a10 <fwrite@plt>
 8053d81:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8053d87:	6a 05                	push   $0x5
 8053d89:	6a 01                	push   $0x1
 8053d8b:	68 42 f3 05 08       	push   $0x805f342
 8053d90:	e8 7b 4c ff ff       	call   8048a10 <fwrite@plt>
 8053d95:	83 c4 14             	add    $0x14,%esp
 8053d98:	68 50 af 0f 10       	push   $0x100faf50
 8053d9d:	68 18 af 0f 10       	push   $0x100faf18
 8053da2:	68 b8 27 06 08       	push   $0x80627b8
 8053da7:	6a 50                	push   $0x50
 8053da9:	68 00 8a 0c 08       	push   $0x80c8a00
 8053dae:	e8 4d 4d ff ff       	call   8048b00 <snprintf@plt>
 8053db3:	83 c4 20             	add    $0x20,%esp
 8053db6:	83 f8 4f             	cmp    $0x4f,%eax
 8053db9:	7e 80                	jle    8053d3b <do_sbb_l+0xcb>
 8053dbb:	68 17 29 06 08       	push   $0x8062917
 8053dc0:	6a 12                	push   $0x12
 8053dc2:	68 c4 27 06 08       	push   $0x80627c4
 8053dc7:	68 b4 28 06 08       	push   $0x80628b4
 8053dcc:	e8 df 4d ff ff       	call   8048bb0 <__assert_fail@plt>
 8053dd1:	eb 0d                	jmp    8053de0 <sbb_i2a_l>
 8053dd3:	90                   	nop
 8053dd4:	90                   	nop
 8053dd5:	90                   	nop
 8053dd6:	90                   	nop
 8053dd7:	90                   	nop
 8053dd8:	90                   	nop
 8053dd9:	90                   	nop
 8053dda:	90                   	nop
 8053ddb:	90                   	nop
 8053ddc:	90                   	nop
 8053ddd:	90                   	nop
 8053dde:	90                   	nop
 8053ddf:	90                   	nop

08053de0 <sbb_i2a_l>:
}

make_instr_helper(i2a)
 8053de0:	53                   	push   %ebx
 8053de1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053de4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053de8:	83 c0 01             	add    $0x1,%eax
 8053deb:	50                   	push   %eax
 8053dec:	e8 6f 8e 00 00       	call   805cc60 <decode_i2a_l>
 8053df1:	89 c3                	mov    %eax,%ebx
	execute();
 8053df3:	e8 78 fe ff ff       	call   8053c70 <do_sbb_l>
 8053df8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053dfb:	8d 43 01             	lea    0x1(%ebx),%eax
 8053dfe:	5b                   	pop    %ebx
 8053dff:	c3                   	ret    

08053e00 <sbb_i2rm_l>:
make_instr_helper(i2rm)
 8053e00:	53                   	push   %ebx
 8053e01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053e04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053e08:	83 c0 01             	add    $0x1,%eax
 8053e0b:	50                   	push   %eax
 8053e0c:	e8 cf 8e 00 00       	call   805cce0 <decode_i2rm_l>
 8053e11:	89 c3                	mov    %eax,%ebx
	execute();
 8053e13:	e8 58 fe ff ff       	call   8053c70 <do_sbb_l>
 8053e18:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053e1b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053e1e:	5b                   	pop    %ebx
 8053e1f:	c3                   	ret    

08053e20 <sbb_r2rm_l>:
make_instr_helper(r2rm)
 8053e20:	53                   	push   %ebx
 8053e21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053e24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053e28:	83 c0 01             	add    $0x1,%eax
 8053e2b:	50                   	push   %eax
 8053e2c:	e8 ef 8d 00 00       	call   805cc20 <decode_r2rm_l>
 8053e31:	89 c3                	mov    %eax,%ebx
	execute();
 8053e33:	e8 38 fe ff ff       	call   8053c70 <do_sbb_l>
 8053e38:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053e3b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053e3e:	5b                   	pop    %ebx
 8053e3f:	c3                   	ret    

08053e40 <sbb_rm2r_l>:
make_instr_helper(rm2r)
 8053e40:	53                   	push   %ebx
 8053e41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053e44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053e48:	83 c0 01             	add    $0x1,%eax
 8053e4b:	50                   	push   %eax
 8053e4c:	e8 ef 8d 00 00       	call   805cc40 <decode_rm2r_l>
 8053e51:	89 c3                	mov    %eax,%ebx
	execute();
 8053e53:	e8 18 fe ff ff       	call   8053c70 <do_sbb_l>
 8053e58:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053e5b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053e5e:	5b                   	pop    %ebx
 8053e5f:	c3                   	ret    

08053e60 <sbb_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8053e60:	53                   	push   %ebx
 8053e61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053e64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053e68:	83 c0 01             	add    $0x1,%eax
 8053e6b:	50                   	push   %eax
 8053e6c:	e8 ef 8e 00 00       	call   805cd60 <decode_si2rm_l>
 8053e71:	89 c3                	mov    %eax,%ebx
	execute();
 8053e73:	e8 f8 fd ff ff       	call   8053c70 <do_sbb_l>
 8053e78:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053e7b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053e7e:	5b                   	pop    %ebx
 8053e7f:	c3                   	ret    

08053e80 <sbb_i2a_b>:
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
}

make_instr_helper(i2a)
 8053e80:	53                   	push   %ebx
 8053e81:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053e84:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053e88:	83 c0 01             	add    $0x1,%eax
 8053e8b:	50                   	push   %eax
 8053e8c:	e8 cf 86 00 00       	call   805c560 <decode_i2a_b>
 8053e91:	89 c3                	mov    %eax,%ebx
	execute();
 8053e93:	e8 58 fa ff ff       	call   80538f0 <do_sbb_b>
 8053e98:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053e9b:	8d 43 01             	lea    0x1(%ebx),%eax
 8053e9e:	5b                   	pop    %ebx
 8053e9f:	c3                   	ret    

08053ea0 <sbb_i2rm_b>:
make_instr_helper(i2rm)
 8053ea0:	53                   	push   %ebx
 8053ea1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053ea4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053ea8:	83 c0 01             	add    $0x1,%eax
 8053eab:	50                   	push   %eax
 8053eac:	e8 2f 87 00 00       	call   805c5e0 <decode_i2rm_b>
 8053eb1:	89 c3                	mov    %eax,%ebx
	execute();
 8053eb3:	e8 38 fa ff ff       	call   80538f0 <do_sbb_b>
 8053eb8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053ebb:	8d 43 01             	lea    0x1(%ebx),%eax
 8053ebe:	5b                   	pop    %ebx
 8053ebf:	c3                   	ret    

08053ec0 <sbb_r2rm_b>:
make_instr_helper(r2rm)
 8053ec0:	53                   	push   %ebx
 8053ec1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053ec4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053ec8:	83 c0 01             	add    $0x1,%eax
 8053ecb:	50                   	push   %eax
 8053ecc:	e8 4f 86 00 00       	call   805c520 <decode_r2rm_b>
 8053ed1:	89 c3                	mov    %eax,%ebx
	execute();
 8053ed3:	e8 18 fa ff ff       	call   80538f0 <do_sbb_b>
 8053ed8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053edb:	8d 43 01             	lea    0x1(%ebx),%eax
 8053ede:	5b                   	pop    %ebx
 8053edf:	c3                   	ret    

08053ee0 <sbb_rm2r_b>:
make_instr_helper(rm2r)
 8053ee0:	53                   	push   %ebx
 8053ee1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8053ee4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8053ee8:	83 c0 01             	add    $0x1,%eax
 8053eeb:	50                   	push   %eax
 8053eec:	e8 4f 86 00 00       	call   805c540 <decode_rm2r_b>
 8053ef1:	89 c3                	mov    %eax,%ebx
	execute();
 8053ef3:	e8 f8 f9 ff ff       	call   80538f0 <do_sbb_b>
 8053ef8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8053efb:	8d 43 01             	lea    0x1(%ebx),%eax
 8053efe:	5b                   	pop    %ebx
 8053eff:	c3                   	ret    

08053f00 <sbb_si2rm_v>:
#include "sbb-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(sbb_si2rm)
 8053f00:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053f07:	8b 54 24 04          	mov    0x4(%esp),%edx
 8053f0b:	b8 50 3c 05 08       	mov    $0x8053c50,%eax
 8053f10:	75 05                	jne    8053f17 <sbb_si2rm_v+0x17>
 8053f12:	b8 60 3e 05 08       	mov    $0x8053e60,%eax
 8053f17:	89 54 24 04          	mov    %edx,0x4(%esp)
 8053f1b:	ff e0                	jmp    *%eax
 8053f1d:	8d 76 00             	lea    0x0(%esi),%esi

08053f20 <sbb_i2rm_v>:
make_helper_v(sbb_i2rm)
 8053f20:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053f27:	8b 54 24 04          	mov    0x4(%esp),%edx
 8053f2b:	b8 f0 3b 05 08       	mov    $0x8053bf0,%eax
 8053f30:	75 05                	jne    8053f37 <sbb_i2rm_v+0x17>
 8053f32:	b8 00 3e 05 08       	mov    $0x8053e00,%eax
 8053f37:	89 54 24 04          	mov    %edx,0x4(%esp)
 8053f3b:	ff e0                	jmp    *%eax
 8053f3d:	8d 76 00             	lea    0x0(%esi),%esi

08053f40 <sbb_i2a_v>:
make_helper_v(sbb_i2a)
 8053f40:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053f47:	8b 54 24 04          	mov    0x4(%esp),%edx
 8053f4b:	b8 d0 3b 05 08       	mov    $0x8053bd0,%eax
 8053f50:	75 05                	jne    8053f57 <sbb_i2a_v+0x17>
 8053f52:	b8 e0 3d 05 08       	mov    $0x8053de0,%eax
 8053f57:	89 54 24 04          	mov    %edx,0x4(%esp)
 8053f5b:	ff e0                	jmp    *%eax
 8053f5d:	8d 76 00             	lea    0x0(%esi),%esi

08053f60 <sbb_r2rm_v>:
make_helper_v(sbb_r2rm)
 8053f60:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053f67:	8b 54 24 04          	mov    0x4(%esp),%edx
 8053f6b:	b8 10 3c 05 08       	mov    $0x8053c10,%eax
 8053f70:	75 05                	jne    8053f77 <sbb_r2rm_v+0x17>
 8053f72:	b8 20 3e 05 08       	mov    $0x8053e20,%eax
 8053f77:	89 54 24 04          	mov    %edx,0x4(%esp)
 8053f7b:	ff e0                	jmp    *%eax
 8053f7d:	8d 76 00             	lea    0x0(%esi),%esi

08053f80 <sbb_rm2r_v>:
make_helper_v(sbb_rm2r)
 8053f80:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8053f87:	8b 54 24 04          	mov    0x4(%esp),%edx
 8053f8b:	b8 30 3c 05 08       	mov    $0x8053c30,%eax
 8053f90:	75 05                	jne    8053f97 <sbb_rm2r_v+0x17>
 8053f92:	b8 40 3e 05 08       	mov    $0x8053e40,%eax
 8053f97:	89 54 24 04          	mov    %edx,0x4(%esp)
 8053f9b:	ff e0                	jmp    *%eax
 8053f9d:	66 90                	xchg   %ax,%ax
 8053f9f:	90                   	nop

08053fa0 <nop>:
#include "cpu/exec/helper.h"
#include "cpu/decode/modrm.h"

make_helper(nop) {
	print_asm("nop");
 8053fa0:	c7 05 00 8a 0c 08 6e 	movl   $0x706f6e,0x80c8a00
 8053fa7:	6f 70 00 
	return 1;
}
 8053faa:	b8 01 00 00 00       	mov    $0x1,%eax
 8053faf:	c3                   	ret    

08053fb0 <int3>:

make_helper(int3) {
 8053fb0:	83 ec 0c             	sub    $0xc,%esp
	void do_int3();
	do_int3();
 8053fb3:	e8 58 6d ff ff       	call   804ad10 <do_int3>
	print_asm("int3");
 8053fb8:	c7 05 00 8a 0c 08 69 	movl   $0x33746e69,0x80c8a00
 8053fbf:	6e 74 33 
 8053fc2:	c6 05 04 8a 0c 08 00 	movb   $0x0,0x80c8a04

	return 1;
}
 8053fc9:	b8 01 00 00 00       	mov    $0x1,%eax
 8053fce:	83 c4 0c             	add    $0xc,%esp
 8053fd1:	c3                   	ret    
 8053fd2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8053fd9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08053fe0 <lea>:

make_helper(lea) {
 8053fe0:	53                   	push   %ebx
 8053fe1:	83 ec 20             	sub    $0x20,%esp
	ModR_M m;
	m.val = instr_fetch(eip + 1, 1);
 8053fe4:	8b 44 24 28          	mov    0x28(%esp),%eax

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 8053fe8:	6a 01                	push   $0x1
 8053fea:	8d 58 01             	lea    0x1(%eax),%ebx
 8053fed:	53                   	push   %ebx
 8053fee:	e8 5d 6f ff ff       	call   804af50 <swaddr_read>
 8053ff3:	88 44 24 1f          	mov    %al,0x1f(%esp)
	int len = load_addr(eip + 1, &m, op_src);
 8053ff7:	83 c4 0c             	add    $0xc,%esp
 8053ffa:	68 08 af 0f 10       	push   $0x100faf08
 8053fff:	8d 44 24 17          	lea    0x17(%esp),%eax
 8054003:	50                   	push   %eax
 8054004:	53                   	push   %ebx
 8054005:	e8 06 8f 00 00       	call   805cf10 <load_addr>
	reg_l(m.reg) = op_src->addr;
 805400a:	0f b6 54 24 1f       	movzbl 0x1f(%esp),%edx
}

make_helper(lea) {
	ModR_M m;
	m.val = instr_fetch(eip + 1, 1);
	int len = load_addr(eip + 1, &m, op_src);
 805400f:	89 c3                	mov    %eax,%ebx
	reg_l(m.reg) = op_src->addr;
 8054011:	a1 10 af 0f 10       	mov    0x100faf10,%eax
 8054016:	c0 ea 03             	shr    $0x3,%dl
 8054019:	83 e2 07             	and    $0x7,%edx
 805401c:	89 04 95 c0 af 0f 10 	mov    %eax,0x100fafc0(,%edx,4)

	print_asm("leal %s,%%%s", op_src->str, regsl[m.reg]);
 8054023:	58                   	pop    %eax
 8054024:	ff 34 95 c0 5c 07 08 	pushl  0x8075cc0(,%edx,4)
 805402b:	68 18 af 0f 10       	push   $0x100faf18
 8054030:	68 32 29 06 08       	push   $0x8062932
 8054035:	6a 50                	push   $0x50
 8054037:	68 00 8a 0c 08       	push   $0x80c8a00
 805403c:	e8 bf 4a ff ff       	call   8048b00 <snprintf@plt>
 8054041:	83 c4 20             	add    $0x20,%esp
 8054044:	83 f8 4f             	cmp    $0x4f,%eax
 8054047:	7f 0f                	jg     8054058 <lea+0x78>
	return 1 + len;
}
 8054049:	83 c4 18             	add    $0x18,%esp
	m.val = instr_fetch(eip + 1, 1);
	int len = load_addr(eip + 1, &m, op_src);
	reg_l(m.reg) = op_src->addr;

	print_asm("leal %s,%%%s", op_src->str, regsl[m.reg]);
	return 1 + len;
 805404c:	8d 43 01             	lea    0x1(%ebx),%eax
}
 805404f:	5b                   	pop    %ebx
 8054050:	c3                   	ret    
 8054051:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	ModR_M m;
	m.val = instr_fetch(eip + 1, 1);
	int len = load_addr(eip + 1, &m, op_src);
	reg_l(m.reg) = op_src->addr;

	print_asm("leal %s,%%%s", op_src->str, regsl[m.reg]);
 8054058:	83 ec 0c             	sub    $0xc,%esp
 805405b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054061:	e8 fa 48 ff ff       	call   8048960 <fflush@plt>
 8054066:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805406c:	6a 07                	push   $0x7
 805406e:	6a 01                	push   $0x1
 8054070:	68 92 e8 05 08       	push   $0x805e892
 8054075:	e8 96 49 ff ff       	call   8048a10 <fwrite@plt>
 805407a:	83 c4 20             	add    $0x20,%esp
 805407d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054083:	6a 10                	push   $0x10
 8054085:	6a 01                	push   $0x1
 8054087:	68 b4 f3 05 08       	push   $0x805f3b4
 805408c:	e8 7f 49 ff ff       	call   8048a10 <fwrite@plt>
 8054091:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054097:	6a 05                	push   $0x5
 8054099:	6a 01                	push   $0x1
 805409b:	68 42 f3 05 08       	push   $0x805f342
 80540a0:	e8 6b 49 ff ff       	call   8048a10 <fwrite@plt>
 80540a5:	83 c4 14             	add    $0x14,%esp
 80540a8:	0f b6 44 24 1b       	movzbl 0x1b(%esp),%eax
 80540ad:	c0 e8 03             	shr    $0x3,%al
 80540b0:	83 e0 07             	and    $0x7,%eax
 80540b3:	ff 34 85 c0 5c 07 08 	pushl  0x8075cc0(,%eax,4)
 80540ba:	68 18 af 0f 10       	push   $0x100faf18
 80540bf:	68 32 29 06 08       	push   $0x8062932
 80540c4:	6a 50                	push   $0x50
 80540c6:	68 00 8a 0c 08       	push   $0x80c8a00
 80540cb:	e8 30 4a ff ff       	call   8048b00 <snprintf@plt>
 80540d0:	83 c4 20             	add    $0x20,%esp
 80540d3:	83 f8 4f             	cmp    $0x4f,%eax
 80540d6:	0f 8e 6d ff ff ff    	jle    8054049 <lea+0x69>
 80540dc:	68 b3 29 06 08       	push   $0x80629b3
 80540e1:	6a 17                	push   $0x17
 80540e3:	68 3f 29 06 08       	push   $0x806293f
 80540e8:	68 60 29 06 08       	push   $0x8062960
 80540ed:	e8 be 4a ff ff       	call   8048bb0 <__assert_fail@plt>
 80540f2:	66 90                	xchg   %ax,%ax
 80540f4:	66 90                	xchg   %ax,%ax
 80540f6:	66 90                	xchg   %ax,%ax
 80540f8:	66 90                	xchg   %ax,%ax
 80540fa:	66 90                	xchg   %ax,%ax
 80540fc:	66 90                	xchg   %ax,%ax
 80540fe:	66 90                	xchg   %ax,%ax

08054100 <jbe_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8054100:	53                   	push   %ebx
 8054101:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054104:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054108:	83 c0 01             	add    $0x1,%eax
 805410b:	50                   	push   %eax
 805410c:	e8 2f 8a 00 00       	call   805cb40 <decode_i_l>
#define instr jbe

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF || cpu.ZF) {
 8054111:	83 c4 10             	add    $0x10,%esp
 8054114:	f6 05 e4 af 0f 10 41 	testb  $0x41,0x100fafe4
 805411b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jbe

static void do_execute() {
	int res = op_src->val;
 805411d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF || cpu.ZF) {
 8054122:	74 06                	je     805412a <jbe_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8054124:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805412a:	68 18 af 0f 10       	push   $0x100faf18
 805412f:	68 b7 29 06 08       	push   $0x80629b7
 8054134:	6a 50                	push   $0x50
 8054136:	68 00 8a 0c 08       	push   $0x80c8a00
 805413b:	e8 c0 49 ff ff       	call   8048b00 <snprintf@plt>
 8054140:	83 c4 10             	add    $0x10,%esp
 8054143:	83 f8 4f             	cmp    $0x4f,%eax
 8054146:	7f 08                	jg     8054150 <jbe_i_l+0x50>
}

make_instr_helper(i)
 8054148:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805414b:	8d 43 01             	lea    0x1(%ebx),%eax
 805414e:	5b                   	pop    %ebx
 805414f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054150:	83 ec 0c             	sub    $0xc,%esp
 8054153:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054159:	e8 02 48 ff ff       	call   8048960 <fflush@plt>
 805415e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054164:	6a 07                	push   $0x7
 8054166:	6a 01                	push   $0x1
 8054168:	68 92 e8 05 08       	push   $0x805e892
 805416d:	e8 9e 48 ff ff       	call   8048a10 <fwrite@plt>
 8054172:	83 c4 20             	add    $0x20,%esp
 8054175:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805417b:	6a 10                	push   $0x10
 805417d:	6a 01                	push   $0x1
 805417f:	68 b4 f3 05 08       	push   $0x805f3b4
 8054184:	e8 87 48 ff ff       	call   8048a10 <fwrite@plt>
 8054189:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805418f:	6a 05                	push   $0x5
 8054191:	6a 01                	push   $0x1
 8054193:	68 42 f3 05 08       	push   $0x805f342
 8054198:	e8 73 48 ff ff       	call   8048a10 <fwrite@plt>
 805419d:	83 c4 20             	add    $0x20,%esp
 80541a0:	68 18 af 0f 10       	push   $0x100faf18
 80541a5:	68 b7 29 06 08       	push   $0x80629b7
 80541aa:	6a 50                	push   $0x50
 80541ac:	68 00 8a 0c 08       	push   $0x80c8a00
 80541b1:	e8 4a 49 ff ff       	call   8048b00 <snprintf@plt>
 80541b6:	83 c4 10             	add    $0x10,%esp
 80541b9:	83 f8 4f             	cmp    $0x4f,%eax
 80541bc:	7e 8a                	jle    8054148 <jbe_i_l+0x48>
 80541be:	68 ce 2a 06 08       	push   $0x8062ace
 80541c3:	6a 0e                	push   $0xe
 80541c5:	68 d0 29 06 08       	push   $0x80629d0
 80541ca:	68 f8 29 06 08       	push   $0x80629f8
 80541cf:	e8 dc 49 ff ff       	call   8048bb0 <__assert_fail@plt>
 80541d4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80541da:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080541e0 <jbe_i_w>:
}

make_instr_helper(i)
 80541e0:	53                   	push   %ebx
 80541e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80541e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80541e8:	83 c0 01             	add    $0x1,%eax
 80541eb:	50                   	push   %eax
 80541ec:	e8 bf 85 00 00       	call   805c7b0 <decode_i_w>
#define instr jbe

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF || cpu.ZF) {
 80541f1:	83 c4 10             	add    $0x10,%esp
 80541f4:	f6 05 e4 af 0f 10 41 	testb  $0x41,0x100fafe4
 80541fb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jbe

static void do_execute() {
	int res = op_src->val;
 80541fd:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF || cpu.ZF) {
 8054202:	74 0f                	je     8054213 <jbe_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8054204:	66 03 05 e0 af 0f 10 	add    0x100fafe0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 805420b:	0f b7 c0             	movzwl %ax,%eax
 805420e:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
#endif
	}
	print_asm_template1();
 8054213:	68 18 af 0f 10       	push   $0x100faf18
 8054218:	68 bf 29 06 08       	push   $0x80629bf
 805421d:	6a 50                	push   $0x50
 805421f:	68 00 8a 0c 08       	push   $0x80c8a00
 8054224:	e8 d7 48 ff ff       	call   8048b00 <snprintf@plt>
 8054229:	83 c4 10             	add    $0x10,%esp
 805422c:	83 f8 4f             	cmp    $0x4f,%eax
 805422f:	7f 0f                	jg     8054240 <jbe_i_w+0x60>
}

make_instr_helper(i)
 8054231:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054234:	8d 43 01             	lea    0x1(%ebx),%eax
 8054237:	5b                   	pop    %ebx
 8054238:	c3                   	ret    
 8054239:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054240:	83 ec 0c             	sub    $0xc,%esp
 8054243:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054249:	e8 12 47 ff ff       	call   8048960 <fflush@plt>
 805424e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054254:	6a 07                	push   $0x7
 8054256:	6a 01                	push   $0x1
 8054258:	68 92 e8 05 08       	push   $0x805e892
 805425d:	e8 ae 47 ff ff       	call   8048a10 <fwrite@plt>
 8054262:	83 c4 20             	add    $0x20,%esp
 8054265:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805426b:	6a 10                	push   $0x10
 805426d:	6a 01                	push   $0x1
 805426f:	68 b4 f3 05 08       	push   $0x805f3b4
 8054274:	e8 97 47 ff ff       	call   8048a10 <fwrite@plt>
 8054279:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805427f:	6a 05                	push   $0x5
 8054281:	6a 01                	push   $0x1
 8054283:	68 42 f3 05 08       	push   $0x805f342
 8054288:	e8 83 47 ff ff       	call   8048a10 <fwrite@plt>
 805428d:	83 c4 20             	add    $0x20,%esp
 8054290:	68 18 af 0f 10       	push   $0x100faf18
 8054295:	68 bf 29 06 08       	push   $0x80629bf
 805429a:	6a 50                	push   $0x50
 805429c:	68 00 8a 0c 08       	push   $0x80c8a00
 80542a1:	e8 5a 48 ff ff       	call   8048b00 <snprintf@plt>
 80542a6:	83 c4 10             	add    $0x10,%esp
 80542a9:	83 f8 4f             	cmp    $0x4f,%eax
 80542ac:	7e 83                	jle    8054231 <jbe_i_w+0x51>
 80542ae:	68 d7 2a 06 08       	push   $0x8062ad7
 80542b3:	6a 0e                	push   $0xe
 80542b5:	68 d0 29 06 08       	push   $0x80629d0
 80542ba:	68 40 2a 06 08       	push   $0x8062a40
 80542bf:	e8 ec 48 ff ff       	call   8048bb0 <__assert_fail@plt>
 80542c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80542ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080542d0 <jbe_i_b>:
}

make_instr_helper(i)
 80542d0:	53                   	push   %ebx
 80542d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80542d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80542d8:	83 c0 01             	add    $0x1,%eax
 80542db:	50                   	push   %eax
 80542dc:	e8 5f 81 00 00       	call   805c440 <decode_i_b>
#define instr jbe

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF || cpu.ZF) {
 80542e1:	83 c4 10             	add    $0x10,%esp
 80542e4:	f6 05 e4 af 0f 10 41 	testb  $0x41,0x100fafe4
 80542eb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jbe

static void do_execute() {
	int res = op_src->val;
 80542ed:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF || cpu.ZF) {
 80542f2:	74 09                	je     80542fd <jbe_i_b+0x2d>

#define instr jbe

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 80542f4:	0f be c0             	movsbl %al,%eax
	if(cpu.CF || cpu.ZF) {
		cpu.eip = cpu.eip + res;
 80542f7:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80542fd:	68 18 af 0f 10       	push   $0x100faf18
 8054302:	68 c7 29 06 08       	push   $0x80629c7
 8054307:	6a 50                	push   $0x50
 8054309:	68 00 8a 0c 08       	push   $0x80c8a00
 805430e:	e8 ed 47 ff ff       	call   8048b00 <snprintf@plt>
 8054313:	83 c4 10             	add    $0x10,%esp
 8054316:	83 f8 4f             	cmp    $0x4f,%eax
 8054319:	7f 0d                	jg     8054328 <jbe_i_b+0x58>
}

make_instr_helper(i)
 805431b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805431e:	8d 43 01             	lea    0x1(%ebx),%eax
 8054321:	5b                   	pop    %ebx
 8054322:	c3                   	ret    
 8054323:	90                   	nop
 8054324:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054328:	83 ec 0c             	sub    $0xc,%esp
 805432b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054331:	e8 2a 46 ff ff       	call   8048960 <fflush@plt>
 8054336:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805433c:	6a 07                	push   $0x7
 805433e:	6a 01                	push   $0x1
 8054340:	68 92 e8 05 08       	push   $0x805e892
 8054345:	e8 c6 46 ff ff       	call   8048a10 <fwrite@plt>
 805434a:	83 c4 20             	add    $0x20,%esp
 805434d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054353:	6a 10                	push   $0x10
 8054355:	6a 01                	push   $0x1
 8054357:	68 b4 f3 05 08       	push   $0x805f3b4
 805435c:	e8 af 46 ff ff       	call   8048a10 <fwrite@plt>
 8054361:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054367:	6a 05                	push   $0x5
 8054369:	6a 01                	push   $0x1
 805436b:	68 42 f3 05 08       	push   $0x805f342
 8054370:	e8 9b 46 ff ff       	call   8048a10 <fwrite@plt>
 8054375:	83 c4 20             	add    $0x20,%esp
 8054378:	68 18 af 0f 10       	push   $0x100faf18
 805437d:	68 c7 29 06 08       	push   $0x80629c7
 8054382:	6a 50                	push   $0x50
 8054384:	68 00 8a 0c 08       	push   $0x80c8a00
 8054389:	e8 72 47 ff ff       	call   8048b00 <snprintf@plt>
 805438e:	83 c4 10             	add    $0x10,%esp
 8054391:	83 f8 4f             	cmp    $0x4f,%eax
 8054394:	7e 85                	jle    805431b <jbe_i_b+0x4b>
 8054396:	68 e0 2a 06 08       	push   $0x8062ae0
 805439b:	6a 0e                	push   $0xe
 805439d:	68 d0 29 06 08       	push   $0x80629d0
 80543a2:	68 88 2a 06 08       	push   $0x8062a88
 80543a7:	e8 04 48 ff ff       	call   8048bb0 <__assert_fail@plt>
 80543ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080543b0 <jbe_i_v>:
#include "jbe-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jbe_i)
 80543b0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80543b7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80543bb:	b8 e0 41 05 08       	mov    $0x80541e0,%eax
 80543c0:	75 05                	jne    80543c7 <jbe_i_v+0x17>
 80543c2:	b8 00 41 05 08       	mov    $0x8054100,%eax
 80543c7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80543cb:	ff e0                	jmp    *%eax
 80543cd:	66 90                	xchg   %ax,%ax
 80543cf:	90                   	nop

080543d0 <jg_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 80543d0:	56                   	push   %esi
 80543d1:	53                   	push   %ebx
 80543d2:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80543d5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80543d9:	83 c0 01             	add    $0x1,%eax
 80543dc:	50                   	push   %eax
 80543dd:	e8 5e 87 00 00       	call   805cb40 <decode_i_l>
#define instr jg

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 80543e2:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 80543e9:	89 c3                	mov    %eax,%ebx
 80543eb:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 80543f2:	83 c4 10             	add    $0x10,%esp
#include "cpu/exec/template-start.h"

#define instr jg

static void do_execute() {
	int res = op_src->val;
 80543f5:	8b 35 14 af 0f 10    	mov    0x100faf14,%esi
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 80543fb:	c0 ea 03             	shr    $0x3,%dl
 80543fe:	89 c1                	mov    %eax,%ecx
 8054400:	83 e2 01             	and    $0x1,%edx
 8054403:	c0 e9 07             	shr    $0x7,%cl
 8054406:	38 ca                	cmp    %cl,%dl
 8054408:	0f 84 b2 00 00 00    	je     80544c0 <jg_i_l+0xf0>
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805440e:	68 18 af 0f 10       	push   $0x100faf18
 8054413:	68 e9 2a 06 08       	push   $0x8062ae9
 8054418:	6a 50                	push   $0x50
 805441a:	68 00 8a 0c 08       	push   $0x80c8a00
 805441f:	e8 dc 46 ff ff       	call   8048b00 <snprintf@plt>
 8054424:	83 c4 10             	add    $0x10,%esp
 8054427:	83 f8 4f             	cmp    $0x4f,%eax
 805442a:	7f 0c                	jg     8054438 <jg_i_l+0x68>
}

make_instr_helper(i)
 805442c:	83 c4 04             	add    $0x4,%esp
	execute();
	return len + 1;	// "1" for opcode
 805442f:	8d 43 01             	lea    0x1(%ebx),%eax
 8054432:	5b                   	pop    %ebx
 8054433:	5e                   	pop    %esi
 8054434:	c3                   	ret    
 8054435:	8d 76 00             	lea    0x0(%esi),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054438:	83 ec 0c             	sub    $0xc,%esp
 805443b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054441:	e8 1a 45 ff ff       	call   8048960 <fflush@plt>
 8054446:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805444c:	6a 07                	push   $0x7
 805444e:	6a 01                	push   $0x1
 8054450:	68 92 e8 05 08       	push   $0x805e892
 8054455:	e8 b6 45 ff ff       	call   8048a10 <fwrite@plt>
 805445a:	83 c4 20             	add    $0x20,%esp
 805445d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054463:	6a 10                	push   $0x10
 8054465:	6a 01                	push   $0x1
 8054467:	68 b4 f3 05 08       	push   $0x805f3b4
 805446c:	e8 9f 45 ff ff       	call   8048a10 <fwrite@plt>
 8054471:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054477:	6a 05                	push   $0x5
 8054479:	6a 01                	push   $0x1
 805447b:	68 42 f3 05 08       	push   $0x805f342
 8054480:	e8 8b 45 ff ff       	call   8048a10 <fwrite@plt>
 8054485:	83 c4 20             	add    $0x20,%esp
 8054488:	68 18 af 0f 10       	push   $0x100faf18
 805448d:	68 e9 2a 06 08       	push   $0x8062ae9
 8054492:	6a 50                	push   $0x50
 8054494:	68 00 8a 0c 08       	push   $0x80c8a00
 8054499:	e8 62 46 ff ff       	call   8048b00 <snprintf@plt>
 805449e:	83 c4 10             	add    $0x10,%esp
 80544a1:	83 f8 4f             	cmp    $0x4f,%eax
 80544a4:	7e 86                	jle    805442c <jg_i_l+0x5c>
 80544a6:	68 f9 2b 06 08       	push   $0x8062bf9
 80544ab:	6a 0e                	push   $0xe
 80544ad:	68 00 2b 06 08       	push   $0x8062b00
 80544b2:	68 24 2b 06 08       	push   $0x8062b24
 80544b7:	e8 f4 46 ff ff       	call   8048bb0 <__assert_fail@plt>
 80544bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr jg

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 80544c0:	a8 40                	test   $0x40,%al
 80544c2:	0f 85 46 ff ff ff    	jne    805440e <jg_i_l+0x3e>
		cpu.eip = cpu.eip + res;
 80544c8:	01 35 e0 af 0f 10    	add    %esi,0x100fafe0
 80544ce:	e9 3b ff ff ff       	jmp    805440e <jg_i_l+0x3e>
 80544d3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80544d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080544e0 <jg_i_w>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 80544e0:	56                   	push   %esi
 80544e1:	53                   	push   %ebx
 80544e2:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80544e5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80544e9:	83 c0 01             	add    $0x1,%eax
 80544ec:	50                   	push   %eax
 80544ed:	e8 be 82 00 00       	call   805c7b0 <decode_i_w>
#define instr jg

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 80544f2:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 80544f9:	89 c3                	mov    %eax,%ebx
 80544fb:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 8054502:	83 c4 10             	add    $0x10,%esp
#include "cpu/exec/template-start.h"

#define instr jg

static void do_execute() {
	int res = op_src->val;
 8054505:	8b 35 14 af 0f 10    	mov    0x100faf14,%esi
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 805450b:	c0 ea 03             	shr    $0x3,%dl
 805450e:	89 c1                	mov    %eax,%ecx
 8054510:	83 e2 01             	and    $0x1,%edx
 8054513:	c0 e9 07             	shr    $0x7,%cl
 8054516:	38 ca                	cmp    %cl,%dl
 8054518:	0f 84 b2 00 00 00    	je     80545d0 <jg_i_w+0xf0>
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805451e:	68 18 af 0f 10       	push   $0x100faf18
 8054523:	68 f0 2a 06 08       	push   $0x8062af0
 8054528:	6a 50                	push   $0x50
 805452a:	68 00 8a 0c 08       	push   $0x80c8a00
 805452f:	e8 cc 45 ff ff       	call   8048b00 <snprintf@plt>
 8054534:	83 c4 10             	add    $0x10,%esp
 8054537:	83 f8 4f             	cmp    $0x4f,%eax
 805453a:	7f 0c                	jg     8054548 <jg_i_w+0x68>
}

make_instr_helper(i)
 805453c:	83 c4 04             	add    $0x4,%esp
	execute();
	return len + 1;	// "1" for opcode
 805453f:	8d 43 01             	lea    0x1(%ebx),%eax
 8054542:	5b                   	pop    %ebx
 8054543:	5e                   	pop    %esi
 8054544:	c3                   	ret    
 8054545:	8d 76 00             	lea    0x0(%esi),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054548:	83 ec 0c             	sub    $0xc,%esp
 805454b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054551:	e8 0a 44 ff ff       	call   8048960 <fflush@plt>
 8054556:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805455c:	6a 07                	push   $0x7
 805455e:	6a 01                	push   $0x1
 8054560:	68 92 e8 05 08       	push   $0x805e892
 8054565:	e8 a6 44 ff ff       	call   8048a10 <fwrite@plt>
 805456a:	83 c4 20             	add    $0x20,%esp
 805456d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054573:	6a 10                	push   $0x10
 8054575:	6a 01                	push   $0x1
 8054577:	68 b4 f3 05 08       	push   $0x805f3b4
 805457c:	e8 8f 44 ff ff       	call   8048a10 <fwrite@plt>
 8054581:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054587:	6a 05                	push   $0x5
 8054589:	6a 01                	push   $0x1
 805458b:	68 42 f3 05 08       	push   $0x805f342
 8054590:	e8 7b 44 ff ff       	call   8048a10 <fwrite@plt>
 8054595:	83 c4 20             	add    $0x20,%esp
 8054598:	68 18 af 0f 10       	push   $0x100faf18
 805459d:	68 f0 2a 06 08       	push   $0x8062af0
 80545a2:	6a 50                	push   $0x50
 80545a4:	68 00 8a 0c 08       	push   $0x80c8a00
 80545a9:	e8 52 45 ff ff       	call   8048b00 <snprintf@plt>
 80545ae:	83 c4 10             	add    $0x10,%esp
 80545b1:	83 f8 4f             	cmp    $0x4f,%eax
 80545b4:	7e 86                	jle    805453c <jg_i_w+0x5c>
 80545b6:	68 01 2c 06 08       	push   $0x8062c01
 80545bb:	6a 0e                	push   $0xe
 80545bd:	68 00 2b 06 08       	push   $0x8062b00
 80545c2:	68 6c 2b 06 08       	push   $0x8062b6c
 80545c7:	e8 e4 45 ff ff       	call   8048bb0 <__assert_fail@plt>
 80545cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr jg

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 80545d0:	a8 40                	test   $0x40,%al
 80545d2:	0f 85 46 ff ff ff    	jne    805451e <jg_i_w+0x3e>
		cpu.eip = cpu.eip + res;
 80545d8:	66 03 35 e0 af 0f 10 	add    0x100fafe0,%si
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 80545df:	0f b7 f6             	movzwl %si,%esi
 80545e2:	89 35 e0 af 0f 10    	mov    %esi,0x100fafe0
 80545e8:	e9 31 ff ff ff       	jmp    805451e <jg_i_w+0x3e>
 80545ed:	8d 76 00             	lea    0x0(%esi),%esi

080545f0 <jg_i_b>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 80545f0:	56                   	push   %esi
 80545f1:	53                   	push   %ebx
 80545f2:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80545f5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80545f9:	83 c0 01             	add    $0x1,%eax
 80545fc:	50                   	push   %eax
 80545fd:	e8 3e 7e 00 00       	call   805c440 <decode_i_b>
#define instr jg

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 8054602:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8054609:	89 c3                	mov    %eax,%ebx
 805460b:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 8054612:	83 c4 10             	add    $0x10,%esp
#include "cpu/exec/template-start.h"

#define instr jg

static void do_execute() {
	int res = op_src->val;
 8054615:	8b 35 14 af 0f 10    	mov    0x100faf14,%esi
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 805461b:	c0 ea 03             	shr    $0x3,%dl
 805461e:	89 c1                	mov    %eax,%ecx
 8054620:	83 e2 01             	and    $0x1,%edx
 8054623:	c0 e9 07             	shr    $0x7,%cl
 8054626:	38 ca                	cmp    %cl,%dl
 8054628:	0f 84 b2 00 00 00    	je     80546e0 <jg_i_b+0xf0>
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805462e:	68 18 af 0f 10       	push   $0x100faf18
 8054633:	68 f7 2a 06 08       	push   $0x8062af7
 8054638:	6a 50                	push   $0x50
 805463a:	68 00 8a 0c 08       	push   $0x80c8a00
 805463f:	e8 bc 44 ff ff       	call   8048b00 <snprintf@plt>
 8054644:	83 c4 10             	add    $0x10,%esp
 8054647:	83 f8 4f             	cmp    $0x4f,%eax
 805464a:	7f 0c                	jg     8054658 <jg_i_b+0x68>
}

make_instr_helper(i)
 805464c:	83 c4 04             	add    $0x4,%esp
	execute();
	return len + 1;	// "1" for opcode
 805464f:	8d 43 01             	lea    0x1(%ebx),%eax
 8054652:	5b                   	pop    %ebx
 8054653:	5e                   	pop    %esi
 8054654:	c3                   	ret    
 8054655:	8d 76 00             	lea    0x0(%esi),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054658:	83 ec 0c             	sub    $0xc,%esp
 805465b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054661:	e8 fa 42 ff ff       	call   8048960 <fflush@plt>
 8054666:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805466c:	6a 07                	push   $0x7
 805466e:	6a 01                	push   $0x1
 8054670:	68 92 e8 05 08       	push   $0x805e892
 8054675:	e8 96 43 ff ff       	call   8048a10 <fwrite@plt>
 805467a:	83 c4 20             	add    $0x20,%esp
 805467d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054683:	6a 10                	push   $0x10
 8054685:	6a 01                	push   $0x1
 8054687:	68 b4 f3 05 08       	push   $0x805f3b4
 805468c:	e8 7f 43 ff ff       	call   8048a10 <fwrite@plt>
 8054691:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054697:	6a 05                	push   $0x5
 8054699:	6a 01                	push   $0x1
 805469b:	68 42 f3 05 08       	push   $0x805f342
 80546a0:	e8 6b 43 ff ff       	call   8048a10 <fwrite@plt>
 80546a5:	83 c4 20             	add    $0x20,%esp
 80546a8:	68 18 af 0f 10       	push   $0x100faf18
 80546ad:	68 f7 2a 06 08       	push   $0x8062af7
 80546b2:	6a 50                	push   $0x50
 80546b4:	68 00 8a 0c 08       	push   $0x80c8a00
 80546b9:	e8 42 44 ff ff       	call   8048b00 <snprintf@plt>
 80546be:	83 c4 10             	add    $0x10,%esp
 80546c1:	83 f8 4f             	cmp    $0x4f,%eax
 80546c4:	7e 86                	jle    805464c <jg_i_b+0x5c>
 80546c6:	68 09 2c 06 08       	push   $0x8062c09
 80546cb:	6a 0e                	push   $0xe
 80546cd:	68 00 2b 06 08       	push   $0x8062b00
 80546d2:	68 b4 2b 06 08       	push   $0x8062bb4
 80546d7:	e8 d4 44 ff ff       	call   8048bb0 <__assert_fail@plt>
 80546dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr jg

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF && !cpu.ZF) {
 80546e0:	a8 40                	test   $0x40,%al
 80546e2:	0f 85 46 ff ff ff    	jne    805462e <jg_i_b+0x3e>

#define instr jg

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 80546e8:	89 f0                	mov    %esi,%eax
 80546ea:	0f be f0             	movsbl %al,%esi
	if(cpu.OF == cpu.SF && !cpu.ZF) {
		cpu.eip = cpu.eip + res;
 80546ed:	01 35 e0 af 0f 10    	add    %esi,0x100fafe0
 80546f3:	e9 36 ff ff ff       	jmp    805462e <jg_i_b+0x3e>
 80546f8:	90                   	nop
 80546f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08054700 <jg_i_v>:
#include "jg-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jg_i)
 8054700:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8054707:	8b 54 24 04          	mov    0x4(%esp),%edx
 805470b:	b8 e0 44 05 08       	mov    $0x80544e0,%eax
 8054710:	75 05                	jne    8054717 <jg_i_v+0x17>
 8054712:	b8 d0 43 05 08       	mov    $0x80543d0,%eax
 8054717:	89 54 24 04          	mov    %edx,0x4(%esp)
 805471b:	ff e0                	jmp    *%eax
 805471d:	66 90                	xchg   %ax,%ax
 805471f:	90                   	nop

08054720 <jne_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8054720:	53                   	push   %ebx
 8054721:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054724:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054728:	83 c0 01             	add    $0x1,%eax
 805472b:	50                   	push   %eax
 805472c:	e8 0f 84 00 00       	call   805cb40 <decode_i_l>
#define instr jne

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.ZF) {
 8054731:	83 c4 10             	add    $0x10,%esp
 8054734:	f6 05 e4 af 0f 10 40 	testb  $0x40,0x100fafe4
 805473b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jne

static void do_execute() {
	int res = op_src->val;
 805473d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.ZF) {
 8054742:	75 06                	jne    805474a <jne_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8054744:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805474a:	68 18 af 0f 10       	push   $0x100faf18
 805474f:	68 11 2c 06 08       	push   $0x8062c11
 8054754:	6a 50                	push   $0x50
 8054756:	68 00 8a 0c 08       	push   $0x80c8a00
 805475b:	e8 a0 43 ff ff       	call   8048b00 <snprintf@plt>
 8054760:	83 c4 10             	add    $0x10,%esp
 8054763:	83 f8 4f             	cmp    $0x4f,%eax
 8054766:	7f 08                	jg     8054770 <jne_i_l+0x50>
}

make_instr_helper(i)
 8054768:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805476b:	8d 43 01             	lea    0x1(%ebx),%eax
 805476e:	5b                   	pop    %ebx
 805476f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054770:	83 ec 0c             	sub    $0xc,%esp
 8054773:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054779:	e8 e2 41 ff ff       	call   8048960 <fflush@plt>
 805477e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054784:	6a 07                	push   $0x7
 8054786:	6a 01                	push   $0x1
 8054788:	68 92 e8 05 08       	push   $0x805e892
 805478d:	e8 7e 42 ff ff       	call   8048a10 <fwrite@plt>
 8054792:	83 c4 20             	add    $0x20,%esp
 8054795:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805479b:	6a 10                	push   $0x10
 805479d:	6a 01                	push   $0x1
 805479f:	68 b4 f3 05 08       	push   $0x805f3b4
 80547a4:	e8 67 42 ff ff       	call   8048a10 <fwrite@plt>
 80547a9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80547af:	6a 05                	push   $0x5
 80547b1:	6a 01                	push   $0x1
 80547b3:	68 42 f3 05 08       	push   $0x805f342
 80547b8:	e8 53 42 ff ff       	call   8048a10 <fwrite@plt>
 80547bd:	83 c4 20             	add    $0x20,%esp
 80547c0:	68 18 af 0f 10       	push   $0x100faf18
 80547c5:	68 11 2c 06 08       	push   $0x8062c11
 80547ca:	6a 50                	push   $0x50
 80547cc:	68 00 8a 0c 08       	push   $0x80c8a00
 80547d1:	e8 2a 43 ff ff       	call   8048b00 <snprintf@plt>
 80547d6:	83 c4 10             	add    $0x10,%esp
 80547d9:	83 f8 4f             	cmp    $0x4f,%eax
 80547dc:	7e 8a                	jle    8054768 <jne_i_l+0x48>
 80547de:	68 2a 2d 06 08       	push   $0x8062d2a
 80547e3:	6a 0e                	push   $0xe
 80547e5:	68 2c 2c 06 08       	push   $0x8062c2c
 80547ea:	68 54 2c 06 08       	push   $0x8062c54
 80547ef:	e8 bc 43 ff ff       	call   8048bb0 <__assert_fail@plt>
 80547f4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80547fa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08054800 <jne_i_w>:
}

make_instr_helper(i)
 8054800:	53                   	push   %ebx
 8054801:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054804:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054808:	83 c0 01             	add    $0x1,%eax
 805480b:	50                   	push   %eax
 805480c:	e8 9f 7f 00 00       	call   805c7b0 <decode_i_w>
#define instr jne

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.ZF) {
 8054811:	83 c4 10             	add    $0x10,%esp
 8054814:	f6 05 e4 af 0f 10 40 	testb  $0x40,0x100fafe4
 805481b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jne

static void do_execute() {
	int res = op_src->val;
 805481d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.ZF) {
 8054822:	75 0f                	jne    8054833 <jne_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8054824:	66 03 05 e0 af 0f 10 	add    0x100fafe0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 805482b:	0f b7 c0             	movzwl %ax,%eax
 805482e:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
#endif
	}
	print_asm_template1();
 8054833:	68 18 af 0f 10       	push   $0x100faf18
 8054838:	68 19 2c 06 08       	push   $0x8062c19
 805483d:	6a 50                	push   $0x50
 805483f:	68 00 8a 0c 08       	push   $0x80c8a00
 8054844:	e8 b7 42 ff ff       	call   8048b00 <snprintf@plt>
 8054849:	83 c4 10             	add    $0x10,%esp
 805484c:	83 f8 4f             	cmp    $0x4f,%eax
 805484f:	7f 0f                	jg     8054860 <jne_i_w+0x60>
}

make_instr_helper(i)
 8054851:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054854:	8d 43 01             	lea    0x1(%ebx),%eax
 8054857:	5b                   	pop    %ebx
 8054858:	c3                   	ret    
 8054859:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054860:	83 ec 0c             	sub    $0xc,%esp
 8054863:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054869:	e8 f2 40 ff ff       	call   8048960 <fflush@plt>
 805486e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054874:	6a 07                	push   $0x7
 8054876:	6a 01                	push   $0x1
 8054878:	68 92 e8 05 08       	push   $0x805e892
 805487d:	e8 8e 41 ff ff       	call   8048a10 <fwrite@plt>
 8054882:	83 c4 20             	add    $0x20,%esp
 8054885:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805488b:	6a 10                	push   $0x10
 805488d:	6a 01                	push   $0x1
 805488f:	68 b4 f3 05 08       	push   $0x805f3b4
 8054894:	e8 77 41 ff ff       	call   8048a10 <fwrite@plt>
 8054899:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805489f:	6a 05                	push   $0x5
 80548a1:	6a 01                	push   $0x1
 80548a3:	68 42 f3 05 08       	push   $0x805f342
 80548a8:	e8 63 41 ff ff       	call   8048a10 <fwrite@plt>
 80548ad:	83 c4 20             	add    $0x20,%esp
 80548b0:	68 18 af 0f 10       	push   $0x100faf18
 80548b5:	68 19 2c 06 08       	push   $0x8062c19
 80548ba:	6a 50                	push   $0x50
 80548bc:	68 00 8a 0c 08       	push   $0x80c8a00
 80548c1:	e8 3a 42 ff ff       	call   8048b00 <snprintf@plt>
 80548c6:	83 c4 10             	add    $0x10,%esp
 80548c9:	83 f8 4f             	cmp    $0x4f,%eax
 80548cc:	7e 83                	jle    8054851 <jne_i_w+0x51>
 80548ce:	68 33 2d 06 08       	push   $0x8062d33
 80548d3:	6a 0e                	push   $0xe
 80548d5:	68 2c 2c 06 08       	push   $0x8062c2c
 80548da:	68 9c 2c 06 08       	push   $0x8062c9c
 80548df:	e8 cc 42 ff ff       	call   8048bb0 <__assert_fail@plt>
 80548e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80548ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080548f0 <jne_i_b>:
}

make_instr_helper(i)
 80548f0:	53                   	push   %ebx
 80548f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80548f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80548f8:	83 c0 01             	add    $0x1,%eax
 80548fb:	50                   	push   %eax
 80548fc:	e8 3f 7b 00 00       	call   805c440 <decode_i_b>
#define instr jne

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.ZF) {
 8054901:	83 c4 10             	add    $0x10,%esp
 8054904:	f6 05 e4 af 0f 10 40 	testb  $0x40,0x100fafe4
 805490b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jne

static void do_execute() {
	int res = op_src->val;
 805490d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.ZF) {
 8054912:	75 09                	jne    805491d <jne_i_b+0x2d>

#define instr jne

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8054914:	0f be c0             	movsbl %al,%eax
	if(!cpu.ZF) {
		cpu.eip = cpu.eip + res;
 8054917:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805491d:	68 18 af 0f 10       	push   $0x100faf18
 8054922:	68 21 2c 06 08       	push   $0x8062c21
 8054927:	6a 50                	push   $0x50
 8054929:	68 00 8a 0c 08       	push   $0x80c8a00
 805492e:	e8 cd 41 ff ff       	call   8048b00 <snprintf@plt>
 8054933:	83 c4 10             	add    $0x10,%esp
 8054936:	83 f8 4f             	cmp    $0x4f,%eax
 8054939:	7f 0d                	jg     8054948 <jne_i_b+0x58>
}

make_instr_helper(i)
 805493b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805493e:	8d 43 01             	lea    0x1(%ebx),%eax
 8054941:	5b                   	pop    %ebx
 8054942:	c3                   	ret    
 8054943:	90                   	nop
 8054944:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054948:	83 ec 0c             	sub    $0xc,%esp
 805494b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054951:	e8 0a 40 ff ff       	call   8048960 <fflush@plt>
 8054956:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805495c:	6a 07                	push   $0x7
 805495e:	6a 01                	push   $0x1
 8054960:	68 92 e8 05 08       	push   $0x805e892
 8054965:	e8 a6 40 ff ff       	call   8048a10 <fwrite@plt>
 805496a:	83 c4 20             	add    $0x20,%esp
 805496d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054973:	6a 10                	push   $0x10
 8054975:	6a 01                	push   $0x1
 8054977:	68 b4 f3 05 08       	push   $0x805f3b4
 805497c:	e8 8f 40 ff ff       	call   8048a10 <fwrite@plt>
 8054981:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054987:	6a 05                	push   $0x5
 8054989:	6a 01                	push   $0x1
 805498b:	68 42 f3 05 08       	push   $0x805f342
 8054990:	e8 7b 40 ff ff       	call   8048a10 <fwrite@plt>
 8054995:	83 c4 20             	add    $0x20,%esp
 8054998:	68 18 af 0f 10       	push   $0x100faf18
 805499d:	68 21 2c 06 08       	push   $0x8062c21
 80549a2:	6a 50                	push   $0x50
 80549a4:	68 00 8a 0c 08       	push   $0x80c8a00
 80549a9:	e8 52 41 ff ff       	call   8048b00 <snprintf@plt>
 80549ae:	83 c4 10             	add    $0x10,%esp
 80549b1:	83 f8 4f             	cmp    $0x4f,%eax
 80549b4:	7e 85                	jle    805493b <jne_i_b+0x4b>
 80549b6:	68 3c 2d 06 08       	push   $0x8062d3c
 80549bb:	6a 0e                	push   $0xe
 80549bd:	68 2c 2c 06 08       	push   $0x8062c2c
 80549c2:	68 e4 2c 06 08       	push   $0x8062ce4
 80549c7:	e8 e4 41 ff ff       	call   8048bb0 <__assert_fail@plt>
 80549cc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080549d0 <jne_i_v>:
#include "jne-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jne_i)
 80549d0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80549d7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80549db:	b8 00 48 05 08       	mov    $0x8054800,%eax
 80549e0:	75 05                	jne    80549e7 <jne_i_v+0x17>
 80549e2:	b8 20 47 05 08       	mov    $0x8054720,%eax
 80549e7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80549eb:	ff e0                	jmp    *%eax
 80549ed:	66 90                	xchg   %ax,%ax
 80549ef:	90                   	nop

080549f0 <jae_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 80549f0:	53                   	push   %ebx
 80549f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80549f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80549f8:	83 c0 01             	add    $0x1,%eax
 80549fb:	50                   	push   %eax
 80549fc:	e8 3f 81 00 00       	call   805cb40 <decode_i_l>
#define instr jae

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF) {
 8054a01:	83 c4 10             	add    $0x10,%esp
 8054a04:	f6 05 e4 af 0f 10 01 	testb  $0x1,0x100fafe4
 8054a0b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jae

static void do_execute() {
	int res = op_src->val;
 8054a0d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF) {
 8054a12:	75 06                	jne    8054a1a <jae_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8054a14:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054a1a:	68 18 af 0f 10       	push   $0x100faf18
 8054a1f:	68 45 2d 06 08       	push   $0x8062d45
 8054a24:	6a 50                	push   $0x50
 8054a26:	68 00 8a 0c 08       	push   $0x80c8a00
 8054a2b:	e8 d0 40 ff ff       	call   8048b00 <snprintf@plt>
 8054a30:	83 c4 10             	add    $0x10,%esp
 8054a33:	83 f8 4f             	cmp    $0x4f,%eax
 8054a36:	7f 08                	jg     8054a40 <jae_i_l+0x50>
}

make_instr_helper(i)
 8054a38:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054a3b:	8d 43 01             	lea    0x1(%ebx),%eax
 8054a3e:	5b                   	pop    %ebx
 8054a3f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054a40:	83 ec 0c             	sub    $0xc,%esp
 8054a43:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054a49:	e8 12 3f ff ff       	call   8048960 <fflush@plt>
 8054a4e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054a54:	6a 07                	push   $0x7
 8054a56:	6a 01                	push   $0x1
 8054a58:	68 92 e8 05 08       	push   $0x805e892
 8054a5d:	e8 ae 3f ff ff       	call   8048a10 <fwrite@plt>
 8054a62:	83 c4 20             	add    $0x20,%esp
 8054a65:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054a6b:	6a 10                	push   $0x10
 8054a6d:	6a 01                	push   $0x1
 8054a6f:	68 b4 f3 05 08       	push   $0x805f3b4
 8054a74:	e8 97 3f ff ff       	call   8048a10 <fwrite@plt>
 8054a79:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054a7f:	6a 05                	push   $0x5
 8054a81:	6a 01                	push   $0x1
 8054a83:	68 42 f3 05 08       	push   $0x805f342
 8054a88:	e8 83 3f ff ff       	call   8048a10 <fwrite@plt>
 8054a8d:	83 c4 20             	add    $0x20,%esp
 8054a90:	68 18 af 0f 10       	push   $0x100faf18
 8054a95:	68 45 2d 06 08       	push   $0x8062d45
 8054a9a:	6a 50                	push   $0x50
 8054a9c:	68 00 8a 0c 08       	push   $0x80c8a00
 8054aa1:	e8 5a 40 ff ff       	call   8048b00 <snprintf@plt>
 8054aa6:	83 c4 10             	add    $0x10,%esp
 8054aa9:	83 f8 4f             	cmp    $0x4f,%eax
 8054aac:	7e 8a                	jle    8054a38 <jae_i_l+0x48>
 8054aae:	68 5e 2e 06 08       	push   $0x8062e5e
 8054ab3:	6a 0e                	push   $0xe
 8054ab5:	68 60 2d 06 08       	push   $0x8062d60
 8054aba:	68 88 2d 06 08       	push   $0x8062d88
 8054abf:	e8 ec 40 ff ff       	call   8048bb0 <__assert_fail@plt>
 8054ac4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8054aca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08054ad0 <jae_i_w>:
}

make_instr_helper(i)
 8054ad0:	53                   	push   %ebx
 8054ad1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054ad4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054ad8:	83 c0 01             	add    $0x1,%eax
 8054adb:	50                   	push   %eax
 8054adc:	e8 cf 7c 00 00       	call   805c7b0 <decode_i_w>
#define instr jae

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF) {
 8054ae1:	83 c4 10             	add    $0x10,%esp
 8054ae4:	f6 05 e4 af 0f 10 01 	testb  $0x1,0x100fafe4
 8054aeb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jae

static void do_execute() {
	int res = op_src->val;
 8054aed:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF) {
 8054af2:	75 0f                	jne    8054b03 <jae_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8054af4:	66 03 05 e0 af 0f 10 	add    0x100fafe0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 8054afb:	0f b7 c0             	movzwl %ax,%eax
 8054afe:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
#endif
	}
	print_asm_template1();
 8054b03:	68 18 af 0f 10       	push   $0x100faf18
 8054b08:	68 4d 2d 06 08       	push   $0x8062d4d
 8054b0d:	6a 50                	push   $0x50
 8054b0f:	68 00 8a 0c 08       	push   $0x80c8a00
 8054b14:	e8 e7 3f ff ff       	call   8048b00 <snprintf@plt>
 8054b19:	83 c4 10             	add    $0x10,%esp
 8054b1c:	83 f8 4f             	cmp    $0x4f,%eax
 8054b1f:	7f 0f                	jg     8054b30 <jae_i_w+0x60>
}

make_instr_helper(i)
 8054b21:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054b24:	8d 43 01             	lea    0x1(%ebx),%eax
 8054b27:	5b                   	pop    %ebx
 8054b28:	c3                   	ret    
 8054b29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054b30:	83 ec 0c             	sub    $0xc,%esp
 8054b33:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054b39:	e8 22 3e ff ff       	call   8048960 <fflush@plt>
 8054b3e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054b44:	6a 07                	push   $0x7
 8054b46:	6a 01                	push   $0x1
 8054b48:	68 92 e8 05 08       	push   $0x805e892
 8054b4d:	e8 be 3e ff ff       	call   8048a10 <fwrite@plt>
 8054b52:	83 c4 20             	add    $0x20,%esp
 8054b55:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054b5b:	6a 10                	push   $0x10
 8054b5d:	6a 01                	push   $0x1
 8054b5f:	68 b4 f3 05 08       	push   $0x805f3b4
 8054b64:	e8 a7 3e ff ff       	call   8048a10 <fwrite@plt>
 8054b69:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054b6f:	6a 05                	push   $0x5
 8054b71:	6a 01                	push   $0x1
 8054b73:	68 42 f3 05 08       	push   $0x805f342
 8054b78:	e8 93 3e ff ff       	call   8048a10 <fwrite@plt>
 8054b7d:	83 c4 20             	add    $0x20,%esp
 8054b80:	68 18 af 0f 10       	push   $0x100faf18
 8054b85:	68 4d 2d 06 08       	push   $0x8062d4d
 8054b8a:	6a 50                	push   $0x50
 8054b8c:	68 00 8a 0c 08       	push   $0x80c8a00
 8054b91:	e8 6a 3f ff ff       	call   8048b00 <snprintf@plt>
 8054b96:	83 c4 10             	add    $0x10,%esp
 8054b99:	83 f8 4f             	cmp    $0x4f,%eax
 8054b9c:	7e 83                	jle    8054b21 <jae_i_w+0x51>
 8054b9e:	68 67 2e 06 08       	push   $0x8062e67
 8054ba3:	6a 0e                	push   $0xe
 8054ba5:	68 60 2d 06 08       	push   $0x8062d60
 8054baa:	68 d0 2d 06 08       	push   $0x8062dd0
 8054baf:	e8 fc 3f ff ff       	call   8048bb0 <__assert_fail@plt>
 8054bb4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8054bba:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08054bc0 <jae_i_b>:
}

make_instr_helper(i)
 8054bc0:	53                   	push   %ebx
 8054bc1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054bc4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054bc8:	83 c0 01             	add    $0x1,%eax
 8054bcb:	50                   	push   %eax
 8054bcc:	e8 6f 78 00 00       	call   805c440 <decode_i_b>
#define instr jae

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF) {
 8054bd1:	83 c4 10             	add    $0x10,%esp
 8054bd4:	f6 05 e4 af 0f 10 01 	testb  $0x1,0x100fafe4
 8054bdb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jae

static void do_execute() {
	int res = op_src->val;
 8054bdd:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF) {
 8054be2:	75 09                	jne    8054bed <jae_i_b+0x2d>

#define instr jae

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8054be4:	0f be c0             	movsbl %al,%eax
	if(!cpu.CF) {
		cpu.eip = cpu.eip + res;
 8054be7:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054bed:	68 18 af 0f 10       	push   $0x100faf18
 8054bf2:	68 55 2d 06 08       	push   $0x8062d55
 8054bf7:	6a 50                	push   $0x50
 8054bf9:	68 00 8a 0c 08       	push   $0x80c8a00
 8054bfe:	e8 fd 3e ff ff       	call   8048b00 <snprintf@plt>
 8054c03:	83 c4 10             	add    $0x10,%esp
 8054c06:	83 f8 4f             	cmp    $0x4f,%eax
 8054c09:	7f 0d                	jg     8054c18 <jae_i_b+0x58>
}

make_instr_helper(i)
 8054c0b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054c0e:	8d 43 01             	lea    0x1(%ebx),%eax
 8054c11:	5b                   	pop    %ebx
 8054c12:	c3                   	ret    
 8054c13:	90                   	nop
 8054c14:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054c18:	83 ec 0c             	sub    $0xc,%esp
 8054c1b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054c21:	e8 3a 3d ff ff       	call   8048960 <fflush@plt>
 8054c26:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054c2c:	6a 07                	push   $0x7
 8054c2e:	6a 01                	push   $0x1
 8054c30:	68 92 e8 05 08       	push   $0x805e892
 8054c35:	e8 d6 3d ff ff       	call   8048a10 <fwrite@plt>
 8054c3a:	83 c4 20             	add    $0x20,%esp
 8054c3d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054c43:	6a 10                	push   $0x10
 8054c45:	6a 01                	push   $0x1
 8054c47:	68 b4 f3 05 08       	push   $0x805f3b4
 8054c4c:	e8 bf 3d ff ff       	call   8048a10 <fwrite@plt>
 8054c51:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054c57:	6a 05                	push   $0x5
 8054c59:	6a 01                	push   $0x1
 8054c5b:	68 42 f3 05 08       	push   $0x805f342
 8054c60:	e8 ab 3d ff ff       	call   8048a10 <fwrite@plt>
 8054c65:	83 c4 20             	add    $0x20,%esp
 8054c68:	68 18 af 0f 10       	push   $0x100faf18
 8054c6d:	68 55 2d 06 08       	push   $0x8062d55
 8054c72:	6a 50                	push   $0x50
 8054c74:	68 00 8a 0c 08       	push   $0x80c8a00
 8054c79:	e8 82 3e ff ff       	call   8048b00 <snprintf@plt>
 8054c7e:	83 c4 10             	add    $0x10,%esp
 8054c81:	83 f8 4f             	cmp    $0x4f,%eax
 8054c84:	7e 85                	jle    8054c0b <jae_i_b+0x4b>
 8054c86:	68 70 2e 06 08       	push   $0x8062e70
 8054c8b:	6a 0e                	push   $0xe
 8054c8d:	68 60 2d 06 08       	push   $0x8062d60
 8054c92:	68 18 2e 06 08       	push   $0x8062e18
 8054c97:	e8 14 3f ff ff       	call   8048bb0 <__assert_fail@plt>
 8054c9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08054ca0 <jae_i_v>:
#include "jae-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jae_i)
 8054ca0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8054ca7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8054cab:	b8 d0 4a 05 08       	mov    $0x8054ad0,%eax
 8054cb0:	75 05                	jne    8054cb7 <jae_i_v+0x17>
 8054cb2:	b8 f0 49 05 08       	mov    $0x80549f0,%eax
 8054cb7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8054cbb:	ff e0                	jmp    *%eax
 8054cbd:	66 90                	xchg   %ax,%ax
 8054cbf:	90                   	nop

08054cc0 <jo_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8054cc0:	53                   	push   %ebx
 8054cc1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054cc4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054cc8:	83 c0 01             	add    $0x1,%eax
 8054ccb:	50                   	push   %eax
 8054ccc:	e8 6f 7e 00 00       	call   805cb40 <decode_i_l>
#define instr jo

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF) {
 8054cd1:	83 c4 10             	add    $0x10,%esp
 8054cd4:	f6 05 e5 af 0f 10 08 	testb  $0x8,0x100fafe5
 8054cdb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jo

static void do_execute() {
	int res = op_src->val;
 8054cdd:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF) {
 8054ce2:	74 06                	je     8054cea <jo_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8054ce4:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054cea:	68 18 af 0f 10       	push   $0x100faf18
 8054cef:	68 79 2e 06 08       	push   $0x8062e79
 8054cf4:	6a 50                	push   $0x50
 8054cf6:	68 00 8a 0c 08       	push   $0x80c8a00
 8054cfb:	e8 00 3e ff ff       	call   8048b00 <snprintf@plt>
 8054d00:	83 c4 10             	add    $0x10,%esp
 8054d03:	83 f8 4f             	cmp    $0x4f,%eax
 8054d06:	7f 08                	jg     8054d10 <jo_i_l+0x50>
}

make_instr_helper(i)
 8054d08:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054d0b:	8d 43 01             	lea    0x1(%ebx),%eax
 8054d0e:	5b                   	pop    %ebx
 8054d0f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054d10:	83 ec 0c             	sub    $0xc,%esp
 8054d13:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054d19:	e8 42 3c ff ff       	call   8048960 <fflush@plt>
 8054d1e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054d24:	6a 07                	push   $0x7
 8054d26:	6a 01                	push   $0x1
 8054d28:	68 92 e8 05 08       	push   $0x805e892
 8054d2d:	e8 de 3c ff ff       	call   8048a10 <fwrite@plt>
 8054d32:	83 c4 20             	add    $0x20,%esp
 8054d35:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054d3b:	6a 10                	push   $0x10
 8054d3d:	6a 01                	push   $0x1
 8054d3f:	68 b4 f3 05 08       	push   $0x805f3b4
 8054d44:	e8 c7 3c ff ff       	call   8048a10 <fwrite@plt>
 8054d49:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054d4f:	6a 05                	push   $0x5
 8054d51:	6a 01                	push   $0x1
 8054d53:	68 42 f3 05 08       	push   $0x805f342
 8054d58:	e8 b3 3c ff ff       	call   8048a10 <fwrite@plt>
 8054d5d:	83 c4 20             	add    $0x20,%esp
 8054d60:	68 18 af 0f 10       	push   $0x100faf18
 8054d65:	68 79 2e 06 08       	push   $0x8062e79
 8054d6a:	6a 50                	push   $0x50
 8054d6c:	68 00 8a 0c 08       	push   $0x80c8a00
 8054d71:	e8 8a 3d ff ff       	call   8048b00 <snprintf@plt>
 8054d76:	83 c4 10             	add    $0x10,%esp
 8054d79:	83 f8 4f             	cmp    $0x4f,%eax
 8054d7c:	7e 8a                	jle    8054d08 <jo_i_l+0x48>
 8054d7e:	68 89 2f 06 08       	push   $0x8062f89
 8054d83:	6a 0e                	push   $0xe
 8054d85:	68 90 2e 06 08       	push   $0x8062e90
 8054d8a:	68 b4 2e 06 08       	push   $0x8062eb4
 8054d8f:	e8 1c 3e ff ff       	call   8048bb0 <__assert_fail@plt>
 8054d94:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8054d9a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08054da0 <jo_i_w>:
}

make_instr_helper(i)
 8054da0:	53                   	push   %ebx
 8054da1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054da4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054da8:	83 c0 01             	add    $0x1,%eax
 8054dab:	50                   	push   %eax
 8054dac:	e8 ff 79 00 00       	call   805c7b0 <decode_i_w>
#define instr jo

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF) {
 8054db1:	83 c4 10             	add    $0x10,%esp
 8054db4:	f6 05 e5 af 0f 10 08 	testb  $0x8,0x100fafe5
 8054dbb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jo

static void do_execute() {
	int res = op_src->val;
 8054dbd:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF) {
 8054dc2:	74 0f                	je     8054dd3 <jo_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8054dc4:	66 03 05 e0 af 0f 10 	add    0x100fafe0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 8054dcb:	0f b7 c0             	movzwl %ax,%eax
 8054dce:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
#endif
	}
	print_asm_template1();
 8054dd3:	68 18 af 0f 10       	push   $0x100faf18
 8054dd8:	68 80 2e 06 08       	push   $0x8062e80
 8054ddd:	6a 50                	push   $0x50
 8054ddf:	68 00 8a 0c 08       	push   $0x80c8a00
 8054de4:	e8 17 3d ff ff       	call   8048b00 <snprintf@plt>
 8054de9:	83 c4 10             	add    $0x10,%esp
 8054dec:	83 f8 4f             	cmp    $0x4f,%eax
 8054def:	7f 0f                	jg     8054e00 <jo_i_w+0x60>
}

make_instr_helper(i)
 8054df1:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054df4:	8d 43 01             	lea    0x1(%ebx),%eax
 8054df7:	5b                   	pop    %ebx
 8054df8:	c3                   	ret    
 8054df9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054e00:	83 ec 0c             	sub    $0xc,%esp
 8054e03:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054e09:	e8 52 3b ff ff       	call   8048960 <fflush@plt>
 8054e0e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054e14:	6a 07                	push   $0x7
 8054e16:	6a 01                	push   $0x1
 8054e18:	68 92 e8 05 08       	push   $0x805e892
 8054e1d:	e8 ee 3b ff ff       	call   8048a10 <fwrite@plt>
 8054e22:	83 c4 20             	add    $0x20,%esp
 8054e25:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054e2b:	6a 10                	push   $0x10
 8054e2d:	6a 01                	push   $0x1
 8054e2f:	68 b4 f3 05 08       	push   $0x805f3b4
 8054e34:	e8 d7 3b ff ff       	call   8048a10 <fwrite@plt>
 8054e39:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054e3f:	6a 05                	push   $0x5
 8054e41:	6a 01                	push   $0x1
 8054e43:	68 42 f3 05 08       	push   $0x805f342
 8054e48:	e8 c3 3b ff ff       	call   8048a10 <fwrite@plt>
 8054e4d:	83 c4 20             	add    $0x20,%esp
 8054e50:	68 18 af 0f 10       	push   $0x100faf18
 8054e55:	68 80 2e 06 08       	push   $0x8062e80
 8054e5a:	6a 50                	push   $0x50
 8054e5c:	68 00 8a 0c 08       	push   $0x80c8a00
 8054e61:	e8 9a 3c ff ff       	call   8048b00 <snprintf@plt>
 8054e66:	83 c4 10             	add    $0x10,%esp
 8054e69:	83 f8 4f             	cmp    $0x4f,%eax
 8054e6c:	7e 83                	jle    8054df1 <jo_i_w+0x51>
 8054e6e:	68 91 2f 06 08       	push   $0x8062f91
 8054e73:	6a 0e                	push   $0xe
 8054e75:	68 90 2e 06 08       	push   $0x8062e90
 8054e7a:	68 fc 2e 06 08       	push   $0x8062efc
 8054e7f:	e8 2c 3d ff ff       	call   8048bb0 <__assert_fail@plt>
 8054e84:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8054e8a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08054e90 <jo_i_b>:
}

make_instr_helper(i)
 8054e90:	53                   	push   %ebx
 8054e91:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054e94:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054e98:	83 c0 01             	add    $0x1,%eax
 8054e9b:	50                   	push   %eax
 8054e9c:	e8 9f 75 00 00       	call   805c440 <decode_i_b>
#define instr jo

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF) {
 8054ea1:	83 c4 10             	add    $0x10,%esp
 8054ea4:	f6 05 e5 af 0f 10 08 	testb  $0x8,0x100fafe5
 8054eab:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jo

static void do_execute() {
	int res = op_src->val;
 8054ead:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF) {
 8054eb2:	74 09                	je     8054ebd <jo_i_b+0x2d>

#define instr jo

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8054eb4:	0f be c0             	movsbl %al,%eax
	if(cpu.OF) {
		cpu.eip = cpu.eip + res;
 8054eb7:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054ebd:	68 18 af 0f 10       	push   $0x100faf18
 8054ec2:	68 87 2e 06 08       	push   $0x8062e87
 8054ec7:	6a 50                	push   $0x50
 8054ec9:	68 00 8a 0c 08       	push   $0x80c8a00
 8054ece:	e8 2d 3c ff ff       	call   8048b00 <snprintf@plt>
 8054ed3:	83 c4 10             	add    $0x10,%esp
 8054ed6:	83 f8 4f             	cmp    $0x4f,%eax
 8054ed9:	7f 0d                	jg     8054ee8 <jo_i_b+0x58>
}

make_instr_helper(i)
 8054edb:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054ede:	8d 43 01             	lea    0x1(%ebx),%eax
 8054ee1:	5b                   	pop    %ebx
 8054ee2:	c3                   	ret    
 8054ee3:	90                   	nop
 8054ee4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054ee8:	83 ec 0c             	sub    $0xc,%esp
 8054eeb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054ef1:	e8 6a 3a ff ff       	call   8048960 <fflush@plt>
 8054ef6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054efc:	6a 07                	push   $0x7
 8054efe:	6a 01                	push   $0x1
 8054f00:	68 92 e8 05 08       	push   $0x805e892
 8054f05:	e8 06 3b ff ff       	call   8048a10 <fwrite@plt>
 8054f0a:	83 c4 20             	add    $0x20,%esp
 8054f0d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054f13:	6a 10                	push   $0x10
 8054f15:	6a 01                	push   $0x1
 8054f17:	68 b4 f3 05 08       	push   $0x805f3b4
 8054f1c:	e8 ef 3a ff ff       	call   8048a10 <fwrite@plt>
 8054f21:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8054f27:	6a 05                	push   $0x5
 8054f29:	6a 01                	push   $0x1
 8054f2b:	68 42 f3 05 08       	push   $0x805f342
 8054f30:	e8 db 3a ff ff       	call   8048a10 <fwrite@plt>
 8054f35:	83 c4 20             	add    $0x20,%esp
 8054f38:	68 18 af 0f 10       	push   $0x100faf18
 8054f3d:	68 87 2e 06 08       	push   $0x8062e87
 8054f42:	6a 50                	push   $0x50
 8054f44:	68 00 8a 0c 08       	push   $0x80c8a00
 8054f49:	e8 b2 3b ff ff       	call   8048b00 <snprintf@plt>
 8054f4e:	83 c4 10             	add    $0x10,%esp
 8054f51:	83 f8 4f             	cmp    $0x4f,%eax
 8054f54:	7e 85                	jle    8054edb <jo_i_b+0x4b>
 8054f56:	68 99 2f 06 08       	push   $0x8062f99
 8054f5b:	6a 0e                	push   $0xe
 8054f5d:	68 90 2e 06 08       	push   $0x8062e90
 8054f62:	68 44 2f 06 08       	push   $0x8062f44
 8054f67:	e8 44 3c ff ff       	call   8048bb0 <__assert_fail@plt>
 8054f6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08054f70 <jo_i_v>:
#include "jo-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jo_i)
 8054f70:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8054f77:	8b 54 24 04          	mov    0x4(%esp),%edx
 8054f7b:	b8 a0 4d 05 08       	mov    $0x8054da0,%eax
 8054f80:	75 05                	jne    8054f87 <jo_i_v+0x17>
 8054f82:	b8 c0 4c 05 08       	mov    $0x8054cc0,%eax
 8054f87:	89 54 24 04          	mov    %edx,0x4(%esp)
 8054f8b:	ff e0                	jmp    *%eax
 8054f8d:	66 90                	xchg   %ax,%ax
 8054f8f:	90                   	nop

08054f90 <jge_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8054f90:	53                   	push   %ebx
 8054f91:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8054f94:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8054f98:	83 c0 01             	add    $0x1,%eax
 8054f9b:	50                   	push   %eax
 8054f9c:	e8 9f 7b 00 00       	call   805cb40 <decode_i_l>
#define instr jge

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
 8054fa1:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8054fa8:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 8054faf:	83 c4 10             	add    $0x10,%esp
 8054fb2:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jge

static void do_execute() {
	int res = op_src->val;
 8054fb4:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
 8054fb9:	c0 ea 03             	shr    $0x3,%dl
 8054fbc:	c0 e9 07             	shr    $0x7,%cl
 8054fbf:	83 e2 01             	and    $0x1,%edx
 8054fc2:	38 ca                	cmp    %cl,%dl
 8054fc4:	0f 84 ae 00 00 00    	je     8055078 <jge_i_l+0xe8>
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054fca:	68 18 af 0f 10       	push   $0x100faf18
 8054fcf:	68 a1 2f 06 08       	push   $0x8062fa1
 8054fd4:	6a 50                	push   $0x50
 8054fd6:	68 00 8a 0c 08       	push   $0x80c8a00
 8054fdb:	e8 20 3b ff ff       	call   8048b00 <snprintf@plt>
 8054fe0:	83 c4 10             	add    $0x10,%esp
 8054fe3:	83 f8 4f             	cmp    $0x4f,%eax
 8054fe6:	7f 08                	jg     8054ff0 <jge_i_l+0x60>
}

make_instr_helper(i)
 8054fe8:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8054feb:	8d 43 01             	lea    0x1(%ebx),%eax
 8054fee:	5b                   	pop    %ebx
 8054fef:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8054ff0:	83 ec 0c             	sub    $0xc,%esp
 8054ff3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8054ff9:	e8 62 39 ff ff       	call   8048960 <fflush@plt>
 8054ffe:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055004:	6a 07                	push   $0x7
 8055006:	6a 01                	push   $0x1
 8055008:	68 92 e8 05 08       	push   $0x805e892
 805500d:	e8 fe 39 ff ff       	call   8048a10 <fwrite@plt>
 8055012:	83 c4 20             	add    $0x20,%esp
 8055015:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805501b:	6a 10                	push   $0x10
 805501d:	6a 01                	push   $0x1
 805501f:	68 b4 f3 05 08       	push   $0x805f3b4
 8055024:	e8 e7 39 ff ff       	call   8048a10 <fwrite@plt>
 8055029:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805502f:	6a 05                	push   $0x5
 8055031:	6a 01                	push   $0x1
 8055033:	68 42 f3 05 08       	push   $0x805f342
 8055038:	e8 d3 39 ff ff       	call   8048a10 <fwrite@plt>
 805503d:	83 c4 20             	add    $0x20,%esp
 8055040:	68 18 af 0f 10       	push   $0x100faf18
 8055045:	68 a1 2f 06 08       	push   $0x8062fa1
 805504a:	6a 50                	push   $0x50
 805504c:	68 00 8a 0c 08       	push   $0x80c8a00
 8055051:	e8 aa 3a ff ff       	call   8048b00 <snprintf@plt>
 8055056:	83 c4 10             	add    $0x10,%esp
 8055059:	83 f8 4f             	cmp    $0x4f,%eax
 805505c:	7e 8a                	jle    8054fe8 <jge_i_l+0x58>
 805505e:	68 ba 30 06 08       	push   $0x80630ba
 8055063:	6a 0e                	push   $0xe
 8055065:	68 bc 2f 06 08       	push   $0x8062fbc
 805506a:	68 e4 2f 06 08       	push   $0x8062fe4
 805506f:	e8 3c 3b ff ff       	call   8048bb0 <__assert_fail@plt>
 8055074:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
		cpu.eip = cpu.eip + res;
 8055078:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
 805507e:	e9 47 ff ff ff       	jmp    8054fca <jge_i_l+0x3a>
 8055083:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8055089:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08055090 <jge_i_w>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8055090:	53                   	push   %ebx
 8055091:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055094:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055098:	83 c0 01             	add    $0x1,%eax
 805509b:	50                   	push   %eax
 805509c:	e8 0f 77 00 00       	call   805c7b0 <decode_i_w>
#define instr jge

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
 80550a1:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 80550a8:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 80550af:	83 c4 10             	add    $0x10,%esp
 80550b2:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jge

static void do_execute() {
	int res = op_src->val;
 80550b4:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
 80550b9:	c0 ea 03             	shr    $0x3,%dl
 80550bc:	c0 e9 07             	shr    $0x7,%cl
 80550bf:	83 e2 01             	and    $0x1,%edx
 80550c2:	38 ca                	cmp    %cl,%dl
 80550c4:	0f 84 ae 00 00 00    	je     8055178 <jge_i_w+0xe8>
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80550ca:	68 18 af 0f 10       	push   $0x100faf18
 80550cf:	68 a9 2f 06 08       	push   $0x8062fa9
 80550d4:	6a 50                	push   $0x50
 80550d6:	68 00 8a 0c 08       	push   $0x80c8a00
 80550db:	e8 20 3a ff ff       	call   8048b00 <snprintf@plt>
 80550e0:	83 c4 10             	add    $0x10,%esp
 80550e3:	83 f8 4f             	cmp    $0x4f,%eax
 80550e6:	7f 08                	jg     80550f0 <jge_i_w+0x60>
}

make_instr_helper(i)
 80550e8:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80550eb:	8d 43 01             	lea    0x1(%ebx),%eax
 80550ee:	5b                   	pop    %ebx
 80550ef:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80550f0:	83 ec 0c             	sub    $0xc,%esp
 80550f3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80550f9:	e8 62 38 ff ff       	call   8048960 <fflush@plt>
 80550fe:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055104:	6a 07                	push   $0x7
 8055106:	6a 01                	push   $0x1
 8055108:	68 92 e8 05 08       	push   $0x805e892
 805510d:	e8 fe 38 ff ff       	call   8048a10 <fwrite@plt>
 8055112:	83 c4 20             	add    $0x20,%esp
 8055115:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805511b:	6a 10                	push   $0x10
 805511d:	6a 01                	push   $0x1
 805511f:	68 b4 f3 05 08       	push   $0x805f3b4
 8055124:	e8 e7 38 ff ff       	call   8048a10 <fwrite@plt>
 8055129:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805512f:	6a 05                	push   $0x5
 8055131:	6a 01                	push   $0x1
 8055133:	68 42 f3 05 08       	push   $0x805f342
 8055138:	e8 d3 38 ff ff       	call   8048a10 <fwrite@plt>
 805513d:	83 c4 20             	add    $0x20,%esp
 8055140:	68 18 af 0f 10       	push   $0x100faf18
 8055145:	68 a9 2f 06 08       	push   $0x8062fa9
 805514a:	6a 50                	push   $0x50
 805514c:	68 00 8a 0c 08       	push   $0x80c8a00
 8055151:	e8 aa 39 ff ff       	call   8048b00 <snprintf@plt>
 8055156:	83 c4 10             	add    $0x10,%esp
 8055159:	83 f8 4f             	cmp    $0x4f,%eax
 805515c:	7e 8a                	jle    80550e8 <jge_i_w+0x58>
 805515e:	68 c3 30 06 08       	push   $0x80630c3
 8055163:	6a 0e                	push   $0xe
 8055165:	68 bc 2f 06 08       	push   $0x8062fbc
 805516a:	68 2c 30 06 08       	push   $0x806302c
 805516f:	e8 3c 3a ff ff       	call   8048bb0 <__assert_fail@plt>
 8055174:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
		cpu.eip = cpu.eip + res;
 8055178:	66 03 05 e0 af 0f 10 	add    0x100fafe0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 805517f:	0f b7 c0             	movzwl %ax,%eax
 8055182:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
 8055187:	e9 3e ff ff ff       	jmp    80550ca <jge_i_w+0x3a>
 805518c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08055190 <jge_i_b>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8055190:	53                   	push   %ebx
 8055191:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055194:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055198:	83 c0 01             	add    $0x1,%eax
 805519b:	50                   	push   %eax
 805519c:	e8 9f 72 00 00       	call   805c440 <decode_i_b>
#define instr jge

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
 80551a1:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 80551a8:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 80551af:	83 c4 10             	add    $0x10,%esp
 80551b2:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jge

static void do_execute() {
	int res = op_src->val;
 80551b4:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF == cpu.SF) {
 80551b9:	c0 ea 03             	shr    $0x3,%dl
 80551bc:	c0 e9 07             	shr    $0x7,%cl
 80551bf:	83 e2 01             	and    $0x1,%edx
 80551c2:	38 ca                	cmp    %cl,%dl
 80551c4:	0f 84 ae 00 00 00    	je     8055278 <jge_i_b+0xe8>
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80551ca:	68 18 af 0f 10       	push   $0x100faf18
 80551cf:	68 b1 2f 06 08       	push   $0x8062fb1
 80551d4:	6a 50                	push   $0x50
 80551d6:	68 00 8a 0c 08       	push   $0x80c8a00
 80551db:	e8 20 39 ff ff       	call   8048b00 <snprintf@plt>
 80551e0:	83 c4 10             	add    $0x10,%esp
 80551e3:	83 f8 4f             	cmp    $0x4f,%eax
 80551e6:	7f 08                	jg     80551f0 <jge_i_b+0x60>
}

make_instr_helper(i)
 80551e8:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80551eb:	8d 43 01             	lea    0x1(%ebx),%eax
 80551ee:	5b                   	pop    %ebx
 80551ef:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80551f0:	83 ec 0c             	sub    $0xc,%esp
 80551f3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80551f9:	e8 62 37 ff ff       	call   8048960 <fflush@plt>
 80551fe:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055204:	6a 07                	push   $0x7
 8055206:	6a 01                	push   $0x1
 8055208:	68 92 e8 05 08       	push   $0x805e892
 805520d:	e8 fe 37 ff ff       	call   8048a10 <fwrite@plt>
 8055212:	83 c4 20             	add    $0x20,%esp
 8055215:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805521b:	6a 10                	push   $0x10
 805521d:	6a 01                	push   $0x1
 805521f:	68 b4 f3 05 08       	push   $0x805f3b4
 8055224:	e8 e7 37 ff ff       	call   8048a10 <fwrite@plt>
 8055229:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805522f:	6a 05                	push   $0x5
 8055231:	6a 01                	push   $0x1
 8055233:	68 42 f3 05 08       	push   $0x805f342
 8055238:	e8 d3 37 ff ff       	call   8048a10 <fwrite@plt>
 805523d:	83 c4 20             	add    $0x20,%esp
 8055240:	68 18 af 0f 10       	push   $0x100faf18
 8055245:	68 b1 2f 06 08       	push   $0x8062fb1
 805524a:	6a 50                	push   $0x50
 805524c:	68 00 8a 0c 08       	push   $0x80c8a00
 8055251:	e8 aa 38 ff ff       	call   8048b00 <snprintf@plt>
 8055256:	83 c4 10             	add    $0x10,%esp
 8055259:	83 f8 4f             	cmp    $0x4f,%eax
 805525c:	7e 8a                	jle    80551e8 <jge_i_b+0x58>
 805525e:	68 cc 30 06 08       	push   $0x80630cc
 8055263:	6a 0e                	push   $0xe
 8055265:	68 bc 2f 06 08       	push   $0x8062fbc
 805526a:	68 74 30 06 08       	push   $0x8063074
 805526f:	e8 3c 39 ff ff       	call   8048bb0 <__assert_fail@plt>
 8055274:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

#define instr jge

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8055278:	0f be c0             	movsbl %al,%eax
	if(cpu.OF == cpu.SF) {
		cpu.eip = cpu.eip + res;
 805527b:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
 8055281:	e9 44 ff ff ff       	jmp    80551ca <jge_i_b+0x3a>
 8055286:	8d 76 00             	lea    0x0(%esi),%esi
 8055289:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08055290 <jge_i_v>:
#include "jge-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jge_i)
 8055290:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8055297:	8b 54 24 04          	mov    0x4(%esp),%edx
 805529b:	b8 90 50 05 08       	mov    $0x8055090,%eax
 80552a0:	75 05                	jne    80552a7 <jge_i_v+0x17>
 80552a2:	b8 90 4f 05 08       	mov    $0x8054f90,%eax
 80552a7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80552ab:	ff e0                	jmp    *%eax
 80552ad:	66 90                	xchg   %ax,%ax
 80552af:	90                   	nop

080552b0 <do_jcxz_b>:
#include "cpu/exec/template-start.h"

#define instr jcxz

static void do_execute() {
 80552b0:	83 ec 0c             	sub    $0xc,%esp
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	bool flag = !(reg_l(R_ECX) << (32 - (op_src2->val << 3)) >> (32 - (op_src2->val << 3)));
 80552b3:	a1 84 af 0f 10       	mov    0x100faf84,%eax
 80552b8:	b9 20 00 00 00       	mov    $0x20,%ecx
#include "cpu/exec/template-start.h"

#define instr jcxz

static void do_execute() {
	int res = op_src->val;
 80552bd:	8b 15 14 af 0f 10    	mov    0x100faf14,%edx
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	bool flag = !(reg_l(R_ECX) << (32 - (op_src2->val << 3)) >> (32 - (op_src2->val << 3)));
 80552c3:	c1 e0 03             	shl    $0x3,%eax
 80552c6:	29 c1                	sub    %eax,%ecx
 80552c8:	a1 c4 af 0f 10       	mov    0x100fafc4,%eax
 80552cd:	d3 e0                	shl    %cl,%eax
 80552cf:	d3 e8                	shr    %cl,%eax
	if(flag) {
 80552d1:	85 c0                	test   %eax,%eax
 80552d3:	75 09                	jne    80552de <do_jcxz_b+0x2e>

#define instr jcxz

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 80552d5:	0f be d2             	movsbl %dl,%edx
	bool flag = !(reg_l(R_ECX) << (32 - (op_src2->val << 3)) >> (32 - (op_src2->val << 3)));
	if(flag) {
		cpu.eip = cpu.eip + res;
 80552d8:	01 15 e0 af 0f 10    	add    %edx,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80552de:	68 18 af 0f 10       	push   $0x100faf18
 80552e3:	68 d5 30 06 08       	push   $0x80630d5
 80552e8:	6a 50                	push   $0x50
 80552ea:	68 00 8a 0c 08       	push   $0x80c8a00
 80552ef:	e8 0c 38 ff ff       	call   8048b00 <snprintf@plt>
 80552f4:	83 c4 10             	add    $0x10,%esp
 80552f7:	83 f8 4f             	cmp    $0x4f,%eax
 80552fa:	7f 04                	jg     8055300 <do_jcxz_b+0x50>
}
 80552fc:	83 c4 0c             	add    $0xc,%esp
 80552ff:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055300:	83 ec 0c             	sub    $0xc,%esp
 8055303:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8055309:	e8 52 36 ff ff       	call   8048960 <fflush@plt>
 805530e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055314:	6a 07                	push   $0x7
 8055316:	6a 01                	push   $0x1
 8055318:	68 92 e8 05 08       	push   $0x805e892
 805531d:	e8 ee 36 ff ff       	call   8048a10 <fwrite@plt>
 8055322:	83 c4 20             	add    $0x20,%esp
 8055325:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805532b:	6a 10                	push   $0x10
 805532d:	6a 01                	push   $0x1
 805532f:	68 b4 f3 05 08       	push   $0x805f3b4
 8055334:	e8 d7 36 ff ff       	call   8048a10 <fwrite@plt>
 8055339:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805533f:	6a 05                	push   $0x5
 8055341:	6a 01                	push   $0x1
 8055343:	68 42 f3 05 08       	push   $0x805f342
 8055348:	e8 c3 36 ff ff       	call   8048a10 <fwrite@plt>
 805534d:	83 c4 20             	add    $0x20,%esp
 8055350:	68 18 af 0f 10       	push   $0x100faf18
 8055355:	68 d5 30 06 08       	push   $0x80630d5
 805535a:	6a 50                	push   $0x50
 805535c:	68 00 8a 0c 08       	push   $0x80c8a00
 8055361:	e8 9a 37 ff ff       	call   8048b00 <snprintf@plt>
 8055366:	83 c4 10             	add    $0x10,%esp
 8055369:	83 f8 4f             	cmp    $0x4f,%eax
 805536c:	7e 8e                	jle    80552fc <do_jcxz_b+0x4c>
 805536e:	68 4f 31 06 08       	push   $0x806314f
 8055373:	6a 0f                	push   $0xf
 8055375:	68 e0 30 06 08       	push   $0x80630e0
 805537a:	68 08 31 06 08       	push   $0x8063108
 805537f:	e8 2c 38 ff ff       	call   8048bb0 <__assert_fail@plt>
 8055384:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805538a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08055390 <jcxz_i_b>:
}

make_instr_helper(i)
 8055390:	53                   	push   %ebx
 8055391:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055394:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055398:	83 c0 01             	add    $0x1,%eax
 805539b:	50                   	push   %eax
 805539c:	e8 9f 70 00 00       	call   805c440 <decode_i_b>
 80553a1:	89 c3                	mov    %eax,%ebx
	execute();
 80553a3:	e8 08 ff ff ff       	call   80552b0 <do_jcxz_b>
 80553a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80553ab:	8d 43 01             	lea    0x1(%ebx),%eax
 80553ae:	5b                   	pop    %ebx
 80553af:	c3                   	ret    

080553b0 <jcxz_i_v>:
#define DATA_BYTE 1
#include "jcxz-template.h"
#undef DATA_BYTE
/* for instruction encoding overloading */

make_helper(jcxz_i_v) {
 80553b0:	53                   	push   %ebx
 80553b1:	83 ec 14             	sub    $0x14,%esp
	if(ops_decoded.is_data_size_16) {
		op_src2->val = 2;
 80553b4:	80 3d 04 af 0f 10 01 	cmpb   $0x1,0x100faf04
 80553bb:	19 c0                	sbb    %eax,%eax
 80553bd:	83 e0 02             	and    $0x2,%eax
 80553c0:	83 c0 02             	add    $0x2,%eax
 80553c3:	a3 84 af 0f 10       	mov    %eax,0x100faf84
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80553c8:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80553cc:	83 c0 01             	add    $0x1,%eax
 80553cf:	50                   	push   %eax
 80553d0:	e8 6b 70 00 00       	call   805c440 <decode_i_b>
 80553d5:	89 c3                	mov    %eax,%ebx
	execute();
 80553d7:	e8 d4 fe ff ff       	call   80552b0 <do_jcxz_b>
	}
	else {
		op_src2->val = 4;
	}
	return jcxz_i_b(eip);
}
 80553dc:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80553df:	8d 43 01             	lea    0x1(%ebx),%eax
 80553e2:	5b                   	pop    %ebx
 80553e3:	c3                   	ret    
 80553e4:	66 90                	xchg   %ax,%ax
 80553e6:	66 90                	xchg   %ax,%ax
 80553e8:	66 90                	xchg   %ax,%ax
 80553ea:	66 90                	xchg   %ax,%ax
 80553ec:	66 90                	xchg   %ax,%ax
 80553ee:	66 90                	xchg   %ax,%ax

080553f0 <js_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 80553f0:	53                   	push   %ebx
 80553f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80553f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80553f8:	83 c0 01             	add    $0x1,%eax
 80553fb:	50                   	push   %eax
 80553fc:	e8 3f 77 00 00       	call   805cb40 <decode_i_l>
#define instr js

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.SF) {
 8055401:	83 c4 10             	add    $0x10,%esp
 8055404:	80 3d e4 af 0f 10 00 	cmpb   $0x0,0x100fafe4
 805540b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr js

static void do_execute() {
	int res = op_src->val;
 805540d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.SF) {
 8055412:	79 06                	jns    805541a <js_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8055414:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805541a:	68 18 af 0f 10       	push   $0x100faf18
 805541f:	68 59 31 06 08       	push   $0x8063159
 8055424:	6a 50                	push   $0x50
 8055426:	68 00 8a 0c 08       	push   $0x80c8a00
 805542b:	e8 d0 36 ff ff       	call   8048b00 <snprintf@plt>
 8055430:	83 c4 10             	add    $0x10,%esp
 8055433:	83 f8 4f             	cmp    $0x4f,%eax
 8055436:	7f 08                	jg     8055440 <js_i_l+0x50>
}

make_instr_helper(i)
 8055438:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805543b:	8d 43 01             	lea    0x1(%ebx),%eax
 805543e:	5b                   	pop    %ebx
 805543f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055440:	83 ec 0c             	sub    $0xc,%esp
 8055443:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8055449:	e8 12 35 ff ff       	call   8048960 <fflush@plt>
 805544e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055454:	6a 07                	push   $0x7
 8055456:	6a 01                	push   $0x1
 8055458:	68 92 e8 05 08       	push   $0x805e892
 805545d:	e8 ae 35 ff ff       	call   8048a10 <fwrite@plt>
 8055462:	83 c4 20             	add    $0x20,%esp
 8055465:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805546b:	6a 10                	push   $0x10
 805546d:	6a 01                	push   $0x1
 805546f:	68 b4 f3 05 08       	push   $0x805f3b4
 8055474:	e8 97 35 ff ff       	call   8048a10 <fwrite@plt>
 8055479:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805547f:	6a 05                	push   $0x5
 8055481:	6a 01                	push   $0x1
 8055483:	68 42 f3 05 08       	push   $0x805f342
 8055488:	e8 83 35 ff ff       	call   8048a10 <fwrite@plt>
 805548d:	83 c4 20             	add    $0x20,%esp
 8055490:	68 18 af 0f 10       	push   $0x100faf18
 8055495:	68 59 31 06 08       	push   $0x8063159
 805549a:	6a 50                	push   $0x50
 805549c:	68 00 8a 0c 08       	push   $0x80c8a00
 80554a1:	e8 5a 36 ff ff       	call   8048b00 <snprintf@plt>
 80554a6:	83 c4 10             	add    $0x10,%esp
 80554a9:	83 f8 4f             	cmp    $0x4f,%eax
 80554ac:	7e 8a                	jle    8055438 <js_i_l+0x48>
 80554ae:	68 69 32 06 08       	push   $0x8063269
 80554b3:	6a 0e                	push   $0xe
 80554b5:	68 70 31 06 08       	push   $0x8063170
 80554ba:	68 94 31 06 08       	push   $0x8063194
 80554bf:	e8 ec 36 ff ff       	call   8048bb0 <__assert_fail@plt>
 80554c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80554ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080554d0 <js_i_w>:
}

make_instr_helper(i)
 80554d0:	53                   	push   %ebx
 80554d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80554d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80554d8:	83 c0 01             	add    $0x1,%eax
 80554db:	50                   	push   %eax
 80554dc:	e8 cf 72 00 00       	call   805c7b0 <decode_i_w>
#define instr js

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.SF) {
 80554e1:	83 c4 10             	add    $0x10,%esp
 80554e4:	80 3d e4 af 0f 10 00 	cmpb   $0x0,0x100fafe4
 80554eb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr js

static void do_execute() {
	int res = op_src->val;
 80554ed:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.SF) {
 80554f2:	79 0f                	jns    8055503 <js_i_w+0x33>
		cpu.eip = cpu.eip + res;
 80554f4:	66 03 05 e0 af 0f 10 	add    0x100fafe0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 80554fb:	0f b7 c0             	movzwl %ax,%eax
 80554fe:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
#endif
	}
	print_asm_template1();
 8055503:	68 18 af 0f 10       	push   $0x100faf18
 8055508:	68 60 31 06 08       	push   $0x8063160
 805550d:	6a 50                	push   $0x50
 805550f:	68 00 8a 0c 08       	push   $0x80c8a00
 8055514:	e8 e7 35 ff ff       	call   8048b00 <snprintf@plt>
 8055519:	83 c4 10             	add    $0x10,%esp
 805551c:	83 f8 4f             	cmp    $0x4f,%eax
 805551f:	7f 0f                	jg     8055530 <js_i_w+0x60>
}

make_instr_helper(i)
 8055521:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055524:	8d 43 01             	lea    0x1(%ebx),%eax
 8055527:	5b                   	pop    %ebx
 8055528:	c3                   	ret    
 8055529:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055530:	83 ec 0c             	sub    $0xc,%esp
 8055533:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8055539:	e8 22 34 ff ff       	call   8048960 <fflush@plt>
 805553e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055544:	6a 07                	push   $0x7
 8055546:	6a 01                	push   $0x1
 8055548:	68 92 e8 05 08       	push   $0x805e892
 805554d:	e8 be 34 ff ff       	call   8048a10 <fwrite@plt>
 8055552:	83 c4 20             	add    $0x20,%esp
 8055555:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805555b:	6a 10                	push   $0x10
 805555d:	6a 01                	push   $0x1
 805555f:	68 b4 f3 05 08       	push   $0x805f3b4
 8055564:	e8 a7 34 ff ff       	call   8048a10 <fwrite@plt>
 8055569:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805556f:	6a 05                	push   $0x5
 8055571:	6a 01                	push   $0x1
 8055573:	68 42 f3 05 08       	push   $0x805f342
 8055578:	e8 93 34 ff ff       	call   8048a10 <fwrite@plt>
 805557d:	83 c4 20             	add    $0x20,%esp
 8055580:	68 18 af 0f 10       	push   $0x100faf18
 8055585:	68 60 31 06 08       	push   $0x8063160
 805558a:	6a 50                	push   $0x50
 805558c:	68 00 8a 0c 08       	push   $0x80c8a00
 8055591:	e8 6a 35 ff ff       	call   8048b00 <snprintf@plt>
 8055596:	83 c4 10             	add    $0x10,%esp
 8055599:	83 f8 4f             	cmp    $0x4f,%eax
 805559c:	7e 83                	jle    8055521 <js_i_w+0x51>
 805559e:	68 71 32 06 08       	push   $0x8063271
 80555a3:	6a 0e                	push   $0xe
 80555a5:	68 70 31 06 08       	push   $0x8063170
 80555aa:	68 dc 31 06 08       	push   $0x80631dc
 80555af:	e8 fc 35 ff ff       	call   8048bb0 <__assert_fail@plt>
 80555b4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80555ba:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080555c0 <js_i_b>:
}

make_instr_helper(i)
 80555c0:	53                   	push   %ebx
 80555c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80555c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80555c8:	83 c0 01             	add    $0x1,%eax
 80555cb:	50                   	push   %eax
 80555cc:	e8 6f 6e 00 00       	call   805c440 <decode_i_b>
#define instr js

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.SF) {
 80555d1:	83 c4 10             	add    $0x10,%esp
 80555d4:	80 3d e4 af 0f 10 00 	cmpb   $0x0,0x100fafe4
 80555db:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr js

static void do_execute() {
	int res = op_src->val;
 80555dd:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.SF) {
 80555e2:	79 09                	jns    80555ed <js_i_b+0x2d>

#define instr js

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 80555e4:	0f be c0             	movsbl %al,%eax
	if(cpu.SF) {
		cpu.eip = cpu.eip + res;
 80555e7:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80555ed:	68 18 af 0f 10       	push   $0x100faf18
 80555f2:	68 67 31 06 08       	push   $0x8063167
 80555f7:	6a 50                	push   $0x50
 80555f9:	68 00 8a 0c 08       	push   $0x80c8a00
 80555fe:	e8 fd 34 ff ff       	call   8048b00 <snprintf@plt>
 8055603:	83 c4 10             	add    $0x10,%esp
 8055606:	83 f8 4f             	cmp    $0x4f,%eax
 8055609:	7f 0d                	jg     8055618 <js_i_b+0x58>
}

make_instr_helper(i)
 805560b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805560e:	8d 43 01             	lea    0x1(%ebx),%eax
 8055611:	5b                   	pop    %ebx
 8055612:	c3                   	ret    
 8055613:	90                   	nop
 8055614:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055618:	83 ec 0c             	sub    $0xc,%esp
 805561b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8055621:	e8 3a 33 ff ff       	call   8048960 <fflush@plt>
 8055626:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805562c:	6a 07                	push   $0x7
 805562e:	6a 01                	push   $0x1
 8055630:	68 92 e8 05 08       	push   $0x805e892
 8055635:	e8 d6 33 ff ff       	call   8048a10 <fwrite@plt>
 805563a:	83 c4 20             	add    $0x20,%esp
 805563d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055643:	6a 10                	push   $0x10
 8055645:	6a 01                	push   $0x1
 8055647:	68 b4 f3 05 08       	push   $0x805f3b4
 805564c:	e8 bf 33 ff ff       	call   8048a10 <fwrite@plt>
 8055651:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055657:	6a 05                	push   $0x5
 8055659:	6a 01                	push   $0x1
 805565b:	68 42 f3 05 08       	push   $0x805f342
 8055660:	e8 ab 33 ff ff       	call   8048a10 <fwrite@plt>
 8055665:	83 c4 20             	add    $0x20,%esp
 8055668:	68 18 af 0f 10       	push   $0x100faf18
 805566d:	68 67 31 06 08       	push   $0x8063167
 8055672:	6a 50                	push   $0x50
 8055674:	68 00 8a 0c 08       	push   $0x80c8a00
 8055679:	e8 82 34 ff ff       	call   8048b00 <snprintf@plt>
 805567e:	83 c4 10             	add    $0x10,%esp
 8055681:	83 f8 4f             	cmp    $0x4f,%eax
 8055684:	7e 85                	jle    805560b <js_i_b+0x4b>
 8055686:	68 79 32 06 08       	push   $0x8063279
 805568b:	6a 0e                	push   $0xe
 805568d:	68 70 31 06 08       	push   $0x8063170
 8055692:	68 24 32 06 08       	push   $0x8063224
 8055697:	e8 14 35 ff ff       	call   8048bb0 <__assert_fail@plt>
 805569c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080556a0 <js_i_v>:
#include "js-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(js_i)
 80556a0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80556a7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80556ab:	b8 d0 54 05 08       	mov    $0x80554d0,%eax
 80556b0:	75 05                	jne    80556b7 <js_i_v+0x17>
 80556b2:	b8 f0 53 05 08       	mov    $0x80553f0,%eax
 80556b7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80556bb:	ff e0                	jmp    *%eax
 80556bd:	66 90                	xchg   %ax,%ax
 80556bf:	90                   	nop

080556c0 <jb_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 80556c0:	53                   	push   %ebx
 80556c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80556c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80556c8:	83 c0 01             	add    $0x1,%eax
 80556cb:	50                   	push   %eax
 80556cc:	e8 6f 74 00 00       	call   805cb40 <decode_i_l>
#define instr jb

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF) {
 80556d1:	83 c4 10             	add    $0x10,%esp
 80556d4:	f6 05 e4 af 0f 10 01 	testb  $0x1,0x100fafe4
 80556db:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jb

static void do_execute() {
	int res = op_src->val;
 80556dd:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF) {
 80556e2:	74 06                	je     80556ea <jb_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 80556e4:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80556ea:	68 18 af 0f 10       	push   $0x100faf18
 80556ef:	68 81 32 06 08       	push   $0x8063281
 80556f4:	6a 50                	push   $0x50
 80556f6:	68 00 8a 0c 08       	push   $0x80c8a00
 80556fb:	e8 00 34 ff ff       	call   8048b00 <snprintf@plt>
 8055700:	83 c4 10             	add    $0x10,%esp
 8055703:	83 f8 4f             	cmp    $0x4f,%eax
 8055706:	7f 08                	jg     8055710 <jb_i_l+0x50>
}

make_instr_helper(i)
 8055708:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805570b:	8d 43 01             	lea    0x1(%ebx),%eax
 805570e:	5b                   	pop    %ebx
 805570f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055710:	83 ec 0c             	sub    $0xc,%esp
 8055713:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8055719:	e8 42 32 ff ff       	call   8048960 <fflush@plt>
 805571e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055724:	6a 07                	push   $0x7
 8055726:	6a 01                	push   $0x1
 8055728:	68 92 e8 05 08       	push   $0x805e892
 805572d:	e8 de 32 ff ff       	call   8048a10 <fwrite@plt>
 8055732:	83 c4 20             	add    $0x20,%esp
 8055735:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805573b:	6a 10                	push   $0x10
 805573d:	6a 01                	push   $0x1
 805573f:	68 b4 f3 05 08       	push   $0x805f3b4
 8055744:	e8 c7 32 ff ff       	call   8048a10 <fwrite@plt>
 8055749:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805574f:	6a 05                	push   $0x5
 8055751:	6a 01                	push   $0x1
 8055753:	68 42 f3 05 08       	push   $0x805f342
 8055758:	e8 b3 32 ff ff       	call   8048a10 <fwrite@plt>
 805575d:	83 c4 20             	add    $0x20,%esp
 8055760:	68 18 af 0f 10       	push   $0x100faf18
 8055765:	68 81 32 06 08       	push   $0x8063281
 805576a:	6a 50                	push   $0x50
 805576c:	68 00 8a 0c 08       	push   $0x80c8a00
 8055771:	e8 8a 33 ff ff       	call   8048b00 <snprintf@plt>
 8055776:	83 c4 10             	add    $0x10,%esp
 8055779:	83 f8 4f             	cmp    $0x4f,%eax
 805577c:	7e 8a                	jle    8055708 <jb_i_l+0x48>
 805577e:	68 91 33 06 08       	push   $0x8063391
 8055783:	6a 0e                	push   $0xe
 8055785:	68 98 32 06 08       	push   $0x8063298
 805578a:	68 bc 32 06 08       	push   $0x80632bc
 805578f:	e8 1c 34 ff ff       	call   8048bb0 <__assert_fail@plt>
 8055794:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805579a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080557a0 <jb_i_w>:
}

make_instr_helper(i)
 80557a0:	53                   	push   %ebx
 80557a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80557a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80557a8:	83 c0 01             	add    $0x1,%eax
 80557ab:	50                   	push   %eax
 80557ac:	e8 ff 6f 00 00       	call   805c7b0 <decode_i_w>
#define instr jb

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF) {
 80557b1:	83 c4 10             	add    $0x10,%esp
 80557b4:	f6 05 e4 af 0f 10 01 	testb  $0x1,0x100fafe4
 80557bb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jb

static void do_execute() {
	int res = op_src->val;
 80557bd:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF) {
 80557c2:	74 0f                	je     80557d3 <jb_i_w+0x33>
		cpu.eip = cpu.eip + res;
 80557c4:	66 03 05 e0 af 0f 10 	add    0x100fafe0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 80557cb:	0f b7 c0             	movzwl %ax,%eax
 80557ce:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
#endif
	}
	print_asm_template1();
 80557d3:	68 18 af 0f 10       	push   $0x100faf18
 80557d8:	68 88 32 06 08       	push   $0x8063288
 80557dd:	6a 50                	push   $0x50
 80557df:	68 00 8a 0c 08       	push   $0x80c8a00
 80557e4:	e8 17 33 ff ff       	call   8048b00 <snprintf@plt>
 80557e9:	83 c4 10             	add    $0x10,%esp
 80557ec:	83 f8 4f             	cmp    $0x4f,%eax
 80557ef:	7f 0f                	jg     8055800 <jb_i_w+0x60>
}

make_instr_helper(i)
 80557f1:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80557f4:	8d 43 01             	lea    0x1(%ebx),%eax
 80557f7:	5b                   	pop    %ebx
 80557f8:	c3                   	ret    
 80557f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055800:	83 ec 0c             	sub    $0xc,%esp
 8055803:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8055809:	e8 52 31 ff ff       	call   8048960 <fflush@plt>
 805580e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055814:	6a 07                	push   $0x7
 8055816:	6a 01                	push   $0x1
 8055818:	68 92 e8 05 08       	push   $0x805e892
 805581d:	e8 ee 31 ff ff       	call   8048a10 <fwrite@plt>
 8055822:	83 c4 20             	add    $0x20,%esp
 8055825:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805582b:	6a 10                	push   $0x10
 805582d:	6a 01                	push   $0x1
 805582f:	68 b4 f3 05 08       	push   $0x805f3b4
 8055834:	e8 d7 31 ff ff       	call   8048a10 <fwrite@plt>
 8055839:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805583f:	6a 05                	push   $0x5
 8055841:	6a 01                	push   $0x1
 8055843:	68 42 f3 05 08       	push   $0x805f342
 8055848:	e8 c3 31 ff ff       	call   8048a10 <fwrite@plt>
 805584d:	83 c4 20             	add    $0x20,%esp
 8055850:	68 18 af 0f 10       	push   $0x100faf18
 8055855:	68 88 32 06 08       	push   $0x8063288
 805585a:	6a 50                	push   $0x50
 805585c:	68 00 8a 0c 08       	push   $0x80c8a00
 8055861:	e8 9a 32 ff ff       	call   8048b00 <snprintf@plt>
 8055866:	83 c4 10             	add    $0x10,%esp
 8055869:	83 f8 4f             	cmp    $0x4f,%eax
 805586c:	7e 83                	jle    80557f1 <jb_i_w+0x51>
 805586e:	68 99 33 06 08       	push   $0x8063399
 8055873:	6a 0e                	push   $0xe
 8055875:	68 98 32 06 08       	push   $0x8063298
 805587a:	68 04 33 06 08       	push   $0x8063304
 805587f:	e8 2c 33 ff ff       	call   8048bb0 <__assert_fail@plt>
 8055884:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805588a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08055890 <jb_i_b>:
}

make_instr_helper(i)
 8055890:	53                   	push   %ebx
 8055891:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055894:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055898:	83 c0 01             	add    $0x1,%eax
 805589b:	50                   	push   %eax
 805589c:	e8 9f 6b 00 00       	call   805c440 <decode_i_b>
#define instr jb

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF) {
 80558a1:	83 c4 10             	add    $0x10,%esp
 80558a4:	f6 05 e4 af 0f 10 01 	testb  $0x1,0x100fafe4
 80558ab:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jb

static void do_execute() {
	int res = op_src->val;
 80558ad:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.CF) {
 80558b2:	74 09                	je     80558bd <jb_i_b+0x2d>

#define instr jb

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 80558b4:	0f be c0             	movsbl %al,%eax
	if(cpu.CF) {
		cpu.eip = cpu.eip + res;
 80558b7:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80558bd:	68 18 af 0f 10       	push   $0x100faf18
 80558c2:	68 8f 32 06 08       	push   $0x806328f
 80558c7:	6a 50                	push   $0x50
 80558c9:	68 00 8a 0c 08       	push   $0x80c8a00
 80558ce:	e8 2d 32 ff ff       	call   8048b00 <snprintf@plt>
 80558d3:	83 c4 10             	add    $0x10,%esp
 80558d6:	83 f8 4f             	cmp    $0x4f,%eax
 80558d9:	7f 0d                	jg     80558e8 <jb_i_b+0x58>
}

make_instr_helper(i)
 80558db:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80558de:	8d 43 01             	lea    0x1(%ebx),%eax
 80558e1:	5b                   	pop    %ebx
 80558e2:	c3                   	ret    
 80558e3:	90                   	nop
 80558e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80558e8:	83 ec 0c             	sub    $0xc,%esp
 80558eb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80558f1:	e8 6a 30 ff ff       	call   8048960 <fflush@plt>
 80558f6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80558fc:	6a 07                	push   $0x7
 80558fe:	6a 01                	push   $0x1
 8055900:	68 92 e8 05 08       	push   $0x805e892
 8055905:	e8 06 31 ff ff       	call   8048a10 <fwrite@plt>
 805590a:	83 c4 20             	add    $0x20,%esp
 805590d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055913:	6a 10                	push   $0x10
 8055915:	6a 01                	push   $0x1
 8055917:	68 b4 f3 05 08       	push   $0x805f3b4
 805591c:	e8 ef 30 ff ff       	call   8048a10 <fwrite@plt>
 8055921:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055927:	6a 05                	push   $0x5
 8055929:	6a 01                	push   $0x1
 805592b:	68 42 f3 05 08       	push   $0x805f342
 8055930:	e8 db 30 ff ff       	call   8048a10 <fwrite@plt>
 8055935:	83 c4 20             	add    $0x20,%esp
 8055938:	68 18 af 0f 10       	push   $0x100faf18
 805593d:	68 8f 32 06 08       	push   $0x806328f
 8055942:	6a 50                	push   $0x50
 8055944:	68 00 8a 0c 08       	push   $0x80c8a00
 8055949:	e8 b2 31 ff ff       	call   8048b00 <snprintf@plt>
 805594e:	83 c4 10             	add    $0x10,%esp
 8055951:	83 f8 4f             	cmp    $0x4f,%eax
 8055954:	7e 85                	jle    80558db <jb_i_b+0x4b>
 8055956:	68 a1 33 06 08       	push   $0x80633a1
 805595b:	6a 0e                	push   $0xe
 805595d:	68 98 32 06 08       	push   $0x8063298
 8055962:	68 4c 33 06 08       	push   $0x806334c
 8055967:	e8 44 32 ff ff       	call   8048bb0 <__assert_fail@plt>
 805596c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08055970 <jb_i_v>:
#include "jb-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jb_i)
 8055970:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8055977:	8b 54 24 04          	mov    0x4(%esp),%edx
 805597b:	b8 a0 57 05 08       	mov    $0x80557a0,%eax
 8055980:	75 05                	jne    8055987 <jb_i_v+0x17>
 8055982:	b8 c0 56 05 08       	mov    $0x80556c0,%eax
 8055987:	89 54 24 04          	mov    %edx,0x4(%esp)
 805598b:	ff e0                	jmp    *%eax
 805598d:	66 90                	xchg   %ax,%ax
 805598f:	90                   	nop

08055990 <je_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8055990:	53                   	push   %ebx
 8055991:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055994:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055998:	83 c0 01             	add    $0x1,%eax
 805599b:	50                   	push   %eax
 805599c:	e8 9f 71 00 00       	call   805cb40 <decode_i_l>
#define instr je

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.ZF) {
 80559a1:	83 c4 10             	add    $0x10,%esp
 80559a4:	f6 05 e4 af 0f 10 40 	testb  $0x40,0x100fafe4
 80559ab:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr je

static void do_execute() {
	int res = op_src->val;
 80559ad:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.ZF) {
 80559b2:	74 06                	je     80559ba <je_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 80559b4:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80559ba:	68 18 af 0f 10       	push   $0x100faf18
 80559bf:	68 a9 33 06 08       	push   $0x80633a9
 80559c4:	6a 50                	push   $0x50
 80559c6:	68 00 8a 0c 08       	push   $0x80c8a00
 80559cb:	e8 30 31 ff ff       	call   8048b00 <snprintf@plt>
 80559d0:	83 c4 10             	add    $0x10,%esp
 80559d3:	83 f8 4f             	cmp    $0x4f,%eax
 80559d6:	7f 08                	jg     80559e0 <je_i_l+0x50>
}

make_instr_helper(i)
 80559d8:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80559db:	8d 43 01             	lea    0x1(%ebx),%eax
 80559de:	5b                   	pop    %ebx
 80559df:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80559e0:	83 ec 0c             	sub    $0xc,%esp
 80559e3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80559e9:	e8 72 2f ff ff       	call   8048960 <fflush@plt>
 80559ee:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80559f4:	6a 07                	push   $0x7
 80559f6:	6a 01                	push   $0x1
 80559f8:	68 92 e8 05 08       	push   $0x805e892
 80559fd:	e8 0e 30 ff ff       	call   8048a10 <fwrite@plt>
 8055a02:	83 c4 20             	add    $0x20,%esp
 8055a05:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055a0b:	6a 10                	push   $0x10
 8055a0d:	6a 01                	push   $0x1
 8055a0f:	68 b4 f3 05 08       	push   $0x805f3b4
 8055a14:	e8 f7 2f ff ff       	call   8048a10 <fwrite@plt>
 8055a19:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055a1f:	6a 05                	push   $0x5
 8055a21:	6a 01                	push   $0x1
 8055a23:	68 42 f3 05 08       	push   $0x805f342
 8055a28:	e8 e3 2f ff ff       	call   8048a10 <fwrite@plt>
 8055a2d:	83 c4 20             	add    $0x20,%esp
 8055a30:	68 18 af 0f 10       	push   $0x100faf18
 8055a35:	68 a9 33 06 08       	push   $0x80633a9
 8055a3a:	6a 50                	push   $0x50
 8055a3c:	68 00 8a 0c 08       	push   $0x80c8a00
 8055a41:	e8 ba 30 ff ff       	call   8048b00 <snprintf@plt>
 8055a46:	83 c4 10             	add    $0x10,%esp
 8055a49:	83 f8 4f             	cmp    $0x4f,%eax
 8055a4c:	7e 8a                	jle    80559d8 <je_i_l+0x48>
 8055a4e:	68 b9 34 06 08       	push   $0x80634b9
 8055a53:	6a 0e                	push   $0xe
 8055a55:	68 c0 33 06 08       	push   $0x80633c0
 8055a5a:	68 e4 33 06 08       	push   $0x80633e4
 8055a5f:	e8 4c 31 ff ff       	call   8048bb0 <__assert_fail@plt>
 8055a64:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8055a6a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08055a70 <je_i_w>:
}

make_instr_helper(i)
 8055a70:	53                   	push   %ebx
 8055a71:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055a74:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055a78:	83 c0 01             	add    $0x1,%eax
 8055a7b:	50                   	push   %eax
 8055a7c:	e8 2f 6d 00 00       	call   805c7b0 <decode_i_w>
#define instr je

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.ZF) {
 8055a81:	83 c4 10             	add    $0x10,%esp
 8055a84:	f6 05 e4 af 0f 10 40 	testb  $0x40,0x100fafe4
 8055a8b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr je

static void do_execute() {
	int res = op_src->val;
 8055a8d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.ZF) {
 8055a92:	74 0f                	je     8055aa3 <je_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8055a94:	66 03 05 e0 af 0f 10 	add    0x100fafe0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 8055a9b:	0f b7 c0             	movzwl %ax,%eax
 8055a9e:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
#endif
	}
	print_asm_template1();
 8055aa3:	68 18 af 0f 10       	push   $0x100faf18
 8055aa8:	68 b0 33 06 08       	push   $0x80633b0
 8055aad:	6a 50                	push   $0x50
 8055aaf:	68 00 8a 0c 08       	push   $0x80c8a00
 8055ab4:	e8 47 30 ff ff       	call   8048b00 <snprintf@plt>
 8055ab9:	83 c4 10             	add    $0x10,%esp
 8055abc:	83 f8 4f             	cmp    $0x4f,%eax
 8055abf:	7f 0f                	jg     8055ad0 <je_i_w+0x60>
}

make_instr_helper(i)
 8055ac1:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055ac4:	8d 43 01             	lea    0x1(%ebx),%eax
 8055ac7:	5b                   	pop    %ebx
 8055ac8:	c3                   	ret    
 8055ac9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055ad0:	83 ec 0c             	sub    $0xc,%esp
 8055ad3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8055ad9:	e8 82 2e ff ff       	call   8048960 <fflush@plt>
 8055ade:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055ae4:	6a 07                	push   $0x7
 8055ae6:	6a 01                	push   $0x1
 8055ae8:	68 92 e8 05 08       	push   $0x805e892
 8055aed:	e8 1e 2f ff ff       	call   8048a10 <fwrite@plt>
 8055af2:	83 c4 20             	add    $0x20,%esp
 8055af5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055afb:	6a 10                	push   $0x10
 8055afd:	6a 01                	push   $0x1
 8055aff:	68 b4 f3 05 08       	push   $0x805f3b4
 8055b04:	e8 07 2f ff ff       	call   8048a10 <fwrite@plt>
 8055b09:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055b0f:	6a 05                	push   $0x5
 8055b11:	6a 01                	push   $0x1
 8055b13:	68 42 f3 05 08       	push   $0x805f342
 8055b18:	e8 f3 2e ff ff       	call   8048a10 <fwrite@plt>
 8055b1d:	83 c4 20             	add    $0x20,%esp
 8055b20:	68 18 af 0f 10       	push   $0x100faf18
 8055b25:	68 b0 33 06 08       	push   $0x80633b0
 8055b2a:	6a 50                	push   $0x50
 8055b2c:	68 00 8a 0c 08       	push   $0x80c8a00
 8055b31:	e8 ca 2f ff ff       	call   8048b00 <snprintf@plt>
 8055b36:	83 c4 10             	add    $0x10,%esp
 8055b39:	83 f8 4f             	cmp    $0x4f,%eax
 8055b3c:	7e 83                	jle    8055ac1 <je_i_w+0x51>
 8055b3e:	68 c1 34 06 08       	push   $0x80634c1
 8055b43:	6a 0e                	push   $0xe
 8055b45:	68 c0 33 06 08       	push   $0x80633c0
 8055b4a:	68 2c 34 06 08       	push   $0x806342c
 8055b4f:	e8 5c 30 ff ff       	call   8048bb0 <__assert_fail@plt>
 8055b54:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8055b5a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08055b60 <je_i_b>:
}

make_instr_helper(i)
 8055b60:	53                   	push   %ebx
 8055b61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055b64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055b68:	83 c0 01             	add    $0x1,%eax
 8055b6b:	50                   	push   %eax
 8055b6c:	e8 cf 68 00 00       	call   805c440 <decode_i_b>
#define instr je

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.ZF) {
 8055b71:	83 c4 10             	add    $0x10,%esp
 8055b74:	f6 05 e4 af 0f 10 40 	testb  $0x40,0x100fafe4
 8055b7b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr je

static void do_execute() {
	int res = op_src->val;
 8055b7d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.ZF) {
 8055b82:	74 09                	je     8055b8d <je_i_b+0x2d>

#define instr je

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8055b84:	0f be c0             	movsbl %al,%eax
	if(cpu.ZF) {
		cpu.eip = cpu.eip + res;
 8055b87:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055b8d:	68 18 af 0f 10       	push   $0x100faf18
 8055b92:	68 b7 33 06 08       	push   $0x80633b7
 8055b97:	6a 50                	push   $0x50
 8055b99:	68 00 8a 0c 08       	push   $0x80c8a00
 8055b9e:	e8 5d 2f ff ff       	call   8048b00 <snprintf@plt>
 8055ba3:	83 c4 10             	add    $0x10,%esp
 8055ba6:	83 f8 4f             	cmp    $0x4f,%eax
 8055ba9:	7f 0d                	jg     8055bb8 <je_i_b+0x58>
}

make_instr_helper(i)
 8055bab:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055bae:	8d 43 01             	lea    0x1(%ebx),%eax
 8055bb1:	5b                   	pop    %ebx
 8055bb2:	c3                   	ret    
 8055bb3:	90                   	nop
 8055bb4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055bb8:	83 ec 0c             	sub    $0xc,%esp
 8055bbb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8055bc1:	e8 9a 2d ff ff       	call   8048960 <fflush@plt>
 8055bc6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055bcc:	6a 07                	push   $0x7
 8055bce:	6a 01                	push   $0x1
 8055bd0:	68 92 e8 05 08       	push   $0x805e892
 8055bd5:	e8 36 2e ff ff       	call   8048a10 <fwrite@plt>
 8055bda:	83 c4 20             	add    $0x20,%esp
 8055bdd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055be3:	6a 10                	push   $0x10
 8055be5:	6a 01                	push   $0x1
 8055be7:	68 b4 f3 05 08       	push   $0x805f3b4
 8055bec:	e8 1f 2e ff ff       	call   8048a10 <fwrite@plt>
 8055bf1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055bf7:	6a 05                	push   $0x5
 8055bf9:	6a 01                	push   $0x1
 8055bfb:	68 42 f3 05 08       	push   $0x805f342
 8055c00:	e8 0b 2e ff ff       	call   8048a10 <fwrite@plt>
 8055c05:	83 c4 20             	add    $0x20,%esp
 8055c08:	68 18 af 0f 10       	push   $0x100faf18
 8055c0d:	68 b7 33 06 08       	push   $0x80633b7
 8055c12:	6a 50                	push   $0x50
 8055c14:	68 00 8a 0c 08       	push   $0x80c8a00
 8055c19:	e8 e2 2e ff ff       	call   8048b00 <snprintf@plt>
 8055c1e:	83 c4 10             	add    $0x10,%esp
 8055c21:	83 f8 4f             	cmp    $0x4f,%eax
 8055c24:	7e 85                	jle    8055bab <je_i_b+0x4b>
 8055c26:	68 c9 34 06 08       	push   $0x80634c9
 8055c2b:	6a 0e                	push   $0xe
 8055c2d:	68 c0 33 06 08       	push   $0x80633c0
 8055c32:	68 74 34 06 08       	push   $0x8063474
 8055c37:	e8 74 2f ff ff       	call   8048bb0 <__assert_fail@plt>
 8055c3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08055c40 <je_i_v>:
#include "je-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(je_i)
 8055c40:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8055c47:	8b 54 24 04          	mov    0x4(%esp),%edx
 8055c4b:	b8 70 5a 05 08       	mov    $0x8055a70,%eax
 8055c50:	75 05                	jne    8055c57 <je_i_v+0x17>
 8055c52:	b8 90 59 05 08       	mov    $0x8055990,%eax
 8055c57:	89 54 24 04          	mov    %edx,0x4(%esp)
 8055c5b:	ff e0                	jmp    *%eax
 8055c5d:	66 90                	xchg   %ax,%ax
 8055c5f:	90                   	nop

08055c60 <jns_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8055c60:	53                   	push   %ebx
 8055c61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055c64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055c68:	83 c0 01             	add    $0x1,%eax
 8055c6b:	50                   	push   %eax
 8055c6c:	e8 cf 6e 00 00       	call   805cb40 <decode_i_l>
#define instr jns

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.SF) {
 8055c71:	83 c4 10             	add    $0x10,%esp
 8055c74:	80 3d e4 af 0f 10 00 	cmpb   $0x0,0x100fafe4
 8055c7b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jns

static void do_execute() {
	int res = op_src->val;
 8055c7d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.SF) {
 8055c82:	78 06                	js     8055c8a <jns_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8055c84:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055c8a:	68 18 af 0f 10       	push   $0x100faf18
 8055c8f:	68 d1 34 06 08       	push   $0x80634d1
 8055c94:	6a 50                	push   $0x50
 8055c96:	68 00 8a 0c 08       	push   $0x80c8a00
 8055c9b:	e8 60 2e ff ff       	call   8048b00 <snprintf@plt>
 8055ca0:	83 c4 10             	add    $0x10,%esp
 8055ca3:	83 f8 4f             	cmp    $0x4f,%eax
 8055ca6:	7f 08                	jg     8055cb0 <jns_i_l+0x50>
}

make_instr_helper(i)
 8055ca8:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055cab:	8d 43 01             	lea    0x1(%ebx),%eax
 8055cae:	5b                   	pop    %ebx
 8055caf:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055cb0:	83 ec 0c             	sub    $0xc,%esp
 8055cb3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8055cb9:	e8 a2 2c ff ff       	call   8048960 <fflush@plt>
 8055cbe:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055cc4:	6a 07                	push   $0x7
 8055cc6:	6a 01                	push   $0x1
 8055cc8:	68 92 e8 05 08       	push   $0x805e892
 8055ccd:	e8 3e 2d ff ff       	call   8048a10 <fwrite@plt>
 8055cd2:	83 c4 20             	add    $0x20,%esp
 8055cd5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055cdb:	6a 10                	push   $0x10
 8055cdd:	6a 01                	push   $0x1
 8055cdf:	68 b4 f3 05 08       	push   $0x805f3b4
 8055ce4:	e8 27 2d ff ff       	call   8048a10 <fwrite@plt>
 8055ce9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055cef:	6a 05                	push   $0x5
 8055cf1:	6a 01                	push   $0x1
 8055cf3:	68 42 f3 05 08       	push   $0x805f342
 8055cf8:	e8 13 2d ff ff       	call   8048a10 <fwrite@plt>
 8055cfd:	83 c4 20             	add    $0x20,%esp
 8055d00:	68 18 af 0f 10       	push   $0x100faf18
 8055d05:	68 d1 34 06 08       	push   $0x80634d1
 8055d0a:	6a 50                	push   $0x50
 8055d0c:	68 00 8a 0c 08       	push   $0x80c8a00
 8055d11:	e8 ea 2d ff ff       	call   8048b00 <snprintf@plt>
 8055d16:	83 c4 10             	add    $0x10,%esp
 8055d19:	83 f8 4f             	cmp    $0x4f,%eax
 8055d1c:	7e 8a                	jle    8055ca8 <jns_i_l+0x48>
 8055d1e:	68 ea 35 06 08       	push   $0x80635ea
 8055d23:	6a 0e                	push   $0xe
 8055d25:	68 ec 34 06 08       	push   $0x80634ec
 8055d2a:	68 14 35 06 08       	push   $0x8063514
 8055d2f:	e8 7c 2e ff ff       	call   8048bb0 <__assert_fail@plt>
 8055d34:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8055d3a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08055d40 <jns_i_w>:
}

make_instr_helper(i)
 8055d40:	53                   	push   %ebx
 8055d41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055d44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055d48:	83 c0 01             	add    $0x1,%eax
 8055d4b:	50                   	push   %eax
 8055d4c:	e8 5f 6a 00 00       	call   805c7b0 <decode_i_w>
#define instr jns

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.SF) {
 8055d51:	83 c4 10             	add    $0x10,%esp
 8055d54:	80 3d e4 af 0f 10 00 	cmpb   $0x0,0x100fafe4
 8055d5b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jns

static void do_execute() {
	int res = op_src->val;
 8055d5d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.SF) {
 8055d62:	78 0f                	js     8055d73 <jns_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8055d64:	66 03 05 e0 af 0f 10 	add    0x100fafe0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 8055d6b:	0f b7 c0             	movzwl %ax,%eax
 8055d6e:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
#endif
	}
	print_asm_template1();
 8055d73:	68 18 af 0f 10       	push   $0x100faf18
 8055d78:	68 d9 34 06 08       	push   $0x80634d9
 8055d7d:	6a 50                	push   $0x50
 8055d7f:	68 00 8a 0c 08       	push   $0x80c8a00
 8055d84:	e8 77 2d ff ff       	call   8048b00 <snprintf@plt>
 8055d89:	83 c4 10             	add    $0x10,%esp
 8055d8c:	83 f8 4f             	cmp    $0x4f,%eax
 8055d8f:	7f 0f                	jg     8055da0 <jns_i_w+0x60>
}

make_instr_helper(i)
 8055d91:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055d94:	8d 43 01             	lea    0x1(%ebx),%eax
 8055d97:	5b                   	pop    %ebx
 8055d98:	c3                   	ret    
 8055d99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055da0:	83 ec 0c             	sub    $0xc,%esp
 8055da3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8055da9:	e8 b2 2b ff ff       	call   8048960 <fflush@plt>
 8055dae:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055db4:	6a 07                	push   $0x7
 8055db6:	6a 01                	push   $0x1
 8055db8:	68 92 e8 05 08       	push   $0x805e892
 8055dbd:	e8 4e 2c ff ff       	call   8048a10 <fwrite@plt>
 8055dc2:	83 c4 20             	add    $0x20,%esp
 8055dc5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055dcb:	6a 10                	push   $0x10
 8055dcd:	6a 01                	push   $0x1
 8055dcf:	68 b4 f3 05 08       	push   $0x805f3b4
 8055dd4:	e8 37 2c ff ff       	call   8048a10 <fwrite@plt>
 8055dd9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055ddf:	6a 05                	push   $0x5
 8055de1:	6a 01                	push   $0x1
 8055de3:	68 42 f3 05 08       	push   $0x805f342
 8055de8:	e8 23 2c ff ff       	call   8048a10 <fwrite@plt>
 8055ded:	83 c4 20             	add    $0x20,%esp
 8055df0:	68 18 af 0f 10       	push   $0x100faf18
 8055df5:	68 d9 34 06 08       	push   $0x80634d9
 8055dfa:	6a 50                	push   $0x50
 8055dfc:	68 00 8a 0c 08       	push   $0x80c8a00
 8055e01:	e8 fa 2c ff ff       	call   8048b00 <snprintf@plt>
 8055e06:	83 c4 10             	add    $0x10,%esp
 8055e09:	83 f8 4f             	cmp    $0x4f,%eax
 8055e0c:	7e 83                	jle    8055d91 <jns_i_w+0x51>
 8055e0e:	68 f3 35 06 08       	push   $0x80635f3
 8055e13:	6a 0e                	push   $0xe
 8055e15:	68 ec 34 06 08       	push   $0x80634ec
 8055e1a:	68 5c 35 06 08       	push   $0x806355c
 8055e1f:	e8 8c 2d ff ff       	call   8048bb0 <__assert_fail@plt>
 8055e24:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8055e2a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08055e30 <jns_i_b>:
}

make_instr_helper(i)
 8055e30:	53                   	push   %ebx
 8055e31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055e34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055e38:	83 c0 01             	add    $0x1,%eax
 8055e3b:	50                   	push   %eax
 8055e3c:	e8 ff 65 00 00       	call   805c440 <decode_i_b>
#define instr jns

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.SF) {
 8055e41:	83 c4 10             	add    $0x10,%esp
 8055e44:	80 3d e4 af 0f 10 00 	cmpb   $0x0,0x100fafe4
 8055e4b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jns

static void do_execute() {
	int res = op_src->val;
 8055e4d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.SF) {
 8055e52:	78 09                	js     8055e5d <jns_i_b+0x2d>

#define instr jns

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8055e54:	0f be c0             	movsbl %al,%eax
	if(!cpu.SF) {
		cpu.eip = cpu.eip + res;
 8055e57:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055e5d:	68 18 af 0f 10       	push   $0x100faf18
 8055e62:	68 e1 34 06 08       	push   $0x80634e1
 8055e67:	6a 50                	push   $0x50
 8055e69:	68 00 8a 0c 08       	push   $0x80c8a00
 8055e6e:	e8 8d 2c ff ff       	call   8048b00 <snprintf@plt>
 8055e73:	83 c4 10             	add    $0x10,%esp
 8055e76:	83 f8 4f             	cmp    $0x4f,%eax
 8055e79:	7f 0d                	jg     8055e88 <jns_i_b+0x58>
}

make_instr_helper(i)
 8055e7b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055e7e:	8d 43 01             	lea    0x1(%ebx),%eax
 8055e81:	5b                   	pop    %ebx
 8055e82:	c3                   	ret    
 8055e83:	90                   	nop
 8055e84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055e88:	83 ec 0c             	sub    $0xc,%esp
 8055e8b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8055e91:	e8 ca 2a ff ff       	call   8048960 <fflush@plt>
 8055e96:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055e9c:	6a 07                	push   $0x7
 8055e9e:	6a 01                	push   $0x1
 8055ea0:	68 92 e8 05 08       	push   $0x805e892
 8055ea5:	e8 66 2b ff ff       	call   8048a10 <fwrite@plt>
 8055eaa:	83 c4 20             	add    $0x20,%esp
 8055ead:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055eb3:	6a 10                	push   $0x10
 8055eb5:	6a 01                	push   $0x1
 8055eb7:	68 b4 f3 05 08       	push   $0x805f3b4
 8055ebc:	e8 4f 2b ff ff       	call   8048a10 <fwrite@plt>
 8055ec1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055ec7:	6a 05                	push   $0x5
 8055ec9:	6a 01                	push   $0x1
 8055ecb:	68 42 f3 05 08       	push   $0x805f342
 8055ed0:	e8 3b 2b ff ff       	call   8048a10 <fwrite@plt>
 8055ed5:	83 c4 20             	add    $0x20,%esp
 8055ed8:	68 18 af 0f 10       	push   $0x100faf18
 8055edd:	68 e1 34 06 08       	push   $0x80634e1
 8055ee2:	6a 50                	push   $0x50
 8055ee4:	68 00 8a 0c 08       	push   $0x80c8a00
 8055ee9:	e8 12 2c ff ff       	call   8048b00 <snprintf@plt>
 8055eee:	83 c4 10             	add    $0x10,%esp
 8055ef1:	83 f8 4f             	cmp    $0x4f,%eax
 8055ef4:	7e 85                	jle    8055e7b <jns_i_b+0x4b>
 8055ef6:	68 fc 35 06 08       	push   $0x80635fc
 8055efb:	6a 0e                	push   $0xe
 8055efd:	68 ec 34 06 08       	push   $0x80634ec
 8055f02:	68 a4 35 06 08       	push   $0x80635a4
 8055f07:	e8 a4 2c ff ff       	call   8048bb0 <__assert_fail@plt>
 8055f0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08055f10 <jns_i_v>:
#include "jns-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jns_i)
 8055f10:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8055f17:	8b 54 24 04          	mov    0x4(%esp),%edx
 8055f1b:	b8 40 5d 05 08       	mov    $0x8055d40,%eax
 8055f20:	75 05                	jne    8055f27 <jns_i_v+0x17>
 8055f22:	b8 60 5c 05 08       	mov    $0x8055c60,%eax
 8055f27:	89 54 24 04          	mov    %edx,0x4(%esp)
 8055f2b:	ff e0                	jmp    *%eax
 8055f2d:	66 90                	xchg   %ax,%ax
 8055f2f:	90                   	nop

08055f30 <jnp_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8055f30:	53                   	push   %ebx
 8055f31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8055f34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8055f38:	83 c0 01             	add    $0x1,%eax
 8055f3b:	50                   	push   %eax
 8055f3c:	e8 ff 6b 00 00       	call   805cb40 <decode_i_l>
#define instr jnp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.PF) {
 8055f41:	83 c4 10             	add    $0x10,%esp
 8055f44:	f6 05 e4 af 0f 10 04 	testb  $0x4,0x100fafe4
 8055f4b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jnp

static void do_execute() {
	int res = op_src->val;
 8055f4d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.PF) {
 8055f52:	75 06                	jne    8055f5a <jnp_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8055f54:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055f5a:	68 18 af 0f 10       	push   $0x100faf18
 8055f5f:	68 05 36 06 08       	push   $0x8063605
 8055f64:	6a 50                	push   $0x50
 8055f66:	68 00 8a 0c 08       	push   $0x80c8a00
 8055f6b:	e8 90 2b ff ff       	call   8048b00 <snprintf@plt>
 8055f70:	83 c4 10             	add    $0x10,%esp
 8055f73:	83 f8 4f             	cmp    $0x4f,%eax
 8055f76:	7f 08                	jg     8055f80 <jnp_i_l+0x50>
}

make_instr_helper(i)
 8055f78:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8055f7b:	8d 43 01             	lea    0x1(%ebx),%eax
 8055f7e:	5b                   	pop    %ebx
 8055f7f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8055f80:	83 ec 0c             	sub    $0xc,%esp
 8055f83:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8055f89:	e8 d2 29 ff ff       	call   8048960 <fflush@plt>
 8055f8e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055f94:	6a 07                	push   $0x7
 8055f96:	6a 01                	push   $0x1
 8055f98:	68 92 e8 05 08       	push   $0x805e892
 8055f9d:	e8 6e 2a ff ff       	call   8048a10 <fwrite@plt>
 8055fa2:	83 c4 20             	add    $0x20,%esp
 8055fa5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055fab:	6a 10                	push   $0x10
 8055fad:	6a 01                	push   $0x1
 8055faf:	68 b4 f3 05 08       	push   $0x805f3b4
 8055fb4:	e8 57 2a ff ff       	call   8048a10 <fwrite@plt>
 8055fb9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8055fbf:	6a 05                	push   $0x5
 8055fc1:	6a 01                	push   $0x1
 8055fc3:	68 42 f3 05 08       	push   $0x805f342
 8055fc8:	e8 43 2a ff ff       	call   8048a10 <fwrite@plt>
 8055fcd:	83 c4 20             	add    $0x20,%esp
 8055fd0:	68 18 af 0f 10       	push   $0x100faf18
 8055fd5:	68 05 36 06 08       	push   $0x8063605
 8055fda:	6a 50                	push   $0x50
 8055fdc:	68 00 8a 0c 08       	push   $0x80c8a00
 8055fe1:	e8 1a 2b ff ff       	call   8048b00 <snprintf@plt>
 8055fe6:	83 c4 10             	add    $0x10,%esp
 8055fe9:	83 f8 4f             	cmp    $0x4f,%eax
 8055fec:	7e 8a                	jle    8055f78 <jnp_i_l+0x48>
 8055fee:	68 1e 37 06 08       	push   $0x806371e
 8055ff3:	6a 0e                	push   $0xe
 8055ff5:	68 20 36 06 08       	push   $0x8063620
 8055ffa:	68 48 36 06 08       	push   $0x8063648
 8055fff:	e8 ac 2b ff ff       	call   8048bb0 <__assert_fail@plt>
 8056004:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805600a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08056010 <jnp_i_w>:
}

make_instr_helper(i)
 8056010:	53                   	push   %ebx
 8056011:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056014:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056018:	83 c0 01             	add    $0x1,%eax
 805601b:	50                   	push   %eax
 805601c:	e8 8f 67 00 00       	call   805c7b0 <decode_i_w>
#define instr jnp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.PF) {
 8056021:	83 c4 10             	add    $0x10,%esp
 8056024:	f6 05 e4 af 0f 10 04 	testb  $0x4,0x100fafe4
 805602b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jnp

static void do_execute() {
	int res = op_src->val;
 805602d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.PF) {
 8056032:	75 0f                	jne    8056043 <jnp_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8056034:	66 03 05 e0 af 0f 10 	add    0x100fafe0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 805603b:	0f b7 c0             	movzwl %ax,%eax
 805603e:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
#endif
	}
	print_asm_template1();
 8056043:	68 18 af 0f 10       	push   $0x100faf18
 8056048:	68 0d 36 06 08       	push   $0x806360d
 805604d:	6a 50                	push   $0x50
 805604f:	68 00 8a 0c 08       	push   $0x80c8a00
 8056054:	e8 a7 2a ff ff       	call   8048b00 <snprintf@plt>
 8056059:	83 c4 10             	add    $0x10,%esp
 805605c:	83 f8 4f             	cmp    $0x4f,%eax
 805605f:	7f 0f                	jg     8056070 <jnp_i_w+0x60>
}

make_instr_helper(i)
 8056061:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056064:	8d 43 01             	lea    0x1(%ebx),%eax
 8056067:	5b                   	pop    %ebx
 8056068:	c3                   	ret    
 8056069:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056070:	83 ec 0c             	sub    $0xc,%esp
 8056073:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056079:	e8 e2 28 ff ff       	call   8048960 <fflush@plt>
 805607e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056084:	6a 07                	push   $0x7
 8056086:	6a 01                	push   $0x1
 8056088:	68 92 e8 05 08       	push   $0x805e892
 805608d:	e8 7e 29 ff ff       	call   8048a10 <fwrite@plt>
 8056092:	83 c4 20             	add    $0x20,%esp
 8056095:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805609b:	6a 10                	push   $0x10
 805609d:	6a 01                	push   $0x1
 805609f:	68 b4 f3 05 08       	push   $0x805f3b4
 80560a4:	e8 67 29 ff ff       	call   8048a10 <fwrite@plt>
 80560a9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80560af:	6a 05                	push   $0x5
 80560b1:	6a 01                	push   $0x1
 80560b3:	68 42 f3 05 08       	push   $0x805f342
 80560b8:	e8 53 29 ff ff       	call   8048a10 <fwrite@plt>
 80560bd:	83 c4 20             	add    $0x20,%esp
 80560c0:	68 18 af 0f 10       	push   $0x100faf18
 80560c5:	68 0d 36 06 08       	push   $0x806360d
 80560ca:	6a 50                	push   $0x50
 80560cc:	68 00 8a 0c 08       	push   $0x80c8a00
 80560d1:	e8 2a 2a ff ff       	call   8048b00 <snprintf@plt>
 80560d6:	83 c4 10             	add    $0x10,%esp
 80560d9:	83 f8 4f             	cmp    $0x4f,%eax
 80560dc:	7e 83                	jle    8056061 <jnp_i_w+0x51>
 80560de:	68 27 37 06 08       	push   $0x8063727
 80560e3:	6a 0e                	push   $0xe
 80560e5:	68 20 36 06 08       	push   $0x8063620
 80560ea:	68 90 36 06 08       	push   $0x8063690
 80560ef:	e8 bc 2a ff ff       	call   8048bb0 <__assert_fail@plt>
 80560f4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80560fa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08056100 <jnp_i_b>:
}

make_instr_helper(i)
 8056100:	53                   	push   %ebx
 8056101:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056104:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056108:	83 c0 01             	add    $0x1,%eax
 805610b:	50                   	push   %eax
 805610c:	e8 2f 63 00 00       	call   805c440 <decode_i_b>
#define instr jnp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.PF) {
 8056111:	83 c4 10             	add    $0x10,%esp
 8056114:	f6 05 e4 af 0f 10 04 	testb  $0x4,0x100fafe4
 805611b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jnp

static void do_execute() {
	int res = op_src->val;
 805611d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.PF) {
 8056122:	75 09                	jne    805612d <jnp_i_b+0x2d>

#define instr jnp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8056124:	0f be c0             	movsbl %al,%eax
	if(!cpu.PF) {
		cpu.eip = cpu.eip + res;
 8056127:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805612d:	68 18 af 0f 10       	push   $0x100faf18
 8056132:	68 15 36 06 08       	push   $0x8063615
 8056137:	6a 50                	push   $0x50
 8056139:	68 00 8a 0c 08       	push   $0x80c8a00
 805613e:	e8 bd 29 ff ff       	call   8048b00 <snprintf@plt>
 8056143:	83 c4 10             	add    $0x10,%esp
 8056146:	83 f8 4f             	cmp    $0x4f,%eax
 8056149:	7f 0d                	jg     8056158 <jnp_i_b+0x58>
}

make_instr_helper(i)
 805614b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805614e:	8d 43 01             	lea    0x1(%ebx),%eax
 8056151:	5b                   	pop    %ebx
 8056152:	c3                   	ret    
 8056153:	90                   	nop
 8056154:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056158:	83 ec 0c             	sub    $0xc,%esp
 805615b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056161:	e8 fa 27 ff ff       	call   8048960 <fflush@plt>
 8056166:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805616c:	6a 07                	push   $0x7
 805616e:	6a 01                	push   $0x1
 8056170:	68 92 e8 05 08       	push   $0x805e892
 8056175:	e8 96 28 ff ff       	call   8048a10 <fwrite@plt>
 805617a:	83 c4 20             	add    $0x20,%esp
 805617d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056183:	6a 10                	push   $0x10
 8056185:	6a 01                	push   $0x1
 8056187:	68 b4 f3 05 08       	push   $0x805f3b4
 805618c:	e8 7f 28 ff ff       	call   8048a10 <fwrite@plt>
 8056191:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056197:	6a 05                	push   $0x5
 8056199:	6a 01                	push   $0x1
 805619b:	68 42 f3 05 08       	push   $0x805f342
 80561a0:	e8 6b 28 ff ff       	call   8048a10 <fwrite@plt>
 80561a5:	83 c4 20             	add    $0x20,%esp
 80561a8:	68 18 af 0f 10       	push   $0x100faf18
 80561ad:	68 15 36 06 08       	push   $0x8063615
 80561b2:	6a 50                	push   $0x50
 80561b4:	68 00 8a 0c 08       	push   $0x80c8a00
 80561b9:	e8 42 29 ff ff       	call   8048b00 <snprintf@plt>
 80561be:	83 c4 10             	add    $0x10,%esp
 80561c1:	83 f8 4f             	cmp    $0x4f,%eax
 80561c4:	7e 85                	jle    805614b <jnp_i_b+0x4b>
 80561c6:	68 30 37 06 08       	push   $0x8063730
 80561cb:	6a 0e                	push   $0xe
 80561cd:	68 20 36 06 08       	push   $0x8063620
 80561d2:	68 d8 36 06 08       	push   $0x80636d8
 80561d7:	e8 d4 29 ff ff       	call   8048bb0 <__assert_fail@plt>
 80561dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080561e0 <jnp_i_v>:
#include "jnp-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jnp_i)
 80561e0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80561e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80561eb:	b8 10 60 05 08       	mov    $0x8056010,%eax
 80561f0:	75 05                	jne    80561f7 <jnp_i_v+0x17>
 80561f2:	b8 30 5f 05 08       	mov    $0x8055f30,%eax
 80561f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80561fb:	ff e0                	jmp    *%eax
 80561fd:	66 90                	xchg   %ax,%ax
 80561ff:	90                   	nop

08056200 <jl_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8056200:	53                   	push   %ebx
 8056201:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056204:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056208:	83 c0 01             	add    $0x1,%eax
 805620b:	50                   	push   %eax
 805620c:	e8 2f 69 00 00       	call   805cb40 <decode_i_l>
#define instr jl

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF) {
 8056211:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8056218:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 805621f:	83 c4 10             	add    $0x10,%esp
 8056222:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jl

static void do_execute() {
	int res = op_src->val;
 8056224:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF) {
 8056229:	c0 ea 03             	shr    $0x3,%dl
 805622c:	c0 e9 07             	shr    $0x7,%cl
 805622f:	83 e2 01             	and    $0x1,%edx
 8056232:	38 ca                	cmp    %cl,%dl
 8056234:	74 06                	je     805623c <jl_i_l+0x3c>
		cpu.eip = cpu.eip + res;
 8056236:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805623c:	68 18 af 0f 10       	push   $0x100faf18
 8056241:	68 39 37 06 08       	push   $0x8063739
 8056246:	6a 50                	push   $0x50
 8056248:	68 00 8a 0c 08       	push   $0x80c8a00
 805624d:	e8 ae 28 ff ff       	call   8048b00 <snprintf@plt>
 8056252:	83 c4 10             	add    $0x10,%esp
 8056255:	83 f8 4f             	cmp    $0x4f,%eax
 8056258:	7f 0e                	jg     8056268 <jl_i_l+0x68>
}

make_instr_helper(i)
 805625a:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805625d:	8d 43 01             	lea    0x1(%ebx),%eax
 8056260:	5b                   	pop    %ebx
 8056261:	c3                   	ret    
 8056262:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056268:	83 ec 0c             	sub    $0xc,%esp
 805626b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056271:	e8 ea 26 ff ff       	call   8048960 <fflush@plt>
 8056276:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805627c:	6a 07                	push   $0x7
 805627e:	6a 01                	push   $0x1
 8056280:	68 92 e8 05 08       	push   $0x805e892
 8056285:	e8 86 27 ff ff       	call   8048a10 <fwrite@plt>
 805628a:	83 c4 20             	add    $0x20,%esp
 805628d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056293:	6a 10                	push   $0x10
 8056295:	6a 01                	push   $0x1
 8056297:	68 b4 f3 05 08       	push   $0x805f3b4
 805629c:	e8 6f 27 ff ff       	call   8048a10 <fwrite@plt>
 80562a1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80562a7:	6a 05                	push   $0x5
 80562a9:	6a 01                	push   $0x1
 80562ab:	68 42 f3 05 08       	push   $0x805f342
 80562b0:	e8 5b 27 ff ff       	call   8048a10 <fwrite@plt>
 80562b5:	83 c4 20             	add    $0x20,%esp
 80562b8:	68 18 af 0f 10       	push   $0x100faf18
 80562bd:	68 39 37 06 08       	push   $0x8063739
 80562c2:	6a 50                	push   $0x50
 80562c4:	68 00 8a 0c 08       	push   $0x80c8a00
 80562c9:	e8 32 28 ff ff       	call   8048b00 <snprintf@plt>
 80562ce:	83 c4 10             	add    $0x10,%esp
 80562d1:	83 f8 4f             	cmp    $0x4f,%eax
 80562d4:	7e 84                	jle    805625a <jl_i_l+0x5a>
 80562d6:	68 49 38 06 08       	push   $0x8063849
 80562db:	6a 0e                	push   $0xe
 80562dd:	68 50 37 06 08       	push   $0x8063750
 80562e2:	68 74 37 06 08       	push   $0x8063774
 80562e7:	e8 c4 28 ff ff       	call   8048bb0 <__assert_fail@plt>
 80562ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080562f0 <jl_i_w>:
}

make_instr_helper(i)
 80562f0:	53                   	push   %ebx
 80562f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80562f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80562f8:	83 c0 01             	add    $0x1,%eax
 80562fb:	50                   	push   %eax
 80562fc:	e8 af 64 00 00       	call   805c7b0 <decode_i_w>
#define instr jl

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF) {
 8056301:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8056308:	89 c3                	mov    %eax,%ebx
 805630a:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 8056311:	83 c4 10             	add    $0x10,%esp
#include "cpu/exec/template-start.h"

#define instr jl

static void do_execute() {
	int res = op_src->val;
 8056314:	8b 0d 14 af 0f 10    	mov    0x100faf14,%ecx
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF) {
 805631a:	c0 ea 03             	shr    $0x3,%dl
 805631d:	c0 e8 07             	shr    $0x7,%al
 8056320:	83 e2 01             	and    $0x1,%edx
 8056323:	38 c2                	cmp    %al,%dl
 8056325:	74 10                	je     8056337 <jl_i_w+0x47>
		cpu.eip = cpu.eip + res;
 8056327:	66 03 0d e0 af 0f 10 	add    0x100fafe0,%cx
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 805632e:	0f b7 c9             	movzwl %cx,%ecx
 8056331:	89 0d e0 af 0f 10    	mov    %ecx,0x100fafe0
#endif
	}
	print_asm_template1();
 8056337:	68 18 af 0f 10       	push   $0x100faf18
 805633c:	68 40 37 06 08       	push   $0x8063740
 8056341:	6a 50                	push   $0x50
 8056343:	68 00 8a 0c 08       	push   $0x80c8a00
 8056348:	e8 b3 27 ff ff       	call   8048b00 <snprintf@plt>
 805634d:	83 c4 10             	add    $0x10,%esp
 8056350:	83 f8 4f             	cmp    $0x4f,%eax
 8056353:	7f 0b                	jg     8056360 <jl_i_w+0x70>
}

make_instr_helper(i)
 8056355:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056358:	8d 43 01             	lea    0x1(%ebx),%eax
 805635b:	5b                   	pop    %ebx
 805635c:	c3                   	ret    
 805635d:	8d 76 00             	lea    0x0(%esi),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056360:	83 ec 0c             	sub    $0xc,%esp
 8056363:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056369:	e8 f2 25 ff ff       	call   8048960 <fflush@plt>
 805636e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056374:	6a 07                	push   $0x7
 8056376:	6a 01                	push   $0x1
 8056378:	68 92 e8 05 08       	push   $0x805e892
 805637d:	e8 8e 26 ff ff       	call   8048a10 <fwrite@plt>
 8056382:	83 c4 20             	add    $0x20,%esp
 8056385:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805638b:	6a 10                	push   $0x10
 805638d:	6a 01                	push   $0x1
 805638f:	68 b4 f3 05 08       	push   $0x805f3b4
 8056394:	e8 77 26 ff ff       	call   8048a10 <fwrite@plt>
 8056399:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805639f:	6a 05                	push   $0x5
 80563a1:	6a 01                	push   $0x1
 80563a3:	68 42 f3 05 08       	push   $0x805f342
 80563a8:	e8 63 26 ff ff       	call   8048a10 <fwrite@plt>
 80563ad:	83 c4 20             	add    $0x20,%esp
 80563b0:	68 18 af 0f 10       	push   $0x100faf18
 80563b5:	68 40 37 06 08       	push   $0x8063740
 80563ba:	6a 50                	push   $0x50
 80563bc:	68 00 8a 0c 08       	push   $0x80c8a00
 80563c1:	e8 3a 27 ff ff       	call   8048b00 <snprintf@plt>
 80563c6:	83 c4 10             	add    $0x10,%esp
 80563c9:	83 f8 4f             	cmp    $0x4f,%eax
 80563cc:	7e 87                	jle    8056355 <jl_i_w+0x65>
 80563ce:	68 51 38 06 08       	push   $0x8063851
 80563d3:	6a 0e                	push   $0xe
 80563d5:	68 50 37 06 08       	push   $0x8063750
 80563da:	68 bc 37 06 08       	push   $0x80637bc
 80563df:	e8 cc 27 ff ff       	call   8048bb0 <__assert_fail@plt>
 80563e4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80563ea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080563f0 <jl_i_b>:
}

make_instr_helper(i)
 80563f0:	53                   	push   %ebx
 80563f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80563f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80563f8:	83 c0 01             	add    $0x1,%eax
 80563fb:	50                   	push   %eax
 80563fc:	e8 3f 60 00 00       	call   805c440 <decode_i_b>
#define instr jl

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF) {
 8056401:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8056408:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 805640f:	83 c4 10             	add    $0x10,%esp
 8056412:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jl

static void do_execute() {
	int res = op_src->val;
 8056414:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF) {
 8056419:	c0 ea 03             	shr    $0x3,%dl
 805641c:	c0 e9 07             	shr    $0x7,%cl
 805641f:	83 e2 01             	and    $0x1,%edx
 8056422:	38 ca                	cmp    %cl,%dl
 8056424:	74 09                	je     805642f <jl_i_b+0x3f>

#define instr jl

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8056426:	0f be c0             	movsbl %al,%eax
	if(cpu.OF != cpu.SF) {
		cpu.eip = cpu.eip + res;
 8056429:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805642f:	68 18 af 0f 10       	push   $0x100faf18
 8056434:	68 47 37 06 08       	push   $0x8063747
 8056439:	6a 50                	push   $0x50
 805643b:	68 00 8a 0c 08       	push   $0x80c8a00
 8056440:	e8 bb 26 ff ff       	call   8048b00 <snprintf@plt>
 8056445:	83 c4 10             	add    $0x10,%esp
 8056448:	83 f8 4f             	cmp    $0x4f,%eax
 805644b:	7f 0b                	jg     8056458 <jl_i_b+0x68>
}

make_instr_helper(i)
 805644d:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056450:	8d 43 01             	lea    0x1(%ebx),%eax
 8056453:	5b                   	pop    %ebx
 8056454:	c3                   	ret    
 8056455:	8d 76 00             	lea    0x0(%esi),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056458:	83 ec 0c             	sub    $0xc,%esp
 805645b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056461:	e8 fa 24 ff ff       	call   8048960 <fflush@plt>
 8056466:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805646c:	6a 07                	push   $0x7
 805646e:	6a 01                	push   $0x1
 8056470:	68 92 e8 05 08       	push   $0x805e892
 8056475:	e8 96 25 ff ff       	call   8048a10 <fwrite@plt>
 805647a:	83 c4 20             	add    $0x20,%esp
 805647d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056483:	6a 10                	push   $0x10
 8056485:	6a 01                	push   $0x1
 8056487:	68 b4 f3 05 08       	push   $0x805f3b4
 805648c:	e8 7f 25 ff ff       	call   8048a10 <fwrite@plt>
 8056491:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056497:	6a 05                	push   $0x5
 8056499:	6a 01                	push   $0x1
 805649b:	68 42 f3 05 08       	push   $0x805f342
 80564a0:	e8 6b 25 ff ff       	call   8048a10 <fwrite@plt>
 80564a5:	83 c4 20             	add    $0x20,%esp
 80564a8:	68 18 af 0f 10       	push   $0x100faf18
 80564ad:	68 47 37 06 08       	push   $0x8063747
 80564b2:	6a 50                	push   $0x50
 80564b4:	68 00 8a 0c 08       	push   $0x80c8a00
 80564b9:	e8 42 26 ff ff       	call   8048b00 <snprintf@plt>
 80564be:	83 c4 10             	add    $0x10,%esp
 80564c1:	83 f8 4f             	cmp    $0x4f,%eax
 80564c4:	7e 87                	jle    805644d <jl_i_b+0x5d>
 80564c6:	68 59 38 06 08       	push   $0x8063859
 80564cb:	6a 0e                	push   $0xe
 80564cd:	68 50 37 06 08       	push   $0x8063750
 80564d2:	68 04 38 06 08       	push   $0x8063804
 80564d7:	e8 d4 26 ff ff       	call   8048bb0 <__assert_fail@plt>
 80564dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080564e0 <jl_i_v>:
#include "jl-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jl_i)
 80564e0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80564e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80564eb:	b8 f0 62 05 08       	mov    $0x80562f0,%eax
 80564f0:	75 05                	jne    80564f7 <jl_i_v+0x17>
 80564f2:	b8 00 62 05 08       	mov    $0x8056200,%eax
 80564f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80564fb:	ff e0                	jmp    *%eax
 80564fd:	66 90                	xchg   %ax,%ax
 80564ff:	90                   	nop

08056500 <ja_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8056500:	53                   	push   %ebx
 8056501:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056504:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056508:	83 c0 01             	add    $0x1,%eax
 805650b:	50                   	push   %eax
 805650c:	e8 2f 66 00 00       	call   805cb40 <decode_i_l>
#define instr ja

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF && !cpu.ZF) {
 8056511:	83 c4 10             	add    $0x10,%esp
 8056514:	f6 05 e4 af 0f 10 41 	testb  $0x41,0x100fafe4
 805651b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr ja

static void do_execute() {
	int res = op_src->val;
 805651d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF && !cpu.ZF) {
 8056522:	75 06                	jne    805652a <ja_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8056524:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 805652a:	68 18 af 0f 10       	push   $0x100faf18
 805652f:	68 61 38 06 08       	push   $0x8063861
 8056534:	6a 50                	push   $0x50
 8056536:	68 00 8a 0c 08       	push   $0x80c8a00
 805653b:	e8 c0 25 ff ff       	call   8048b00 <snprintf@plt>
 8056540:	83 c4 10             	add    $0x10,%esp
 8056543:	83 f8 4f             	cmp    $0x4f,%eax
 8056546:	7f 08                	jg     8056550 <ja_i_l+0x50>
}

make_instr_helper(i)
 8056548:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805654b:	8d 43 01             	lea    0x1(%ebx),%eax
 805654e:	5b                   	pop    %ebx
 805654f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056550:	83 ec 0c             	sub    $0xc,%esp
 8056553:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056559:	e8 02 24 ff ff       	call   8048960 <fflush@plt>
 805655e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056564:	6a 07                	push   $0x7
 8056566:	6a 01                	push   $0x1
 8056568:	68 92 e8 05 08       	push   $0x805e892
 805656d:	e8 9e 24 ff ff       	call   8048a10 <fwrite@plt>
 8056572:	83 c4 20             	add    $0x20,%esp
 8056575:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805657b:	6a 10                	push   $0x10
 805657d:	6a 01                	push   $0x1
 805657f:	68 b4 f3 05 08       	push   $0x805f3b4
 8056584:	e8 87 24 ff ff       	call   8048a10 <fwrite@plt>
 8056589:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805658f:	6a 05                	push   $0x5
 8056591:	6a 01                	push   $0x1
 8056593:	68 42 f3 05 08       	push   $0x805f342
 8056598:	e8 73 24 ff ff       	call   8048a10 <fwrite@plt>
 805659d:	83 c4 20             	add    $0x20,%esp
 80565a0:	68 18 af 0f 10       	push   $0x100faf18
 80565a5:	68 61 38 06 08       	push   $0x8063861
 80565aa:	6a 50                	push   $0x50
 80565ac:	68 00 8a 0c 08       	push   $0x80c8a00
 80565b1:	e8 4a 25 ff ff       	call   8048b00 <snprintf@plt>
 80565b6:	83 c4 10             	add    $0x10,%esp
 80565b9:	83 f8 4f             	cmp    $0x4f,%eax
 80565bc:	7e 8a                	jle    8056548 <ja_i_l+0x48>
 80565be:	68 71 39 06 08       	push   $0x8063971
 80565c3:	6a 0e                	push   $0xe
 80565c5:	68 78 38 06 08       	push   $0x8063878
 80565ca:	68 9c 38 06 08       	push   $0x806389c
 80565cf:	e8 dc 25 ff ff       	call   8048bb0 <__assert_fail@plt>
 80565d4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80565da:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080565e0 <ja_i_w>:
}

make_instr_helper(i)
 80565e0:	53                   	push   %ebx
 80565e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80565e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80565e8:	83 c0 01             	add    $0x1,%eax
 80565eb:	50                   	push   %eax
 80565ec:	e8 bf 61 00 00       	call   805c7b0 <decode_i_w>
#define instr ja

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF && !cpu.ZF) {
 80565f1:	83 c4 10             	add    $0x10,%esp
 80565f4:	f6 05 e4 af 0f 10 41 	testb  $0x41,0x100fafe4
 80565fb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr ja

static void do_execute() {
	int res = op_src->val;
 80565fd:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF && !cpu.ZF) {
 8056602:	75 0f                	jne    8056613 <ja_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8056604:	66 03 05 e0 af 0f 10 	add    0x100fafe0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 805660b:	0f b7 c0             	movzwl %ax,%eax
 805660e:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
#endif
	}
	print_asm_template1();
 8056613:	68 18 af 0f 10       	push   $0x100faf18
 8056618:	68 68 38 06 08       	push   $0x8063868
 805661d:	6a 50                	push   $0x50
 805661f:	68 00 8a 0c 08       	push   $0x80c8a00
 8056624:	e8 d7 24 ff ff       	call   8048b00 <snprintf@plt>
 8056629:	83 c4 10             	add    $0x10,%esp
 805662c:	83 f8 4f             	cmp    $0x4f,%eax
 805662f:	7f 0f                	jg     8056640 <ja_i_w+0x60>
}

make_instr_helper(i)
 8056631:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056634:	8d 43 01             	lea    0x1(%ebx),%eax
 8056637:	5b                   	pop    %ebx
 8056638:	c3                   	ret    
 8056639:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056640:	83 ec 0c             	sub    $0xc,%esp
 8056643:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056649:	e8 12 23 ff ff       	call   8048960 <fflush@plt>
 805664e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056654:	6a 07                	push   $0x7
 8056656:	6a 01                	push   $0x1
 8056658:	68 92 e8 05 08       	push   $0x805e892
 805665d:	e8 ae 23 ff ff       	call   8048a10 <fwrite@plt>
 8056662:	83 c4 20             	add    $0x20,%esp
 8056665:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805666b:	6a 10                	push   $0x10
 805666d:	6a 01                	push   $0x1
 805666f:	68 b4 f3 05 08       	push   $0x805f3b4
 8056674:	e8 97 23 ff ff       	call   8048a10 <fwrite@plt>
 8056679:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805667f:	6a 05                	push   $0x5
 8056681:	6a 01                	push   $0x1
 8056683:	68 42 f3 05 08       	push   $0x805f342
 8056688:	e8 83 23 ff ff       	call   8048a10 <fwrite@plt>
 805668d:	83 c4 20             	add    $0x20,%esp
 8056690:	68 18 af 0f 10       	push   $0x100faf18
 8056695:	68 68 38 06 08       	push   $0x8063868
 805669a:	6a 50                	push   $0x50
 805669c:	68 00 8a 0c 08       	push   $0x80c8a00
 80566a1:	e8 5a 24 ff ff       	call   8048b00 <snprintf@plt>
 80566a6:	83 c4 10             	add    $0x10,%esp
 80566a9:	83 f8 4f             	cmp    $0x4f,%eax
 80566ac:	7e 83                	jle    8056631 <ja_i_w+0x51>
 80566ae:	68 79 39 06 08       	push   $0x8063979
 80566b3:	6a 0e                	push   $0xe
 80566b5:	68 78 38 06 08       	push   $0x8063878
 80566ba:	68 e4 38 06 08       	push   $0x80638e4
 80566bf:	e8 ec 24 ff ff       	call   8048bb0 <__assert_fail@plt>
 80566c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80566ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

080566d0 <ja_i_b>:
}

make_instr_helper(i)
 80566d0:	53                   	push   %ebx
 80566d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80566d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80566d8:	83 c0 01             	add    $0x1,%eax
 80566db:	50                   	push   %eax
 80566dc:	e8 5f 5d 00 00       	call   805c440 <decode_i_b>
#define instr ja

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF && !cpu.ZF) {
 80566e1:	83 c4 10             	add    $0x10,%esp
 80566e4:	f6 05 e4 af 0f 10 41 	testb  $0x41,0x100fafe4
 80566eb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr ja

static void do_execute() {
	int res = op_src->val;
 80566ed:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.CF && !cpu.ZF) {
 80566f2:	75 09                	jne    80566fd <ja_i_b+0x2d>

#define instr ja

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 80566f4:	0f be c0             	movsbl %al,%eax
	if(!cpu.CF && !cpu.ZF) {
		cpu.eip = cpu.eip + res;
 80566f7:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 80566fd:	68 18 af 0f 10       	push   $0x100faf18
 8056702:	68 6f 38 06 08       	push   $0x806386f
 8056707:	6a 50                	push   $0x50
 8056709:	68 00 8a 0c 08       	push   $0x80c8a00
 805670e:	e8 ed 23 ff ff       	call   8048b00 <snprintf@plt>
 8056713:	83 c4 10             	add    $0x10,%esp
 8056716:	83 f8 4f             	cmp    $0x4f,%eax
 8056719:	7f 0d                	jg     8056728 <ja_i_b+0x58>
}

make_instr_helper(i)
 805671b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805671e:	8d 43 01             	lea    0x1(%ebx),%eax
 8056721:	5b                   	pop    %ebx
 8056722:	c3                   	ret    
 8056723:	90                   	nop
 8056724:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056728:	83 ec 0c             	sub    $0xc,%esp
 805672b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056731:	e8 2a 22 ff ff       	call   8048960 <fflush@plt>
 8056736:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805673c:	6a 07                	push   $0x7
 805673e:	6a 01                	push   $0x1
 8056740:	68 92 e8 05 08       	push   $0x805e892
 8056745:	e8 c6 22 ff ff       	call   8048a10 <fwrite@plt>
 805674a:	83 c4 20             	add    $0x20,%esp
 805674d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056753:	6a 10                	push   $0x10
 8056755:	6a 01                	push   $0x1
 8056757:	68 b4 f3 05 08       	push   $0x805f3b4
 805675c:	e8 af 22 ff ff       	call   8048a10 <fwrite@plt>
 8056761:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056767:	6a 05                	push   $0x5
 8056769:	6a 01                	push   $0x1
 805676b:	68 42 f3 05 08       	push   $0x805f342
 8056770:	e8 9b 22 ff ff       	call   8048a10 <fwrite@plt>
 8056775:	83 c4 20             	add    $0x20,%esp
 8056778:	68 18 af 0f 10       	push   $0x100faf18
 805677d:	68 6f 38 06 08       	push   $0x806386f
 8056782:	6a 50                	push   $0x50
 8056784:	68 00 8a 0c 08       	push   $0x80c8a00
 8056789:	e8 72 23 ff ff       	call   8048b00 <snprintf@plt>
 805678e:	83 c4 10             	add    $0x10,%esp
 8056791:	83 f8 4f             	cmp    $0x4f,%eax
 8056794:	7e 85                	jle    805671b <ja_i_b+0x4b>
 8056796:	68 81 39 06 08       	push   $0x8063981
 805679b:	6a 0e                	push   $0xe
 805679d:	68 78 38 06 08       	push   $0x8063878
 80567a2:	68 2c 39 06 08       	push   $0x806392c
 80567a7:	e8 04 24 ff ff       	call   8048bb0 <__assert_fail@plt>
 80567ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080567b0 <ja_i_v>:
#include "ja-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(ja_i)
 80567b0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80567b7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80567bb:	b8 e0 65 05 08       	mov    $0x80565e0,%eax
 80567c0:	75 05                	jne    80567c7 <ja_i_v+0x17>
 80567c2:	b8 00 65 05 08       	mov    $0x8056500,%eax
 80567c7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80567cb:	ff e0                	jmp    *%eax
 80567cd:	66 90                	xchg   %ax,%ax
 80567cf:	90                   	nop

080567d0 <jle_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 80567d0:	56                   	push   %esi
 80567d1:	53                   	push   %ebx
 80567d2:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80567d5:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80567d9:	83 c0 01             	add    $0x1,%eax
 80567dc:	50                   	push   %eax
 80567dd:	e8 5e 63 00 00       	call   805cb40 <decode_i_l>
#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF || cpu.ZF) {
 80567e2:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 80567e9:	89 c3                	mov    %eax,%ebx
 80567eb:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 80567f2:	83 c4 10             	add    $0x10,%esp
#include "cpu/exec/template-start.h"

#define instr jle

static void do_execute() {
	int res = op_src->val;
 80567f5:	8b 35 14 af 0f 10    	mov    0x100faf14,%esi
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF || cpu.ZF) {
 80567fb:	c0 ea 03             	shr    $0x3,%dl
 80567fe:	89 c1                	mov    %eax,%ecx
 8056800:	83 e2 01             	and    $0x1,%edx
 8056803:	c0 e9 07             	shr    $0x7,%cl
 8056806:	38 ca                	cmp    %cl,%dl
 8056808:	0f 84 ba 00 00 00    	je     80568c8 <jle_i_l+0xf8>
		cpu.eip = cpu.eip + res;
 805680e:	01 35 e0 af 0f 10    	add    %esi,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056814:	68 18 af 0f 10       	push   $0x100faf18
 8056819:	68 89 39 06 08       	push   $0x8063989
 805681e:	6a 50                	push   $0x50
 8056820:	68 00 8a 0c 08       	push   $0x80c8a00
 8056825:	e8 d6 22 ff ff       	call   8048b00 <snprintf@plt>
 805682a:	83 c4 10             	add    $0x10,%esp
 805682d:	83 f8 4f             	cmp    $0x4f,%eax
 8056830:	7f 0e                	jg     8056840 <jle_i_l+0x70>
}

make_instr_helper(i)
 8056832:	83 c4 04             	add    $0x4,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056835:	8d 43 01             	lea    0x1(%ebx),%eax
 8056838:	5b                   	pop    %ebx
 8056839:	5e                   	pop    %esi
 805683a:	c3                   	ret    
 805683b:	90                   	nop
 805683c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056840:	83 ec 0c             	sub    $0xc,%esp
 8056843:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056849:	e8 12 21 ff ff       	call   8048960 <fflush@plt>
 805684e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056854:	6a 07                	push   $0x7
 8056856:	6a 01                	push   $0x1
 8056858:	68 92 e8 05 08       	push   $0x805e892
 805685d:	e8 ae 21 ff ff       	call   8048a10 <fwrite@plt>
 8056862:	83 c4 20             	add    $0x20,%esp
 8056865:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805686b:	6a 10                	push   $0x10
 805686d:	6a 01                	push   $0x1
 805686f:	68 b4 f3 05 08       	push   $0x805f3b4
 8056874:	e8 97 21 ff ff       	call   8048a10 <fwrite@plt>
 8056879:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805687f:	6a 05                	push   $0x5
 8056881:	6a 01                	push   $0x1
 8056883:	68 42 f3 05 08       	push   $0x805f342
 8056888:	e8 83 21 ff ff       	call   8048a10 <fwrite@plt>
 805688d:	83 c4 20             	add    $0x20,%esp
 8056890:	68 18 af 0f 10       	push   $0x100faf18
 8056895:	68 89 39 06 08       	push   $0x8063989
 805689a:	6a 50                	push   $0x50
 805689c:	68 00 8a 0c 08       	push   $0x80c8a00
 80568a1:	e8 5a 22 ff ff       	call   8048b00 <snprintf@plt>
 80568a6:	83 c4 10             	add    $0x10,%esp
 80568a9:	83 f8 4f             	cmp    $0x4f,%eax
 80568ac:	7e 84                	jle    8056832 <jle_i_l+0x62>
 80568ae:	68 a2 3a 06 08       	push   $0x8063aa2
 80568b3:	6a 0e                	push   $0xe
 80568b5:	68 a4 39 06 08       	push   $0x80639a4
 80568ba:	68 cc 39 06 08       	push   $0x80639cc
 80568bf:	e8 ec 22 ff ff       	call   8048bb0 <__assert_fail@plt>
 80568c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF || cpu.ZF) {
 80568c8:	a8 40                	test   $0x40,%al
 80568ca:	0f 84 44 ff ff ff    	je     8056814 <jle_i_l+0x44>
 80568d0:	e9 39 ff ff ff       	jmp    805680e <jle_i_l+0x3e>
 80568d5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80568d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080568e0 <jle_i_w>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 80568e0:	57                   	push   %edi
 80568e1:	56                   	push   %esi
 80568e2:	53                   	push   %ebx
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80568e3:	83 ec 0c             	sub    $0xc,%esp
 80568e6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80568ea:	83 c0 01             	add    $0x1,%eax
 80568ed:	50                   	push   %eax
 80568ee:	e8 bd 5e 00 00       	call   805c7b0 <decode_i_w>
#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF || cpu.ZF) {
 80568f3:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 80568fa:	89 c3                	mov    %eax,%ebx
 80568fc:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 8056903:	83 c4 10             	add    $0x10,%esp

#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8056906:	0f bf 3d 14 af 0f 10 	movswl 0x100faf14,%edi
	if(cpu.OF != cpu.SF || cpu.ZF) {
 805690d:	c0 ea 03             	shr    $0x3,%dl
 8056910:	89 c1                	mov    %eax,%ecx
 8056912:	83 e2 01             	and    $0x1,%edx
 8056915:	c0 e9 07             	shr    $0x7,%cl
 8056918:	38 ca                	cmp    %cl,%dl
 805691a:	0f 84 c8 00 00 00    	je     80569e8 <jle_i_w+0x108>
		cpu.eip = cpu.eip + res;
 8056920:	03 3d e0 af 0f 10    	add    0x100fafe0,%edi
 8056926:	89 f9                	mov    %edi,%ecx
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 8056928:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
 805692e:	89 0d e0 af 0f 10    	mov    %ecx,0x100fafe0
#endif
	}
	print_asm_template1();
 8056934:	68 18 af 0f 10       	push   $0x100faf18
 8056939:	68 91 39 06 08       	push   $0x8063991
 805693e:	6a 50                	push   $0x50
 8056940:	68 00 8a 0c 08       	push   $0x80c8a00
 8056945:	e8 b6 21 ff ff       	call   8048b00 <snprintf@plt>
 805694a:	83 c4 10             	add    $0x10,%esp
 805694d:	83 f8 4f             	cmp    $0x4f,%eax
 8056950:	7f 0e                	jg     8056960 <jle_i_w+0x80>
	execute();
	return len + 1;	// "1" for opcode
 8056952:	8d 43 01             	lea    0x1(%ebx),%eax
}

make_instr_helper(i)
 8056955:	5b                   	pop    %ebx
 8056956:	5e                   	pop    %esi
 8056957:	5f                   	pop    %edi
 8056958:	c3                   	ret    
 8056959:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056960:	83 ec 0c             	sub    $0xc,%esp
 8056963:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056969:	e8 f2 1f ff ff       	call   8048960 <fflush@plt>
 805696e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056974:	6a 07                	push   $0x7
 8056976:	6a 01                	push   $0x1
 8056978:	68 92 e8 05 08       	push   $0x805e892
 805697d:	e8 8e 20 ff ff       	call   8048a10 <fwrite@plt>
 8056982:	83 c4 20             	add    $0x20,%esp
 8056985:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805698b:	6a 10                	push   $0x10
 805698d:	6a 01                	push   $0x1
 805698f:	68 b4 f3 05 08       	push   $0x805f3b4
 8056994:	e8 77 20 ff ff       	call   8048a10 <fwrite@plt>
 8056999:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805699f:	6a 05                	push   $0x5
 80569a1:	6a 01                	push   $0x1
 80569a3:	68 42 f3 05 08       	push   $0x805f342
 80569a8:	e8 63 20 ff ff       	call   8048a10 <fwrite@plt>
 80569ad:	83 c4 20             	add    $0x20,%esp
 80569b0:	68 18 af 0f 10       	push   $0x100faf18
 80569b5:	68 91 39 06 08       	push   $0x8063991
 80569ba:	6a 50                	push   $0x50
 80569bc:	68 00 8a 0c 08       	push   $0x80c8a00
 80569c1:	e8 3a 21 ff ff       	call   8048b00 <snprintf@plt>
 80569c6:	83 c4 10             	add    $0x10,%esp
 80569c9:	83 f8 4f             	cmp    $0x4f,%eax
 80569cc:	7e 84                	jle    8056952 <jle_i_w+0x72>
 80569ce:	68 ab 3a 06 08       	push   $0x8063aab
 80569d3:	6a 0e                	push   $0xe
 80569d5:	68 a4 39 06 08       	push   $0x80639a4
 80569da:	68 14 3a 06 08       	push   $0x8063a14
 80569df:	e8 cc 21 ff ff       	call   8048bb0 <__assert_fail@plt>
 80569e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF || cpu.ZF) {
 80569e8:	a8 40                	test   $0x40,%al
 80569ea:	0f 84 44 ff ff ff    	je     8056934 <jle_i_w+0x54>
 80569f0:	e9 2b ff ff ff       	jmp    8056920 <jle_i_w+0x40>
 80569f5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 80569f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08056a00 <jle_i_b>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8056a00:	56                   	push   %esi
 8056a01:	53                   	push   %ebx
 8056a02:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056a05:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056a09:	83 c0 01             	add    $0x1,%eax
 8056a0c:	50                   	push   %eax
 8056a0d:	e8 2e 5a 00 00       	call   805c440 <decode_i_b>
#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF || cpu.ZF) {
 8056a12:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 8056a19:	89 c3                	mov    %eax,%ebx
 8056a1b:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 8056a22:	83 c4 10             	add    $0x10,%esp

#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8056a25:	0f be 35 14 af 0f 10 	movsbl 0x100faf14,%esi
	if(cpu.OF != cpu.SF || cpu.ZF) {
 8056a2c:	c0 ea 03             	shr    $0x3,%dl
 8056a2f:	89 c1                	mov    %eax,%ecx
 8056a31:	83 e2 01             	and    $0x1,%edx
 8056a34:	c0 e9 07             	shr    $0x7,%cl
 8056a37:	38 ca                	cmp    %cl,%dl
 8056a39:	0f 84 b9 00 00 00    	je     8056af8 <jle_i_b+0xf8>
		cpu.eip = cpu.eip + res;
 8056a3f:	01 35 e0 af 0f 10    	add    %esi,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056a45:	68 18 af 0f 10       	push   $0x100faf18
 8056a4a:	68 99 39 06 08       	push   $0x8063999
 8056a4f:	6a 50                	push   $0x50
 8056a51:	68 00 8a 0c 08       	push   $0x80c8a00
 8056a56:	e8 a5 20 ff ff       	call   8048b00 <snprintf@plt>
 8056a5b:	83 c4 10             	add    $0x10,%esp
 8056a5e:	83 f8 4f             	cmp    $0x4f,%eax
 8056a61:	7f 0d                	jg     8056a70 <jle_i_b+0x70>
}

make_instr_helper(i)
 8056a63:	83 c4 04             	add    $0x4,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056a66:	8d 43 01             	lea    0x1(%ebx),%eax
 8056a69:	5b                   	pop    %ebx
 8056a6a:	5e                   	pop    %esi
 8056a6b:	c3                   	ret    
 8056a6c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056a70:	83 ec 0c             	sub    $0xc,%esp
 8056a73:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056a79:	e8 e2 1e ff ff       	call   8048960 <fflush@plt>
 8056a7e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056a84:	6a 07                	push   $0x7
 8056a86:	6a 01                	push   $0x1
 8056a88:	68 92 e8 05 08       	push   $0x805e892
 8056a8d:	e8 7e 1f ff ff       	call   8048a10 <fwrite@plt>
 8056a92:	83 c4 20             	add    $0x20,%esp
 8056a95:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056a9b:	6a 10                	push   $0x10
 8056a9d:	6a 01                	push   $0x1
 8056a9f:	68 b4 f3 05 08       	push   $0x805f3b4
 8056aa4:	e8 67 1f ff ff       	call   8048a10 <fwrite@plt>
 8056aa9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056aaf:	6a 05                	push   $0x5
 8056ab1:	6a 01                	push   $0x1
 8056ab3:	68 42 f3 05 08       	push   $0x805f342
 8056ab8:	e8 53 1f ff ff       	call   8048a10 <fwrite@plt>
 8056abd:	83 c4 20             	add    $0x20,%esp
 8056ac0:	68 18 af 0f 10       	push   $0x100faf18
 8056ac5:	68 99 39 06 08       	push   $0x8063999
 8056aca:	6a 50                	push   $0x50
 8056acc:	68 00 8a 0c 08       	push   $0x80c8a00
 8056ad1:	e8 2a 20 ff ff       	call   8048b00 <snprintf@plt>
 8056ad6:	83 c4 10             	add    $0x10,%esp
 8056ad9:	83 f8 4f             	cmp    $0x4f,%eax
 8056adc:	7e 85                	jle    8056a63 <jle_i_b+0x63>
 8056ade:	68 b4 3a 06 08       	push   $0x8063ab4
 8056ae3:	6a 0e                	push   $0xe
 8056ae5:	68 a4 39 06 08       	push   $0x80639a4
 8056aea:	68 5c 3a 06 08       	push   $0x8063a5c
 8056aef:	e8 bc 20 ff ff       	call   8048bb0 <__assert_fail@plt>
 8056af4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
#define instr jle

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.OF != cpu.SF || cpu.ZF) {
 8056af8:	a8 40                	test   $0x40,%al
 8056afa:	0f 84 45 ff ff ff    	je     8056a45 <jle_i_b+0x45>
 8056b00:	e9 3a ff ff ff       	jmp    8056a3f <jle_i_b+0x3f>
 8056b05:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8056b09:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08056b10 <jle_i_v>:
#include "jle-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jle_i)
 8056b10:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8056b17:	8b 54 24 04          	mov    0x4(%esp),%edx
 8056b1b:	b8 e0 68 05 08       	mov    $0x80568e0,%eax
 8056b20:	75 05                	jne    8056b27 <jle_i_v+0x17>
 8056b22:	b8 d0 67 05 08       	mov    $0x80567d0,%eax
 8056b27:	89 54 24 04          	mov    %edx,0x4(%esp)
 8056b2b:	ff e0                	jmp    *%eax
 8056b2d:	66 90                	xchg   %ax,%ax
 8056b2f:	90                   	nop

08056b30 <jno_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8056b30:	53                   	push   %ebx
 8056b31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056b34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056b38:	83 c0 01             	add    $0x1,%eax
 8056b3b:	50                   	push   %eax
 8056b3c:	e8 ff 5f 00 00       	call   805cb40 <decode_i_l>
#define instr jno

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.OF) {
 8056b41:	83 c4 10             	add    $0x10,%esp
 8056b44:	f6 05 e5 af 0f 10 08 	testb  $0x8,0x100fafe5
 8056b4b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jno

static void do_execute() {
	int res = op_src->val;
 8056b4d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.OF) {
 8056b52:	75 06                	jne    8056b5a <jno_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8056b54:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056b5a:	68 18 af 0f 10       	push   $0x100faf18
 8056b5f:	68 bd 3a 06 08       	push   $0x8063abd
 8056b64:	6a 50                	push   $0x50
 8056b66:	68 00 8a 0c 08       	push   $0x80c8a00
 8056b6b:	e8 90 1f ff ff       	call   8048b00 <snprintf@plt>
 8056b70:	83 c4 10             	add    $0x10,%esp
 8056b73:	83 f8 4f             	cmp    $0x4f,%eax
 8056b76:	7f 08                	jg     8056b80 <jno_i_l+0x50>
}

make_instr_helper(i)
 8056b78:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056b7b:	8d 43 01             	lea    0x1(%ebx),%eax
 8056b7e:	5b                   	pop    %ebx
 8056b7f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056b80:	83 ec 0c             	sub    $0xc,%esp
 8056b83:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056b89:	e8 d2 1d ff ff       	call   8048960 <fflush@plt>
 8056b8e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056b94:	6a 07                	push   $0x7
 8056b96:	6a 01                	push   $0x1
 8056b98:	68 92 e8 05 08       	push   $0x805e892
 8056b9d:	e8 6e 1e ff ff       	call   8048a10 <fwrite@plt>
 8056ba2:	83 c4 20             	add    $0x20,%esp
 8056ba5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056bab:	6a 10                	push   $0x10
 8056bad:	6a 01                	push   $0x1
 8056baf:	68 b4 f3 05 08       	push   $0x805f3b4
 8056bb4:	e8 57 1e ff ff       	call   8048a10 <fwrite@plt>
 8056bb9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056bbf:	6a 05                	push   $0x5
 8056bc1:	6a 01                	push   $0x1
 8056bc3:	68 42 f3 05 08       	push   $0x805f342
 8056bc8:	e8 43 1e ff ff       	call   8048a10 <fwrite@plt>
 8056bcd:	83 c4 20             	add    $0x20,%esp
 8056bd0:	68 18 af 0f 10       	push   $0x100faf18
 8056bd5:	68 bd 3a 06 08       	push   $0x8063abd
 8056bda:	6a 50                	push   $0x50
 8056bdc:	68 00 8a 0c 08       	push   $0x80c8a00
 8056be1:	e8 1a 1f ff ff       	call   8048b00 <snprintf@plt>
 8056be6:	83 c4 10             	add    $0x10,%esp
 8056be9:	83 f8 4f             	cmp    $0x4f,%eax
 8056bec:	7e 8a                	jle    8056b78 <jno_i_l+0x48>
 8056bee:	68 d6 3b 06 08       	push   $0x8063bd6
 8056bf3:	6a 0e                	push   $0xe
 8056bf5:	68 d8 3a 06 08       	push   $0x8063ad8
 8056bfa:	68 00 3b 06 08       	push   $0x8063b00
 8056bff:	e8 ac 1f ff ff       	call   8048bb0 <__assert_fail@plt>
 8056c04:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8056c0a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08056c10 <jno_i_w>:
}

make_instr_helper(i)
 8056c10:	53                   	push   %ebx
 8056c11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056c14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056c18:	83 c0 01             	add    $0x1,%eax
 8056c1b:	50                   	push   %eax
 8056c1c:	e8 8f 5b 00 00       	call   805c7b0 <decode_i_w>
#define instr jno

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.OF) {
 8056c21:	83 c4 10             	add    $0x10,%esp
 8056c24:	f6 05 e5 af 0f 10 08 	testb  $0x8,0x100fafe5
 8056c2b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jno

static void do_execute() {
	int res = op_src->val;
 8056c2d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.OF) {
 8056c32:	75 0f                	jne    8056c43 <jno_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8056c34:	66 03 05 e0 af 0f 10 	add    0x100fafe0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 8056c3b:	0f b7 c0             	movzwl %ax,%eax
 8056c3e:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
#endif
	}
	print_asm_template1();
 8056c43:	68 18 af 0f 10       	push   $0x100faf18
 8056c48:	68 c5 3a 06 08       	push   $0x8063ac5
 8056c4d:	6a 50                	push   $0x50
 8056c4f:	68 00 8a 0c 08       	push   $0x80c8a00
 8056c54:	e8 a7 1e ff ff       	call   8048b00 <snprintf@plt>
 8056c59:	83 c4 10             	add    $0x10,%esp
 8056c5c:	83 f8 4f             	cmp    $0x4f,%eax
 8056c5f:	7f 0f                	jg     8056c70 <jno_i_w+0x60>
}

make_instr_helper(i)
 8056c61:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056c64:	8d 43 01             	lea    0x1(%ebx),%eax
 8056c67:	5b                   	pop    %ebx
 8056c68:	c3                   	ret    
 8056c69:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056c70:	83 ec 0c             	sub    $0xc,%esp
 8056c73:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056c79:	e8 e2 1c ff ff       	call   8048960 <fflush@plt>
 8056c7e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056c84:	6a 07                	push   $0x7
 8056c86:	6a 01                	push   $0x1
 8056c88:	68 92 e8 05 08       	push   $0x805e892
 8056c8d:	e8 7e 1d ff ff       	call   8048a10 <fwrite@plt>
 8056c92:	83 c4 20             	add    $0x20,%esp
 8056c95:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056c9b:	6a 10                	push   $0x10
 8056c9d:	6a 01                	push   $0x1
 8056c9f:	68 b4 f3 05 08       	push   $0x805f3b4
 8056ca4:	e8 67 1d ff ff       	call   8048a10 <fwrite@plt>
 8056ca9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056caf:	6a 05                	push   $0x5
 8056cb1:	6a 01                	push   $0x1
 8056cb3:	68 42 f3 05 08       	push   $0x805f342
 8056cb8:	e8 53 1d ff ff       	call   8048a10 <fwrite@plt>
 8056cbd:	83 c4 20             	add    $0x20,%esp
 8056cc0:	68 18 af 0f 10       	push   $0x100faf18
 8056cc5:	68 c5 3a 06 08       	push   $0x8063ac5
 8056cca:	6a 50                	push   $0x50
 8056ccc:	68 00 8a 0c 08       	push   $0x80c8a00
 8056cd1:	e8 2a 1e ff ff       	call   8048b00 <snprintf@plt>
 8056cd6:	83 c4 10             	add    $0x10,%esp
 8056cd9:	83 f8 4f             	cmp    $0x4f,%eax
 8056cdc:	7e 83                	jle    8056c61 <jno_i_w+0x51>
 8056cde:	68 df 3b 06 08       	push   $0x8063bdf
 8056ce3:	6a 0e                	push   $0xe
 8056ce5:	68 d8 3a 06 08       	push   $0x8063ad8
 8056cea:	68 48 3b 06 08       	push   $0x8063b48
 8056cef:	e8 bc 1e ff ff       	call   8048bb0 <__assert_fail@plt>
 8056cf4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8056cfa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08056d00 <jno_i_b>:
}

make_instr_helper(i)
 8056d00:	53                   	push   %ebx
 8056d01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056d04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056d08:	83 c0 01             	add    $0x1,%eax
 8056d0b:	50                   	push   %eax
 8056d0c:	e8 2f 57 00 00       	call   805c440 <decode_i_b>
#define instr jno

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.OF) {
 8056d11:	83 c4 10             	add    $0x10,%esp
 8056d14:	f6 05 e5 af 0f 10 08 	testb  $0x8,0x100fafe5
 8056d1b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jno

static void do_execute() {
	int res = op_src->val;
 8056d1d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(!cpu.OF) {
 8056d22:	75 09                	jne    8056d2d <jno_i_b+0x2d>

#define instr jno

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8056d24:	0f be c0             	movsbl %al,%eax
	if(!cpu.OF) {
		cpu.eip = cpu.eip + res;
 8056d27:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056d2d:	68 18 af 0f 10       	push   $0x100faf18
 8056d32:	68 cd 3a 06 08       	push   $0x8063acd
 8056d37:	6a 50                	push   $0x50
 8056d39:	68 00 8a 0c 08       	push   $0x80c8a00
 8056d3e:	e8 bd 1d ff ff       	call   8048b00 <snprintf@plt>
 8056d43:	83 c4 10             	add    $0x10,%esp
 8056d46:	83 f8 4f             	cmp    $0x4f,%eax
 8056d49:	7f 0d                	jg     8056d58 <jno_i_b+0x58>
}

make_instr_helper(i)
 8056d4b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056d4e:	8d 43 01             	lea    0x1(%ebx),%eax
 8056d51:	5b                   	pop    %ebx
 8056d52:	c3                   	ret    
 8056d53:	90                   	nop
 8056d54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056d58:	83 ec 0c             	sub    $0xc,%esp
 8056d5b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056d61:	e8 fa 1b ff ff       	call   8048960 <fflush@plt>
 8056d66:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056d6c:	6a 07                	push   $0x7
 8056d6e:	6a 01                	push   $0x1
 8056d70:	68 92 e8 05 08       	push   $0x805e892
 8056d75:	e8 96 1c ff ff       	call   8048a10 <fwrite@plt>
 8056d7a:	83 c4 20             	add    $0x20,%esp
 8056d7d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056d83:	6a 10                	push   $0x10
 8056d85:	6a 01                	push   $0x1
 8056d87:	68 b4 f3 05 08       	push   $0x805f3b4
 8056d8c:	e8 7f 1c ff ff       	call   8048a10 <fwrite@plt>
 8056d91:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056d97:	6a 05                	push   $0x5
 8056d99:	6a 01                	push   $0x1
 8056d9b:	68 42 f3 05 08       	push   $0x805f342
 8056da0:	e8 6b 1c ff ff       	call   8048a10 <fwrite@plt>
 8056da5:	83 c4 20             	add    $0x20,%esp
 8056da8:	68 18 af 0f 10       	push   $0x100faf18
 8056dad:	68 cd 3a 06 08       	push   $0x8063acd
 8056db2:	6a 50                	push   $0x50
 8056db4:	68 00 8a 0c 08       	push   $0x80c8a00
 8056db9:	e8 42 1d ff ff       	call   8048b00 <snprintf@plt>
 8056dbe:	83 c4 10             	add    $0x10,%esp
 8056dc1:	83 f8 4f             	cmp    $0x4f,%eax
 8056dc4:	7e 85                	jle    8056d4b <jno_i_b+0x4b>
 8056dc6:	68 e8 3b 06 08       	push   $0x8063be8
 8056dcb:	6a 0e                	push   $0xe
 8056dcd:	68 d8 3a 06 08       	push   $0x8063ad8
 8056dd2:	68 90 3b 06 08       	push   $0x8063b90
 8056dd7:	e8 d4 1d ff ff       	call   8048bb0 <__assert_fail@plt>
 8056ddc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

08056de0 <jno_i_v>:
#include "jno-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jno_i)
 8056de0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8056de7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8056deb:	b8 10 6c 05 08       	mov    $0x8056c10,%eax
 8056df0:	75 05                	jne    8056df7 <jno_i_v+0x17>
 8056df2:	b8 30 6b 05 08       	mov    $0x8056b30,%eax
 8056df7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8056dfb:	ff e0                	jmp    *%eax
 8056dfd:	66 90                	xchg   %ax,%ax
 8056dff:	90                   	nop

08056e00 <jp_i_l>:
#endif
	}
	print_asm_template1();
}

make_instr_helper(i)
 8056e00:	53                   	push   %ebx
 8056e01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056e04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056e08:	83 c0 01             	add    $0x1,%eax
 8056e0b:	50                   	push   %eax
 8056e0c:	e8 2f 5d 00 00       	call   805cb40 <decode_i_l>
#define instr jp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.PF) {
 8056e11:	83 c4 10             	add    $0x10,%esp
 8056e14:	f6 05 e4 af 0f 10 04 	testb  $0x4,0x100fafe4
 8056e1b:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jp

static void do_execute() {
	int res = op_src->val;
 8056e1d:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.PF) {
 8056e22:	74 06                	je     8056e2a <jp_i_l+0x2a>
		cpu.eip = cpu.eip + res;
 8056e24:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056e2a:	68 18 af 0f 10       	push   $0x100faf18
 8056e2f:	68 f1 3b 06 08       	push   $0x8063bf1
 8056e34:	6a 50                	push   $0x50
 8056e36:	68 00 8a 0c 08       	push   $0x80c8a00
 8056e3b:	e8 c0 1c ff ff       	call   8048b00 <snprintf@plt>
 8056e40:	83 c4 10             	add    $0x10,%esp
 8056e43:	83 f8 4f             	cmp    $0x4f,%eax
 8056e46:	7f 08                	jg     8056e50 <jp_i_l+0x50>
}

make_instr_helper(i)
 8056e48:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056e4b:	8d 43 01             	lea    0x1(%ebx),%eax
 8056e4e:	5b                   	pop    %ebx
 8056e4f:	c3                   	ret    
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056e50:	83 ec 0c             	sub    $0xc,%esp
 8056e53:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056e59:	e8 02 1b ff ff       	call   8048960 <fflush@plt>
 8056e5e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056e64:	6a 07                	push   $0x7
 8056e66:	6a 01                	push   $0x1
 8056e68:	68 92 e8 05 08       	push   $0x805e892
 8056e6d:	e8 9e 1b ff ff       	call   8048a10 <fwrite@plt>
 8056e72:	83 c4 20             	add    $0x20,%esp
 8056e75:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056e7b:	6a 10                	push   $0x10
 8056e7d:	6a 01                	push   $0x1
 8056e7f:	68 b4 f3 05 08       	push   $0x805f3b4
 8056e84:	e8 87 1b ff ff       	call   8048a10 <fwrite@plt>
 8056e89:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056e8f:	6a 05                	push   $0x5
 8056e91:	6a 01                	push   $0x1
 8056e93:	68 42 f3 05 08       	push   $0x805f342
 8056e98:	e8 73 1b ff ff       	call   8048a10 <fwrite@plt>
 8056e9d:	83 c4 20             	add    $0x20,%esp
 8056ea0:	68 18 af 0f 10       	push   $0x100faf18
 8056ea5:	68 f1 3b 06 08       	push   $0x8063bf1
 8056eaa:	6a 50                	push   $0x50
 8056eac:	68 00 8a 0c 08       	push   $0x80c8a00
 8056eb1:	e8 4a 1c ff ff       	call   8048b00 <snprintf@plt>
 8056eb6:	83 c4 10             	add    $0x10,%esp
 8056eb9:	83 f8 4f             	cmp    $0x4f,%eax
 8056ebc:	7e 8a                	jle    8056e48 <jp_i_l+0x48>
 8056ebe:	68 01 3d 06 08       	push   $0x8063d01
 8056ec3:	6a 0e                	push   $0xe
 8056ec5:	68 08 3c 06 08       	push   $0x8063c08
 8056eca:	68 2c 3c 06 08       	push   $0x8063c2c
 8056ecf:	e8 dc 1c ff ff       	call   8048bb0 <__assert_fail@plt>
 8056ed4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8056eda:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08056ee0 <jp_i_w>:
}

make_instr_helper(i)
 8056ee0:	53                   	push   %ebx
 8056ee1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056ee4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056ee8:	83 c0 01             	add    $0x1,%eax
 8056eeb:	50                   	push   %eax
 8056eec:	e8 bf 58 00 00       	call   805c7b0 <decode_i_w>
#define instr jp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.PF) {
 8056ef1:	83 c4 10             	add    $0x10,%esp
 8056ef4:	f6 05 e4 af 0f 10 04 	testb  $0x4,0x100fafe4
 8056efb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jp

static void do_execute() {
	int res = op_src->val;
 8056efd:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.PF) {
 8056f02:	74 0f                	je     8056f13 <jp_i_w+0x33>
		cpu.eip = cpu.eip + res;
 8056f04:	66 03 05 e0 af 0f 10 	add    0x100fafe0,%ax
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
 8056f0b:	0f b7 c0             	movzwl %ax,%eax
 8056f0e:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0
#endif
	}
	print_asm_template1();
 8056f13:	68 18 af 0f 10       	push   $0x100faf18
 8056f18:	68 f8 3b 06 08       	push   $0x8063bf8
 8056f1d:	6a 50                	push   $0x50
 8056f1f:	68 00 8a 0c 08       	push   $0x80c8a00
 8056f24:	e8 d7 1b ff ff       	call   8048b00 <snprintf@plt>
 8056f29:	83 c4 10             	add    $0x10,%esp
 8056f2c:	83 f8 4f             	cmp    $0x4f,%eax
 8056f2f:	7f 0f                	jg     8056f40 <jp_i_w+0x60>
}

make_instr_helper(i)
 8056f31:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8056f34:	8d 43 01             	lea    0x1(%ebx),%eax
 8056f37:	5b                   	pop    %ebx
 8056f38:	c3                   	ret    
 8056f39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056f40:	83 ec 0c             	sub    $0xc,%esp
 8056f43:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8056f49:	e8 12 1a ff ff       	call   8048960 <fflush@plt>
 8056f4e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056f54:	6a 07                	push   $0x7
 8056f56:	6a 01                	push   $0x1
 8056f58:	68 92 e8 05 08       	push   $0x805e892
 8056f5d:	e8 ae 1a ff ff       	call   8048a10 <fwrite@plt>
 8056f62:	83 c4 20             	add    $0x20,%esp
 8056f65:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056f6b:	6a 10                	push   $0x10
 8056f6d:	6a 01                	push   $0x1
 8056f6f:	68 b4 f3 05 08       	push   $0x805f3b4
 8056f74:	e8 97 1a ff ff       	call   8048a10 <fwrite@plt>
 8056f79:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8056f7f:	6a 05                	push   $0x5
 8056f81:	6a 01                	push   $0x1
 8056f83:	68 42 f3 05 08       	push   $0x805f342
 8056f88:	e8 83 1a ff ff       	call   8048a10 <fwrite@plt>
 8056f8d:	83 c4 20             	add    $0x20,%esp
 8056f90:	68 18 af 0f 10       	push   $0x100faf18
 8056f95:	68 f8 3b 06 08       	push   $0x8063bf8
 8056f9a:	6a 50                	push   $0x50
 8056f9c:	68 00 8a 0c 08       	push   $0x80c8a00
 8056fa1:	e8 5a 1b ff ff       	call   8048b00 <snprintf@plt>
 8056fa6:	83 c4 10             	add    $0x10,%esp
 8056fa9:	83 f8 4f             	cmp    $0x4f,%eax
 8056fac:	7e 83                	jle    8056f31 <jp_i_w+0x51>
 8056fae:	68 09 3d 06 08       	push   $0x8063d09
 8056fb3:	6a 0e                	push   $0xe
 8056fb5:	68 08 3c 06 08       	push   $0x8063c08
 8056fba:	68 74 3c 06 08       	push   $0x8063c74
 8056fbf:	e8 ec 1b ff ff       	call   8048bb0 <__assert_fail@plt>
 8056fc4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8056fca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08056fd0 <jp_i_b>:
}

make_instr_helper(i)
 8056fd0:	53                   	push   %ebx
 8056fd1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8056fd4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8056fd8:	83 c0 01             	add    $0x1,%eax
 8056fdb:	50                   	push   %eax
 8056fdc:	e8 5f 54 00 00       	call   805c440 <decode_i_b>
#define instr jp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.PF) {
 8056fe1:	83 c4 10             	add    $0x10,%esp
 8056fe4:	f6 05 e4 af 0f 10 04 	testb  $0x4,0x100fafe4
 8056feb:	89 c3                	mov    %eax,%ebx
#include "cpu/exec/template-start.h"

#define instr jp

static void do_execute() {
	int res = op_src->val;
 8056fed:	a1 14 af 0f 10       	mov    0x100faf14,%eax
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
	if(cpu.PF) {
 8056ff2:	74 09                	je     8056ffd <jp_i_b+0x2d>

#define instr jp

static void do_execute() {
	int res = op_src->val;
	res = res << (32 - (DATA_BYTE << 3)) >> (32 - (DATA_BYTE << 3)); 
 8056ff4:	0f be c0             	movsbl %al,%eax
	if(cpu.PF) {
		cpu.eip = cpu.eip + res;
 8056ff7:	01 05 e0 af 0f 10    	add    %eax,0x100fafe0
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8056ffd:	68 18 af 0f 10       	push   $0x100faf18
 8057002:	68 ff 3b 06 08       	push   $0x8063bff
 8057007:	6a 50                	push   $0x50
 8057009:	68 00 8a 0c 08       	push   $0x80c8a00
 805700e:	e8 ed 1a ff ff       	call   8048b00 <snprintf@plt>
 8057013:	83 c4 10             	add    $0x10,%esp
 8057016:	83 f8 4f             	cmp    $0x4f,%eax
 8057019:	7f 0d                	jg     8057028 <jp_i_b+0x58>
}

make_instr_helper(i)
 805701b:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805701e:	8d 43 01             	lea    0x1(%ebx),%eax
 8057021:	5b                   	pop    %ebx
 8057022:	c3                   	ret    
 8057023:	90                   	nop
 8057024:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.eip = cpu.eip + res;
#if DATA_BYTE == 2
		cpu.eip = cpu.eip & 0xffff;
#endif
	}
	print_asm_template1();
 8057028:	83 ec 0c             	sub    $0xc,%esp
 805702b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8057031:	e8 2a 19 ff ff       	call   8048960 <fflush@plt>
 8057036:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805703c:	6a 07                	push   $0x7
 805703e:	6a 01                	push   $0x1
 8057040:	68 92 e8 05 08       	push   $0x805e892
 8057045:	e8 c6 19 ff ff       	call   8048a10 <fwrite@plt>
 805704a:	83 c4 20             	add    $0x20,%esp
 805704d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8057053:	6a 10                	push   $0x10
 8057055:	6a 01                	push   $0x1
 8057057:	68 b4 f3 05 08       	push   $0x805f3b4
 805705c:	e8 af 19 ff ff       	call   8048a10 <fwrite@plt>
 8057061:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8057067:	6a 05                	push   $0x5
 8057069:	6a 01                	push   $0x1
 805706b:	68 42 f3 05 08       	push   $0x805f342
 8057070:	e8 9b 19 ff ff       	call   8048a10 <fwrite@plt>
 8057075:	83 c4 20             	add    $0x20,%esp
 8057078:	68 18 af 0f 10       	push   $0x100faf18
 805707d:	68 ff 3b 06 08       	push   $0x8063bff
 8057082:	6a 50                	push   $0x50
 8057084:	68 00 8a 0c 08       	push   $0x80c8a00
 8057089:	e8 72 1a ff ff       	call   8048b00 <snprintf@plt>
 805708e:	83 c4 10             	add    $0x10,%esp
 8057091:	83 f8 4f             	cmp    $0x4f,%eax
 8057094:	7e 85                	jle    805701b <jp_i_b+0x4b>
 8057096:	68 11 3d 06 08       	push   $0x8063d11
 805709b:	6a 0e                	push   $0xe
 805709d:	68 08 3c 06 08       	push   $0x8063c08
 80570a2:	68 bc 3c 06 08       	push   $0x8063cbc
 80570a7:	e8 04 1b ff ff       	call   8048bb0 <__assert_fail@plt>
 80570ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

080570b0 <jp_i_v>:
#include "jp-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(jp_i)
 80570b0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80570b7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80570bb:	b8 e0 6e 05 08       	mov    $0x8056ee0,%eax
 80570c0:	75 05                	jne    80570c7 <jp_i_v+0x17>
 80570c2:	b8 00 6e 05 08       	mov    $0x8056e00,%eax
 80570c7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80570cb:	ff e0                	jmp    *%eax
 80570cd:	66 90                	xchg   %ax,%ax
 80570cf:	90                   	nop

080570d0 <do_adc_b>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
 80570d0:	55                   	push   %ebp
 80570d1:	57                   	push   %edi
 80570d2:	56                   	push   %esi
 80570d3:	53                   	push   %ebx
 80570d4:	83 ec 0c             	sub    $0xc,%esp
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 80570d7:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 80570de:	8b 15 14 af 0f 10    	mov    0x100faf14,%edx
 80570e4:	8b 35 4c af 0f 10    	mov    0x100faf4c,%esi
 80570ea:	89 c1                	mov    %eax,%ecx
 80570ec:	8d 1c 16             	lea    (%esi,%edx,1),%ebx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80570ef:	89 f7                	mov    %esi,%edi
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 80570f1:	83 e1 01             	and    $0x1,%ecx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80570f4:	c1 ef 07             	shr    $0x7,%edi
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 80570f7:	00 cb                	add    %cl,%bl
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80570f9:	89 d1                	mov    %edx,%ecx
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 80570fb:	0f 88 4f 01 00 00    	js     8057250 <do_adc_b+0x180>
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
	}
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
 8057101:	c1 e9 07             	shr    $0x7,%ecx
 8057104:	83 e0 fe             	and    $0xfffffffe,%eax
 8057107:	09 f9                	or     %edi,%ecx
 8057109:	83 e1 01             	and    $0x1,%ecx
 805710c:	09 c8                	or     %ecx,%eax
 805710e:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
 8057113:	0f be fb             	movsbl %bl,%edi
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
 8057116:	31 c0                	xor    %eax,%eax
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 8057118:	31 c9                	xor    %ecx,%ecx
 805711a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
 8057120:	89 fd                	mov    %edi,%ebp
 8057122:	d3 fd                	sar    %cl,%ebp
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 8057124:	83 c1 01             	add    $0x1,%ecx
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
 8057127:	83 e5 01             	and    $0x1,%ebp
 805712a:	31 e8                	xor    %ebp,%eax
 805712c:	83 e0 01             	and    $0x1,%eax
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 805712f:	83 f9 08             	cmp    $0x8,%ecx
 8057132:	75 ec                	jne    8057120 <do_adc_b+0x50>
 8057134:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 805713b:	c1 e0 02             	shl    $0x2,%eax
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 805713e:	89 df                	mov    %ebx,%edi
 8057140:	83 e1 fb             	and    $0xfffffffb,%ecx
 8057143:	09 c8                	or     %ecx,%eax
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 8057145:	84 db                	test   %bl,%bl
 8057147:	0f 94 c1             	sete   %cl
 805714a:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 805714d:	83 e7 80             	and    $0xffffff80,%edi
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 8057150:	c1 e1 06             	shl    $0x6,%ecx
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057153:	31 da                	xor    %ebx,%edx
	OPERAND_W(op_dest, res);
 8057155:	83 ec 08             	sub    $0x8,%esp
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8057158:	09 c8                	or     %ecx,%eax
 805715a:	09 f8                	or     %edi,%eax
 805715c:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057161:	89 f0                	mov    %esi,%eax
 8057163:	31 d8                	xor    %ebx,%eax
	OPERAND_W(op_dest, res);
 8057165:	0f b6 db             	movzbl %bl,%ebx
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057168:	21 d0                	and    %edx,%eax
 805716a:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
	OPERAND_W(op_dest, res);
 8057171:	53                   	push   %ebx
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057172:	83 e0 01             	and    $0x1,%eax
	OPERAND_W(op_dest, res);
 8057175:	68 40 af 0f 10       	push   $0x100faf40
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 805717a:	c1 e0 03             	shl    $0x3,%eax
 805717d:	83 e2 f7             	and    $0xfffffff7,%edx
 8057180:	09 d0                	or     %edx,%eax
 8057182:	a2 e5 af 0f 10       	mov    %al,0x100fafe5
	OPERAND_W(op_dest, res);
 8057187:	e8 b4 55 00 00       	call   805c740 <write_operand_b>
	print_asm_template2();
 805718c:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 8057193:	68 18 af 0f 10       	push   $0x100faf18
 8057198:	68 19 3d 06 08       	push   $0x8063d19
 805719d:	6a 50                	push   $0x50
 805719f:	68 00 8a 0c 08       	push   $0x80c8a00
 80571a4:	e8 57 19 ff ff       	call   8048b00 <snprintf@plt>
 80571a9:	83 c4 20             	add    $0x20,%esp
 80571ac:	83 f8 4f             	cmp    $0x4f,%eax
 80571af:	7f 0f                	jg     80571c0 <do_adc_b+0xf0>
}
 80571b1:	83 c4 0c             	add    $0xc,%esp
 80571b4:	5b                   	pop    %ebx
 80571b5:	5e                   	pop    %esi
 80571b6:	5f                   	pop    %edi
 80571b7:	5d                   	pop    %ebp
 80571b8:	c3                   	ret    
 80571b9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 80571c0:	83 ec 0c             	sub    $0xc,%esp
 80571c3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80571c9:	e8 92 17 ff ff       	call   8048960 <fflush@plt>
 80571ce:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80571d4:	6a 07                	push   $0x7
 80571d6:	6a 01                	push   $0x1
 80571d8:	68 92 e8 05 08       	push   $0x805e892
 80571dd:	e8 2e 18 ff ff       	call   8048a10 <fwrite@plt>
 80571e2:	83 c4 20             	add    $0x20,%esp
 80571e5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80571eb:	6a 10                	push   $0x10
 80571ed:	6a 01                	push   $0x1
 80571ef:	68 b4 f3 05 08       	push   $0x805f3b4
 80571f4:	e8 17 18 ff ff       	call   8048a10 <fwrite@plt>
 80571f9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80571ff:	6a 05                	push   $0x5
 8057201:	6a 01                	push   $0x1
 8057203:	68 42 f3 05 08       	push   $0x805f342
 8057208:	e8 03 18 ff ff       	call   8048a10 <fwrite@plt>
 805720d:	83 c4 14             	add    $0x14,%esp
 8057210:	68 50 af 0f 10       	push   $0x100faf50
 8057215:	68 18 af 0f 10       	push   $0x100faf18
 805721a:	68 19 3d 06 08       	push   $0x8063d19
 805721f:	6a 50                	push   $0x50
 8057221:	68 00 8a 0c 08       	push   $0x80c8a00
 8057226:	e8 d5 18 ff ff       	call   8048b00 <snprintf@plt>
 805722b:	83 c4 20             	add    $0x20,%esp
 805722e:	83 f8 4f             	cmp    $0x4f,%eax
 8057231:	0f 8e 7a ff ff ff    	jle    80571b1 <do_adc_b+0xe1>
 8057237:	68 a1 3e 06 08       	push   $0x8063ea1
 805723c:	6a 1d                	push   $0x1d
 805723e:	68 3c 3d 06 08       	push   $0x8063d3c
 8057243:	68 64 3d 06 08       	push   $0x8063d64
 8057248:	e8 63 19 ff ff       	call   8048bb0 <__assert_fail@plt>
 805724d:	8d 76 00             	lea    0x0(%esi),%esi
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8057250:	c1 e9 07             	shr    $0x7,%ecx
 8057253:	83 e0 fe             	and    $0xfffffffe,%eax
 8057256:	21 f9                	and    %edi,%ecx
 8057258:	83 e1 01             	and    $0x1,%ecx
 805725b:	09 c8                	or     %ecx,%eax
 805725d:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
 8057262:	e9 ac fe ff ff       	jmp    8057113 <do_adc_b+0x43>
 8057267:	89 f6                	mov    %esi,%esi
 8057269:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08057270 <do_adc_w>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
 8057270:	55                   	push   %ebp
 8057271:	57                   	push   %edi
 8057272:	56                   	push   %esi
 8057273:	53                   	push   %ebx
 8057274:	83 ec 0c             	sub    $0xc,%esp
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 8057277:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
 805727e:	8b 15 14 af 0f 10    	mov    0x100faf14,%edx
 8057284:	8b 35 4c af 0f 10    	mov    0x100faf4c,%esi
 805728a:	89 c1                	mov    %eax,%ecx
 805728c:	8d 1c 16             	lea    (%esi,%edx,1),%ebx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 805728f:	89 f7                	mov    %esi,%edi
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 8057291:	83 e1 01             	and    $0x1,%ecx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8057294:	c1 ef 0f             	shr    $0xf,%edi
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 8057297:	66 01 cb             	add    %cx,%bx
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 805729a:	89 d1                	mov    %edx,%ecx
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 805729c:	0f 88 4e 01 00 00    	js     80573f0 <do_adc_w+0x180>
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
	}
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
 80572a2:	c1 e9 0f             	shr    $0xf,%ecx
 80572a5:	83 e0 fe             	and    $0xfffffffe,%eax
 80572a8:	09 f9                	or     %edi,%ecx
 80572aa:	83 e1 01             	and    $0x1,%ecx
 80572ad:	09 c8                	or     %ecx,%eax
 80572af:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
 80572b4:	0f bf fb             	movswl %bx,%edi
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
 80572b7:	31 c0                	xor    %eax,%eax
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 80572b9:	31 c9                	xor    %ecx,%ecx
 80572bb:	90                   	nop
 80572bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
 80572c0:	89 fd                	mov    %edi,%ebp
 80572c2:	d3 fd                	sar    %cl,%ebp
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 80572c4:	83 c1 01             	add    $0x1,%ecx
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
 80572c7:	83 e5 01             	and    $0x1,%ebp
 80572ca:	31 e8                	xor    %ebp,%eax
 80572cc:	83 e0 01             	and    $0x1,%eax
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 80572cf:	83 f9 10             	cmp    $0x10,%ecx
 80572d2:	75 ec                	jne    80572c0 <do_adc_w+0x50>
 80572d4:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 80572db:	c1 e0 02             	shl    $0x2,%eax
 80572de:	83 e1 fb             	and    $0xfffffffb,%ecx
 80572e1:	09 c8                	or     %ecx,%eax
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 80572e3:	66 85 db             	test   %bx,%bx
 80572e6:	0f 94 c1             	sete   %cl
 80572e9:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80572ec:	31 da                	xor    %ebx,%edx
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 80572ee:	89 cf                	mov    %ecx,%edi
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80572f0:	89 d9                	mov    %ebx,%ecx
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 80572f2:	83 ec 08             	sub    $0x8,%esp
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 80572f5:	c1 e7 06             	shl    $0x6,%edi
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80572f8:	66 c1 f9 0f          	sar    $0xf,%cx
 80572fc:	c1 e1 07             	shl    $0x7,%ecx
 80572ff:	09 f8                	or     %edi,%eax
 8057301:	09 c8                	or     %ecx,%eax
 8057303:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057308:	89 f0                	mov    %esi,%eax
 805730a:	31 d8                	xor    %ebx,%eax
	OPERAND_W(op_dest, res);
 805730c:	0f b7 db             	movzwl %bx,%ebx
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 805730f:	21 d0                	and    %edx,%eax
 8057311:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
	OPERAND_W(op_dest, res);
 8057318:	53                   	push   %ebx
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057319:	83 e0 01             	and    $0x1,%eax
	OPERAND_W(op_dest, res);
 805731c:	68 40 af 0f 10       	push   $0x100faf40
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057321:	c1 e0 03             	shl    $0x3,%eax
 8057324:	83 e2 f7             	and    $0xfffffff7,%edx
 8057327:	09 d0                	or     %edx,%eax
 8057329:	a2 e5 af 0f 10       	mov    %al,0x100fafe5
	OPERAND_W(op_dest, res);
 805732e:	e8 9d 57 00 00       	call   805cad0 <write_operand_w>
	print_asm_template2();
 8057333:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 805733a:	68 18 af 0f 10       	push   $0x100faf18
 805733f:	68 24 3d 06 08       	push   $0x8063d24
 8057344:	6a 50                	push   $0x50
 8057346:	68 00 8a 0c 08       	push   $0x80c8a00
 805734b:	e8 b0 17 ff ff       	call   8048b00 <snprintf@plt>
 8057350:	83 c4 20             	add    $0x20,%esp
 8057353:	83 f8 4f             	cmp    $0x4f,%eax
 8057356:	7f 08                	jg     8057360 <do_adc_w+0xf0>
}
 8057358:	83 c4 0c             	add    $0xc,%esp
 805735b:	5b                   	pop    %ebx
 805735c:	5e                   	pop    %esi
 805735d:	5f                   	pop    %edi
 805735e:	5d                   	pop    %ebp
 805735f:	c3                   	ret    
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8057360:	83 ec 0c             	sub    $0xc,%esp
 8057363:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8057369:	e8 f2 15 ff ff       	call   8048960 <fflush@plt>
 805736e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8057374:	6a 07                	push   $0x7
 8057376:	6a 01                	push   $0x1
 8057378:	68 92 e8 05 08       	push   $0x805e892
 805737d:	e8 8e 16 ff ff       	call   8048a10 <fwrite@plt>
 8057382:	83 c4 20             	add    $0x20,%esp
 8057385:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805738b:	6a 10                	push   $0x10
 805738d:	6a 01                	push   $0x1
 805738f:	68 b4 f3 05 08       	push   $0x805f3b4
 8057394:	e8 77 16 ff ff       	call   8048a10 <fwrite@plt>
 8057399:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805739f:	6a 05                	push   $0x5
 80573a1:	6a 01                	push   $0x1
 80573a3:	68 42 f3 05 08       	push   $0x805f342
 80573a8:	e8 63 16 ff ff       	call   8048a10 <fwrite@plt>
 80573ad:	83 c4 14             	add    $0x14,%esp
 80573b0:	68 50 af 0f 10       	push   $0x100faf50
 80573b5:	68 18 af 0f 10       	push   $0x100faf18
 80573ba:	68 24 3d 06 08       	push   $0x8063d24
 80573bf:	6a 50                	push   $0x50
 80573c1:	68 00 8a 0c 08       	push   $0x80c8a00
 80573c6:	e8 35 17 ff ff       	call   8048b00 <snprintf@plt>
 80573cb:	83 c4 20             	add    $0x20,%esp
 80573ce:	83 f8 4f             	cmp    $0x4f,%eax
 80573d1:	7e 85                	jle    8057358 <do_adc_w+0xe8>
 80573d3:	68 98 3e 06 08       	push   $0x8063e98
 80573d8:	6a 1d                	push   $0x1d
 80573da:	68 3c 3d 06 08       	push   $0x8063d3c
 80573df:	68 c8 3d 06 08       	push   $0x8063dc8
 80573e4:	e8 c7 17 ff ff       	call   8048bb0 <__assert_fail@plt>
 80573e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80573f0:	c1 e9 0f             	shr    $0xf,%ecx
 80573f3:	83 e0 fe             	and    $0xfffffffe,%eax
 80573f6:	21 f9                	and    %edi,%ecx
 80573f8:	83 e1 01             	and    $0x1,%ecx
 80573fb:	09 c8                	or     %ecx,%eax
 80573fd:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
 8057402:	e9 ad fe ff ff       	jmp    80572b4 <do_adc_w+0x44>
 8057407:	89 f6                	mov    %esi,%esi
 8057409:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08057410 <adc_i2a_w>:
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(i2a)
 8057410:	53                   	push   %ebx
 8057411:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057414:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057418:	83 c0 01             	add    $0x1,%eax
 805741b:	50                   	push   %eax
 805741c:	e8 6f 54 00 00       	call   805c890 <decode_i2a_w>
 8057421:	89 c3                	mov    %eax,%ebx
	execute();
 8057423:	e8 48 fe ff ff       	call   8057270 <do_adc_w>
 8057428:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805742b:	8d 43 01             	lea    0x1(%ebx),%eax
 805742e:	5b                   	pop    %ebx
 805742f:	c3                   	ret    

08057430 <adc_i2rm_w>:
make_instr_helper(i2rm)
 8057430:	53                   	push   %ebx
 8057431:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057434:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057438:	83 c0 01             	add    $0x1,%eax
 805743b:	50                   	push   %eax
 805743c:	e8 cf 54 00 00       	call   805c910 <decode_i2rm_w>
 8057441:	89 c3                	mov    %eax,%ebx
	execute();
 8057443:	e8 28 fe ff ff       	call   8057270 <do_adc_w>
 8057448:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805744b:	8d 43 01             	lea    0x1(%ebx),%eax
 805744e:	5b                   	pop    %ebx
 805744f:	c3                   	ret    

08057450 <adc_r2rm_w>:
make_instr_helper(r2rm)
 8057450:	53                   	push   %ebx
 8057451:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057454:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057458:	83 c0 01             	add    $0x1,%eax
 805745b:	50                   	push   %eax
 805745c:	e8 ef 53 00 00       	call   805c850 <decode_r2rm_w>
 8057461:	89 c3                	mov    %eax,%ebx
	execute();
 8057463:	e8 08 fe ff ff       	call   8057270 <do_adc_w>
 8057468:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805746b:	8d 43 01             	lea    0x1(%ebx),%eax
 805746e:	5b                   	pop    %ebx
 805746f:	c3                   	ret    

08057470 <adc_rm2r_w>:
make_instr_helper(rm2r)
 8057470:	53                   	push   %ebx
 8057471:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057474:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057478:	83 c0 01             	add    $0x1,%eax
 805747b:	50                   	push   %eax
 805747c:	e8 ef 53 00 00       	call   805c870 <decode_rm2r_w>
 8057481:	89 c3                	mov    %eax,%ebx
	execute();
 8057483:	e8 e8 fd ff ff       	call   8057270 <do_adc_w>
 8057488:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805748b:	8d 43 01             	lea    0x1(%ebx),%eax
 805748e:	5b                   	pop    %ebx
 805748f:	c3                   	ret    

08057490 <adc_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8057490:	53                   	push   %ebx
 8057491:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057494:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057498:	83 c0 01             	add    $0x1,%eax
 805749b:	50                   	push   %eax
 805749c:	e8 ef 54 00 00       	call   805c990 <decode_si2rm_w>
 80574a1:	89 c3                	mov    %eax,%ebx
	execute();
 80574a3:	e8 c8 fd ff ff       	call   8057270 <do_adc_w>
 80574a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80574ab:	8d 43 01             	lea    0x1(%ebx),%eax
 80574ae:	5b                   	pop    %ebx
 80574af:	c3                   	ret    

080574b0 <do_adc_l>:
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 80574b0:	0f b6 05 e4 af 0f 10 	movzbl 0x100fafe4,%eax
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
 80574b7:	57                   	push   %edi
 80574b8:	56                   	push   %esi
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 80574b9:	8b 35 4c af 0f 10    	mov    0x100faf4c,%esi
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
 80574bf:	53                   	push   %ebx
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 80574c0:	8b 1d 14 af 0f 10    	mov    0x100faf14,%ebx
 80574c6:	89 c2                	mov    %eax,%edx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80574c8:	89 f7                	mov    %esi,%edi
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
 80574ca:	8d 0c 1e             	lea    (%esi,%ebx,1),%ecx
 80574cd:	83 e2 01             	and    $0x1,%edx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80574d0:	c1 ef 1f             	shr    $0x1f,%edi
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 80574d3:	01 ca                	add    %ecx,%edx
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80574d5:	89 d9                	mov    %ebx,%ecx
#endif
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 80574d7:	0f 88 43 01 00 00    	js     8057620 <do_adc_l+0x170>
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
	}
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
 80574dd:	c1 e9 1f             	shr    $0x1f,%ecx
 80574e0:	83 e0 fe             	and    $0xfffffffe,%eax
 80574e3:	09 f9                	or     %edi,%ecx
 80574e5:	09 c8                	or     %ecx,%eax
 80574e7:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr adc

static void do_execute() {
 80574ec:	31 c0                	xor    %eax,%eax
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 80574ee:	31 c9                	xor    %ecx,%ecx
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
 80574f0:	89 d7                	mov    %edx,%edi
 80574f2:	d3 ff                	sar    %cl,%edi
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 80574f4:	83 c1 01             	add    $0x1,%ecx
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
 80574f7:	83 e7 01             	and    $0x1,%edi
 80574fa:	31 f8                	xor    %edi,%eax
 80574fc:	83 e0 01             	and    $0x1,%eax
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
 80574ff:	83 f9 20             	cmp    $0x20,%ecx
 8057502:	75 ec                	jne    80574f0 <do_adc_l+0x40>
 8057504:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 805750b:	c1 e0 02             	shl    $0x2,%eax
 805750e:	83 e1 fb             	and    $0xfffffffb,%ecx
 8057511:	09 c8                	or     %ecx,%eax
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 8057513:	85 d2                	test   %edx,%edx
 8057515:	0f 94 c1             	sete   %cl
 8057518:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 805751b:	31 d3                	xor    %edx,%ebx
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 805751d:	c1 e1 06             	shl    $0x6,%ecx
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 8057520:	83 ec 08             	sub    $0x8,%esp
	cpu.PF = 0;
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
 8057523:	89 cf                	mov    %ecx,%edi
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8057525:	89 d1                	mov    %edx,%ecx
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 8057527:	52                   	push   %edx
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8057528:	c1 e9 1f             	shr    $0x1f,%ecx
 805752b:	09 f8                	or     %edi,%eax
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 805752d:	68 40 af 0f 10       	push   $0x100faf40
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8057532:	c1 e1 07             	shl    $0x7,%ecx
 8057535:	09 c8                	or     %ecx,%eax
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057537:	0f b6 0d e5 af 0f 10 	movzbl 0x100fafe5,%ecx
	int i;
	for(i = 0; i < (DATA_BYTE << 3); i ++) {
		cpu.PF = cpu.PF ^ ((res >> i) & 1);
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 805753e:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8057543:	89 f0                	mov    %esi,%eax
 8057545:	31 d0                	xor    %edx,%eax
 8057547:	21 d8                	and    %ebx,%eax
 8057549:	83 e0 01             	and    $0x1,%eax
 805754c:	83 e1 f7             	and    $0xfffffff7,%ecx
 805754f:	c1 e0 03             	shl    $0x3,%eax
 8057552:	09 c8                	or     %ecx,%eax
 8057554:	a2 e5 af 0f 10       	mov    %al,0x100fafe5
	OPERAND_W(op_dest, res);
 8057559:	e8 42 59 00 00       	call   805cea0 <write_operand_l>
	print_asm_template2();
 805755e:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 8057565:	68 18 af 0f 10       	push   $0x100faf18
 805756a:	68 2f 3d 06 08       	push   $0x8063d2f
 805756f:	6a 50                	push   $0x50
 8057571:	68 00 8a 0c 08       	push   $0x80c8a00
 8057576:	e8 85 15 ff ff       	call   8048b00 <snprintf@plt>
 805757b:	83 c4 20             	add    $0x20,%esp
 805757e:	83 f8 4f             	cmp    $0x4f,%eax
 8057581:	7f 0d                	jg     8057590 <do_adc_l+0xe0>
}
 8057583:	5b                   	pop    %ebx
 8057584:	5e                   	pop    %esi
 8057585:	5f                   	pop    %edi
 8057586:	c3                   	ret    
 8057587:	89 f6                	mov    %esi,%esi
 8057589:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	}
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8057590:	83 ec 0c             	sub    $0xc,%esp
 8057593:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8057599:	e8 c2 13 ff ff       	call   8048960 <fflush@plt>
 805759e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80575a4:	6a 07                	push   $0x7
 80575a6:	6a 01                	push   $0x1
 80575a8:	68 92 e8 05 08       	push   $0x805e892
 80575ad:	e8 5e 14 ff ff       	call   8048a10 <fwrite@plt>
 80575b2:	83 c4 20             	add    $0x20,%esp
 80575b5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80575bb:	6a 10                	push   $0x10
 80575bd:	6a 01                	push   $0x1
 80575bf:	68 b4 f3 05 08       	push   $0x805f3b4
 80575c4:	e8 47 14 ff ff       	call   8048a10 <fwrite@plt>
 80575c9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80575cf:	6a 05                	push   $0x5
 80575d1:	6a 01                	push   $0x1
 80575d3:	68 42 f3 05 08       	push   $0x805f342
 80575d8:	e8 33 14 ff ff       	call   8048a10 <fwrite@plt>
 80575dd:	83 c4 14             	add    $0x14,%esp
 80575e0:	68 50 af 0f 10       	push   $0x100faf50
 80575e5:	68 18 af 0f 10       	push   $0x100faf18
 80575ea:	68 2f 3d 06 08       	push   $0x8063d2f
 80575ef:	6a 50                	push   $0x50
 80575f1:	68 00 8a 0c 08       	push   $0x80c8a00
 80575f6:	e8 05 15 ff ff       	call   8048b00 <snprintf@plt>
 80575fb:	83 c4 20             	add    $0x20,%esp
 80575fe:	83 f8 4f             	cmp    $0x4f,%eax
 8057601:	7e 80                	jle    8057583 <do_adc_l+0xd3>
 8057603:	68 8f 3e 06 08       	push   $0x8063e8f
 8057608:	6a 1d                	push   $0x1d
 805760a:	68 3c 3d 06 08       	push   $0x8063d3c
 805760f:	68 2c 3e 06 08       	push   $0x8063e2c
 8057614:	e8 97 15 ff ff       	call   8048bb0 <__assert_fail@plt>
 8057619:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#define instr adc

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val + cpu.CF;
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8057620:	c1 e9 1f             	shr    $0x1f,%ecx
 8057623:	83 e0 fe             	and    $0xfffffffe,%eax
 8057626:	21 f9                	and    %edi,%ecx
 8057628:	09 c8                	or     %ecx,%eax
 805762a:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
 805762f:	e9 b8 fe ff ff       	jmp    80574ec <do_adc_l+0x3c>
 8057634:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805763a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08057640 <adc_i2a_l>:
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(i2a)
 8057640:	53                   	push   %ebx
 8057641:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057644:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057648:	83 c0 01             	add    $0x1,%eax
 805764b:	50                   	push   %eax
 805764c:	e8 0f 56 00 00       	call   805cc60 <decode_i2a_l>
 8057651:	89 c3                	mov    %eax,%ebx
	execute();
 8057653:	e8 58 fe ff ff       	call   80574b0 <do_adc_l>
 8057658:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805765b:	8d 43 01             	lea    0x1(%ebx),%eax
 805765e:	5b                   	pop    %ebx
 805765f:	c3                   	ret    

08057660 <adc_i2rm_l>:
make_instr_helper(i2rm)
 8057660:	53                   	push   %ebx
 8057661:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057664:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057668:	83 c0 01             	add    $0x1,%eax
 805766b:	50                   	push   %eax
 805766c:	e8 6f 56 00 00       	call   805cce0 <decode_i2rm_l>
 8057671:	89 c3                	mov    %eax,%ebx
	execute();
 8057673:	e8 38 fe ff ff       	call   80574b0 <do_adc_l>
 8057678:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805767b:	8d 43 01             	lea    0x1(%ebx),%eax
 805767e:	5b                   	pop    %ebx
 805767f:	c3                   	ret    

08057680 <adc_r2rm_l>:
make_instr_helper(r2rm)
 8057680:	53                   	push   %ebx
 8057681:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057684:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057688:	83 c0 01             	add    $0x1,%eax
 805768b:	50                   	push   %eax
 805768c:	e8 8f 55 00 00       	call   805cc20 <decode_r2rm_l>
 8057691:	89 c3                	mov    %eax,%ebx
	execute();
 8057693:	e8 18 fe ff ff       	call   80574b0 <do_adc_l>
 8057698:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805769b:	8d 43 01             	lea    0x1(%ebx),%eax
 805769e:	5b                   	pop    %ebx
 805769f:	c3                   	ret    

080576a0 <adc_rm2r_l>:
make_instr_helper(rm2r)
 80576a0:	53                   	push   %ebx
 80576a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80576a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80576a8:	83 c0 01             	add    $0x1,%eax
 80576ab:	50                   	push   %eax
 80576ac:	e8 8f 55 00 00       	call   805cc40 <decode_rm2r_l>
 80576b1:	89 c3                	mov    %eax,%ebx
	execute();
 80576b3:	e8 f8 fd ff ff       	call   80574b0 <do_adc_l>
 80576b8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80576bb:	8d 43 01             	lea    0x1(%ebx),%eax
 80576be:	5b                   	pop    %ebx
 80576bf:	c3                   	ret    

080576c0 <adc_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 80576c0:	53                   	push   %ebx
 80576c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80576c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80576c8:	83 c0 01             	add    $0x1,%eax
 80576cb:	50                   	push   %eax
 80576cc:	e8 8f 56 00 00       	call   805cd60 <decode_si2rm_l>
 80576d1:	89 c3                	mov    %eax,%ebx
	execute();
 80576d3:	e8 d8 fd ff ff       	call   80574b0 <do_adc_l>
 80576d8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80576db:	8d 43 01             	lea    0x1(%ebx),%eax
 80576de:	5b                   	pop    %ebx
 80576df:	c3                   	ret    

080576e0 <adc_i2a_b>:
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(i2a)
 80576e0:	53                   	push   %ebx
 80576e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80576e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80576e8:	83 c0 01             	add    $0x1,%eax
 80576eb:	50                   	push   %eax
 80576ec:	e8 6f 4e 00 00       	call   805c560 <decode_i2a_b>
 80576f1:	89 c3                	mov    %eax,%ebx
	execute();
 80576f3:	e8 d8 f9 ff ff       	call   80570d0 <do_adc_b>
 80576f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80576fb:	8d 43 01             	lea    0x1(%ebx),%eax
 80576fe:	5b                   	pop    %ebx
 80576ff:	c3                   	ret    

08057700 <adc_i2rm_b>:
make_instr_helper(i2rm)
 8057700:	53                   	push   %ebx
 8057701:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057704:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057708:	83 c0 01             	add    $0x1,%eax
 805770b:	50                   	push   %eax
 805770c:	e8 cf 4e 00 00       	call   805c5e0 <decode_i2rm_b>
 8057711:	89 c3                	mov    %eax,%ebx
	execute();
 8057713:	e8 b8 f9 ff ff       	call   80570d0 <do_adc_b>
 8057718:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805771b:	8d 43 01             	lea    0x1(%ebx),%eax
 805771e:	5b                   	pop    %ebx
 805771f:	c3                   	ret    

08057720 <adc_r2rm_b>:
make_instr_helper(r2rm)
 8057720:	53                   	push   %ebx
 8057721:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057724:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057728:	83 c0 01             	add    $0x1,%eax
 805772b:	50                   	push   %eax
 805772c:	e8 ef 4d 00 00       	call   805c520 <decode_r2rm_b>
 8057731:	89 c3                	mov    %eax,%ebx
	execute();
 8057733:	e8 98 f9 ff ff       	call   80570d0 <do_adc_b>
 8057738:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805773b:	8d 43 01             	lea    0x1(%ebx),%eax
 805773e:	5b                   	pop    %ebx
 805773f:	c3                   	ret    

08057740 <adc_rm2r_b>:
make_instr_helper(rm2r)
 8057740:	53                   	push   %ebx
 8057741:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057744:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057748:	83 c0 01             	add    $0x1,%eax
 805774b:	50                   	push   %eax
 805774c:	e8 ef 4d 00 00       	call   805c540 <decode_rm2r_b>
 8057751:	89 c3                	mov    %eax,%ebx
	execute();
 8057753:	e8 78 f9 ff ff       	call   80570d0 <do_adc_b>
 8057758:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805775b:	8d 43 01             	lea    0x1(%ebx),%eax
 805775e:	5b                   	pop    %ebx
 805775f:	c3                   	ret    

08057760 <adc_r2rm_v>:
#include "adc-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(adc_r2rm)
 8057760:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8057767:	8b 54 24 04          	mov    0x4(%esp),%edx
 805776b:	b8 50 74 05 08       	mov    $0x8057450,%eax
 8057770:	75 05                	jne    8057777 <adc_r2rm_v+0x17>
 8057772:	b8 80 76 05 08       	mov    $0x8057680,%eax
 8057777:	89 54 24 04          	mov    %edx,0x4(%esp)
 805777b:	ff e0                	jmp    *%eax
 805777d:	8d 76 00             	lea    0x0(%esi),%esi

08057780 <adc_rm2r_v>:
make_helper_v(adc_rm2r)
 8057780:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8057787:	8b 54 24 04          	mov    0x4(%esp),%edx
 805778b:	b8 70 74 05 08       	mov    $0x8057470,%eax
 8057790:	75 05                	jne    8057797 <adc_rm2r_v+0x17>
 8057792:	b8 a0 76 05 08       	mov    $0x80576a0,%eax
 8057797:	89 54 24 04          	mov    %edx,0x4(%esp)
 805779b:	ff e0                	jmp    *%eax
 805779d:	8d 76 00             	lea    0x0(%esi),%esi

080577a0 <adc_i2rm_v>:
make_helper_v(adc_i2rm)
 80577a0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80577a7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80577ab:	b8 30 74 05 08       	mov    $0x8057430,%eax
 80577b0:	75 05                	jne    80577b7 <adc_i2rm_v+0x17>
 80577b2:	b8 60 76 05 08       	mov    $0x8057660,%eax
 80577b7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80577bb:	ff e0                	jmp    *%eax
 80577bd:	8d 76 00             	lea    0x0(%esi),%esi

080577c0 <adc_si2rm_v>:
make_helper_v(adc_si2rm)
 80577c0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80577c7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80577cb:	b8 90 74 05 08       	mov    $0x8057490,%eax
 80577d0:	75 05                	jne    80577d7 <adc_si2rm_v+0x17>
 80577d2:	b8 c0 76 05 08       	mov    $0x80576c0,%eax
 80577d7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80577db:	ff e0                	jmp    *%eax
 80577dd:	8d 76 00             	lea    0x0(%esi),%esi

080577e0 <adc_i2a_v>:
make_helper_v(adc_i2a)
 80577e0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80577e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80577eb:	b8 10 74 05 08       	mov    $0x8057410,%eax
 80577f0:	75 05                	jne    80577f7 <adc_i2a_v+0x17>
 80577f2:	b8 40 76 05 08       	mov    $0x8057640,%eax
 80577f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80577fb:	ff e0                	jmp    *%eax
 80577fd:	66 90                	xchg   %ax,%ax
 80577ff:	90                   	nop

08057800 <do_sub_b>:
#include "cpu/exec/template-start.h"

#define instr sub

static void do_execute() {
 8057800:	55                   	push   %ebp
 8057801:	57                   	push   %edi
 8057802:	56                   	push   %esi
 8057803:	53                   	push   %ebx
 8057804:	83 ec 14             	sub    $0x14,%esp
	uint32_t res = op_dest->val - op_src->val;
 8057807:	8b 1d 14 af 0f 10    	mov    0x100faf14,%ebx
 805780d:	8b 0d 4c af 0f 10    	mov    0x100faf4c,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 8057813:	0f b6 2d e4 af 0f 10 	movzbl 0x100fafe4,%ebp
#include "cpu/exec/template-start.h"

#define instr sub

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
 805781a:	29 d9                	sub    %ebx,%ecx
	uint32_t pf = (res & 255);
 805781c:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
 805781f:	89 c6                	mov    %eax,%esi
 8057821:	c1 ee 04             	shr    $0x4,%esi
 8057824:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 8057826:	89 c6                	mov    %eax,%esi
 8057828:	c1 ee 02             	shr    $0x2,%esi
 805782b:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 805782d:	89 c6                	mov    %eax,%esi
 805782f:	d1 ee                	shr    %esi
	cpu.CF = op_dest->val < op_src->val;
 8057831:	39 1d 4c af 0f 10    	cmp    %ebx,0x100faf4c
 8057837:	0f 92 c2             	setb   %dl
static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805783a:	31 f0                	xor    %esi,%eax
	cpu.CF = op_dest->val < op_src->val;
 805783c:	83 e5 fa             	and    $0xfffffffa,%ebp
	cpu.PF = (pf & 1);
 805783f:	83 e0 01             	and    $0x1,%eax
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 8057842:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
 8057844:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 805784b:	89 e8                	mov    %ebp,%eax
 805784d:	09 f8                	or     %edi,%eax
 805784f:	09 f0                	or     %esi,%eax
	cpu.ZF = (res == 0);
 8057851:	85 c9                	test   %ecx,%ecx
 8057853:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 8057856:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 8057859:	83 e0 3f             	and    $0x3f,%eax
 805785c:	89 d6                	mov    %edx,%esi
	cpu.SF = (res >> 31) & 1;
 805785e:	89 cf                	mov    %ecx,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057860:	0f b6 15 4c af 0f 10 	movzbl 0x100faf4c,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 8057867:	c1 e6 06             	shl    $0x6,%esi
	cpu.SF = (res >> 31) & 1;
 805786a:	c1 e7 07             	shl    $0x7,%edi
 805786d:	09 f0                	or     %esi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805786f:	8b 35 4c af 0f 10    	mov    0x100faf4c,%esi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 8057875:	09 f8                	or     %edi,%eax
 8057877:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805787c:	89 d8                	mov    %ebx,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 805787e:	29 da                	sub    %ebx,%edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057880:	c1 ee 1f             	shr    $0x1f,%esi
 8057883:	c1 e8 1f             	shr    $0x1f,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057886:	0f b6 d2             	movzbl %dl,%edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057889:	31 f0                	xor    %esi,%eax
 805788b:	31 f1                	xor    %esi,%ecx
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 805788d:	52                   	push   %edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805788e:	21 c1                	and    %eax,%ecx
 8057890:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057897:	68 40 af 0f 10       	push   $0x100faf40
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805789c:	c1 e1 03             	shl    $0x3,%ecx
 805789f:	83 e0 f7             	and    $0xfffffff7,%eax
 80578a2:	09 c1                	or     %eax,%ecx
 80578a4:	88 0d e5 af 0f 10    	mov    %cl,0x100fafe5
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 80578aa:	e8 91 4e 00 00       	call   805c740 <write_operand_b>
	print_asm_template2();
 80578af:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 80578b6:	68 18 af 0f 10       	push   $0x100faf18
 80578bb:	68 aa 3e 06 08       	push   $0x8063eaa
 80578c0:	6a 50                	push   $0x50
 80578c2:	68 00 8a 0c 08       	push   $0x80c8a00
 80578c7:	e8 34 12 ff ff       	call   8048b00 <snprintf@plt>
 80578cc:	83 c4 20             	add    $0x20,%esp
 80578cf:	83 f8 4f             	cmp    $0x4f,%eax
 80578d2:	7f 0c                	jg     80578e0 <do_sub_b+0xe0>
}
 80578d4:	83 c4 0c             	add    $0xc,%esp
 80578d7:	5b                   	pop    %ebx
 80578d8:	5e                   	pop    %esi
 80578d9:	5f                   	pop    %edi
 80578da:	5d                   	pop    %ebp
 80578db:	c3                   	ret    
 80578dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
 80578e0:	83 ec 0c             	sub    $0xc,%esp
 80578e3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80578e9:	e8 72 10 ff ff       	call   8048960 <fflush@plt>
 80578ee:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80578f4:	6a 07                	push   $0x7
 80578f6:	6a 01                	push   $0x1
 80578f8:	68 92 e8 05 08       	push   $0x805e892
 80578fd:	e8 0e 11 ff ff       	call   8048a10 <fwrite@plt>
 8057902:	83 c4 20             	add    $0x20,%esp
 8057905:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805790b:	6a 10                	push   $0x10
 805790d:	6a 01                	push   $0x1
 805790f:	68 b4 f3 05 08       	push   $0x805f3b4
 8057914:	e8 f7 10 ff ff       	call   8048a10 <fwrite@plt>
 8057919:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805791f:	6a 05                	push   $0x5
 8057921:	6a 01                	push   $0x1
 8057923:	68 42 f3 05 08       	push   $0x805f342
 8057928:	e8 e3 10 ff ff       	call   8048a10 <fwrite@plt>
 805792d:	83 c4 14             	add    $0x14,%esp
 8057930:	68 50 af 0f 10       	push   $0x100faf50
 8057935:	68 18 af 0f 10       	push   $0x100faf18
 805793a:	68 aa 3e 06 08       	push   $0x8063eaa
 805793f:	6a 50                	push   $0x50
 8057941:	68 00 8a 0c 08       	push   $0x80c8a00
 8057946:	e8 b5 11 ff ff       	call   8048b00 <snprintf@plt>
 805794b:	83 c4 20             	add    $0x20,%esp
 805794e:	83 f8 4f             	cmp    $0x4f,%eax
 8057951:	7e 81                	jle    80578d4 <do_sub_b+0xd4>
 8057953:	68 31 40 06 08       	push   $0x8064031
 8057958:	6a 11                	push   $0x11
 805795a:	68 cc 3e 06 08       	push   $0x8063ecc
 805795f:	68 f4 3e 06 08       	push   $0x8063ef4
 8057964:	e8 47 12 ff ff       	call   8048bb0 <__assert_fail@plt>
 8057969:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08057970 <do_sub_w>:
#include "cpu/exec/template-start.h"

#define instr sub

static void do_execute() {
 8057970:	55                   	push   %ebp
 8057971:	57                   	push   %edi
 8057972:	56                   	push   %esi
 8057973:	53                   	push   %ebx
 8057974:	83 ec 14             	sub    $0x14,%esp
	uint32_t res = op_dest->val - op_src->val;
 8057977:	8b 1d 14 af 0f 10    	mov    0x100faf14,%ebx
 805797d:	8b 0d 4c af 0f 10    	mov    0x100faf4c,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 8057983:	0f b6 2d e4 af 0f 10 	movzbl 0x100fafe4,%ebp
#include "cpu/exec/template-start.h"

#define instr sub

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
 805798a:	29 d9                	sub    %ebx,%ecx
	uint32_t pf = (res & 255);
 805798c:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
 805798f:	89 c6                	mov    %eax,%esi
 8057991:	c1 ee 04             	shr    $0x4,%esi
 8057994:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 8057996:	89 c6                	mov    %eax,%esi
 8057998:	c1 ee 02             	shr    $0x2,%esi
 805799b:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 805799d:	89 c6                	mov    %eax,%esi
 805799f:	d1 ee                	shr    %esi
	cpu.CF = op_dest->val < op_src->val;
 80579a1:	39 1d 4c af 0f 10    	cmp    %ebx,0x100faf4c
 80579a7:	0f 92 c2             	setb   %dl
static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 80579aa:	31 f0                	xor    %esi,%eax
	cpu.CF = op_dest->val < op_src->val;
 80579ac:	83 e5 fa             	and    $0xfffffffa,%ebp
	cpu.PF = (pf & 1);
 80579af:	83 e0 01             	and    $0x1,%eax
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 80579b2:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
 80579b4:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 80579bb:	89 e8                	mov    %ebp,%eax
 80579bd:	09 f8                	or     %edi,%eax
 80579bf:	09 f0                	or     %esi,%eax
	cpu.ZF = (res == 0);
 80579c1:	85 c9                	test   %ecx,%ecx
 80579c3:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 80579c6:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 80579c9:	83 e0 3f             	and    $0x3f,%eax
 80579cc:	89 d6                	mov    %edx,%esi
	cpu.SF = (res >> 31) & 1;
 80579ce:	89 cf                	mov    %ecx,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 80579d0:	0f b7 15 4c af 0f 10 	movzwl 0x100faf4c,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 80579d7:	c1 e6 06             	shl    $0x6,%esi
	cpu.SF = (res >> 31) & 1;
 80579da:	c1 e7 07             	shl    $0x7,%edi
 80579dd:	09 f0                	or     %esi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 80579df:	8b 35 4c af 0f 10    	mov    0x100faf4c,%esi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 80579e5:	09 f8                	or     %edi,%eax
 80579e7:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 80579ec:	89 d8                	mov    %ebx,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 80579ee:	29 da                	sub    %ebx,%edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 80579f0:	c1 ee 1f             	shr    $0x1f,%esi
 80579f3:	c1 e8 1f             	shr    $0x1f,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 80579f6:	0f b7 d2             	movzwl %dx,%edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 80579f9:	31 f0                	xor    %esi,%eax
 80579fb:	31 f1                	xor    %esi,%ecx
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 80579fd:	52                   	push   %edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 80579fe:	21 c1                	and    %eax,%ecx
 8057a00:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057a07:	68 40 af 0f 10       	push   $0x100faf40
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057a0c:	c1 e1 03             	shl    $0x3,%ecx
 8057a0f:	83 e0 f7             	and    $0xfffffff7,%eax
 8057a12:	09 c1                	or     %eax,%ecx
 8057a14:	88 0d e5 af 0f 10    	mov    %cl,0x100fafe5
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057a1a:	e8 b1 50 00 00       	call   805cad0 <write_operand_w>
	print_asm_template2();
 8057a1f:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 8057a26:	68 18 af 0f 10       	push   $0x100faf18
 8057a2b:	68 b5 3e 06 08       	push   $0x8063eb5
 8057a30:	6a 50                	push   $0x50
 8057a32:	68 00 8a 0c 08       	push   $0x80c8a00
 8057a37:	e8 c4 10 ff ff       	call   8048b00 <snprintf@plt>
 8057a3c:	83 c4 20             	add    $0x20,%esp
 8057a3f:	83 f8 4f             	cmp    $0x4f,%eax
 8057a42:	7f 0c                	jg     8057a50 <do_sub_w+0xe0>
}
 8057a44:	83 c4 0c             	add    $0xc,%esp
 8057a47:	5b                   	pop    %ebx
 8057a48:	5e                   	pop    %esi
 8057a49:	5f                   	pop    %edi
 8057a4a:	5d                   	pop    %ebp
 8057a4b:	c3                   	ret    
 8057a4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
 8057a50:	83 ec 0c             	sub    $0xc,%esp
 8057a53:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8057a59:	e8 02 0f ff ff       	call   8048960 <fflush@plt>
 8057a5e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8057a64:	6a 07                	push   $0x7
 8057a66:	6a 01                	push   $0x1
 8057a68:	68 92 e8 05 08       	push   $0x805e892
 8057a6d:	e8 9e 0f ff ff       	call   8048a10 <fwrite@plt>
 8057a72:	83 c4 20             	add    $0x20,%esp
 8057a75:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8057a7b:	6a 10                	push   $0x10
 8057a7d:	6a 01                	push   $0x1
 8057a7f:	68 b4 f3 05 08       	push   $0x805f3b4
 8057a84:	e8 87 0f ff ff       	call   8048a10 <fwrite@plt>
 8057a89:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8057a8f:	6a 05                	push   $0x5
 8057a91:	6a 01                	push   $0x1
 8057a93:	68 42 f3 05 08       	push   $0x805f342
 8057a98:	e8 73 0f ff ff       	call   8048a10 <fwrite@plt>
 8057a9d:	83 c4 14             	add    $0x14,%esp
 8057aa0:	68 50 af 0f 10       	push   $0x100faf50
 8057aa5:	68 18 af 0f 10       	push   $0x100faf18
 8057aaa:	68 b5 3e 06 08       	push   $0x8063eb5
 8057aaf:	6a 50                	push   $0x50
 8057ab1:	68 00 8a 0c 08       	push   $0x80c8a00
 8057ab6:	e8 45 10 ff ff       	call   8048b00 <snprintf@plt>
 8057abb:	83 c4 20             	add    $0x20,%esp
 8057abe:	83 f8 4f             	cmp    $0x4f,%eax
 8057ac1:	7e 81                	jle    8057a44 <do_sub_w+0xd4>
 8057ac3:	68 28 40 06 08       	push   $0x8064028
 8057ac8:	6a 11                	push   $0x11
 8057aca:	68 cc 3e 06 08       	push   $0x8063ecc
 8057acf:	68 58 3f 06 08       	push   $0x8063f58
 8057ad4:	e8 d7 10 ff ff       	call   8048bb0 <__assert_fail@plt>
 8057ad9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08057ae0 <sub_i2a_w>:
}

make_instr_helper(i2a)
 8057ae0:	53                   	push   %ebx
 8057ae1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057ae4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057ae8:	83 c0 01             	add    $0x1,%eax
 8057aeb:	50                   	push   %eax
 8057aec:	e8 9f 4d 00 00       	call   805c890 <decode_i2a_w>
 8057af1:	89 c3                	mov    %eax,%ebx
	execute();
 8057af3:	e8 78 fe ff ff       	call   8057970 <do_sub_w>
 8057af8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057afb:	8d 43 01             	lea    0x1(%ebx),%eax
 8057afe:	5b                   	pop    %ebx
 8057aff:	c3                   	ret    

08057b00 <sub_i2rm_w>:
make_instr_helper(i2rm)
 8057b00:	53                   	push   %ebx
 8057b01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057b04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057b08:	83 c0 01             	add    $0x1,%eax
 8057b0b:	50                   	push   %eax
 8057b0c:	e8 ff 4d 00 00       	call   805c910 <decode_i2rm_w>
 8057b11:	89 c3                	mov    %eax,%ebx
	execute();
 8057b13:	e8 58 fe ff ff       	call   8057970 <do_sub_w>
 8057b18:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057b1b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057b1e:	5b                   	pop    %ebx
 8057b1f:	c3                   	ret    

08057b20 <sub_r2rm_w>:
make_instr_helper(r2rm)
 8057b20:	53                   	push   %ebx
 8057b21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057b24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057b28:	83 c0 01             	add    $0x1,%eax
 8057b2b:	50                   	push   %eax
 8057b2c:	e8 1f 4d 00 00       	call   805c850 <decode_r2rm_w>
 8057b31:	89 c3                	mov    %eax,%ebx
	execute();
 8057b33:	e8 38 fe ff ff       	call   8057970 <do_sub_w>
 8057b38:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057b3b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057b3e:	5b                   	pop    %ebx
 8057b3f:	c3                   	ret    

08057b40 <sub_rm2r_w>:
make_instr_helper(rm2r)
 8057b40:	53                   	push   %ebx
 8057b41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057b44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057b48:	83 c0 01             	add    $0x1,%eax
 8057b4b:	50                   	push   %eax
 8057b4c:	e8 1f 4d 00 00       	call   805c870 <decode_rm2r_w>
 8057b51:	89 c3                	mov    %eax,%ebx
	execute();
 8057b53:	e8 18 fe ff ff       	call   8057970 <do_sub_w>
 8057b58:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057b5b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057b5e:	5b                   	pop    %ebx
 8057b5f:	c3                   	ret    

08057b60 <sub_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8057b60:	53                   	push   %ebx
 8057b61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057b64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057b68:	83 c0 01             	add    $0x1,%eax
 8057b6b:	50                   	push   %eax
 8057b6c:	e8 1f 4e 00 00       	call   805c990 <decode_si2rm_w>
 8057b71:	89 c3                	mov    %eax,%ebx
	execute();
 8057b73:	e8 f8 fd ff ff       	call   8057970 <do_sub_w>
 8057b78:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057b7b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057b7e:	5b                   	pop    %ebx
 8057b7f:	c3                   	ret    

08057b80 <do_sub_l>:
#include "cpu/exec/template-start.h"

#define instr sub

static void do_execute() {
 8057b80:	55                   	push   %ebp
 8057b81:	57                   	push   %edi
 8057b82:	56                   	push   %esi
 8057b83:	53                   	push   %ebx
 8057b84:	83 ec 14             	sub    $0x14,%esp
	uint32_t res = op_dest->val - op_src->val;
 8057b87:	8b 0d 4c af 0f 10    	mov    0x100faf4c,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 8057b8d:	0f b6 2d e4 af 0f 10 	movzbl 0x100fafe4,%ebp
#include "cpu/exec/template-start.h"

#define instr sub

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
 8057b94:	89 cb                	mov    %ecx,%ebx
 8057b96:	2b 1d 14 af 0f 10    	sub    0x100faf14,%ebx
	uint32_t pf = (res & 255);
 8057b9c:	0f b6 c3             	movzbl %bl,%eax
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057b9f:	53                   	push   %ebx
 8057ba0:	68 40 af 0f 10       	push   $0x100faf40
#define instr sub

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 8057ba5:	89 c6                	mov    %eax,%esi
 8057ba7:	c1 ee 04             	shr    $0x4,%esi
 8057baa:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 8057bac:	89 c6                	mov    %eax,%esi
 8057bae:	c1 ee 02             	shr    $0x2,%esi
 8057bb1:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 8057bb3:	89 c6                	mov    %eax,%esi
 8057bb5:	d1 ee                	shr    %esi
	cpu.CF = op_dest->val < op_src->val;
 8057bb7:	3b 0d 14 af 0f 10    	cmp    0x100faf14,%ecx
 8057bbd:	0f 92 c2             	setb   %dl
static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 8057bc0:	31 f0                	xor    %esi,%eax
	cpu.CF = op_dest->val < op_src->val;
 8057bc2:	83 e5 fa             	and    $0xfffffffa,%ebp
	cpu.PF = (pf & 1);
 8057bc5:	83 e0 01             	and    $0x1,%eax
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 8057bc8:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
 8057bca:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 8057bd1:	89 e8                	mov    %ebp,%eax
 8057bd3:	09 f8                	or     %edi,%eax
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 8057bd5:	89 df                	mov    %ebx,%edi
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
 8057bd7:	09 f0                	or     %esi,%eax
	cpu.ZF = (res == 0);
 8057bd9:	85 db                	test   %ebx,%ebx
 8057bdb:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 8057bde:	c1 ef 1f             	shr    $0x1f,%edi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 8057be1:	83 e0 3f             	and    $0x3f,%eax
 8057be4:	89 d6                	mov    %edx,%esi
	cpu.SF = (res >> 31) & 1;
 8057be6:	89 fd                	mov    %edi,%ebp
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057be8:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 8057beb:	c1 e6 06             	shl    $0x6,%esi
	cpu.SF = (res >> 31) & 1;
 8057bee:	c1 e5 07             	shl    $0x7,%ebp
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057bf1:	31 cf                	xor    %ecx,%edi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 8057bf3:	09 f0                	or     %esi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057bf5:	89 ca                	mov    %ecx,%edx
 8057bf7:	0f b6 0d e5 af 0f 10 	movzbl 0x100fafe5,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 8057bfe:	09 e8                	or     %ebp,%eax
 8057c00:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 8057c05:	a1 14 af 0f 10       	mov    0x100faf14,%eax
 8057c0a:	83 e1 f7             	and    $0xfffffff7,%ecx
 8057c0d:	c1 e8 1f             	shr    $0x1f,%eax
 8057c10:	31 c2                	xor    %eax,%edx
 8057c12:	21 fa                	and    %edi,%edx
 8057c14:	c1 e2 03             	shl    $0x3,%edx
 8057c17:	09 ca                	or     %ecx,%edx
 8057c19:	88 15 e5 af 0f 10    	mov    %dl,0x100fafe5
	OPERAND_W(op_dest, op_dest->val - op_src->val);
 8057c1f:	e8 7c 52 00 00       	call   805cea0 <write_operand_l>
	print_asm_template2();
 8057c24:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 8057c2b:	68 18 af 0f 10       	push   $0x100faf18
 8057c30:	68 c0 3e 06 08       	push   $0x8063ec0
 8057c35:	6a 50                	push   $0x50
 8057c37:	68 00 8a 0c 08       	push   $0x80c8a00
 8057c3c:	e8 bf 0e ff ff       	call   8048b00 <snprintf@plt>
 8057c41:	83 c4 20             	add    $0x20,%esp
 8057c44:	83 f8 4f             	cmp    $0x4f,%eax
 8057c47:	7f 0f                	jg     8057c58 <do_sub_l+0xd8>
}
 8057c49:	83 c4 0c             	add    $0xc,%esp
 8057c4c:	5b                   	pop    %ebx
 8057c4d:	5e                   	pop    %esi
 8057c4e:	5f                   	pop    %edi
 8057c4f:	5d                   	pop    %ebp
 8057c50:	c3                   	ret    
 8057c51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
 8057c58:	83 ec 0c             	sub    $0xc,%esp
 8057c5b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8057c61:	e8 fa 0c ff ff       	call   8048960 <fflush@plt>
 8057c66:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8057c6c:	6a 07                	push   $0x7
 8057c6e:	6a 01                	push   $0x1
 8057c70:	68 92 e8 05 08       	push   $0x805e892
 8057c75:	e8 96 0d ff ff       	call   8048a10 <fwrite@plt>
 8057c7a:	83 c4 20             	add    $0x20,%esp
 8057c7d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8057c83:	6a 10                	push   $0x10
 8057c85:	6a 01                	push   $0x1
 8057c87:	68 b4 f3 05 08       	push   $0x805f3b4
 8057c8c:	e8 7f 0d ff ff       	call   8048a10 <fwrite@plt>
 8057c91:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8057c97:	6a 05                	push   $0x5
 8057c99:	6a 01                	push   $0x1
 8057c9b:	68 42 f3 05 08       	push   $0x805f342
 8057ca0:	e8 6b 0d ff ff       	call   8048a10 <fwrite@plt>
 8057ca5:	83 c4 14             	add    $0x14,%esp
 8057ca8:	68 50 af 0f 10       	push   $0x100faf50
 8057cad:	68 18 af 0f 10       	push   $0x100faf18
 8057cb2:	68 c0 3e 06 08       	push   $0x8063ec0
 8057cb7:	6a 50                	push   $0x50
 8057cb9:	68 00 8a 0c 08       	push   $0x80c8a00
 8057cbe:	e8 3d 0e ff ff       	call   8048b00 <snprintf@plt>
 8057cc3:	83 c4 20             	add    $0x20,%esp
 8057cc6:	83 f8 4f             	cmp    $0x4f,%eax
 8057cc9:	0f 8e 7a ff ff ff    	jle    8057c49 <do_sub_l+0xc9>
 8057ccf:	68 1f 40 06 08       	push   $0x806401f
 8057cd4:	6a 11                	push   $0x11
 8057cd6:	68 cc 3e 06 08       	push   $0x8063ecc
 8057cdb:	68 bc 3f 06 08       	push   $0x8063fbc
 8057ce0:	e8 cb 0e ff ff       	call   8048bb0 <__assert_fail@plt>
 8057ce5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 8057ce9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08057cf0 <sub_i2a_l>:
}

make_instr_helper(i2a)
 8057cf0:	53                   	push   %ebx
 8057cf1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057cf4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057cf8:	83 c0 01             	add    $0x1,%eax
 8057cfb:	50                   	push   %eax
 8057cfc:	e8 5f 4f 00 00       	call   805cc60 <decode_i2a_l>
 8057d01:	89 c3                	mov    %eax,%ebx
	execute();
 8057d03:	e8 78 fe ff ff       	call   8057b80 <do_sub_l>
 8057d08:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057d0b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057d0e:	5b                   	pop    %ebx
 8057d0f:	c3                   	ret    

08057d10 <sub_i2rm_l>:
make_instr_helper(i2rm)
 8057d10:	53                   	push   %ebx
 8057d11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057d14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057d18:	83 c0 01             	add    $0x1,%eax
 8057d1b:	50                   	push   %eax
 8057d1c:	e8 bf 4f 00 00       	call   805cce0 <decode_i2rm_l>
 8057d21:	89 c3                	mov    %eax,%ebx
	execute();
 8057d23:	e8 58 fe ff ff       	call   8057b80 <do_sub_l>
 8057d28:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057d2b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057d2e:	5b                   	pop    %ebx
 8057d2f:	c3                   	ret    

08057d30 <sub_r2rm_l>:
make_instr_helper(r2rm)
 8057d30:	53                   	push   %ebx
 8057d31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057d34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057d38:	83 c0 01             	add    $0x1,%eax
 8057d3b:	50                   	push   %eax
 8057d3c:	e8 df 4e 00 00       	call   805cc20 <decode_r2rm_l>
 8057d41:	89 c3                	mov    %eax,%ebx
	execute();
 8057d43:	e8 38 fe ff ff       	call   8057b80 <do_sub_l>
 8057d48:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057d4b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057d4e:	5b                   	pop    %ebx
 8057d4f:	c3                   	ret    

08057d50 <sub_rm2r_l>:
make_instr_helper(rm2r)
 8057d50:	53                   	push   %ebx
 8057d51:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057d54:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057d58:	83 c0 01             	add    $0x1,%eax
 8057d5b:	50                   	push   %eax
 8057d5c:	e8 df 4e 00 00       	call   805cc40 <decode_rm2r_l>
 8057d61:	89 c3                	mov    %eax,%ebx
	execute();
 8057d63:	e8 18 fe ff ff       	call   8057b80 <do_sub_l>
 8057d68:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057d6b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057d6e:	5b                   	pop    %ebx
 8057d6f:	c3                   	ret    

08057d70 <sub_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8057d70:	53                   	push   %ebx
 8057d71:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057d74:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057d78:	83 c0 01             	add    $0x1,%eax
 8057d7b:	50                   	push   %eax
 8057d7c:	e8 df 4f 00 00       	call   805cd60 <decode_si2rm_l>
 8057d81:	89 c3                	mov    %eax,%ebx
	execute();
 8057d83:	e8 f8 fd ff ff       	call   8057b80 <do_sub_l>
 8057d88:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057d8b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057d8e:	5b                   	pop    %ebx
 8057d8f:	c3                   	ret    

08057d90 <sub_i2a_b>:
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	OPERAND_W(op_dest, op_dest->val - op_src->val);
	print_asm_template2();
}

make_instr_helper(i2a)
 8057d90:	53                   	push   %ebx
 8057d91:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057d94:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057d98:	83 c0 01             	add    $0x1,%eax
 8057d9b:	50                   	push   %eax
 8057d9c:	e8 bf 47 00 00       	call   805c560 <decode_i2a_b>
 8057da1:	89 c3                	mov    %eax,%ebx
	execute();
 8057da3:	e8 58 fa ff ff       	call   8057800 <do_sub_b>
 8057da8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057dab:	8d 43 01             	lea    0x1(%ebx),%eax
 8057dae:	5b                   	pop    %ebx
 8057daf:	c3                   	ret    

08057db0 <sub_i2rm_b>:
make_instr_helper(i2rm)
 8057db0:	53                   	push   %ebx
 8057db1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057db4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057db8:	83 c0 01             	add    $0x1,%eax
 8057dbb:	50                   	push   %eax
 8057dbc:	e8 1f 48 00 00       	call   805c5e0 <decode_i2rm_b>
 8057dc1:	89 c3                	mov    %eax,%ebx
	execute();
 8057dc3:	e8 38 fa ff ff       	call   8057800 <do_sub_b>
 8057dc8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057dcb:	8d 43 01             	lea    0x1(%ebx),%eax
 8057dce:	5b                   	pop    %ebx
 8057dcf:	c3                   	ret    

08057dd0 <sub_r2rm_b>:
make_instr_helper(r2rm)
 8057dd0:	53                   	push   %ebx
 8057dd1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057dd4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057dd8:	83 c0 01             	add    $0x1,%eax
 8057ddb:	50                   	push   %eax
 8057ddc:	e8 3f 47 00 00       	call   805c520 <decode_r2rm_b>
 8057de1:	89 c3                	mov    %eax,%ebx
	execute();
 8057de3:	e8 18 fa ff ff       	call   8057800 <do_sub_b>
 8057de8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057deb:	8d 43 01             	lea    0x1(%ebx),%eax
 8057dee:	5b                   	pop    %ebx
 8057def:	c3                   	ret    

08057df0 <sub_rm2r_b>:
make_instr_helper(rm2r)
 8057df0:	53                   	push   %ebx
 8057df1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8057df4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8057df8:	83 c0 01             	add    $0x1,%eax
 8057dfb:	50                   	push   %eax
 8057dfc:	e8 3f 47 00 00       	call   805c540 <decode_rm2r_b>
 8057e01:	89 c3                	mov    %eax,%ebx
	execute();
 8057e03:	e8 f8 f9 ff ff       	call   8057800 <do_sub_b>
 8057e08:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8057e0b:	8d 43 01             	lea    0x1(%ebx),%eax
 8057e0e:	5b                   	pop    %ebx
 8057e0f:	c3                   	ret    

08057e10 <sub_si2rm_v>:
#include "sub-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(sub_si2rm)
 8057e10:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8057e17:	8b 54 24 04          	mov    0x4(%esp),%edx
 8057e1b:	b8 60 7b 05 08       	mov    $0x8057b60,%eax
 8057e20:	75 05                	jne    8057e27 <sub_si2rm_v+0x17>
 8057e22:	b8 70 7d 05 08       	mov    $0x8057d70,%eax
 8057e27:	89 54 24 04          	mov    %edx,0x4(%esp)
 8057e2b:	ff e0                	jmp    *%eax
 8057e2d:	8d 76 00             	lea    0x0(%esi),%esi

08057e30 <sub_i2rm_v>:
make_helper_v(sub_i2rm)
 8057e30:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8057e37:	8b 54 24 04          	mov    0x4(%esp),%edx
 8057e3b:	b8 00 7b 05 08       	mov    $0x8057b00,%eax
 8057e40:	75 05                	jne    8057e47 <sub_i2rm_v+0x17>
 8057e42:	b8 10 7d 05 08       	mov    $0x8057d10,%eax
 8057e47:	89 54 24 04          	mov    %edx,0x4(%esp)
 8057e4b:	ff e0                	jmp    *%eax
 8057e4d:	8d 76 00             	lea    0x0(%esi),%esi

08057e50 <sub_i2a_v>:
make_helper_v(sub_i2a)
 8057e50:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8057e57:	8b 54 24 04          	mov    0x4(%esp),%edx
 8057e5b:	b8 e0 7a 05 08       	mov    $0x8057ae0,%eax
 8057e60:	75 05                	jne    8057e67 <sub_i2a_v+0x17>
 8057e62:	b8 f0 7c 05 08       	mov    $0x8057cf0,%eax
 8057e67:	89 54 24 04          	mov    %edx,0x4(%esp)
 8057e6b:	ff e0                	jmp    *%eax
 8057e6d:	8d 76 00             	lea    0x0(%esi),%esi

08057e70 <sub_r2rm_v>:
make_helper_v(sub_r2rm)
 8057e70:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8057e77:	8b 54 24 04          	mov    0x4(%esp),%edx
 8057e7b:	b8 20 7b 05 08       	mov    $0x8057b20,%eax
 8057e80:	75 05                	jne    8057e87 <sub_r2rm_v+0x17>
 8057e82:	b8 30 7d 05 08       	mov    $0x8057d30,%eax
 8057e87:	89 54 24 04          	mov    %edx,0x4(%esp)
 8057e8b:	ff e0                	jmp    *%eax
 8057e8d:	8d 76 00             	lea    0x0(%esi),%esi

08057e90 <sub_rm2r_v>:
make_helper_v(sub_rm2r)
 8057e90:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8057e97:	8b 54 24 04          	mov    0x4(%esp),%edx
 8057e9b:	b8 40 7b 05 08       	mov    $0x8057b40,%eax
 8057ea0:	75 05                	jne    8057ea7 <sub_rm2r_v+0x17>
 8057ea2:	b8 50 7d 05 08       	mov    $0x8057d50,%eax
 8057ea7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8057eab:	ff e0                	jmp    *%eax
 8057ead:	66 90                	xchg   %ax,%ax
 8057eaf:	90                   	nop

08057eb0 <stos_w>:
#include "cpu/exec/template-start.h"

#define instr stos

make_helper(concat(stos_, SUFFIX)) {
 8057eb0:	83 ec 10             	sub    $0x10,%esp
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
 8057eb3:	0f b7 05 c0 af 0f 10 	movzwl 0x100fafc0,%eax
 8057eba:	50                   	push   %eax
 8057ebb:	6a 02                	push   $0x2
 8057ebd:	ff 35 dc af 0f 10    	pushl  0x100fafdc
 8057ec3:	e8 d8 30 ff ff       	call   804afa0 <swaddr_write>
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 8057ec8:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
 8057ecf:	ba 01 00 00 00       	mov    $0x1,%edx
	print_asm_template1();
 8057ed4:	68 18 af 0f 10       	push   $0x100faf18
 8057ed9:	68 3a 40 06 08       	push   $0x806403a
 8057ede:	6a 50                	push   $0x50
 8057ee0:	68 00 8a 0c 08       	push   $0x80c8a00

#define instr stos

make_helper(concat(stos_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 8057ee5:	c0 e8 02             	shr    $0x2,%al
 8057ee8:	83 e0 01             	and    $0x1,%eax
 8057eeb:	01 c0                	add    %eax,%eax
 8057eed:	29 c2                	sub    %eax,%edx
 8057eef:	89 d0                	mov    %edx,%eax
 8057ef1:	01 c0                	add    %eax,%eax
 8057ef3:	01 05 dc af 0f 10    	add    %eax,0x100fafdc
	print_asm_template1();
 8057ef9:	e8 02 0c ff ff       	call   8048b00 <snprintf@plt>
 8057efe:	83 c4 20             	add    $0x20,%esp
 8057f01:	83 f8 4f             	cmp    $0x4f,%eax
 8057f04:	7f 0a                	jg     8057f10 <stos_w+0x60>
	return 1;
}
 8057f06:	b8 01 00 00 00       	mov    $0x1,%eax
 8057f0b:	83 c4 0c             	add    $0xc,%esp
 8057f0e:	c3                   	ret    
 8057f0f:	90                   	nop
#define instr stos

make_helper(concat(stos_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 8057f10:	83 ec 0c             	sub    $0xc,%esp
 8057f13:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8057f19:	e8 42 0a ff ff       	call   8048960 <fflush@plt>
 8057f1e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8057f24:	6a 07                	push   $0x7
 8057f26:	6a 01                	push   $0x1
 8057f28:	68 92 e8 05 08       	push   $0x805e892
 8057f2d:	e8 de 0a ff ff       	call   8048a10 <fwrite@plt>
 8057f32:	83 c4 20             	add    $0x20,%esp
 8057f35:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8057f3b:	6a 10                	push   $0x10
 8057f3d:	6a 01                	push   $0x1
 8057f3f:	68 b4 f3 05 08       	push   $0x805f3b4
 8057f44:	e8 c7 0a ff ff       	call   8048a10 <fwrite@plt>
 8057f49:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8057f4f:	6a 05                	push   $0x5
 8057f51:	6a 01                	push   $0x1
 8057f53:	68 42 f3 05 08       	push   $0x805f342
 8057f58:	e8 b3 0a ff ff       	call   8048a10 <fwrite@plt>
 8057f5d:	83 c4 20             	add    $0x20,%esp
 8057f60:	68 18 af 0f 10       	push   $0x100faf18
 8057f65:	68 3a 40 06 08       	push   $0x806403a
 8057f6a:	6a 50                	push   $0x50
 8057f6c:	68 00 8a 0c 08       	push   $0x80c8a00
 8057f71:	e8 8a 0b ff ff       	call   8048b00 <snprintf@plt>
 8057f76:	83 c4 10             	add    $0x10,%esp
 8057f79:	83 f8 4f             	cmp    $0x4f,%eax
 8057f7c:	7e 88                	jle    8057f06 <stos_w+0x56>
 8057f7e:	68 5e 41 06 08       	push   $0x806415e
 8057f83:	6a 08                	push   $0x8
 8057f85:	68 58 40 06 08       	push   $0x8064058
 8057f8a:	68 80 40 06 08       	push   $0x8064080
 8057f8f:	e8 1c 0c ff ff       	call   8048bb0 <__assert_fail@plt>
 8057f94:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8057f9a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08057fa0 <stos_l>:
#include "cpu/exec/template-start.h"

#define instr stos

make_helper(concat(stos_, SUFFIX)) {
 8057fa0:	83 ec 10             	sub    $0x10,%esp
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
 8057fa3:	ff 35 c0 af 0f 10    	pushl  0x100fafc0
 8057fa9:	6a 04                	push   $0x4
 8057fab:	ff 35 dc af 0f 10    	pushl  0x100fafdc
 8057fb1:	e8 ea 2f ff ff       	call   804afa0 <swaddr_write>
 8057fb6:	a1 dc af 0f 10       	mov    0x100fafdc,%eax
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 8057fbb:	68 18 af 0f 10       	push   $0x100faf18
 8057fc0:	68 43 40 06 08       	push   $0x8064043
 8057fc5:	6a 50                	push   $0x50
 8057fc7:	68 00 8a 0c 08       	push   $0x80c8a00
 8057fcc:	8d 50 04             	lea    0x4(%eax),%edx

#define instr stos

make_helper(concat(stos_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 8057fcf:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
 8057fd6:	c0 e8 02             	shr    $0x2,%al
 8057fd9:	83 e0 01             	and    $0x1,%eax
 8057fdc:	c1 e0 03             	shl    $0x3,%eax
 8057fdf:	29 c2                	sub    %eax,%edx
 8057fe1:	89 15 dc af 0f 10    	mov    %edx,0x100fafdc
	print_asm_template1();
 8057fe7:	e8 14 0b ff ff       	call   8048b00 <snprintf@plt>
 8057fec:	83 c4 20             	add    $0x20,%esp
 8057fef:	83 f8 4f             	cmp    $0x4f,%eax
 8057ff2:	7f 0c                	jg     8058000 <stos_l+0x60>
	return 1;
}
 8057ff4:	b8 01 00 00 00       	mov    $0x1,%eax
 8057ff9:	83 c4 0c             	add    $0xc,%esp
 8057ffc:	c3                   	ret    
 8057ffd:	8d 76 00             	lea    0x0(%esi),%esi
#define instr stos

make_helper(concat(stos_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 8058000:	83 ec 0c             	sub    $0xc,%esp
 8058003:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8058009:	e8 52 09 ff ff       	call   8048960 <fflush@plt>
 805800e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058014:	6a 07                	push   $0x7
 8058016:	6a 01                	push   $0x1
 8058018:	68 92 e8 05 08       	push   $0x805e892
 805801d:	e8 ee 09 ff ff       	call   8048a10 <fwrite@plt>
 8058022:	83 c4 20             	add    $0x20,%esp
 8058025:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805802b:	6a 10                	push   $0x10
 805802d:	6a 01                	push   $0x1
 805802f:	68 b4 f3 05 08       	push   $0x805f3b4
 8058034:	e8 d7 09 ff ff       	call   8048a10 <fwrite@plt>
 8058039:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805803f:	6a 05                	push   $0x5
 8058041:	6a 01                	push   $0x1
 8058043:	68 42 f3 05 08       	push   $0x805f342
 8058048:	e8 c3 09 ff ff       	call   8048a10 <fwrite@plt>
 805804d:	83 c4 20             	add    $0x20,%esp
 8058050:	68 18 af 0f 10       	push   $0x100faf18
 8058055:	68 43 40 06 08       	push   $0x8064043
 805805a:	6a 50                	push   $0x50
 805805c:	68 00 8a 0c 08       	push   $0x80c8a00
 8058061:	e8 9a 0a ff ff       	call   8048b00 <snprintf@plt>
 8058066:	83 c4 10             	add    $0x10,%esp
 8058069:	83 f8 4f             	cmp    $0x4f,%eax
 805806c:	7e 86                	jle    8057ff4 <stos_l+0x54>
 805806e:	68 57 41 06 08       	push   $0x8064157
 8058073:	6a 08                	push   $0x8
 8058075:	68 58 40 06 08       	push   $0x8064058
 805807a:	68 c8 40 06 08       	push   $0x80640c8
 805807f:	e8 2c 0b ff ff       	call   8048bb0 <__assert_fail@plt>
 8058084:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805808a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08058090 <stos_b>:
#include "cpu/exec/template-start.h"

#define instr stos

make_helper(concat(stos_, SUFFIX)) {
 8058090:	83 ec 10             	sub    $0x10,%esp
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
 8058093:	0f b6 05 c0 af 0f 10 	movzbl 0x100fafc0,%eax
 805809a:	50                   	push   %eax
 805809b:	6a 01                	push   $0x1
 805809d:	ff 35 dc af 0f 10    	pushl  0x100fafdc
 80580a3:	e8 f8 2e ff ff       	call   804afa0 <swaddr_write>
 80580a8:	a1 dc af 0f 10       	mov    0x100fafdc,%eax
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 80580ad:	68 18 af 0f 10       	push   $0x100faf18
 80580b2:	68 4c 40 06 08       	push   $0x806404c
 80580b7:	6a 50                	push   $0x50
 80580b9:	68 00 8a 0c 08       	push   $0x80c8a00
 80580be:	8d 50 01             	lea    0x1(%eax),%edx

#define instr stos

make_helper(concat(stos_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
 80580c1:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
 80580c8:	c0 e8 02             	shr    $0x2,%al
 80580cb:	83 e0 01             	and    $0x1,%eax
 80580ce:	01 c0                	add    %eax,%eax
 80580d0:	29 c2                	sub    %eax,%edx
 80580d2:	89 15 dc af 0f 10    	mov    %edx,0x100fafdc
	print_asm_template1();
 80580d8:	e8 23 0a ff ff       	call   8048b00 <snprintf@plt>
 80580dd:	83 c4 20             	add    $0x20,%esp
 80580e0:	83 f8 4f             	cmp    $0x4f,%eax
 80580e3:	7f 0b                	jg     80580f0 <stos_b+0x60>
	return 1;
}
 80580e5:	b8 01 00 00 00       	mov    $0x1,%eax
 80580ea:	83 c4 0c             	add    $0xc,%esp
 80580ed:	c3                   	ret    
 80580ee:	66 90                	xchg   %ax,%ax
#define instr stos

make_helper(concat(stos_, SUFFIX)) {
	swaddr_write(reg_l(R_EDI), DATA_BYTE, (DATA_TYPE) reg_l(R_EAX));
	reg_l(R_EDI) -= (((DATA_TYPE)cpu.DF << 1) - 1) * DATA_BYTE;
	print_asm_template1();
 80580f0:	83 ec 0c             	sub    $0xc,%esp
 80580f3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80580f9:	e8 62 08 ff ff       	call   8048960 <fflush@plt>
 80580fe:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058104:	6a 07                	push   $0x7
 8058106:	6a 01                	push   $0x1
 8058108:	68 92 e8 05 08       	push   $0x805e892
 805810d:	e8 fe 08 ff ff       	call   8048a10 <fwrite@plt>
 8058112:	83 c4 20             	add    $0x20,%esp
 8058115:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805811b:	6a 10                	push   $0x10
 805811d:	6a 01                	push   $0x1
 805811f:	68 b4 f3 05 08       	push   $0x805f3b4
 8058124:	e8 e7 08 ff ff       	call   8048a10 <fwrite@plt>
 8058129:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805812f:	6a 05                	push   $0x5
 8058131:	6a 01                	push   $0x1
 8058133:	68 42 f3 05 08       	push   $0x805f342
 8058138:	e8 d3 08 ff ff       	call   8048a10 <fwrite@plt>
 805813d:	83 c4 20             	add    $0x20,%esp
 8058140:	68 18 af 0f 10       	push   $0x100faf18
 8058145:	68 4c 40 06 08       	push   $0x806404c
 805814a:	6a 50                	push   $0x50
 805814c:	68 00 8a 0c 08       	push   $0x80c8a00
 8058151:	e8 aa 09 ff ff       	call   8048b00 <snprintf@plt>
 8058156:	83 c4 10             	add    $0x10,%esp
 8058159:	83 f8 4f             	cmp    $0x4f,%eax
 805815c:	7e 87                	jle    80580e5 <stos_b+0x55>
 805815e:	68 65 41 06 08       	push   $0x8064165
 8058163:	6a 08                	push   $0x8
 8058165:	68 58 40 06 08       	push   $0x8064058
 805816a:	68 10 41 06 08       	push   $0x8064110
 805816f:	e8 3c 0a ff ff       	call   8048bb0 <__assert_fail@plt>
 8058174:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805817a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08058180 <stos_v>:

#define DATA_BYTE 4
#include "stos-template.h"
#undef DATA_BYTE

make_helper_v(stos)
 8058180:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8058187:	8b 54 24 04          	mov    0x4(%esp),%edx
 805818b:	b8 b0 7e 05 08       	mov    $0x8057eb0,%eax
 8058190:	75 05                	jne    8058197 <stos_v+0x17>
 8058192:	b8 a0 7f 05 08       	mov    $0x8057fa0,%eax
 8058197:	89 54 24 04          	mov    %edx,0x4(%esp)
 805819b:	ff e0                	jmp    *%eax
 805819d:	66 90                	xchg   %ax,%ax
 805819f:	90                   	nop

080581a0 <do_add_b>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr add

static void do_execute() {
 80581a0:	55                   	push   %ebp
 80581a1:	57                   	push   %edi
 80581a2:	56                   	push   %esi
 80581a3:	53                   	push   %ebx
 80581a4:	83 ec 1c             	sub    $0x1c,%esp
	RET_DATA_TYPE res = op_src->val + op_dest->val;
 80581a7:	8b 1d 14 af 0f 10    	mov    0x100faf14,%ebx
 80581ad:	8b 35 4c af 0f 10    	mov    0x100faf4c,%esi
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80581b3:	89 da                	mov    %ebx,%edx
#endif
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 80581b5:	89 f0                	mov    %esi,%eax
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80581b7:	89 f1                	mov    %esi,%ecx
 80581b9:	c1 e9 07             	shr    $0x7,%ecx
 80581bc:	c1 ea 07             	shr    $0x7,%edx
#endif
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 80581bf:	00 d8                	add    %bl,%al
 80581c1:	0f 88 59 01 00 00    	js     8058320 <do_add_b+0x180>
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
	}
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
 80581c7:	09 ca                	or     %ecx,%edx
 80581c9:	0f b6 0d e4 af 0f 10 	movzbl 0x100fafe4,%ecx
 80581d0:	83 e2 01             	and    $0x1,%edx
 80581d3:	83 e1 fe             	and    $0xfffffffe,%ecx
 80581d6:	09 ca                	or     %ecx,%edx
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
 80581d8:	0f b6 c8             	movzbl %al,%ecx
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
	}
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
 80581db:	88 15 e4 af 0f 10    	mov    %dl,0x100fafe4
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 80581e1:	89 ca                	mov    %ecx,%edx
 80581e3:	c1 ea 04             	shr    $0x4,%edx
 80581e6:	31 ca                	xor    %ecx,%edx
	pf = (pf >> 2) ^ pf;
 80581e8:	89 d7                	mov    %edx,%edi
 80581ea:	c1 ef 02             	shr    $0x2,%edi
 80581ed:	31 fa                	xor    %edi,%edx
	pf = (pf >> 1) ^ pf;
 80581ef:	89 d7                	mov    %edx,%edi
 80581f1:	d1 ef                	shr    %edi
 80581f3:	31 fa                	xor    %edi,%edx
	cpu.PF = pf & 1;
 80581f5:	83 e2 01             	and    $0x1,%edx
 80581f8:	8d 3c 95 00 00 00 00 	lea    0x0(,%edx,4),%edi
 80581ff:	0f b6 15 e4 af 0f 10 	movzbl 0x100fafe4,%edx
 8058206:	83 e2 bb             	and    $0xffffffbb,%edx
	cpu.ZF = (res == 0);
 8058209:	84 c0                	test   %al,%al
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 805820b:	88 54 24 0f          	mov    %dl,0xf(%esp)
	cpu.ZF = (res == 0);
 805820f:	0f 94 c2             	sete   %dl
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058212:	31 c6                	xor    %eax,%esi
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 8058214:	89 d5                	mov    %edx,%ebp
 8058216:	0f b6 54 24 0f       	movzbl 0xf(%esp),%edx
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 805821b:	83 ec 08             	sub    $0x8,%esp
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 805821e:	c1 e5 06             	shl    $0x6,%ebp
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 8058221:	51                   	push   %ecx
 8058222:	68 40 af 0f 10       	push   $0x100faf40
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 8058227:	09 fa                	or     %edi,%edx
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8058229:	89 c7                	mov    %eax,%edi
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 805822b:	31 d8                	xor    %ebx,%eax
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 805822d:	09 ea                	or     %ebp,%edx
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 805822f:	83 e7 80             	and    $0xffffff80,%edi
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058232:	21 f0                	and    %esi,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8058234:	83 e2 7f             	and    $0x7f,%edx
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058237:	83 e0 01             	and    $0x1,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 805823a:	09 fa                	or     %edi,%edx
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 805823c:	c1 e0 03             	shl    $0x3,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 805823f:	88 15 e4 af 0f 10    	mov    %dl,0x100fafe4
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058245:	0f b6 15 e5 af 0f 10 	movzbl 0x100fafe5,%edx
 805824c:	83 e2 f7             	and    $0xfffffff7,%edx
 805824f:	09 d0                	or     %edx,%eax
 8058251:	a2 e5 af 0f 10       	mov    %al,0x100fafe5
	OPERAND_W(op_dest, res);
 8058256:	e8 e5 44 00 00       	call   805c740 <write_operand_b>
	print_asm_template2();
 805825b:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 8058262:	68 18 af 0f 10       	push   $0x100faf18
 8058267:	68 6c 41 06 08       	push   $0x806416c
 805826c:	6a 50                	push   $0x50
 805826e:	68 00 8a 0c 08       	push   $0x80c8a00
 8058273:	e8 88 08 ff ff       	call   8048b00 <snprintf@plt>
 8058278:	83 c4 20             	add    $0x20,%esp
 805827b:	83 f8 4f             	cmp    $0x4f,%eax
 805827e:	7f 10                	jg     8058290 <do_add_b+0xf0>
}
 8058280:	83 c4 1c             	add    $0x1c,%esp
 8058283:	5b                   	pop    %ebx
 8058284:	5e                   	pop    %esi
 8058285:	5f                   	pop    %edi
 8058286:	5d                   	pop    %ebp
 8058287:	c3                   	ret    
 8058288:	90                   	nop
 8058289:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8058290:	83 ec 0c             	sub    $0xc,%esp
 8058293:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8058299:	e8 c2 06 ff ff       	call   8048960 <fflush@plt>
 805829e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80582a4:	6a 07                	push   $0x7
 80582a6:	6a 01                	push   $0x1
 80582a8:	68 92 e8 05 08       	push   $0x805e892
 80582ad:	e8 5e 07 ff ff       	call   8048a10 <fwrite@plt>
 80582b2:	83 c4 20             	add    $0x20,%esp
 80582b5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80582bb:	6a 10                	push   $0x10
 80582bd:	6a 01                	push   $0x1
 80582bf:	68 b4 f3 05 08       	push   $0x805f3b4
 80582c4:	e8 47 07 ff ff       	call   8048a10 <fwrite@plt>
 80582c9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80582cf:	6a 05                	push   $0x5
 80582d1:	6a 01                	push   $0x1
 80582d3:	68 42 f3 05 08       	push   $0x805f342
 80582d8:	e8 33 07 ff ff       	call   8048a10 <fwrite@plt>
 80582dd:	83 c4 14             	add    $0x14,%esp
 80582e0:	68 50 af 0f 10       	push   $0x100faf50
 80582e5:	68 18 af 0f 10       	push   $0x100faf18
 80582ea:	68 6c 41 06 08       	push   $0x806416c
 80582ef:	6a 50                	push   $0x50
 80582f1:	68 00 8a 0c 08       	push   $0x80c8a00
 80582f6:	e8 05 08 ff ff       	call   8048b00 <snprintf@plt>
 80582fb:	83 c4 20             	add    $0x20,%esp
 80582fe:	83 f8 4f             	cmp    $0x4f,%eax
 8058301:	0f 8e 79 ff ff ff    	jle    8058280 <do_add_b+0xe0>
 8058307:	68 f5 42 06 08       	push   $0x80642f5
 805830c:	6a 1e                	push   $0x1e
 805830e:	68 90 41 06 08       	push   $0x8064190
 8058313:	68 b8 41 06 08       	push   $0x80641b8
 8058318:	e8 93 08 ff ff       	call   8048bb0 <__assert_fail@plt>
 805831d:	8d 76 00             	lea    0x0(%esi),%esi
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8058320:	21 ca                	and    %ecx,%edx
 8058322:	e9 a2 fe ff ff       	jmp    80581c9 <do_add_b+0x29>
 8058327:	89 f6                	mov    %esi,%esi
 8058329:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08058330 <do_add_w>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr add

static void do_execute() {
 8058330:	55                   	push   %ebp
 8058331:	57                   	push   %edi
 8058332:	56                   	push   %esi
 8058333:	53                   	push   %ebx
 8058334:	83 ec 0c             	sub    $0xc,%esp
	RET_DATA_TYPE res = op_src->val + op_dest->val;
 8058337:	8b 15 14 af 0f 10    	mov    0x100faf14,%edx
 805833d:	8b 1d 4c af 0f 10    	mov    0x100faf4c,%ebx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8058343:	89 d0                	mov    %edx,%eax
#endif
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 8058345:	89 d9                	mov    %ebx,%ecx
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8058347:	89 de                	mov    %ebx,%esi
 8058349:	c1 ee 0f             	shr    $0xf,%esi
 805834c:	c1 e8 0f             	shr    $0xf,%eax
#endif
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 805834f:	66 01 d1             	add    %dx,%cx
 8058352:	0f 88 58 01 00 00    	js     80584b0 <do_add_w+0x180>
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
	}
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
 8058358:	09 f0                	or     %esi,%eax
 805835a:	0f b6 35 e4 af 0f 10 	movzbl 0x100fafe4,%esi
 8058361:	83 e0 01             	and    $0x1,%eax
 8058364:	83 e6 fe             	and    $0xfffffffe,%esi
 8058367:	09 f0                	or     %esi,%eax
 8058369:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
 805836e:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 8058371:	0f b6 2d e4 af 0f 10 	movzbl 0x100fafe4,%ebp
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 8058378:	89 c6                	mov    %eax,%esi
 805837a:	c1 ee 04             	shr    $0x4,%esi
 805837d:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 805837f:	89 c6                	mov    %eax,%esi
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 8058381:	83 e5 bb             	and    $0xffffffbb,%ebp
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 8058384:	c1 ee 02             	shr    $0x2,%esi
 8058387:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 8058389:	89 c6                	mov    %eax,%esi
 805838b:	d1 ee                	shr    %esi
 805838d:	31 f0                	xor    %esi,%eax
	cpu.PF = pf & 1;
 805838f:	83 e0 01             	and    $0x1,%eax
	cpu.ZF = (res == 0);
 8058392:	66 85 c9             	test   %cx,%cx
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 8058395:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
	cpu.ZF = (res == 0);
 805839c:	0f 94 c0             	sete   %al
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 805839f:	31 cb                	xor    %ecx,%ebx
 80583a1:	31 ca                	xor    %ecx,%edx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 80583a3:	c1 e0 06             	shl    $0x6,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 80583a6:	83 ec 08             	sub    $0x8,%esp
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80583a9:	21 da                	and    %ebx,%edx
 80583ab:	0f b6 1d e5 af 0f 10 	movzbl 0x100fafe5,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 80583b2:	89 c7                	mov    %eax,%edi
 80583b4:	89 e8                	mov    %ebp,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80583b6:	83 e2 01             	and    $0x1,%edx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 80583b9:	09 f0                	or     %esi,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80583bb:	89 ce                	mov    %ecx,%esi
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 80583bd:	0f b7 c9             	movzwl %cx,%ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 80583c0:	09 f8                	or     %edi,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80583c2:	66 c1 fe 0f          	sar    $0xf,%si
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 80583c6:	51                   	push   %ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80583c7:	c1 e6 07             	shl    $0x7,%esi
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 80583ca:	68 40 af 0f 10       	push   $0x100faf40
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80583cf:	83 e0 7f             	and    $0x7f,%eax
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80583d2:	c1 e2 03             	shl    $0x3,%edx
 80583d5:	83 e3 f7             	and    $0xfffffff7,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80583d8:	09 f0                	or     %esi,%eax
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80583da:	09 da                	or     %ebx,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80583dc:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80583e1:	88 15 e5 af 0f 10    	mov    %dl,0x100fafe5
	OPERAND_W(op_dest, res);
 80583e7:	e8 e4 46 00 00       	call   805cad0 <write_operand_w>
	print_asm_template2();
 80583ec:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 80583f3:	68 18 af 0f 10       	push   $0x100faf18
 80583f8:	68 77 41 06 08       	push   $0x8064177
 80583fd:	6a 50                	push   $0x50
 80583ff:	68 00 8a 0c 08       	push   $0x80c8a00
 8058404:	e8 f7 06 ff ff       	call   8048b00 <snprintf@plt>
 8058409:	83 c4 20             	add    $0x20,%esp
 805840c:	83 f8 4f             	cmp    $0x4f,%eax
 805840f:	7f 0f                	jg     8058420 <do_add_w+0xf0>
}
 8058411:	83 c4 0c             	add    $0xc,%esp
 8058414:	5b                   	pop    %ebx
 8058415:	5e                   	pop    %esi
 8058416:	5f                   	pop    %edi
 8058417:	5d                   	pop    %ebp
 8058418:	c3                   	ret    
 8058419:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8058420:	83 ec 0c             	sub    $0xc,%esp
 8058423:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8058429:	e8 32 05 ff ff       	call   8048960 <fflush@plt>
 805842e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058434:	6a 07                	push   $0x7
 8058436:	6a 01                	push   $0x1
 8058438:	68 92 e8 05 08       	push   $0x805e892
 805843d:	e8 ce 05 ff ff       	call   8048a10 <fwrite@plt>
 8058442:	83 c4 20             	add    $0x20,%esp
 8058445:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805844b:	6a 10                	push   $0x10
 805844d:	6a 01                	push   $0x1
 805844f:	68 b4 f3 05 08       	push   $0x805f3b4
 8058454:	e8 b7 05 ff ff       	call   8048a10 <fwrite@plt>
 8058459:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805845f:	6a 05                	push   $0x5
 8058461:	6a 01                	push   $0x1
 8058463:	68 42 f3 05 08       	push   $0x805f342
 8058468:	e8 a3 05 ff ff       	call   8048a10 <fwrite@plt>
 805846d:	83 c4 14             	add    $0x14,%esp
 8058470:	68 50 af 0f 10       	push   $0x100faf50
 8058475:	68 18 af 0f 10       	push   $0x100faf18
 805847a:	68 77 41 06 08       	push   $0x8064177
 805847f:	6a 50                	push   $0x50
 8058481:	68 00 8a 0c 08       	push   $0x80c8a00
 8058486:	e8 75 06 ff ff       	call   8048b00 <snprintf@plt>
 805848b:	83 c4 20             	add    $0x20,%esp
 805848e:	83 f8 4f             	cmp    $0x4f,%eax
 8058491:	0f 8e 7a ff ff ff    	jle    8058411 <do_add_w+0xe1>
 8058497:	68 ec 42 06 08       	push   $0x80642ec
 805849c:	6a 1e                	push   $0x1e
 805849e:	68 90 41 06 08       	push   $0x8064190
 80584a3:	68 1c 42 06 08       	push   $0x806421c
 80584a8:	e8 03 07 ff ff       	call   8048bb0 <__assert_fail@plt>
 80584ad:	8d 76 00             	lea    0x0(%esi),%esi
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80584b0:	21 f0                	and    %esi,%eax
 80584b2:	e9 a3 fe ff ff       	jmp    805835a <do_add_w+0x2a>
 80584b7:	89 f6                	mov    %esi,%esi
 80584b9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080584c0 <add_i2a_w>:
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(i2a)
 80584c0:	53                   	push   %ebx
 80584c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80584c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80584c8:	83 c0 01             	add    $0x1,%eax
 80584cb:	50                   	push   %eax
 80584cc:	e8 bf 43 00 00       	call   805c890 <decode_i2a_w>
 80584d1:	89 c3                	mov    %eax,%ebx
	execute();
 80584d3:	e8 58 fe ff ff       	call   8058330 <do_add_w>
 80584d8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80584db:	8d 43 01             	lea    0x1(%ebx),%eax
 80584de:	5b                   	pop    %ebx
 80584df:	c3                   	ret    

080584e0 <add_i2rm_w>:
make_instr_helper(i2rm)
 80584e0:	53                   	push   %ebx
 80584e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80584e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80584e8:	83 c0 01             	add    $0x1,%eax
 80584eb:	50                   	push   %eax
 80584ec:	e8 1f 44 00 00       	call   805c910 <decode_i2rm_w>
 80584f1:	89 c3                	mov    %eax,%ebx
	execute();
 80584f3:	e8 38 fe ff ff       	call   8058330 <do_add_w>
 80584f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80584fb:	8d 43 01             	lea    0x1(%ebx),%eax
 80584fe:	5b                   	pop    %ebx
 80584ff:	c3                   	ret    

08058500 <add_r2rm_w>:
make_instr_helper(r2rm)
 8058500:	53                   	push   %ebx
 8058501:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058504:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058508:	83 c0 01             	add    $0x1,%eax
 805850b:	50                   	push   %eax
 805850c:	e8 3f 43 00 00       	call   805c850 <decode_r2rm_w>
 8058511:	89 c3                	mov    %eax,%ebx
	execute();
 8058513:	e8 18 fe ff ff       	call   8058330 <do_add_w>
 8058518:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805851b:	8d 43 01             	lea    0x1(%ebx),%eax
 805851e:	5b                   	pop    %ebx
 805851f:	c3                   	ret    

08058520 <add_rm2r_w>:
make_instr_helper(rm2r)
 8058520:	53                   	push   %ebx
 8058521:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058524:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058528:	83 c0 01             	add    $0x1,%eax
 805852b:	50                   	push   %eax
 805852c:	e8 3f 43 00 00       	call   805c870 <decode_rm2r_w>
 8058531:	89 c3                	mov    %eax,%ebx
	execute();
 8058533:	e8 f8 fd ff ff       	call   8058330 <do_add_w>
 8058538:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805853b:	8d 43 01             	lea    0x1(%ebx),%eax
 805853e:	5b                   	pop    %ebx
 805853f:	c3                   	ret    

08058540 <add_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8058540:	53                   	push   %ebx
 8058541:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058544:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058548:	83 c0 01             	add    $0x1,%eax
 805854b:	50                   	push   %eax
 805854c:	e8 3f 44 00 00       	call   805c990 <decode_si2rm_w>
 8058551:	89 c3                	mov    %eax,%ebx
	execute();
 8058553:	e8 d8 fd ff ff       	call   8058330 <do_add_w>
 8058558:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805855b:	8d 43 01             	lea    0x1(%ebx),%eax
 805855e:	5b                   	pop    %ebx
 805855f:	c3                   	ret    

08058560 <do_add_l>:
#elif DATA_BYTE == 4
#define RET_DATA_TYPE int32_t
#endif
#define instr add

static void do_execute() {
 8058560:	55                   	push   %ebp
 8058561:	57                   	push   %edi
 8058562:	56                   	push   %esi
 8058563:	53                   	push   %ebx
 8058564:	83 ec 0c             	sub    $0xc,%esp
	RET_DATA_TYPE res = op_src->val + op_dest->val;
 8058567:	8b 15 14 af 0f 10    	mov    0x100faf14,%edx
 805856d:	8b 1d 4c af 0f 10    	mov    0x100faf4c,%ebx
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8058573:	89 d0                	mov    %edx,%eax
#endif
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 8058575:	89 d9                	mov    %ebx,%ecx
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 8058577:	89 de                	mov    %ebx,%esi
 8058579:	c1 ee 1f             	shr    $0x1f,%esi
 805857c:	c1 e8 1f             	shr    $0x1f,%eax
#endif
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
 805857f:	01 d1                	add    %edx,%ecx
 8058581:	0f 88 49 01 00 00    	js     80586d0 <do_add_l+0x170>
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
	}
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
 8058587:	09 f0                	or     %esi,%eax
 8058589:	0f b6 35 e4 af 0f 10 	movzbl 0x100fafe4,%esi
 8058590:	83 e6 fe             	and    $0xfffffffe,%esi
 8058593:	09 f0                	or     %esi,%eax
 8058595:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
 805859a:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 805859d:	0f b6 2d e4 af 0f 10 	movzbl 0x100fafe4,%ebp
	else {
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
 80585a4:	89 c6                	mov    %eax,%esi
 80585a6:	c1 ee 04             	shr    $0x4,%esi
 80585a9:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 80585ab:	89 c6                	mov    %eax,%esi
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 80585ad:	83 e5 bb             	and    $0xffffffbb,%ebp
		cpu.CF = ((op_src->val >> ((DATA_BYTE << 3) - 1)) | (op_dest->val >> ((DATA_BYTE << 3) - 1))) & 1;
	}
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 80585b0:	c1 ee 02             	shr    $0x2,%esi
 80585b3:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 80585b5:	89 c6                	mov    %eax,%esi
 80585b7:	d1 ee                	shr    %esi
 80585b9:	31 f0                	xor    %esi,%eax
	cpu.PF = pf & 1;
 80585bb:	83 e0 01             	and    $0x1,%eax
	cpu.ZF = (res == 0);
 80585be:	85 c9                	test   %ecx,%ecx
	cpu.PF = 0;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
 80585c0:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
	cpu.ZF = (res == 0);
 80585c7:	0f 94 c0             	sete   %al
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80585ca:	31 cb                	xor    %ecx,%ebx
 80585cc:	31 ca                	xor    %ecx,%edx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 80585ce:	c1 e0 06             	shl    $0x6,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 80585d1:	83 ec 08             	sub    $0x8,%esp
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80585d4:	21 da                	and    %ebx,%edx
 80585d6:	0f b6 1d e5 af 0f 10 	movzbl 0x100fafe5,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 80585dd:	89 c7                	mov    %eax,%edi
 80585df:	89 e8                	mov    %ebp,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80585e1:	83 e2 01             	and    $0x1,%edx
	OPERAND_W(op_dest, res);
 80585e4:	51                   	push   %ecx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 80585e5:	09 f0                	or     %esi,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80585e7:	89 ce                	mov    %ecx,%esi
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
 80585e9:	68 40 af 0f 10       	push   $0x100faf40
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
 80585ee:	09 f8                	or     %edi,%eax
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80585f0:	c1 ee 1f             	shr    $0x1f,%esi
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80585f3:	c1 e2 03             	shl    $0x3,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80585f6:	c1 e6 07             	shl    $0x7,%esi
 80585f9:	83 e0 7f             	and    $0x7f,%eax
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 80585fc:	83 e3 f7             	and    $0xfffffff7,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 80585ff:	09 f0                	or     %esi,%eax
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058601:	09 da                	or     %ebx,%edx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
 8058603:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
 8058608:	88 15 e5 af 0f 10    	mov    %dl,0x100fafe5
	OPERAND_W(op_dest, res);
 805860e:	e8 8d 48 00 00       	call   805cea0 <write_operand_l>
	print_asm_template2();
 8058613:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 805861a:	68 18 af 0f 10       	push   $0x100faf18
 805861f:	68 82 41 06 08       	push   $0x8064182
 8058624:	6a 50                	push   $0x50
 8058626:	68 00 8a 0c 08       	push   $0x80c8a00
 805862b:	e8 d0 04 ff ff       	call   8048b00 <snprintf@plt>
 8058630:	83 c4 20             	add    $0x20,%esp
 8058633:	83 f8 4f             	cmp    $0x4f,%eax
 8058636:	7f 08                	jg     8058640 <do_add_l+0xe0>
}
 8058638:	83 c4 0c             	add    $0xc,%esp
 805863b:	5b                   	pop    %ebx
 805863c:	5e                   	pop    %esi
 805863d:	5f                   	pop    %edi
 805863e:	5d                   	pop    %ebp
 805863f:	c3                   	ret    
	cpu.PF = pf & 1;
	cpu.ZF = (res == 0);
	cpu.SF = ((res >> ((DATA_BYTE << 3) - 1)) & 1);
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8058640:	83 ec 0c             	sub    $0xc,%esp
 8058643:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8058649:	e8 12 03 ff ff       	call   8048960 <fflush@plt>
 805864e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058654:	6a 07                	push   $0x7
 8058656:	6a 01                	push   $0x1
 8058658:	68 92 e8 05 08       	push   $0x805e892
 805865d:	e8 ae 03 ff ff       	call   8048a10 <fwrite@plt>
 8058662:	83 c4 20             	add    $0x20,%esp
 8058665:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805866b:	6a 10                	push   $0x10
 805866d:	6a 01                	push   $0x1
 805866f:	68 b4 f3 05 08       	push   $0x805f3b4
 8058674:	e8 97 03 ff ff       	call   8048a10 <fwrite@plt>
 8058679:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805867f:	6a 05                	push   $0x5
 8058681:	6a 01                	push   $0x1
 8058683:	68 42 f3 05 08       	push   $0x805f342
 8058688:	e8 83 03 ff ff       	call   8048a10 <fwrite@plt>
 805868d:	83 c4 14             	add    $0x14,%esp
 8058690:	68 50 af 0f 10       	push   $0x100faf50
 8058695:	68 18 af 0f 10       	push   $0x100faf18
 805869a:	68 82 41 06 08       	push   $0x8064182
 805869f:	6a 50                	push   $0x50
 80586a1:	68 00 8a 0c 08       	push   $0x80c8a00
 80586a6:	e8 55 04 ff ff       	call   8048b00 <snprintf@plt>
 80586ab:	83 c4 20             	add    $0x20,%esp
 80586ae:	83 f8 4f             	cmp    $0x4f,%eax
 80586b1:	7e 85                	jle    8058638 <do_add_l+0xd8>
 80586b3:	68 e3 42 06 08       	push   $0x80642e3
 80586b8:	6a 1e                	push   $0x1e
 80586ba:	68 90 41 06 08       	push   $0x8064190
 80586bf:	68 80 42 06 08       	push   $0x8064280
 80586c4:	e8 e7 04 ff ff       	call   8048bb0 <__assert_fail@plt>
 80586c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
#define instr add

static void do_execute() {
	RET_DATA_TYPE res = op_src->val + op_dest->val;
	if(res >> ((DATA_BYTE << 3) - 1)) {
		cpu.CF = (op_src->val >> ((DATA_BYTE << 3) - 1)) & (op_dest->val >> ((DATA_BYTE << 3) - 1)) & 1;
 80586d0:	21 f0                	and    %esi,%eax
 80586d2:	0f b6 35 e4 af 0f 10 	movzbl 0x100fafe4,%esi
 80586d9:	83 e6 fe             	and    $0xfffffffe,%esi
 80586dc:	09 f0                	or     %esi,%eax
 80586de:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
 80586e3:	e9 b2 fe ff ff       	jmp    805859a <do_add_l+0x3a>
 80586e8:	90                   	nop
 80586e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

080586f0 <add_i2a_l>:
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(i2a)
 80586f0:	53                   	push   %ebx
 80586f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80586f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80586f8:	83 c0 01             	add    $0x1,%eax
 80586fb:	50                   	push   %eax
 80586fc:	e8 5f 45 00 00       	call   805cc60 <decode_i2a_l>
 8058701:	89 c3                	mov    %eax,%ebx
	execute();
 8058703:	e8 58 fe ff ff       	call   8058560 <do_add_l>
 8058708:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805870b:	8d 43 01             	lea    0x1(%ebx),%eax
 805870e:	5b                   	pop    %ebx
 805870f:	c3                   	ret    

08058710 <add_i2rm_l>:
make_instr_helper(i2rm)
 8058710:	53                   	push   %ebx
 8058711:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058714:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058718:	83 c0 01             	add    $0x1,%eax
 805871b:	50                   	push   %eax
 805871c:	e8 bf 45 00 00       	call   805cce0 <decode_i2rm_l>
 8058721:	89 c3                	mov    %eax,%ebx
	execute();
 8058723:	e8 38 fe ff ff       	call   8058560 <do_add_l>
 8058728:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805872b:	8d 43 01             	lea    0x1(%ebx),%eax
 805872e:	5b                   	pop    %ebx
 805872f:	c3                   	ret    

08058730 <add_r2rm_l>:
make_instr_helper(r2rm)
 8058730:	53                   	push   %ebx
 8058731:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058734:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058738:	83 c0 01             	add    $0x1,%eax
 805873b:	50                   	push   %eax
 805873c:	e8 df 44 00 00       	call   805cc20 <decode_r2rm_l>
 8058741:	89 c3                	mov    %eax,%ebx
	execute();
 8058743:	e8 18 fe ff ff       	call   8058560 <do_add_l>
 8058748:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805874b:	8d 43 01             	lea    0x1(%ebx),%eax
 805874e:	5b                   	pop    %ebx
 805874f:	c3                   	ret    

08058750 <add_rm2r_l>:
make_instr_helper(rm2r)
 8058750:	53                   	push   %ebx
 8058751:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058754:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058758:	83 c0 01             	add    $0x1,%eax
 805875b:	50                   	push   %eax
 805875c:	e8 df 44 00 00       	call   805cc40 <decode_rm2r_l>
 8058761:	89 c3                	mov    %eax,%ebx
	execute();
 8058763:	e8 f8 fd ff ff       	call   8058560 <do_add_l>
 8058768:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805876b:	8d 43 01             	lea    0x1(%ebx),%eax
 805876e:	5b                   	pop    %ebx
 805876f:	c3                   	ret    

08058770 <add_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 8058770:	53                   	push   %ebx
 8058771:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058774:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058778:	83 c0 01             	add    $0x1,%eax
 805877b:	50                   	push   %eax
 805877c:	e8 df 45 00 00       	call   805cd60 <decode_si2rm_l>
 8058781:	89 c3                	mov    %eax,%ebx
	execute();
 8058783:	e8 d8 fd ff ff       	call   8058560 <do_add_l>
 8058788:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805878b:	8d 43 01             	lea    0x1(%ebx),%eax
 805878e:	5b                   	pop    %ebx
 805878f:	c3                   	ret    

08058790 <add_i2a_b>:
	cpu.OF = ((res ^ op_src->val) & (res ^ op_dest->val) & 1);
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(i2a)
 8058790:	53                   	push   %ebx
 8058791:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058794:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058798:	83 c0 01             	add    $0x1,%eax
 805879b:	50                   	push   %eax
 805879c:	e8 bf 3d 00 00       	call   805c560 <decode_i2a_b>
 80587a1:	89 c3                	mov    %eax,%ebx
	execute();
 80587a3:	e8 f8 f9 ff ff       	call   80581a0 <do_add_b>
 80587a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80587ab:	8d 43 01             	lea    0x1(%ebx),%eax
 80587ae:	5b                   	pop    %ebx
 80587af:	c3                   	ret    

080587b0 <add_i2rm_b>:
make_instr_helper(i2rm)
 80587b0:	53                   	push   %ebx
 80587b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80587b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80587b8:	83 c0 01             	add    $0x1,%eax
 80587bb:	50                   	push   %eax
 80587bc:	e8 1f 3e 00 00       	call   805c5e0 <decode_i2rm_b>
 80587c1:	89 c3                	mov    %eax,%ebx
	execute();
 80587c3:	e8 d8 f9 ff ff       	call   80581a0 <do_add_b>
 80587c8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80587cb:	8d 43 01             	lea    0x1(%ebx),%eax
 80587ce:	5b                   	pop    %ebx
 80587cf:	c3                   	ret    

080587d0 <add_r2rm_b>:
make_instr_helper(r2rm)
 80587d0:	53                   	push   %ebx
 80587d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80587d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80587d8:	83 c0 01             	add    $0x1,%eax
 80587db:	50                   	push   %eax
 80587dc:	e8 3f 3d 00 00       	call   805c520 <decode_r2rm_b>
 80587e1:	89 c3                	mov    %eax,%ebx
	execute();
 80587e3:	e8 b8 f9 ff ff       	call   80581a0 <do_add_b>
 80587e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80587eb:	8d 43 01             	lea    0x1(%ebx),%eax
 80587ee:	5b                   	pop    %ebx
 80587ef:	c3                   	ret    

080587f0 <add_rm2r_b>:
make_instr_helper(rm2r)
 80587f0:	53                   	push   %ebx
 80587f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80587f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80587f8:	83 c0 01             	add    $0x1,%eax
 80587fb:	50                   	push   %eax
 80587fc:	e8 3f 3d 00 00       	call   805c540 <decode_rm2r_b>
 8058801:	89 c3                	mov    %eax,%ebx
	execute();
 8058803:	e8 98 f9 ff ff       	call   80581a0 <do_add_b>
 8058808:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805880b:	8d 43 01             	lea    0x1(%ebx),%eax
 805880e:	5b                   	pop    %ebx
 805880f:	c3                   	ret    

08058810 <add_r2rm_v>:
#include "add-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(add_r2rm)
 8058810:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8058817:	8b 54 24 04          	mov    0x4(%esp),%edx
 805881b:	b8 00 85 05 08       	mov    $0x8058500,%eax
 8058820:	75 05                	jne    8058827 <add_r2rm_v+0x17>
 8058822:	b8 30 87 05 08       	mov    $0x8058730,%eax
 8058827:	89 54 24 04          	mov    %edx,0x4(%esp)
 805882b:	ff e0                	jmp    *%eax
 805882d:	8d 76 00             	lea    0x0(%esi),%esi

08058830 <add_rm2r_v>:
make_helper_v(add_rm2r)
 8058830:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8058837:	8b 54 24 04          	mov    0x4(%esp),%edx
 805883b:	b8 20 85 05 08       	mov    $0x8058520,%eax
 8058840:	75 05                	jne    8058847 <add_rm2r_v+0x17>
 8058842:	b8 50 87 05 08       	mov    $0x8058750,%eax
 8058847:	89 54 24 04          	mov    %edx,0x4(%esp)
 805884b:	ff e0                	jmp    *%eax
 805884d:	8d 76 00             	lea    0x0(%esi),%esi

08058850 <add_i2rm_v>:
make_helper_v(add_i2rm)
 8058850:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8058857:	8b 54 24 04          	mov    0x4(%esp),%edx
 805885b:	b8 e0 84 05 08       	mov    $0x80584e0,%eax
 8058860:	75 05                	jne    8058867 <add_i2rm_v+0x17>
 8058862:	b8 10 87 05 08       	mov    $0x8058710,%eax
 8058867:	89 54 24 04          	mov    %edx,0x4(%esp)
 805886b:	ff e0                	jmp    *%eax
 805886d:	8d 76 00             	lea    0x0(%esi),%esi

08058870 <add_si2rm_v>:
make_helper_v(add_si2rm)
 8058870:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8058877:	8b 54 24 04          	mov    0x4(%esp),%edx
 805887b:	b8 40 85 05 08       	mov    $0x8058540,%eax
 8058880:	75 05                	jne    8058887 <add_si2rm_v+0x17>
 8058882:	b8 70 87 05 08       	mov    $0x8058770,%eax
 8058887:	89 54 24 04          	mov    %edx,0x4(%esp)
 805888b:	ff e0                	jmp    *%eax
 805888d:	8d 76 00             	lea    0x0(%esi),%esi

08058890 <add_i2a_v>:
make_helper_v(add_i2a)
 8058890:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8058897:	8b 54 24 04          	mov    0x4(%esp),%edx
 805889b:	b8 c0 84 05 08       	mov    $0x80584c0,%eax
 80588a0:	75 05                	jne    80588a7 <add_i2a_v+0x17>
 80588a2:	b8 f0 86 05 08       	mov    $0x80586f0,%eax
 80588a7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80588ab:	ff e0                	jmp    *%eax
 80588ad:	66 90                	xchg   %ax,%ax
 80588af:	90                   	nop

080588b0 <mov_a2moffs_w>:
make_instr_helper(i2r)
make_instr_helper(i2rm)
make_instr_helper(r2rm)
make_instr_helper(rm2r)

make_helper(concat(mov_a2moffs_, SUFFIX)) {
 80588b0:	53                   	push   %ebx
 80588b1:	83 ec 10             	sub    $0x10,%esp

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 80588b4:	6a 04                	push   $0x4
	swaddr_t addr = instr_fetch(eip + 1, 4);
 80588b6:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80588ba:	83 c0 01             	add    $0x1,%eax
 80588bd:	50                   	push   %eax
 80588be:	e8 8d 26 ff ff       	call   804af50 <swaddr_read>
 80588c3:	89 c3                	mov    %eax,%ebx
	MEM_W(addr, REG(R_EAX));
 80588c5:	0f b7 05 c0 af 0f 10 	movzwl 0x100fafc0,%eax
 80588cc:	83 c4 0c             	add    $0xc,%esp
 80588cf:	50                   	push   %eax
 80588d0:	6a 02                	push   $0x2
 80588d2:	53                   	push   %ebx
 80588d3:	e8 c8 26 ff ff       	call   804afa0 <swaddr_write>

	print_asm("mov" str(SUFFIX) " %%%s,0x%x", REG_NAME(R_EAX), addr);
 80588d8:	89 1c 24             	mov    %ebx,(%esp)
 80588db:	ff 35 a0 5c 07 08    	pushl  0x8075ca0
 80588e1:	68 fe 42 06 08       	push   $0x80642fe
 80588e6:	6a 50                	push   $0x50
 80588e8:	68 00 8a 0c 08       	push   $0x80c8a00
 80588ed:	e8 0e 02 ff ff       	call   8048b00 <snprintf@plt>
 80588f2:	83 c4 20             	add    $0x20,%esp
 80588f5:	83 f8 4f             	cmp    $0x4f,%eax
 80588f8:	7f 0e                	jg     8058908 <mov_a2moffs_w+0x58>
	return 5;
}
 80588fa:	83 c4 08             	add    $0x8,%esp
 80588fd:	b8 05 00 00 00       	mov    $0x5,%eax
 8058902:	5b                   	pop    %ebx
 8058903:	c3                   	ret    
 8058904:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

make_helper(concat(mov_a2moffs_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	MEM_W(addr, REG(R_EAX));

	print_asm("mov" str(SUFFIX) " %%%s,0x%x", REG_NAME(R_EAX), addr);
 8058908:	83 ec 0c             	sub    $0xc,%esp
 805890b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8058911:	e8 4a 00 ff ff       	call   8048960 <fflush@plt>
 8058916:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805891c:	6a 07                	push   $0x7
 805891e:	6a 01                	push   $0x1
 8058920:	68 92 e8 05 08       	push   $0x805e892
 8058925:	e8 e6 00 ff ff       	call   8048a10 <fwrite@plt>
 805892a:	83 c4 20             	add    $0x20,%esp
 805892d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058933:	6a 10                	push   $0x10
 8058935:	6a 01                	push   $0x1
 8058937:	68 b4 f3 05 08       	push   $0x805f3b4
 805893c:	e8 cf 00 ff ff       	call   8048a10 <fwrite@plt>
 8058941:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058947:	6a 05                	push   $0x5
 8058949:	6a 01                	push   $0x1
 805894b:	68 42 f3 05 08       	push   $0x805f342
 8058950:	e8 bb 00 ff ff       	call   8048a10 <fwrite@plt>
 8058955:	83 c4 14             	add    $0x14,%esp
 8058958:	53                   	push   %ebx
 8058959:	ff 35 a0 5c 07 08    	pushl  0x8075ca0
 805895f:	68 fe 42 06 08       	push   $0x80642fe
 8058964:	6a 50                	push   $0x50
 8058966:	68 00 8a 0c 08       	push   $0x80c8a00
 805896b:	e8 90 01 ff ff       	call   8048b00 <snprintf@plt>
 8058970:	83 c4 20             	add    $0x20,%esp
 8058973:	83 f8 4f             	cmp    $0x4f,%eax
 8058976:	7e 82                	jle    80588fa <mov_a2moffs_w+0x4a>
 8058978:	68 cc 46 06 08       	push   $0x80646cc
 805897d:	6a 13                	push   $0x13
 805897f:	68 7c 43 06 08       	push   $0x806437c
 8058984:	68 a8 43 06 08       	push   $0x80643a8
 8058989:	e8 22 02 ff ff       	call   8048bb0 <__assert_fail@plt>
 805898e:	66 90                	xchg   %ax,%ax

08058990 <mov_a2moffs_l>:
make_instr_helper(i2r)
make_instr_helper(i2rm)
make_instr_helper(r2rm)
make_instr_helper(rm2r)

make_helper(concat(mov_a2moffs_, SUFFIX)) {
 8058990:	53                   	push   %ebx
 8058991:	83 ec 10             	sub    $0x10,%esp
 8058994:	6a 04                	push   $0x4
	swaddr_t addr = instr_fetch(eip + 1, 4);
 8058996:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805899a:	83 c0 01             	add    $0x1,%eax
 805899d:	50                   	push   %eax
 805899e:	e8 ad 25 ff ff       	call   804af50 <swaddr_read>
	MEM_W(addr, REG(R_EAX));
 80589a3:	83 c4 0c             	add    $0xc,%esp
 80589a6:	ff 35 c0 af 0f 10    	pushl  0x100fafc0
 80589ac:	89 c3                	mov    %eax,%ebx
 80589ae:	6a 04                	push   $0x4
 80589b0:	50                   	push   %eax
 80589b1:	e8 ea 25 ff ff       	call   804afa0 <swaddr_write>

	print_asm("mov" str(SUFFIX) " %%%s,0x%x", REG_NAME(R_EAX), addr);
 80589b6:	89 1c 24             	mov    %ebx,(%esp)
 80589b9:	ff 35 c0 5c 07 08    	pushl  0x8075cc0
 80589bf:	68 0d 43 06 08       	push   $0x806430d
 80589c4:	6a 50                	push   $0x50
 80589c6:	68 00 8a 0c 08       	push   $0x80c8a00
 80589cb:	e8 30 01 ff ff       	call   8048b00 <snprintf@plt>
 80589d0:	83 c4 20             	add    $0x20,%esp
 80589d3:	83 f8 4f             	cmp    $0x4f,%eax
 80589d6:	7f 10                	jg     80589e8 <mov_a2moffs_l+0x58>
	return 5;
}
 80589d8:	83 c4 08             	add    $0x8,%esp
 80589db:	b8 05 00 00 00       	mov    $0x5,%eax
 80589e0:	5b                   	pop    %ebx
 80589e1:	c3                   	ret    
 80589e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

make_helper(concat(mov_a2moffs_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	MEM_W(addr, REG(R_EAX));

	print_asm("mov" str(SUFFIX) " %%%s,0x%x", REG_NAME(R_EAX), addr);
 80589e8:	83 ec 0c             	sub    $0xc,%esp
 80589eb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80589f1:	e8 6a ff fe ff       	call   8048960 <fflush@plt>
 80589f6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80589fc:	6a 07                	push   $0x7
 80589fe:	6a 01                	push   $0x1
 8058a00:	68 92 e8 05 08       	push   $0x805e892
 8058a05:	e8 06 00 ff ff       	call   8048a10 <fwrite@plt>
 8058a0a:	83 c4 20             	add    $0x20,%esp
 8058a0d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058a13:	6a 10                	push   $0x10
 8058a15:	6a 01                	push   $0x1
 8058a17:	68 b4 f3 05 08       	push   $0x805f3b4
 8058a1c:	e8 ef ff fe ff       	call   8048a10 <fwrite@plt>
 8058a21:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058a27:	6a 05                	push   $0x5
 8058a29:	6a 01                	push   $0x1
 8058a2b:	68 42 f3 05 08       	push   $0x805f342
 8058a30:	e8 db ff fe ff       	call   8048a10 <fwrite@plt>
 8058a35:	83 c4 14             	add    $0x14,%esp
 8058a38:	53                   	push   %ebx
 8058a39:	ff 35 c0 5c 07 08    	pushl  0x8075cc0
 8058a3f:	68 0d 43 06 08       	push   $0x806430d
 8058a44:	6a 50                	push   $0x50
 8058a46:	68 00 8a 0c 08       	push   $0x80c8a00
 8058a4b:	e8 b0 00 ff ff       	call   8048b00 <snprintf@plt>
 8058a50:	83 c4 20             	add    $0x20,%esp
 8058a53:	83 f8 4f             	cmp    $0x4f,%eax
 8058a56:	7e 80                	jle    80589d8 <mov_a2moffs_l+0x48>
 8058a58:	68 a7 46 06 08       	push   $0x80646a7
 8058a5d:	6a 13                	push   $0x13
 8058a5f:	68 7c 43 06 08       	push   $0x806437c
 8058a64:	68 f4 43 06 08       	push   $0x80643f4
 8058a69:	e8 42 01 ff ff       	call   8048bb0 <__assert_fail@plt>
 8058a6e:	66 90                	xchg   %ax,%ax

08058a70 <mov_moffs2a_w>:
	return 5;
}

make_helper(concat(mov_moffs2a_, SUFFIX)) {
 8058a70:	53                   	push   %ebx
 8058a71:	83 ec 10             	sub    $0x10,%esp
 8058a74:	6a 04                	push   $0x4
	swaddr_t addr = instr_fetch(eip + 1, 4);
 8058a76:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058a7a:	83 c0 01             	add    $0x1,%eax
 8058a7d:	50                   	push   %eax
 8058a7e:	e8 cd 24 ff ff       	call   804af50 <swaddr_read>
 8058a83:	89 c3                	mov    %eax,%ebx
	REG(R_EAX) = MEM_R(addr);
 8058a85:	58                   	pop    %eax
 8058a86:	5a                   	pop    %edx
 8058a87:	6a 02                	push   $0x2
 8058a89:	53                   	push   %ebx
 8058a8a:	e8 c1 24 ff ff       	call   804af50 <swaddr_read>

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 8058a8f:	59                   	pop    %ecx
 8058a90:	ff 35 a0 5c 07 08    	pushl  0x8075ca0
 8058a96:	53                   	push   %ebx
 8058a97:	68 1c 43 06 08       	push   $0x806431c
 8058a9c:	6a 50                	push   $0x50
 8058a9e:	68 00 8a 0c 08       	push   $0x80c8a00
	return 5;
}

make_helper(concat(mov_moffs2a_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	REG(R_EAX) = MEM_R(addr);
 8058aa3:	66 a3 c0 af 0f 10    	mov    %ax,0x100fafc0

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 8058aa9:	e8 52 00 ff ff       	call   8048b00 <snprintf@plt>
 8058aae:	83 c4 20             	add    $0x20,%esp
 8058ab1:	83 f8 4f             	cmp    $0x4f,%eax
 8058ab4:	7f 0a                	jg     8058ac0 <mov_moffs2a_w+0x50>
	return 5;
}
 8058ab6:	83 c4 08             	add    $0x8,%esp
 8058ab9:	b8 05 00 00 00       	mov    $0x5,%eax
 8058abe:	5b                   	pop    %ebx
 8058abf:	c3                   	ret    

make_helper(concat(mov_moffs2a_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	REG(R_EAX) = MEM_R(addr);

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 8058ac0:	83 ec 0c             	sub    $0xc,%esp
 8058ac3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8058ac9:	e8 92 fe fe ff       	call   8048960 <fflush@plt>
 8058ace:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058ad4:	6a 07                	push   $0x7
 8058ad6:	6a 01                	push   $0x1
 8058ad8:	68 92 e8 05 08       	push   $0x805e892
 8058add:	e8 2e ff fe ff       	call   8048a10 <fwrite@plt>
 8058ae2:	83 c4 20             	add    $0x20,%esp
 8058ae5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058aeb:	6a 10                	push   $0x10
 8058aed:	6a 01                	push   $0x1
 8058aef:	68 b4 f3 05 08       	push   $0x805f3b4
 8058af4:	e8 17 ff fe ff       	call   8048a10 <fwrite@plt>
 8058af9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058aff:	6a 05                	push   $0x5
 8058b01:	6a 01                	push   $0x1
 8058b03:	68 42 f3 05 08       	push   $0x805f342
 8058b08:	e8 03 ff fe ff       	call   8048a10 <fwrite@plt>
 8058b0d:	83 c4 14             	add    $0x14,%esp
 8058b10:	ff 35 a0 5c 07 08    	pushl  0x8075ca0
 8058b16:	53                   	push   %ebx
 8058b17:	68 1c 43 06 08       	push   $0x806431c
 8058b1c:	6a 50                	push   $0x50
 8058b1e:	68 00 8a 0c 08       	push   $0x80c8a00
 8058b23:	e8 d8 ff fe ff       	call   8048b00 <snprintf@plt>
 8058b28:	83 c4 20             	add    $0x20,%esp
 8058b2b:	83 f8 4f             	cmp    $0x4f,%eax
 8058b2e:	7e 86                	jle    8058ab6 <mov_moffs2a_w+0x46>
 8058b30:	68 be 46 06 08       	push   $0x80646be
 8058b35:	6a 1b                	push   $0x1b
 8058b37:	68 7c 43 06 08       	push   $0x806437c
 8058b3c:	68 40 44 06 08       	push   $0x8064440
 8058b41:	e8 6a 00 ff ff       	call   8048bb0 <__assert_fail@plt>
 8058b46:	8d 76 00             	lea    0x0(%esi),%esi
 8058b49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08058b50 <mov_moffs2a_l>:

	print_asm("mov" str(SUFFIX) " %%%s,0x%x", REG_NAME(R_EAX), addr);
	return 5;
}

make_helper(concat(mov_moffs2a_, SUFFIX)) {
 8058b50:	53                   	push   %ebx
 8058b51:	83 ec 10             	sub    $0x10,%esp
 8058b54:	6a 04                	push   $0x4
	swaddr_t addr = instr_fetch(eip + 1, 4);
 8058b56:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058b5a:	83 c0 01             	add    $0x1,%eax
 8058b5d:	50                   	push   %eax
 8058b5e:	e8 ed 23 ff ff       	call   804af50 <swaddr_read>
 8058b63:	89 c3                	mov    %eax,%ebx
	REG(R_EAX) = MEM_R(addr);
 8058b65:	58                   	pop    %eax
 8058b66:	5a                   	pop    %edx
 8058b67:	6a 04                	push   $0x4
 8058b69:	53                   	push   %ebx
 8058b6a:	e8 e1 23 ff ff       	call   804af50 <swaddr_read>

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 8058b6f:	59                   	pop    %ecx
 8058b70:	ff 35 c0 5c 07 08    	pushl  0x8075cc0
 8058b76:	53                   	push   %ebx
 8058b77:	68 2b 43 06 08       	push   $0x806432b
 8058b7c:	6a 50                	push   $0x50
 8058b7e:	68 00 8a 0c 08       	push   $0x80c8a00
	return 5;
}

make_helper(concat(mov_moffs2a_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	REG(R_EAX) = MEM_R(addr);
 8058b83:	a3 c0 af 0f 10       	mov    %eax,0x100fafc0

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 8058b88:	e8 73 ff fe ff       	call   8048b00 <snprintf@plt>
 8058b8d:	83 c4 20             	add    $0x20,%esp
 8058b90:	83 f8 4f             	cmp    $0x4f,%eax
 8058b93:	7f 0b                	jg     8058ba0 <mov_moffs2a_l+0x50>
	return 5;
}
 8058b95:	83 c4 08             	add    $0x8,%esp
 8058b98:	b8 05 00 00 00       	mov    $0x5,%eax
 8058b9d:	5b                   	pop    %ebx
 8058b9e:	c3                   	ret    
 8058b9f:	90                   	nop

make_helper(concat(mov_moffs2a_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	REG(R_EAX) = MEM_R(addr);

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 8058ba0:	83 ec 0c             	sub    $0xc,%esp
 8058ba3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8058ba9:	e8 b2 fd fe ff       	call   8048960 <fflush@plt>
 8058bae:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058bb4:	6a 07                	push   $0x7
 8058bb6:	6a 01                	push   $0x1
 8058bb8:	68 92 e8 05 08       	push   $0x805e892
 8058bbd:	e8 4e fe fe ff       	call   8048a10 <fwrite@plt>
 8058bc2:	83 c4 20             	add    $0x20,%esp
 8058bc5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058bcb:	6a 10                	push   $0x10
 8058bcd:	6a 01                	push   $0x1
 8058bcf:	68 b4 f3 05 08       	push   $0x805f3b4
 8058bd4:	e8 37 fe fe ff       	call   8048a10 <fwrite@plt>
 8058bd9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058bdf:	6a 05                	push   $0x5
 8058be1:	6a 01                	push   $0x1
 8058be3:	68 42 f3 05 08       	push   $0x805f342
 8058be8:	e8 23 fe fe ff       	call   8048a10 <fwrite@plt>
 8058bed:	83 c4 14             	add    $0x14,%esp
 8058bf0:	ff 35 c0 5c 07 08    	pushl  0x8075cc0
 8058bf6:	53                   	push   %ebx
 8058bf7:	68 2b 43 06 08       	push   $0x806432b
 8058bfc:	6a 50                	push   $0x50
 8058bfe:	68 00 8a 0c 08       	push   $0x80c8a00
 8058c03:	e8 f8 fe fe ff       	call   8048b00 <snprintf@plt>
 8058c08:	83 c4 20             	add    $0x20,%esp
 8058c0b:	83 f8 4f             	cmp    $0x4f,%eax
 8058c0e:	7e 85                	jle    8058b95 <mov_moffs2a_l+0x45>
 8058c10:	68 99 46 06 08       	push   $0x8064699
 8058c15:	6a 1b                	push   $0x1b
 8058c17:	68 7c 43 06 08       	push   $0x806437c
 8058c1c:	68 8c 44 06 08       	push   $0x806448c
 8058c21:	e8 8a ff fe ff       	call   8048bb0 <__assert_fail@plt>
 8058c26:	8d 76 00             	lea    0x0(%esi),%esi
 8058c29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08058c30 <do_mov_b>:
#include "cpu/exec/template-start.h"

#define instr mov

static void do_execute() {
 8058c30:	83 ec 14             	sub    $0x14,%esp
 8058c33:	0f b6 05 14 af 0f 10 	movzbl 0x100faf14,%eax
	OPERAND_W(op_dest, op_src->val);
 8058c3a:	50                   	push   %eax
 8058c3b:	68 40 af 0f 10       	push   $0x100faf40
 8058c40:	e8 fb 3a 00 00       	call   805c740 <write_operand_b>
	print_asm_template2();
 8058c45:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 8058c4c:	68 18 af 0f 10       	push   $0x100faf18
 8058c51:	68 3a 43 06 08       	push   $0x806433a
 8058c56:	6a 50                	push   $0x50
 8058c58:	68 00 8a 0c 08       	push   $0x80c8a00
 8058c5d:	e8 9e fe fe ff       	call   8048b00 <snprintf@plt>
 8058c62:	83 c4 20             	add    $0x20,%esp
 8058c65:	83 f8 4f             	cmp    $0x4f,%eax
 8058c68:	7f 06                	jg     8058c70 <do_mov_b+0x40>
}
 8058c6a:	83 c4 0c             	add    $0xc,%esp
 8058c6d:	c3                   	ret    
 8058c6e:	66 90                	xchg   %ax,%ax

#define instr mov

static void do_execute() {
	OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8058c70:	83 ec 0c             	sub    $0xc,%esp
 8058c73:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8058c79:	e8 e2 fc fe ff       	call   8048960 <fflush@plt>
 8058c7e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058c84:	6a 07                	push   $0x7
 8058c86:	6a 01                	push   $0x1
 8058c88:	68 92 e8 05 08       	push   $0x805e892
 8058c8d:	e8 7e fd fe ff       	call   8048a10 <fwrite@plt>
 8058c92:	83 c4 20             	add    $0x20,%esp
 8058c95:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058c9b:	6a 10                	push   $0x10
 8058c9d:	6a 01                	push   $0x1
 8058c9f:	68 b4 f3 05 08       	push   $0x805f3b4
 8058ca4:	e8 67 fd fe ff       	call   8048a10 <fwrite@plt>
 8058ca9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058caf:	6a 05                	push   $0x5
 8058cb1:	6a 01                	push   $0x1
 8058cb3:	68 42 f3 05 08       	push   $0x805f342
 8058cb8:	e8 53 fd fe ff       	call   8048a10 <fwrite@plt>
 8058cbd:	83 c4 14             	add    $0x14,%esp
 8058cc0:	68 50 af 0f 10       	push   $0x100faf50
 8058cc5:	68 18 af 0f 10       	push   $0x100faf18
 8058cca:	68 3a 43 06 08       	push   $0x806433a
 8058ccf:	6a 50                	push   $0x50
 8058cd1:	68 00 8a 0c 08       	push   $0x80c8a00
 8058cd6:	e8 25 fe fe ff       	call   8048b00 <snprintf@plt>
 8058cdb:	83 c4 20             	add    $0x20,%esp
 8058cde:	83 f8 4f             	cmp    $0x4f,%eax
 8058ce1:	7e 87                	jle    8058c6a <do_mov_b+0x3a>
 8058ce3:	68 ff 46 06 08       	push   $0x80646ff
 8058ce8:	6a 07                	push   $0x7
 8058cea:	68 7c 43 06 08       	push   $0x806437c
 8058cef:	68 d8 44 06 08       	push   $0x80644d8
 8058cf4:	e8 b7 fe fe ff       	call   8048bb0 <__assert_fail@plt>
 8058cf9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08058d00 <do_mov_w>:
#include "cpu/exec/template-start.h"

#define instr mov

static void do_execute() {
 8058d00:	83 ec 14             	sub    $0x14,%esp
 8058d03:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
	OPERAND_W(op_dest, op_src->val);
 8058d0a:	50                   	push   %eax
 8058d0b:	68 40 af 0f 10       	push   $0x100faf40
 8058d10:	e8 bb 3d 00 00       	call   805cad0 <write_operand_w>
	print_asm_template2();
 8058d15:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 8058d1c:	68 18 af 0f 10       	push   $0x100faf18
 8058d21:	68 45 43 06 08       	push   $0x8064345
 8058d26:	6a 50                	push   $0x50
 8058d28:	68 00 8a 0c 08       	push   $0x80c8a00
 8058d2d:	e8 ce fd fe ff       	call   8048b00 <snprintf@plt>
 8058d32:	83 c4 20             	add    $0x20,%esp
 8058d35:	83 f8 4f             	cmp    $0x4f,%eax
 8058d38:	7f 06                	jg     8058d40 <do_mov_w+0x40>
}
 8058d3a:	83 c4 0c             	add    $0xc,%esp
 8058d3d:	c3                   	ret    
 8058d3e:	66 90                	xchg   %ax,%ax

#define instr mov

static void do_execute() {
	OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8058d40:	83 ec 0c             	sub    $0xc,%esp
 8058d43:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8058d49:	e8 12 fc fe ff       	call   8048960 <fflush@plt>
 8058d4e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058d54:	6a 07                	push   $0x7
 8058d56:	6a 01                	push   $0x1
 8058d58:	68 92 e8 05 08       	push   $0x805e892
 8058d5d:	e8 ae fc fe ff       	call   8048a10 <fwrite@plt>
 8058d62:	83 c4 20             	add    $0x20,%esp
 8058d65:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058d6b:	6a 10                	push   $0x10
 8058d6d:	6a 01                	push   $0x1
 8058d6f:	68 b4 f3 05 08       	push   $0x805f3b4
 8058d74:	e8 97 fc fe ff       	call   8048a10 <fwrite@plt>
 8058d79:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058d7f:	6a 05                	push   $0x5
 8058d81:	6a 01                	push   $0x1
 8058d83:	68 42 f3 05 08       	push   $0x805f342
 8058d88:	e8 83 fc fe ff       	call   8048a10 <fwrite@plt>
 8058d8d:	83 c4 14             	add    $0x14,%esp
 8058d90:	68 50 af 0f 10       	push   $0x100faf50
 8058d95:	68 18 af 0f 10       	push   $0x100faf18
 8058d9a:	68 45 43 06 08       	push   $0x8064345
 8058d9f:	6a 50                	push   $0x50
 8058da1:	68 00 8a 0c 08       	push   $0x80c8a00
 8058da6:	e8 55 fd fe ff       	call   8048b00 <snprintf@plt>
 8058dab:	83 c4 20             	add    $0x20,%esp
 8058dae:	83 f8 4f             	cmp    $0x4f,%eax
 8058db1:	7e 87                	jle    8058d3a <do_mov_w+0x3a>
 8058db3:	68 da 46 06 08       	push   $0x80646da
 8058db8:	6a 07                	push   $0x7
 8058dba:	68 7c 43 06 08       	push   $0x806437c
 8058dbf:	68 3c 45 06 08       	push   $0x806453c
 8058dc4:	e8 e7 fd fe ff       	call   8048bb0 <__assert_fail@plt>
 8058dc9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08058dd0 <mov_i2r_w>:
}

make_instr_helper(i2r)
 8058dd0:	53                   	push   %ebx
 8058dd1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058dd4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058dd8:	83 c0 01             	add    $0x1,%eax
 8058ddb:	50                   	push   %eax
 8058ddc:	e8 5f 3b 00 00       	call   805c940 <decode_i2r_w>
 8058de1:	89 c3                	mov    %eax,%ebx
	execute();
 8058de3:	e8 18 ff ff ff       	call   8058d00 <do_mov_w>
 8058de8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058deb:	8d 43 01             	lea    0x1(%ebx),%eax
 8058dee:	5b                   	pop    %ebx
 8058def:	c3                   	ret    

08058df0 <mov_i2rm_w>:
make_instr_helper(i2rm)
 8058df0:	53                   	push   %ebx
 8058df1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058df4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058df8:	83 c0 01             	add    $0x1,%eax
 8058dfb:	50                   	push   %eax
 8058dfc:	e8 0f 3b 00 00       	call   805c910 <decode_i2rm_w>
 8058e01:	89 c3                	mov    %eax,%ebx
	execute();
 8058e03:	e8 f8 fe ff ff       	call   8058d00 <do_mov_w>
 8058e08:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058e0b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058e0e:	5b                   	pop    %ebx
 8058e0f:	c3                   	ret    

08058e10 <mov_r2rm_w>:
make_instr_helper(r2rm)
 8058e10:	53                   	push   %ebx
 8058e11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058e14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058e18:	83 c0 01             	add    $0x1,%eax
 8058e1b:	50                   	push   %eax
 8058e1c:	e8 2f 3a 00 00       	call   805c850 <decode_r2rm_w>
 8058e21:	89 c3                	mov    %eax,%ebx
	execute();
 8058e23:	e8 d8 fe ff ff       	call   8058d00 <do_mov_w>
 8058e28:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058e2b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058e2e:	5b                   	pop    %ebx
 8058e2f:	c3                   	ret    

08058e30 <mov_rm2r_w>:
make_instr_helper(rm2r)
 8058e30:	53                   	push   %ebx
 8058e31:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058e34:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058e38:	83 c0 01             	add    $0x1,%eax
 8058e3b:	50                   	push   %eax
 8058e3c:	e8 2f 3a 00 00       	call   805c870 <decode_rm2r_w>
 8058e41:	89 c3                	mov    %eax,%ebx
	execute();
 8058e43:	e8 b8 fe ff ff       	call   8058d00 <do_mov_w>
 8058e48:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058e4b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058e4e:	5b                   	pop    %ebx
 8058e4f:	c3                   	ret    

08058e50 <do_mov_l>:
#include "cpu/exec/template-start.h"

#define instr mov

static void do_execute() {
 8058e50:	83 ec 14             	sub    $0x14,%esp
	OPERAND_W(op_dest, op_src->val);
 8058e53:	ff 35 14 af 0f 10    	pushl  0x100faf14
 8058e59:	68 40 af 0f 10       	push   $0x100faf40
 8058e5e:	e8 3d 40 00 00       	call   805cea0 <write_operand_l>
	print_asm_template2();
 8058e63:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 8058e6a:	68 18 af 0f 10       	push   $0x100faf18
 8058e6f:	68 50 43 06 08       	push   $0x8064350
 8058e74:	6a 50                	push   $0x50
 8058e76:	68 00 8a 0c 08       	push   $0x80c8a00
 8058e7b:	e8 80 fc fe ff       	call   8048b00 <snprintf@plt>
 8058e80:	83 c4 20             	add    $0x20,%esp
 8058e83:	83 f8 4f             	cmp    $0x4f,%eax
 8058e86:	7f 08                	jg     8058e90 <do_mov_l+0x40>
}
 8058e88:	83 c4 0c             	add    $0xc,%esp
 8058e8b:	c3                   	ret    
 8058e8c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

#define instr mov

static void do_execute() {
	OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
 8058e90:	83 ec 0c             	sub    $0xc,%esp
 8058e93:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8058e99:	e8 c2 fa fe ff       	call   8048960 <fflush@plt>
 8058e9e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058ea4:	6a 07                	push   $0x7
 8058ea6:	6a 01                	push   $0x1
 8058ea8:	68 92 e8 05 08       	push   $0x805e892
 8058ead:	e8 5e fb fe ff       	call   8048a10 <fwrite@plt>
 8058eb2:	83 c4 20             	add    $0x20,%esp
 8058eb5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058ebb:	6a 10                	push   $0x10
 8058ebd:	6a 01                	push   $0x1
 8058ebf:	68 b4 f3 05 08       	push   $0x805f3b4
 8058ec4:	e8 47 fb fe ff       	call   8048a10 <fwrite@plt>
 8058ec9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8058ecf:	6a 05                	push   $0x5
 8058ed1:	6a 01                	push   $0x1
 8058ed3:	68 42 f3 05 08       	push   $0x805f342
 8058ed8:	e8 33 fb fe ff       	call   8048a10 <fwrite@plt>
 8058edd:	83 c4 14             	add    $0x14,%esp
 8058ee0:	68 50 af 0f 10       	push   $0x100faf50
 8058ee5:	68 18 af 0f 10       	push   $0x100faf18
 8058eea:	68 50 43 06 08       	push   $0x8064350
 8058eef:	6a 50                	push   $0x50
 8058ef1:	68 00 8a 0c 08       	push   $0x80c8a00
 8058ef6:	e8 05 fc fe ff       	call   8048b00 <snprintf@plt>
 8058efb:	83 c4 20             	add    $0x20,%esp
 8058efe:	83 f8 4f             	cmp    $0x4f,%eax
 8058f01:	7e 85                	jle    8058e88 <do_mov_l+0x38>
 8058f03:	68 b5 46 06 08       	push   $0x80646b5
 8058f08:	6a 07                	push   $0x7
 8058f0a:	68 7c 43 06 08       	push   $0x806437c
 8058f0f:	68 a0 45 06 08       	push   $0x80645a0
 8058f14:	e8 97 fc fe ff       	call   8048bb0 <__assert_fail@plt>
 8058f19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08058f20 <mov_i2r_l>:
}

make_instr_helper(i2r)
 8058f20:	53                   	push   %ebx
 8058f21:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058f24:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058f28:	83 c0 01             	add    $0x1,%eax
 8058f2b:	50                   	push   %eax
 8058f2c:	e8 df 3d 00 00       	call   805cd10 <decode_i2r_l>
 8058f31:	89 c3                	mov    %eax,%ebx
	execute();
 8058f33:	e8 18 ff ff ff       	call   8058e50 <do_mov_l>
 8058f38:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058f3b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058f3e:	5b                   	pop    %ebx
 8058f3f:	c3                   	ret    

08058f40 <mov_i2rm_l>:
make_instr_helper(i2rm)
 8058f40:	53                   	push   %ebx
 8058f41:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058f44:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058f48:	83 c0 01             	add    $0x1,%eax
 8058f4b:	50                   	push   %eax
 8058f4c:	e8 8f 3d 00 00       	call   805cce0 <decode_i2rm_l>
 8058f51:	89 c3                	mov    %eax,%ebx
	execute();
 8058f53:	e8 f8 fe ff ff       	call   8058e50 <do_mov_l>
 8058f58:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058f5b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058f5e:	5b                   	pop    %ebx
 8058f5f:	c3                   	ret    

08058f60 <mov_r2rm_l>:
make_instr_helper(r2rm)
 8058f60:	53                   	push   %ebx
 8058f61:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058f64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058f68:	83 c0 01             	add    $0x1,%eax
 8058f6b:	50                   	push   %eax
 8058f6c:	e8 af 3c 00 00       	call   805cc20 <decode_r2rm_l>
 8058f71:	89 c3                	mov    %eax,%ebx
	execute();
 8058f73:	e8 d8 fe ff ff       	call   8058e50 <do_mov_l>
 8058f78:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058f7b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058f7e:	5b                   	pop    %ebx
 8058f7f:	c3                   	ret    

08058f80 <mov_rm2r_l>:
make_instr_helper(rm2r)
 8058f80:	53                   	push   %ebx
 8058f81:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058f84:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058f88:	83 c0 01             	add    $0x1,%eax
 8058f8b:	50                   	push   %eax
 8058f8c:	e8 af 3c 00 00       	call   805cc40 <decode_rm2r_l>
 8058f91:	89 c3                	mov    %eax,%ebx
	execute();
 8058f93:	e8 b8 fe ff ff       	call   8058e50 <do_mov_l>
 8058f98:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058f9b:	8d 43 01             	lea    0x1(%ebx),%eax
 8058f9e:	5b                   	pop    %ebx
 8058f9f:	c3                   	ret    

08058fa0 <mov_i2r_b>:
static void do_execute() {
	OPERAND_W(op_dest, op_src->val);
	print_asm_template2();
}

make_instr_helper(i2r)
 8058fa0:	53                   	push   %ebx
 8058fa1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058fa4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058fa8:	83 c0 01             	add    $0x1,%eax
 8058fab:	50                   	push   %eax
 8058fac:	e8 5f 36 00 00       	call   805c610 <decode_i2r_b>
 8058fb1:	89 c3                	mov    %eax,%ebx
	execute();
 8058fb3:	e8 78 fc ff ff       	call   8058c30 <do_mov_b>
 8058fb8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058fbb:	8d 43 01             	lea    0x1(%ebx),%eax
 8058fbe:	5b                   	pop    %ebx
 8058fbf:	c3                   	ret    

08058fc0 <mov_i2rm_b>:
make_instr_helper(i2rm)
 8058fc0:	53                   	push   %ebx
 8058fc1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058fc4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058fc8:	83 c0 01             	add    $0x1,%eax
 8058fcb:	50                   	push   %eax
 8058fcc:	e8 0f 36 00 00       	call   805c5e0 <decode_i2rm_b>
 8058fd1:	89 c3                	mov    %eax,%ebx
	execute();
 8058fd3:	e8 58 fc ff ff       	call   8058c30 <do_mov_b>
 8058fd8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058fdb:	8d 43 01             	lea    0x1(%ebx),%eax
 8058fde:	5b                   	pop    %ebx
 8058fdf:	c3                   	ret    

08058fe0 <mov_r2rm_b>:
make_instr_helper(r2rm)
 8058fe0:	53                   	push   %ebx
 8058fe1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8058fe4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8058fe8:	83 c0 01             	add    $0x1,%eax
 8058feb:	50                   	push   %eax
 8058fec:	e8 2f 35 00 00       	call   805c520 <decode_r2rm_b>
 8058ff1:	89 c3                	mov    %eax,%ebx
	execute();
 8058ff3:	e8 38 fc ff ff       	call   8058c30 <do_mov_b>
 8058ff8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 8058ffb:	8d 43 01             	lea    0x1(%ebx),%eax
 8058ffe:	5b                   	pop    %ebx
 8058fff:	c3                   	ret    

08059000 <mov_rm2r_b>:
make_instr_helper(rm2r)
 8059000:	53                   	push   %ebx
 8059001:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059004:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059008:	83 c0 01             	add    $0x1,%eax
 805900b:	50                   	push   %eax
 805900c:	e8 2f 35 00 00       	call   805c540 <decode_rm2r_b>
 8059011:	89 c3                	mov    %eax,%ebx
	execute();
 8059013:	e8 18 fc ff ff       	call   8058c30 <do_mov_b>
 8059018:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805901b:	8d 43 01             	lea    0x1(%ebx),%eax
 805901e:	5b                   	pop    %ebx
 805901f:	c3                   	ret    

08059020 <mov_a2moffs_b>:

make_helper(concat(mov_a2moffs_, SUFFIX)) {
 8059020:	53                   	push   %ebx
 8059021:	83 ec 10             	sub    $0x10,%esp

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 8059024:	6a 04                	push   $0x4
	swaddr_t addr = instr_fetch(eip + 1, 4);
 8059026:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805902a:	83 c0 01             	add    $0x1,%eax
 805902d:	50                   	push   %eax
 805902e:	e8 1d 1f ff ff       	call   804af50 <swaddr_read>
 8059033:	89 c3                	mov    %eax,%ebx
	MEM_W(addr, REG(R_EAX));
 8059035:	0f b6 05 c0 af 0f 10 	movzbl 0x100fafc0,%eax
 805903c:	83 c4 0c             	add    $0xc,%esp
 805903f:	50                   	push   %eax
 8059040:	6a 01                	push   $0x1
 8059042:	53                   	push   %ebx
 8059043:	e8 58 1f ff ff       	call   804afa0 <swaddr_write>

	print_asm("mov" str(SUFFIX) " %%%s,0x%x", REG_NAME(R_EAX), addr);
 8059048:	89 1c 24             	mov    %ebx,(%esp)
 805904b:	ff 35 80 5c 07 08    	pushl  0x8075c80
 8059051:	68 5b 43 06 08       	push   $0x806435b
 8059056:	6a 50                	push   $0x50
 8059058:	68 00 8a 0c 08       	push   $0x80c8a00
 805905d:	e8 9e fa fe ff       	call   8048b00 <snprintf@plt>
 8059062:	83 c4 20             	add    $0x20,%esp
 8059065:	83 f8 4f             	cmp    $0x4f,%eax
 8059068:	7f 0e                	jg     8059078 <mov_a2moffs_b+0x58>
	return 5;
}
 805906a:	83 c4 08             	add    $0x8,%esp
 805906d:	b8 05 00 00 00       	mov    $0x5,%eax
 8059072:	5b                   	pop    %ebx
 8059073:	c3                   	ret    
 8059074:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

make_helper(concat(mov_a2moffs_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	MEM_W(addr, REG(R_EAX));

	print_asm("mov" str(SUFFIX) " %%%s,0x%x", REG_NAME(R_EAX), addr);
 8059078:	83 ec 0c             	sub    $0xc,%esp
 805907b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8059081:	e8 da f8 fe ff       	call   8048960 <fflush@plt>
 8059086:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805908c:	6a 07                	push   $0x7
 805908e:	6a 01                	push   $0x1
 8059090:	68 92 e8 05 08       	push   $0x805e892
 8059095:	e8 76 f9 fe ff       	call   8048a10 <fwrite@plt>
 805909a:	83 c4 20             	add    $0x20,%esp
 805909d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80590a3:	6a 10                	push   $0x10
 80590a5:	6a 01                	push   $0x1
 80590a7:	68 b4 f3 05 08       	push   $0x805f3b4
 80590ac:	e8 5f f9 fe ff       	call   8048a10 <fwrite@plt>
 80590b1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80590b7:	6a 05                	push   $0x5
 80590b9:	6a 01                	push   $0x1
 80590bb:	68 42 f3 05 08       	push   $0x805f342
 80590c0:	e8 4b f9 fe ff       	call   8048a10 <fwrite@plt>
 80590c5:	83 c4 14             	add    $0x14,%esp
 80590c8:	53                   	push   %ebx
 80590c9:	ff 35 80 5c 07 08    	pushl  0x8075c80
 80590cf:	68 5b 43 06 08       	push   $0x806435b
 80590d4:	6a 50                	push   $0x50
 80590d6:	68 00 8a 0c 08       	push   $0x80c8a00
 80590db:	e8 20 fa fe ff       	call   8048b00 <snprintf@plt>
 80590e0:	83 c4 20             	add    $0x20,%esp
 80590e3:	83 f8 4f             	cmp    $0x4f,%eax
 80590e6:	7e 82                	jle    805906a <mov_a2moffs_b+0x4a>
 80590e8:	68 f1 46 06 08       	push   $0x80646f1
 80590ed:	6a 13                	push   $0x13
 80590ef:	68 7c 43 06 08       	push   $0x806437c
 80590f4:	68 04 46 06 08       	push   $0x8064604
 80590f9:	e8 b2 fa fe ff       	call   8048bb0 <__assert_fail@plt>
 80590fe:	66 90                	xchg   %ax,%ax

08059100 <mov_moffs2a_b>:
	return 5;
}

make_helper(concat(mov_moffs2a_, SUFFIX)) {
 8059100:	53                   	push   %ebx
 8059101:	83 ec 10             	sub    $0x10,%esp
 8059104:	6a 04                	push   $0x4
	swaddr_t addr = instr_fetch(eip + 1, 4);
 8059106:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805910a:	83 c0 01             	add    $0x1,%eax
 805910d:	50                   	push   %eax
 805910e:	e8 3d 1e ff ff       	call   804af50 <swaddr_read>
 8059113:	89 c3                	mov    %eax,%ebx
	REG(R_EAX) = MEM_R(addr);
 8059115:	58                   	pop    %eax
 8059116:	5a                   	pop    %edx
 8059117:	6a 01                	push   $0x1
 8059119:	53                   	push   %ebx
 805911a:	e8 31 1e ff ff       	call   804af50 <swaddr_read>

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 805911f:	59                   	pop    %ecx
 8059120:	ff 35 80 5c 07 08    	pushl  0x8075c80
 8059126:	53                   	push   %ebx
 8059127:	68 6a 43 06 08       	push   $0x806436a
 805912c:	6a 50                	push   $0x50
 805912e:	68 00 8a 0c 08       	push   $0x80c8a00
	return 5;
}

make_helper(concat(mov_moffs2a_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	REG(R_EAX) = MEM_R(addr);
 8059133:	a2 c0 af 0f 10       	mov    %al,0x100fafc0

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 8059138:	e8 c3 f9 fe ff       	call   8048b00 <snprintf@plt>
 805913d:	83 c4 20             	add    $0x20,%esp
 8059140:	83 f8 4f             	cmp    $0x4f,%eax
 8059143:	7f 0b                	jg     8059150 <mov_moffs2a_b+0x50>
	return 5;
}
 8059145:	83 c4 08             	add    $0x8,%esp
 8059148:	b8 05 00 00 00       	mov    $0x5,%eax
 805914d:	5b                   	pop    %ebx
 805914e:	c3                   	ret    
 805914f:	90                   	nop

make_helper(concat(mov_moffs2a_, SUFFIX)) {
	swaddr_t addr = instr_fetch(eip + 1, 4);
	REG(R_EAX) = MEM_R(addr);

	print_asm("mov" str(SUFFIX) " 0x%x,%%%s", addr, REG_NAME(R_EAX));
 8059150:	83 ec 0c             	sub    $0xc,%esp
 8059153:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8059159:	e8 02 f8 fe ff       	call   8048960 <fflush@plt>
 805915e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059164:	6a 07                	push   $0x7
 8059166:	6a 01                	push   $0x1
 8059168:	68 92 e8 05 08       	push   $0x805e892
 805916d:	e8 9e f8 fe ff       	call   8048a10 <fwrite@plt>
 8059172:	83 c4 20             	add    $0x20,%esp
 8059175:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805917b:	6a 10                	push   $0x10
 805917d:	6a 01                	push   $0x1
 805917f:	68 b4 f3 05 08       	push   $0x805f3b4
 8059184:	e8 87 f8 fe ff       	call   8048a10 <fwrite@plt>
 8059189:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805918f:	6a 05                	push   $0x5
 8059191:	6a 01                	push   $0x1
 8059193:	68 42 f3 05 08       	push   $0x805f342
 8059198:	e8 73 f8 fe ff       	call   8048a10 <fwrite@plt>
 805919d:	83 c4 14             	add    $0x14,%esp
 80591a0:	ff 35 80 5c 07 08    	pushl  0x8075c80
 80591a6:	53                   	push   %ebx
 80591a7:	68 6a 43 06 08       	push   $0x806436a
 80591ac:	6a 50                	push   $0x50
 80591ae:	68 00 8a 0c 08       	push   $0x80c8a00
 80591b3:	e8 48 f9 fe ff       	call   8048b00 <snprintf@plt>
 80591b8:	83 c4 20             	add    $0x20,%esp
 80591bb:	83 f8 4f             	cmp    $0x4f,%eax
 80591be:	7e 85                	jle    8059145 <mov_moffs2a_b+0x45>
 80591c0:	68 e3 46 06 08       	push   $0x80646e3
 80591c5:	6a 1b                	push   $0x1b
 80591c7:	68 7c 43 06 08       	push   $0x806437c
 80591cc:	68 50 46 06 08       	push   $0x8064650
 80591d1:	e8 da f9 fe ff       	call   8048bb0 <__assert_fail@plt>
 80591d6:	8d 76 00             	lea    0x0(%esi),%esi
 80591d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080591e0 <mov_i2r_v>:
#include "mov-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(mov_i2r)
 80591e0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80591e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80591eb:	b8 d0 8d 05 08       	mov    $0x8058dd0,%eax
 80591f0:	75 05                	jne    80591f7 <mov_i2r_v+0x17>
 80591f2:	b8 20 8f 05 08       	mov    $0x8058f20,%eax
 80591f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80591fb:	ff e0                	jmp    *%eax
 80591fd:	8d 76 00             	lea    0x0(%esi),%esi

08059200 <mov_i2rm_v>:
make_helper_v(mov_i2rm)
 8059200:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8059207:	8b 54 24 04          	mov    0x4(%esp),%edx
 805920b:	b8 f0 8d 05 08       	mov    $0x8058df0,%eax
 8059210:	75 05                	jne    8059217 <mov_i2rm_v+0x17>
 8059212:	b8 40 8f 05 08       	mov    $0x8058f40,%eax
 8059217:	89 54 24 04          	mov    %edx,0x4(%esp)
 805921b:	ff e0                	jmp    *%eax
 805921d:	8d 76 00             	lea    0x0(%esi),%esi

08059220 <mov_r2rm_v>:
make_helper_v(mov_r2rm)
 8059220:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8059227:	8b 54 24 04          	mov    0x4(%esp),%edx
 805922b:	b8 10 8e 05 08       	mov    $0x8058e10,%eax
 8059230:	75 05                	jne    8059237 <mov_r2rm_v+0x17>
 8059232:	b8 60 8f 05 08       	mov    $0x8058f60,%eax
 8059237:	89 54 24 04          	mov    %edx,0x4(%esp)
 805923b:	ff e0                	jmp    *%eax
 805923d:	8d 76 00             	lea    0x0(%esi),%esi

08059240 <mov_rm2r_v>:
make_helper_v(mov_rm2r)
 8059240:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8059247:	8b 54 24 04          	mov    0x4(%esp),%edx
 805924b:	b8 30 8e 05 08       	mov    $0x8058e30,%eax
 8059250:	75 05                	jne    8059257 <mov_rm2r_v+0x17>
 8059252:	b8 80 8f 05 08       	mov    $0x8058f80,%eax
 8059257:	89 54 24 04          	mov    %edx,0x4(%esp)
 805925b:	ff e0                	jmp    *%eax
 805925d:	8d 76 00             	lea    0x0(%esi),%esi

08059260 <mov_a2moffs_v>:
make_helper_v(mov_a2moffs)
 8059260:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8059267:	8b 54 24 04          	mov    0x4(%esp),%edx
 805926b:	b8 b0 88 05 08       	mov    $0x80588b0,%eax
 8059270:	75 05                	jne    8059277 <mov_a2moffs_v+0x17>
 8059272:	b8 90 89 05 08       	mov    $0x8058990,%eax
 8059277:	89 54 24 04          	mov    %edx,0x4(%esp)
 805927b:	ff e0                	jmp    *%eax
 805927d:	8d 76 00             	lea    0x0(%esi),%esi

08059280 <mov_moffs2a_v>:
make_helper_v(mov_moffs2a)
 8059280:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8059287:	8b 54 24 04          	mov    0x4(%esp),%edx
 805928b:	b8 70 8a 05 08       	mov    $0x8058a70,%eax
 8059290:	75 05                	jne    8059297 <mov_moffs2a_v+0x17>
 8059292:	b8 50 8b 05 08       	mov    $0x8058b50,%eax
 8059297:	89 54 24 04          	mov    %edx,0x4(%esp)
 805929b:	ff e0                	jmp    *%eax
 805929d:	66 90                	xchg   %ax,%ax
 805929f:	90                   	nop

080592a0 <do_xchg_w>:
#include "cpu/exec/template-start.h"

#define instr xchg

static void do_execute () {
 80592a0:	53                   	push   %ebx
 80592a1:	83 ec 10             	sub    $0x10,%esp
 80592a4:	0f b7 05 4c af 0f 10 	movzwl 0x100faf4c,%eax
	DATA_TYPE temp = op_src->val;
 80592ab:	8b 1d 14 af 0f 10    	mov    0x100faf14,%ebx
 80592b1:	0f b7 db             	movzwl %bx,%ebx
	OPERAND_W(op_src, op_dest->val);
 80592b4:	50                   	push   %eax
 80592b5:	68 08 af 0f 10       	push   $0x100faf08
 80592ba:	e8 11 38 00 00       	call   805cad0 <write_operand_w>
	OPERAND_W(op_dest, temp);
 80592bf:	58                   	pop    %eax
 80592c0:	5a                   	pop    %edx
 80592c1:	53                   	push   %ebx
 80592c2:	68 40 af 0f 10       	push   $0x100faf40
 80592c7:	e8 04 38 00 00       	call   805cad0 <write_operand_w>
	print_asm_template2();
 80592cc:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 80592d3:	68 18 af 0f 10       	push   $0x100faf18
 80592d8:	68 08 47 06 08       	push   $0x8064708
 80592dd:	6a 50                	push   $0x50
 80592df:	68 00 8a 0c 08       	push   $0x80c8a00
 80592e4:	e8 17 f8 fe ff       	call   8048b00 <snprintf@plt>
 80592e9:	83 c4 20             	add    $0x20,%esp
 80592ec:	83 f8 4f             	cmp    $0x4f,%eax
 80592ef:	7f 0f                	jg     8059300 <do_xchg_w+0x60>
}
 80592f1:	83 c4 08             	add    $0x8,%esp
 80592f4:	5b                   	pop    %ebx
 80592f5:	c3                   	ret    
 80592f6:	8d 76 00             	lea    0x0(%esi),%esi
 80592f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

static void do_execute () {
	DATA_TYPE temp = op_src->val;
	OPERAND_W(op_src, op_dest->val);
	OPERAND_W(op_dest, temp);
	print_asm_template2();
 8059300:	83 ec 0c             	sub    $0xc,%esp
 8059303:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8059309:	e8 52 f6 fe ff       	call   8048960 <fflush@plt>
 805930e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059314:	6a 07                	push   $0x7
 8059316:	6a 01                	push   $0x1
 8059318:	68 92 e8 05 08       	push   $0x805e892
 805931d:	e8 ee f6 fe ff       	call   8048a10 <fwrite@plt>
 8059322:	83 c4 20             	add    $0x20,%esp
 8059325:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805932b:	6a 10                	push   $0x10
 805932d:	6a 01                	push   $0x1
 805932f:	68 b4 f3 05 08       	push   $0x805f3b4
 8059334:	e8 d7 f6 fe ff       	call   8048a10 <fwrite@plt>
 8059339:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805933f:	6a 05                	push   $0x5
 8059341:	6a 01                	push   $0x1
 8059343:	68 42 f3 05 08       	push   $0x805f342
 8059348:	e8 c3 f6 fe ff       	call   8048a10 <fwrite@plt>
 805934d:	83 c4 14             	add    $0x14,%esp
 8059350:	68 50 af 0f 10       	push   $0x100faf50
 8059355:	68 18 af 0f 10       	push   $0x100faf18
 805935a:	68 08 47 06 08       	push   $0x8064708
 805935f:	6a 50                	push   $0x50
 8059361:	68 00 8a 0c 08       	push   $0x80c8a00
 8059366:	e8 95 f7 fe ff       	call   8048b00 <snprintf@plt>
 805936b:	83 c4 20             	add    $0x20,%esp
 805936e:	83 f8 4f             	cmp    $0x4f,%eax
 8059371:	0f 8e 7a ff ff ff    	jle    80592f1 <do_xchg_w+0x51>
 8059377:	68 8e 48 06 08       	push   $0x806488e
 805937c:	6a 09                	push   $0x9
 805937e:	68 2c 47 06 08       	push   $0x806472c
 8059383:	68 58 47 06 08       	push   $0x8064758
 8059388:	e8 23 f8 fe ff       	call   8048bb0 <__assert_fail@plt>
 805938d:	8d 76 00             	lea    0x0(%esi),%esi

08059390 <xchg_r2rm_w>:
	do_execute();
	return 1;
}
#endif

make_instr_helper(r2rm);
 8059390:	53                   	push   %ebx
 8059391:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059394:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059398:	83 c0 01             	add    $0x1,%eax
 805939b:	50                   	push   %eax
 805939c:	e8 af 34 00 00       	call   805c850 <decode_r2rm_w>
 80593a1:	89 c3                	mov    %eax,%ebx
	execute();
 80593a3:	e8 f8 fe ff ff       	call   80592a0 <do_xchg_w>
 80593a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 80593ab:	8d 43 01             	lea    0x1(%ebx),%eax
 80593ae:	5b                   	pop    %ebx
 80593af:	c3                   	ret    

080593b0 <xchg_a2r_w>:
	OPERAND_W(op_dest, temp);
	print_asm_template2();
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(xchg_a2r_, SUFFIX)) {
 80593b0:	83 ec 18             	sub    $0x18,%esp
	concat(decode_r_, SUFFIX)(eip);
 80593b3:	ff 74 24 1c          	pushl  0x1c(%esp)
 80593b7:	e8 c4 35 00 00       	call   805c980 <decode_r_w>
	op_dest->type = OP_TYPE_REG;
	op_dest->reg = R_EAX;
	op_dest->val = REG(R_EAX);
 80593bc:	0f b7 05 c0 af 0f 10 	movzwl 0x100fafc0,%eax
	snprintf(op_dest->str, OP_STR_SIZE, "%s", REG_NAME(R_EAX));
 80593c3:	ff 35 a0 5c 07 08    	pushl  0x8075ca0
 80593c9:	68 dd f5 05 08       	push   $0x805f5dd
 80593ce:	6a 28                	push   $0x28
 80593d0:	68 50 af 0f 10       	push   $0x100faf50
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(xchg_a2r_, SUFFIX)) {
	concat(decode_r_, SUFFIX)(eip);
	op_dest->type = OP_TYPE_REG;
 80593d5:	c7 05 40 af 0f 10 00 	movl   $0x0,0x100faf40
 80593dc:	00 00 00 
	op_dest->reg = R_EAX;
 80593df:	c7 05 48 af 0f 10 00 	movl   $0x0,0x100faf48
 80593e6:	00 00 00 
	op_dest->val = REG(R_EAX);
 80593e9:	a3 4c af 0f 10       	mov    %eax,0x100faf4c
	snprintf(op_dest->str, OP_STR_SIZE, "%s", REG_NAME(R_EAX));
 80593ee:	e8 0d f7 fe ff       	call   8048b00 <snprintf@plt>
	do_execute();
 80593f3:	83 c4 20             	add    $0x20,%esp
 80593f6:	e8 a5 fe ff ff       	call   80592a0 <do_xchg_w>
	return 1;
}
 80593fb:	b8 01 00 00 00       	mov    $0x1,%eax
 8059400:	83 c4 0c             	add    $0xc,%esp
 8059403:	c3                   	ret    
 8059404:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805940a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08059410 <do_xchg_l>:
#include "cpu/exec/template-start.h"

#define instr xchg

static void do_execute () {
 8059410:	53                   	push   %ebx
 8059411:	83 ec 10             	sub    $0x10,%esp
	DATA_TYPE temp = op_src->val;
	OPERAND_W(op_src, op_dest->val);
 8059414:	ff 35 4c af 0f 10    	pushl  0x100faf4c
#include "cpu/exec/template-start.h"

#define instr xchg

static void do_execute () {
	DATA_TYPE temp = op_src->val;
 805941a:	8b 1d 14 af 0f 10    	mov    0x100faf14,%ebx
	OPERAND_W(op_src, op_dest->val);
 8059420:	68 08 af 0f 10       	push   $0x100faf08
 8059425:	e8 76 3a 00 00       	call   805cea0 <write_operand_l>
	OPERAND_W(op_dest, temp);
 805942a:	58                   	pop    %eax
 805942b:	5a                   	pop    %edx
 805942c:	53                   	push   %ebx
 805942d:	68 40 af 0f 10       	push   $0x100faf40
 8059432:	e8 69 3a 00 00       	call   805cea0 <write_operand_l>
	print_asm_template2();
 8059437:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 805943e:	68 18 af 0f 10       	push   $0x100faf18
 8059443:	68 14 47 06 08       	push   $0x8064714
 8059448:	6a 50                	push   $0x50
 805944a:	68 00 8a 0c 08       	push   $0x80c8a00
 805944f:	e8 ac f6 fe ff       	call   8048b00 <snprintf@plt>
 8059454:	83 c4 20             	add    $0x20,%esp
 8059457:	83 f8 4f             	cmp    $0x4f,%eax
 805945a:	7f 0c                	jg     8059468 <do_xchg_l+0x58>
}
 805945c:	83 c4 08             	add    $0x8,%esp
 805945f:	5b                   	pop    %ebx
 8059460:	c3                   	ret    
 8059461:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

static void do_execute () {
	DATA_TYPE temp = op_src->val;
	OPERAND_W(op_src, op_dest->val);
	OPERAND_W(op_dest, temp);
	print_asm_template2();
 8059468:	83 ec 0c             	sub    $0xc,%esp
 805946b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8059471:	e8 ea f4 fe ff       	call   8048960 <fflush@plt>
 8059476:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805947c:	6a 07                	push   $0x7
 805947e:	6a 01                	push   $0x1
 8059480:	68 92 e8 05 08       	push   $0x805e892
 8059485:	e8 86 f5 fe ff       	call   8048a10 <fwrite@plt>
 805948a:	83 c4 20             	add    $0x20,%esp
 805948d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059493:	6a 10                	push   $0x10
 8059495:	6a 01                	push   $0x1
 8059497:	68 b4 f3 05 08       	push   $0x805f3b4
 805949c:	e8 6f f5 fe ff       	call   8048a10 <fwrite@plt>
 80594a1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 80594a7:	6a 05                	push   $0x5
 80594a9:	6a 01                	push   $0x1
 80594ab:	68 42 f3 05 08       	push   $0x805f342
 80594b0:	e8 5b f5 fe ff       	call   8048a10 <fwrite@plt>
 80594b5:	83 c4 14             	add    $0x14,%esp
 80594b8:	68 50 af 0f 10       	push   $0x100faf50
 80594bd:	68 18 af 0f 10       	push   $0x100faf18
 80594c2:	68 14 47 06 08       	push   $0x8064714
 80594c7:	6a 50                	push   $0x50
 80594c9:	68 00 8a 0c 08       	push   $0x80c8a00
 80594ce:	e8 2d f6 fe ff       	call   8048b00 <snprintf@plt>
 80594d3:	83 c4 20             	add    $0x20,%esp
 80594d6:	83 f8 4f             	cmp    $0x4f,%eax
 80594d9:	7e 81                	jle    805945c <do_xchg_l+0x4c>
 80594db:	68 84 48 06 08       	push   $0x8064884
 80594e0:	6a 09                	push   $0x9
 80594e2:	68 2c 47 06 08       	push   $0x806472c
 80594e7:	68 bc 47 06 08       	push   $0x80647bc
 80594ec:	e8 bf f6 fe ff       	call   8048bb0 <__assert_fail@plt>
 80594f1:	eb 0d                	jmp    8059500 <xchg_r2rm_l>
 80594f3:	90                   	nop
 80594f4:	90                   	nop
 80594f5:	90                   	nop
 80594f6:	90                   	nop
 80594f7:	90                   	nop
 80594f8:	90                   	nop
 80594f9:	90                   	nop
 80594fa:	90                   	nop
 80594fb:	90                   	nop
 80594fc:	90                   	nop
 80594fd:	90                   	nop
 80594fe:	90                   	nop
 80594ff:	90                   	nop

08059500 <xchg_r2rm_l>:
	do_execute();
	return 1;
}
#endif

make_instr_helper(r2rm);
 8059500:	53                   	push   %ebx
 8059501:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059504:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059508:	83 c0 01             	add    $0x1,%eax
 805950b:	50                   	push   %eax
 805950c:	e8 0f 37 00 00       	call   805cc20 <decode_r2rm_l>
 8059511:	89 c3                	mov    %eax,%ebx
	execute();
 8059513:	e8 f8 fe ff ff       	call   8059410 <do_xchg_l>
 8059518:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805951b:	8d 43 01             	lea    0x1(%ebx),%eax
 805951e:	5b                   	pop    %ebx
 805951f:	c3                   	ret    

08059520 <xchg_a2r_l>:
	OPERAND_W(op_dest, temp);
	print_asm_template2();
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(xchg_a2r_, SUFFIX)) {
 8059520:	83 ec 18             	sub    $0x18,%esp
	concat(decode_r_, SUFFIX)(eip);
 8059523:	ff 74 24 1c          	pushl  0x1c(%esp)
 8059527:	e8 24 38 00 00       	call   805cd50 <decode_r_l>
	op_dest->type = OP_TYPE_REG;
	op_dest->reg = R_EAX;
	op_dest->val = REG(R_EAX);
 805952c:	a1 c0 af 0f 10       	mov    0x100fafc0,%eax
	snprintf(op_dest->str, OP_STR_SIZE, "%s", REG_NAME(R_EAX));
 8059531:	ff 35 c0 5c 07 08    	pushl  0x8075cc0
 8059537:	68 dd f5 05 08       	push   $0x805f5dd
 805953c:	6a 28                	push   $0x28
 805953e:	68 50 af 0f 10       	push   $0x100faf50
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(xchg_a2r_, SUFFIX)) {
	concat(decode_r_, SUFFIX)(eip);
	op_dest->type = OP_TYPE_REG;
 8059543:	c7 05 40 af 0f 10 00 	movl   $0x0,0x100faf40
 805954a:	00 00 00 
	op_dest->reg = R_EAX;
 805954d:	c7 05 48 af 0f 10 00 	movl   $0x0,0x100faf48
 8059554:	00 00 00 
	op_dest->val = REG(R_EAX);
 8059557:	a3 4c af 0f 10       	mov    %eax,0x100faf4c
	snprintf(op_dest->str, OP_STR_SIZE, "%s", REG_NAME(R_EAX));
 805955c:	e8 9f f5 fe ff       	call   8048b00 <snprintf@plt>
	do_execute();
 8059561:	83 c4 20             	add    $0x20,%esp
 8059564:	e8 a7 fe ff ff       	call   8059410 <do_xchg_l>
	return 1;
}
 8059569:	b8 01 00 00 00       	mov    $0x1,%eax
 805956e:	83 c4 0c             	add    $0xc,%esp
 8059571:	c3                   	ret    
 8059572:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 8059579:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

08059580 <xchg_r2rm_b>:
#endif

make_instr_helper(r2rm);
 8059580:	56                   	push   %esi
 8059581:	53                   	push   %ebx
 8059582:	83 ec 10             	sub    $0x10,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059585:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059589:	83 c0 01             	add    $0x1,%eax
 805958c:	50                   	push   %eax
 805958d:	e8 8e 2f 00 00       	call   805c520 <decode_r2rm_b>
 8059592:	89 c6                	mov    %eax,%esi
#include "cpu/exec/template-start.h"

#define instr xchg

static void do_execute () {
	DATA_TYPE temp = op_src->val;
 8059594:	8b 1d 14 af 0f 10    	mov    0x100faf14,%ebx
	OPERAND_W(op_src, op_dest->val);
 805959a:	58                   	pop    %eax
 805959b:	0f b6 05 4c af 0f 10 	movzbl 0x100faf4c,%eax
 80595a2:	5a                   	pop    %edx
 80595a3:	0f b6 db             	movzbl %bl,%ebx
 80595a6:	50                   	push   %eax
 80595a7:	68 08 af 0f 10       	push   $0x100faf08
 80595ac:	e8 8f 31 00 00       	call   805c740 <write_operand_b>
	OPERAND_W(op_dest, temp);
 80595b1:	59                   	pop    %ecx
 80595b2:	58                   	pop    %eax
 80595b3:	53                   	push   %ebx
 80595b4:	68 40 af 0f 10       	push   $0x100faf40
 80595b9:	e8 82 31 00 00       	call   805c740 <write_operand_b>
	print_asm_template2();
 80595be:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 80595c5:	68 18 af 0f 10       	push   $0x100faf18
 80595ca:	68 20 47 06 08       	push   $0x8064720
 80595cf:	6a 50                	push   $0x50
 80595d1:	68 00 8a 0c 08       	push   $0x80c8a00
 80595d6:	e8 25 f5 fe ff       	call   8048b00 <snprintf@plt>
 80595db:	83 c4 20             	add    $0x20,%esp
 80595de:	83 f8 4f             	cmp    $0x4f,%eax
 80595e1:	7f 0d                	jg     80595f0 <xchg_r2rm_b+0x70>
	do_execute();
	return 1;
}
#endif

make_instr_helper(r2rm);
 80595e3:	83 c4 04             	add    $0x4,%esp
	execute();
	return len + 1;	// "1" for opcode
 80595e6:	8d 46 01             	lea    0x1(%esi),%eax
 80595e9:	5b                   	pop    %ebx
 80595ea:	5e                   	pop    %esi
 80595eb:	c3                   	ret    
 80595ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static void do_execute () {
	DATA_TYPE temp = op_src->val;
	OPERAND_W(op_src, op_dest->val);
	OPERAND_W(op_dest, temp);
	print_asm_template2();
 80595f0:	83 ec 0c             	sub    $0xc,%esp
 80595f3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 80595f9:	e8 62 f3 fe ff       	call   8048960 <fflush@plt>
 80595fe:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059604:	6a 07                	push   $0x7
 8059606:	6a 01                	push   $0x1
 8059608:	68 92 e8 05 08       	push   $0x805e892
 805960d:	e8 fe f3 fe ff       	call   8048a10 <fwrite@plt>
 8059612:	83 c4 20             	add    $0x20,%esp
 8059615:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805961b:	6a 10                	push   $0x10
 805961d:	6a 01                	push   $0x1
 805961f:	68 b4 f3 05 08       	push   $0x805f3b4
 8059624:	e8 e7 f3 fe ff       	call   8048a10 <fwrite@plt>
 8059629:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805962f:	6a 05                	push   $0x5
 8059631:	6a 01                	push   $0x1
 8059633:	68 42 f3 05 08       	push   $0x805f342
 8059638:	e8 d3 f3 fe ff       	call   8048a10 <fwrite@plt>
 805963d:	83 c4 14             	add    $0x14,%esp
 8059640:	68 50 af 0f 10       	push   $0x100faf50
 8059645:	68 18 af 0f 10       	push   $0x100faf18
 805964a:	68 20 47 06 08       	push   $0x8064720
 805964f:	6a 50                	push   $0x50
 8059651:	68 00 8a 0c 08       	push   $0x80c8a00
 8059656:	e8 a5 f4 fe ff       	call   8048b00 <snprintf@plt>
 805965b:	83 c4 20             	add    $0x20,%esp
 805965e:	83 f8 4f             	cmp    $0x4f,%eax
 8059661:	7e 80                	jle    80595e3 <xchg_r2rm_b+0x63>
 8059663:	68 98 48 06 08       	push   $0x8064898
 8059668:	6a 09                	push   $0x9
 805966a:	68 2c 47 06 08       	push   $0x806472c
 805966f:	68 20 48 06 08       	push   $0x8064820
 8059674:	e8 37 f5 fe ff       	call   8048bb0 <__assert_fail@plt>
 8059679:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

08059680 <xchg_a2r_v>:
#undef DATA_BYTE


/* for instruction encoding overloading */

make_helper_v(xchg_a2r)
 8059680:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8059687:	8b 54 24 04          	mov    0x4(%esp),%edx
 805968b:	b8 b0 93 05 08       	mov    $0x80593b0,%eax
 8059690:	75 05                	jne    8059697 <xchg_a2r_v+0x17>
 8059692:	b8 20 95 05 08       	mov    $0x8059520,%eax
 8059697:	89 54 24 04          	mov    %edx,0x4(%esp)
 805969b:	ff e0                	jmp    *%eax
 805969d:	8d 76 00             	lea    0x0(%esi),%esi

080596a0 <xchg_r2rm_v>:
make_helper_v(xchg_r2rm)
 80596a0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80596a7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80596ab:	b8 90 93 05 08       	mov    $0x8059390,%eax
 80596b0:	75 05                	jne    80596b7 <xchg_r2rm_v+0x17>
 80596b2:	b8 00 95 05 08       	mov    $0x8059500,%eax
 80596b7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80596bb:	ff e0                	jmp    *%eax
 80596bd:	66 90                	xchg   %ax,%ax
 80596bf:	90                   	nop

080596c0 <movsx_rm2r_l>:
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(rm2r)
 80596c0:	53                   	push   %ebx
 80596c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80596c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80596c8:	83 c0 01             	add    $0x1,%eax
 80596cb:	50                   	push   %eax
 80596cc:	e8 6f 35 00 00       	call   805cc40 <decode_rm2r_l>
 80596d1:	89 c3                	mov    %eax,%ebx

static void do_execute() {
	DATA_TYPE_S res;
	res = op_src->val;
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
	OPERAND_W(op_dest, res);
 80596d3:	58                   	pop    %eax
#define instr movsx

static void do_execute() {
	DATA_TYPE_S res;
	res = op_src->val;
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
 80596d4:	0f be 05 14 af 0f 10 	movsbl 0x100faf14,%eax
	OPERAND_W(op_dest, res);
 80596db:	5a                   	pop    %edx
 80596dc:	50                   	push   %eax
 80596dd:	68 40 af 0f 10       	push   $0x100faf40
 80596e2:	e8 b9 37 00 00       	call   805cea0 <write_operand_l>
	print_asm_template2();
 80596e7:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 80596ee:	68 18 af 0f 10       	push   $0x100faf18
 80596f3:	68 a2 48 06 08       	push   $0x80648a2
 80596f8:	6a 50                	push   $0x50
 80596fa:	68 00 8a 0c 08       	push   $0x80c8a00
 80596ff:	e8 fc f3 fe ff       	call   8048b00 <snprintf@plt>
 8059704:	83 c4 20             	add    $0x20,%esp
 8059707:	83 f8 4f             	cmp    $0x4f,%eax
 805970a:	7f 0c                	jg     8059718 <movsx_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 805970c:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805970f:	8d 43 01             	lea    0x1(%ebx),%eax
 8059712:	5b                   	pop    %ebx
 8059713:	c3                   	ret    
 8059714:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static void do_execute() {
	DATA_TYPE_S res;
	res = op_src->val;
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8059718:	83 ec 0c             	sub    $0xc,%esp
 805971b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8059721:	e8 3a f2 fe ff       	call   8048960 <fflush@plt>
 8059726:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805972c:	6a 07                	push   $0x7
 805972e:	6a 01                	push   $0x1
 8059730:	68 92 e8 05 08       	push   $0x805e892
 8059735:	e8 d6 f2 fe ff       	call   8048a10 <fwrite@plt>
 805973a:	83 c4 20             	add    $0x20,%esp
 805973d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059743:	6a 10                	push   $0x10
 8059745:	6a 01                	push   $0x1
 8059747:	68 b4 f3 05 08       	push   $0x805f3b4
 805974c:	e8 bf f2 fe ff       	call   8048a10 <fwrite@plt>
 8059751:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059757:	6a 05                	push   $0x5
 8059759:	6a 01                	push   $0x1
 805975b:	68 42 f3 05 08       	push   $0x805f342
 8059760:	e8 ab f2 fe ff       	call   8048a10 <fwrite@plt>
 8059765:	83 c4 14             	add    $0x14,%esp
 8059768:	68 50 af 0f 10       	push   $0x100faf50
 805976d:	68 18 af 0f 10       	push   $0x100faf18
 8059772:	68 a2 48 06 08       	push   $0x80648a2
 8059777:	6a 50                	push   $0x50
 8059779:	68 00 8a 0c 08       	push   $0x80c8a00
 805977e:	e8 7d f3 fe ff       	call   8048b00 <snprintf@plt>
 8059783:	83 c4 20             	add    $0x20,%esp
 8059786:	83 f8 4f             	cmp    $0x4f,%eax
 8059789:	7e 81                	jle    805970c <movsx_rm2r_l+0x4c>
 805978b:	68 2d 4a 06 08       	push   $0x8064a2d
 8059790:	6a 0a                	push   $0xa
 8059792:	68 cc 48 06 08       	push   $0x80648cc
 8059797:	68 f8 48 06 08       	push   $0x80648f8
 805979c:	e8 0f f4 fe ff       	call   8048bb0 <__assert_fail@plt>
 80597a1:	eb 0d                	jmp    80597b0 <movsx_rm2r_w>
 80597a3:	90                   	nop
 80597a4:	90                   	nop
 80597a5:	90                   	nop
 80597a6:	90                   	nop
 80597a7:	90                   	nop
 80597a8:	90                   	nop
 80597a9:	90                   	nop
 80597aa:	90                   	nop
 80597ab:	90                   	nop
 80597ac:	90                   	nop
 80597ad:	90                   	nop
 80597ae:	90                   	nop
 80597af:	90                   	nop

080597b0 <movsx_rm2r_w>:
}

make_instr_helper(rm2r)
 80597b0:	53                   	push   %ebx
 80597b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80597b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80597b8:	83 c0 01             	add    $0x1,%eax
 80597bb:	50                   	push   %eax
 80597bc:	e8 af 30 00 00       	call   805c870 <decode_rm2r_w>
 80597c1:	89 c3                	mov    %eax,%ebx

static void do_execute() {
	DATA_TYPE_S res;
	res = op_src->val;
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
	OPERAND_W(op_dest, res);
 80597c3:	58                   	pop    %eax
 80597c4:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
 80597cb:	5a                   	pop    %edx
 80597cc:	50                   	push   %eax
 80597cd:	68 40 af 0f 10       	push   $0x100faf40
 80597d2:	e8 f9 32 00 00       	call   805cad0 <write_operand_w>
	print_asm_template2();
 80597d7:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 80597de:	68 18 af 0f 10       	push   $0x100faf18
 80597e3:	68 af 48 06 08       	push   $0x80648af
 80597e8:	6a 50                	push   $0x50
 80597ea:	68 00 8a 0c 08       	push   $0x80c8a00
 80597ef:	e8 0c f3 fe ff       	call   8048b00 <snprintf@plt>
 80597f4:	83 c4 20             	add    $0x20,%esp
 80597f7:	83 f8 4f             	cmp    $0x4f,%eax
 80597fa:	7f 0c                	jg     8059808 <movsx_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 80597fc:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80597ff:	8d 43 01             	lea    0x1(%ebx),%eax
 8059802:	5b                   	pop    %ebx
 8059803:	c3                   	ret    
 8059804:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static void do_execute() {
	DATA_TYPE_S res;
	res = op_src->val;
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8059808:	83 ec 0c             	sub    $0xc,%esp
 805980b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8059811:	e8 4a f1 fe ff       	call   8048960 <fflush@plt>
 8059816:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805981c:	6a 07                	push   $0x7
 805981e:	6a 01                	push   $0x1
 8059820:	68 92 e8 05 08       	push   $0x805e892
 8059825:	e8 e6 f1 fe ff       	call   8048a10 <fwrite@plt>
 805982a:	83 c4 20             	add    $0x20,%esp
 805982d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059833:	6a 10                	push   $0x10
 8059835:	6a 01                	push   $0x1
 8059837:	68 b4 f3 05 08       	push   $0x805f3b4
 805983c:	e8 cf f1 fe ff       	call   8048a10 <fwrite@plt>
 8059841:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059847:	6a 05                	push   $0x5
 8059849:	6a 01                	push   $0x1
 805984b:	68 42 f3 05 08       	push   $0x805f342
 8059850:	e8 bb f1 fe ff       	call   8048a10 <fwrite@plt>
 8059855:	83 c4 14             	add    $0x14,%esp
 8059858:	68 50 af 0f 10       	push   $0x100faf50
 805985d:	68 18 af 0f 10       	push   $0x100faf18
 8059862:	68 af 48 06 08       	push   $0x80648af
 8059867:	6a 50                	push   $0x50
 8059869:	68 00 8a 0c 08       	push   $0x80c8a00
 805986e:	e8 8d f2 fe ff       	call   8048b00 <snprintf@plt>
 8059873:	83 c4 20             	add    $0x20,%esp
 8059876:	83 f8 4f             	cmp    $0x4f,%eax
 8059879:	7e 81                	jle    80597fc <movsx_rm2r_w+0x4c>
 805987b:	68 38 4a 06 08       	push   $0x8064a38
 8059880:	6a 0a                	push   $0xa
 8059882:	68 cc 48 06 08       	push   $0x80648cc
 8059887:	68 60 49 06 08       	push   $0x8064960
 805988c:	e8 1f f3 fe ff       	call   8048bb0 <__assert_fail@plt>
 8059891:	eb 0d                	jmp    80598a0 <movsx_rm2r_b>
 8059893:	90                   	nop
 8059894:	90                   	nop
 8059895:	90                   	nop
 8059896:	90                   	nop
 8059897:	90                   	nop
 8059898:	90                   	nop
 8059899:	90                   	nop
 805989a:	90                   	nop
 805989b:	90                   	nop
 805989c:	90                   	nop
 805989d:	90                   	nop
 805989e:	90                   	nop
 805989f:	90                   	nop

080598a0 <movsx_rm2r_b>:
}

make_instr_helper(rm2r)
 80598a0:	53                   	push   %ebx
 80598a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 80598a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 80598a8:	83 c0 01             	add    $0x1,%eax
 80598ab:	50                   	push   %eax
 80598ac:	e8 8f 2c 00 00       	call   805c540 <decode_rm2r_b>
 80598b1:	89 c3                	mov    %eax,%ebx

static void do_execute() {
	DATA_TYPE_S res;
	res = op_src->val;
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
	OPERAND_W(op_dest, res);
 80598b3:	58                   	pop    %eax
 80598b4:	0f b6 05 14 af 0f 10 	movzbl 0x100faf14,%eax
 80598bb:	5a                   	pop    %edx
 80598bc:	50                   	push   %eax
 80598bd:	68 40 af 0f 10       	push   $0x100faf40
 80598c2:	e8 79 2e 00 00       	call   805c740 <write_operand_b>
	print_asm_template2();
 80598c7:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 80598ce:	68 18 af 0f 10       	push   $0x100faf18
 80598d3:	68 bc 48 06 08       	push   $0x80648bc
 80598d8:	6a 50                	push   $0x50
 80598da:	68 00 8a 0c 08       	push   $0x80c8a00
 80598df:	e8 1c f2 fe ff       	call   8048b00 <snprintf@plt>
 80598e4:	83 c4 20             	add    $0x20,%esp
 80598e7:	83 f8 4f             	cmp    $0x4f,%eax
 80598ea:	7f 0c                	jg     80598f8 <movsx_rm2r_b+0x58>
}

make_instr_helper(rm2r)
 80598ec:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 80598ef:	8d 43 01             	lea    0x1(%ebx),%eax
 80598f2:	5b                   	pop    %ebx
 80598f3:	c3                   	ret    
 80598f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
static void do_execute() {
	DATA_TYPE_S res;
	res = op_src->val;
	res = res << ((DATA_BYTE << 3) - 8) >> ((DATA_BYTE << 3) - 8);
	OPERAND_W(op_dest, res);
	print_asm_template2();
 80598f8:	83 ec 0c             	sub    $0xc,%esp
 80598fb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8059901:	e8 5a f0 fe ff       	call   8048960 <fflush@plt>
 8059906:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805990c:	6a 07                	push   $0x7
 805990e:	6a 01                	push   $0x1
 8059910:	68 92 e8 05 08       	push   $0x805e892
 8059915:	e8 f6 f0 fe ff       	call   8048a10 <fwrite@plt>
 805991a:	83 c4 20             	add    $0x20,%esp
 805991d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059923:	6a 10                	push   $0x10
 8059925:	6a 01                	push   $0x1
 8059927:	68 b4 f3 05 08       	push   $0x805f3b4
 805992c:	e8 df f0 fe ff       	call   8048a10 <fwrite@plt>
 8059931:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059937:	6a 05                	push   $0x5
 8059939:	6a 01                	push   $0x1
 805993b:	68 42 f3 05 08       	push   $0x805f342
 8059940:	e8 cb f0 fe ff       	call   8048a10 <fwrite@plt>
 8059945:	83 c4 14             	add    $0x14,%esp
 8059948:	68 50 af 0f 10       	push   $0x100faf50
 805994d:	68 18 af 0f 10       	push   $0x100faf18
 8059952:	68 bc 48 06 08       	push   $0x80648bc
 8059957:	6a 50                	push   $0x50
 8059959:	68 00 8a 0c 08       	push   $0x80c8a00
 805995e:	e8 9d f1 fe ff       	call   8048b00 <snprintf@plt>
 8059963:	83 c4 20             	add    $0x20,%esp
 8059966:	83 f8 4f             	cmp    $0x4f,%eax
 8059969:	7e 81                	jle    80598ec <movsx_rm2r_b+0x4c>
 805996b:	68 43 4a 06 08       	push   $0x8064a43
 8059970:	6a 0a                	push   $0xa
 8059972:	68 cc 48 06 08       	push   $0x80648cc
 8059977:	68 c8 49 06 08       	push   $0x80649c8
 805997c:	e8 2f f2 fe ff       	call   8048bb0 <__assert_fail@plt>
 8059981:	eb 0d                	jmp    8059990 <movsx_rm2r_v>
 8059983:	90                   	nop
 8059984:	90                   	nop
 8059985:	90                   	nop
 8059986:	90                   	nop
 8059987:	90                   	nop
 8059988:	90                   	nop
 8059989:	90                   	nop
 805998a:	90                   	nop
 805998b:	90                   	nop
 805998c:	90                   	nop
 805998d:	90                   	nop
 805998e:	90                   	nop
 805998f:	90                   	nop

08059990 <movsx_rm2r_v>:
#include "movsx-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(movsx_rm2r)
 8059990:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8059997:	8b 54 24 04          	mov    0x4(%esp),%edx
 805999b:	b8 b0 97 05 08       	mov    $0x80597b0,%eax
 80599a0:	75 05                	jne    80599a7 <movsx_rm2r_v+0x17>
 80599a2:	b8 c0 96 05 08       	mov    $0x80596c0,%eax
 80599a7:	89 54 24 04          	mov    %edx,0x4(%esp)
 80599ab:	ff e0                	jmp    *%eax
 80599ad:	66 90                	xchg   %ax,%ax
 80599af:	90                   	nop

080599b0 <cwdcdq_l>:

/* for instruction encoding overloading */

int cwdcdq_l(uint32_t eip) {
	int res = reg_l(R_EAX);
	reg_l(R_EDX) = res >> 31;
 80599b0:	a1 c0 af 0f 10       	mov    0x100fafc0,%eax
 80599b5:	c1 f8 1f             	sar    $0x1f,%eax
 80599b8:	a3 c8 af 0f 10       	mov    %eax,0x100fafc8
	return 1;
}
 80599bd:	b8 01 00 00 00       	mov    $0x1,%eax
 80599c2:	c3                   	ret    
 80599c3:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 80599c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080599d0 <cwdcdq_w>:

int cwdcdq_w(uint32_t eip) {
	short res = reg_w(R_AX);
	reg_w(R_DX) = res >> 15;
 80599d0:	0f b7 05 c0 af 0f 10 	movzwl 0x100fafc0,%eax
 80599d7:	66 c1 f8 0f          	sar    $0xf,%ax
 80599db:	66 a3 c8 af 0f 10    	mov    %ax,0x100fafc8
	return 1;
}
 80599e1:	b8 01 00 00 00       	mov    $0x1,%eax
 80599e6:	c3                   	ret    
 80599e7:	89 f6                	mov    %esi,%esi
 80599e9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

080599f0 <cwdcdq_v>:

make_helper_v(cwdcdq)
 80599f0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 80599f7:	8b 54 24 04          	mov    0x4(%esp),%edx
 80599fb:	b8 d0 99 05 08       	mov    $0x80599d0,%eax
 8059a00:	75 05                	jne    8059a07 <cwdcdq_v+0x17>
 8059a02:	b8 b0 99 05 08       	mov    $0x80599b0,%eax
 8059a07:	89 54 24 04          	mov    %edx,0x4(%esp)
 8059a0b:	ff e0                	jmp    *%eax
 8059a0d:	66 90                	xchg   %ax,%ax
 8059a0f:	90                   	nop

08059a10 <movzx_rm2r_l>:
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
	OPERAND_W(op_dest, res);
	print_asm_template2();
}

make_instr_helper(rm2r)
 8059a10:	53                   	push   %ebx
 8059a11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059a14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059a18:	83 c0 01             	add    $0x1,%eax
 8059a1b:	50                   	push   %eax
 8059a1c:	e8 1f 32 00 00       	call   805cc40 <decode_rm2r_l>
 8059a21:	89 c3                	mov    %eax,%ebx
#define instr movzx

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
	OPERAND_W(op_dest, res);
 8059a23:	58                   	pop    %eax

#define instr movzx

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
 8059a24:	0f b6 05 14 af 0f 10 	movzbl 0x100faf14,%eax
	OPERAND_W(op_dest, res);
 8059a2b:	5a                   	pop    %edx
 8059a2c:	50                   	push   %eax
 8059a2d:	68 40 af 0f 10       	push   $0x100faf40
 8059a32:	e8 69 34 00 00       	call   805cea0 <write_operand_l>
	print_asm_template2();
 8059a37:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 8059a3e:	68 18 af 0f 10       	push   $0x100faf18
 8059a43:	68 4e 4a 06 08       	push   $0x8064a4e
 8059a48:	6a 50                	push   $0x50
 8059a4a:	68 00 8a 0c 08       	push   $0x80c8a00
 8059a4f:	e8 ac f0 fe ff       	call   8048b00 <snprintf@plt>
 8059a54:	83 c4 20             	add    $0x20,%esp
 8059a57:	83 f8 4f             	cmp    $0x4f,%eax
 8059a5a:	7f 0c                	jg     8059a68 <movzx_rm2r_l+0x58>
}

make_instr_helper(rm2r)
 8059a5c:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8059a5f:	8d 43 01             	lea    0x1(%ebx),%eax
 8059a62:	5b                   	pop    %ebx
 8059a63:	c3                   	ret    
 8059a64:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8059a68:	83 ec 0c             	sub    $0xc,%esp
 8059a6b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8059a71:	e8 ea ee fe ff       	call   8048960 <fflush@plt>
 8059a76:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059a7c:	6a 07                	push   $0x7
 8059a7e:	6a 01                	push   $0x1
 8059a80:	68 92 e8 05 08       	push   $0x805e892
 8059a85:	e8 86 ef fe ff       	call   8048a10 <fwrite@plt>
 8059a8a:	83 c4 20             	add    $0x20,%esp
 8059a8d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059a93:	6a 10                	push   $0x10
 8059a95:	6a 01                	push   $0x1
 8059a97:	68 b4 f3 05 08       	push   $0x805f3b4
 8059a9c:	e8 6f ef fe ff       	call   8048a10 <fwrite@plt>
 8059aa1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059aa7:	6a 05                	push   $0x5
 8059aa9:	6a 01                	push   $0x1
 8059aab:	68 42 f3 05 08       	push   $0x805f342
 8059ab0:	e8 5b ef fe ff       	call   8048a10 <fwrite@plt>
 8059ab5:	83 c4 14             	add    $0x14,%esp
 8059ab8:	68 50 af 0f 10       	push   $0x100faf50
 8059abd:	68 18 af 0f 10       	push   $0x100faf18
 8059ac2:	68 4e 4a 06 08       	push   $0x8064a4e
 8059ac7:	6a 50                	push   $0x50
 8059ac9:	68 00 8a 0c 08       	push   $0x80c8a00
 8059ace:	e8 2d f0 fe ff       	call   8048b00 <snprintf@plt>
 8059ad3:	83 c4 20             	add    $0x20,%esp
 8059ad6:	83 f8 4f             	cmp    $0x4f,%eax
 8059ad9:	7e 81                	jle    8059a5c <movzx_rm2r_l+0x4c>
 8059adb:	68 d9 4b 06 08       	push   $0x8064bd9
 8059ae0:	6a 09                	push   $0x9
 8059ae2:	68 78 4a 06 08       	push   $0x8064a78
 8059ae7:	68 a4 4a 06 08       	push   $0x8064aa4
 8059aec:	e8 bf f0 fe ff       	call   8048bb0 <__assert_fail@plt>
 8059af1:	eb 0d                	jmp    8059b00 <movzx_rm2r_w>
 8059af3:	90                   	nop
 8059af4:	90                   	nop
 8059af5:	90                   	nop
 8059af6:	90                   	nop
 8059af7:	90                   	nop
 8059af8:	90                   	nop
 8059af9:	90                   	nop
 8059afa:	90                   	nop
 8059afb:	90                   	nop
 8059afc:	90                   	nop
 8059afd:	90                   	nop
 8059afe:	90                   	nop
 8059aff:	90                   	nop

08059b00 <movzx_rm2r_w>:
}

make_instr_helper(rm2r)
 8059b00:	53                   	push   %ebx
 8059b01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059b04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059b08:	83 c0 01             	add    $0x1,%eax
 8059b0b:	50                   	push   %eax
 8059b0c:	e8 5f 2d 00 00       	call   805c870 <decode_rm2r_w>
 8059b11:	89 c3                	mov    %eax,%ebx
#define instr movzx

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
	OPERAND_W(op_dest, res);
 8059b13:	58                   	pop    %eax

#define instr movzx

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
 8059b14:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
	OPERAND_W(op_dest, res);
 8059b1b:	5a                   	pop    %edx
 8059b1c:	50                   	push   %eax
 8059b1d:	68 40 af 0f 10       	push   $0x100faf40
 8059b22:	e8 a9 2f 00 00       	call   805cad0 <write_operand_w>
	print_asm_template2();
 8059b27:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 8059b2e:	68 18 af 0f 10       	push   $0x100faf18
 8059b33:	68 5b 4a 06 08       	push   $0x8064a5b
 8059b38:	6a 50                	push   $0x50
 8059b3a:	68 00 8a 0c 08       	push   $0x80c8a00
 8059b3f:	e8 bc ef fe ff       	call   8048b00 <snprintf@plt>
 8059b44:	83 c4 20             	add    $0x20,%esp
 8059b47:	83 f8 4f             	cmp    $0x4f,%eax
 8059b4a:	7f 0c                	jg     8059b58 <movzx_rm2r_w+0x58>
}

make_instr_helper(rm2r)
 8059b4c:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8059b4f:	8d 43 01             	lea    0x1(%ebx),%eax
 8059b52:	5b                   	pop    %ebx
 8059b53:	c3                   	ret    
 8059b54:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8059b58:	83 ec 0c             	sub    $0xc,%esp
 8059b5b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8059b61:	e8 fa ed fe ff       	call   8048960 <fflush@plt>
 8059b66:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059b6c:	6a 07                	push   $0x7
 8059b6e:	6a 01                	push   $0x1
 8059b70:	68 92 e8 05 08       	push   $0x805e892
 8059b75:	e8 96 ee fe ff       	call   8048a10 <fwrite@plt>
 8059b7a:	83 c4 20             	add    $0x20,%esp
 8059b7d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059b83:	6a 10                	push   $0x10
 8059b85:	6a 01                	push   $0x1
 8059b87:	68 b4 f3 05 08       	push   $0x805f3b4
 8059b8c:	e8 7f ee fe ff       	call   8048a10 <fwrite@plt>
 8059b91:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059b97:	6a 05                	push   $0x5
 8059b99:	6a 01                	push   $0x1
 8059b9b:	68 42 f3 05 08       	push   $0x805f342
 8059ba0:	e8 6b ee fe ff       	call   8048a10 <fwrite@plt>
 8059ba5:	83 c4 14             	add    $0x14,%esp
 8059ba8:	68 50 af 0f 10       	push   $0x100faf50
 8059bad:	68 18 af 0f 10       	push   $0x100faf18
 8059bb2:	68 5b 4a 06 08       	push   $0x8064a5b
 8059bb7:	6a 50                	push   $0x50
 8059bb9:	68 00 8a 0c 08       	push   $0x80c8a00
 8059bbe:	e8 3d ef fe ff       	call   8048b00 <snprintf@plt>
 8059bc3:	83 c4 20             	add    $0x20,%esp
 8059bc6:	83 f8 4f             	cmp    $0x4f,%eax
 8059bc9:	7e 81                	jle    8059b4c <movzx_rm2r_w+0x4c>
 8059bcb:	68 e4 4b 06 08       	push   $0x8064be4
 8059bd0:	6a 09                	push   $0x9
 8059bd2:	68 78 4a 06 08       	push   $0x8064a78
 8059bd7:	68 0c 4b 06 08       	push   $0x8064b0c
 8059bdc:	e8 cf ef fe ff       	call   8048bb0 <__assert_fail@plt>
 8059be1:	eb 0d                	jmp    8059bf0 <movzx_rm2r_b>
 8059be3:	90                   	nop
 8059be4:	90                   	nop
 8059be5:	90                   	nop
 8059be6:	90                   	nop
 8059be7:	90                   	nop
 8059be8:	90                   	nop
 8059be9:	90                   	nop
 8059bea:	90                   	nop
 8059beb:	90                   	nop
 8059bec:	90                   	nop
 8059bed:	90                   	nop
 8059bee:	90                   	nop
 8059bef:	90                   	nop

08059bf0 <movzx_rm2r_b>:
}

make_instr_helper(rm2r)
 8059bf0:	53                   	push   %ebx
 8059bf1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059bf4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059bf8:	83 c0 01             	add    $0x1,%eax
 8059bfb:	50                   	push   %eax
 8059bfc:	e8 3f 29 00 00       	call   805c540 <decode_rm2r_b>
 8059c01:	89 c3                	mov    %eax,%ebx
#define instr movzx

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
	OPERAND_W(op_dest, res);
 8059c03:	58                   	pop    %eax
 8059c04:	0f b6 05 14 af 0f 10 	movzbl 0x100faf14,%eax
 8059c0b:	5a                   	pop    %edx
 8059c0c:	50                   	push   %eax
 8059c0d:	68 40 af 0f 10       	push   $0x100faf40
 8059c12:	e8 29 2b 00 00       	call   805c740 <write_operand_b>
	print_asm_template2();
 8059c17:	c7 04 24 50 af 0f 10 	movl   $0x100faf50,(%esp)
 8059c1e:	68 18 af 0f 10       	push   $0x100faf18
 8059c23:	68 68 4a 06 08       	push   $0x8064a68
 8059c28:	6a 50                	push   $0x50
 8059c2a:	68 00 8a 0c 08       	push   $0x80c8a00
 8059c2f:	e8 cc ee fe ff       	call   8048b00 <snprintf@plt>
 8059c34:	83 c4 20             	add    $0x20,%esp
 8059c37:	83 f8 4f             	cmp    $0x4f,%eax
 8059c3a:	7f 0c                	jg     8059c48 <movzx_rm2r_b+0x58>
}

make_instr_helper(rm2r)
 8059c3c:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8059c3f:	8d 43 01             	lea    0x1(%ebx),%eax
 8059c42:	5b                   	pop    %ebx
 8059c43:	c3                   	ret    
 8059c44:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static void do_execute() {
	DATA_TYPE res = op_src->val;
	res = ((res << ((DATA_BYTE << 3) - 8)) >> ((DATA_BYTE << 3) - 8));
	OPERAND_W(op_dest, res);
	print_asm_template2();
 8059c48:	83 ec 0c             	sub    $0xc,%esp
 8059c4b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8059c51:	e8 0a ed fe ff       	call   8048960 <fflush@plt>
 8059c56:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059c5c:	6a 07                	push   $0x7
 8059c5e:	6a 01                	push   $0x1
 8059c60:	68 92 e8 05 08       	push   $0x805e892
 8059c65:	e8 a6 ed fe ff       	call   8048a10 <fwrite@plt>
 8059c6a:	83 c4 20             	add    $0x20,%esp
 8059c6d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059c73:	6a 10                	push   $0x10
 8059c75:	6a 01                	push   $0x1
 8059c77:	68 b4 f3 05 08       	push   $0x805f3b4
 8059c7c:	e8 8f ed fe ff       	call   8048a10 <fwrite@plt>
 8059c81:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059c87:	6a 05                	push   $0x5
 8059c89:	6a 01                	push   $0x1
 8059c8b:	68 42 f3 05 08       	push   $0x805f342
 8059c90:	e8 7b ed fe ff       	call   8048a10 <fwrite@plt>
 8059c95:	83 c4 14             	add    $0x14,%esp
 8059c98:	68 50 af 0f 10       	push   $0x100faf50
 8059c9d:	68 18 af 0f 10       	push   $0x100faf18
 8059ca2:	68 68 4a 06 08       	push   $0x8064a68
 8059ca7:	6a 50                	push   $0x50
 8059ca9:	68 00 8a 0c 08       	push   $0x80c8a00
 8059cae:	e8 4d ee fe ff       	call   8048b00 <snprintf@plt>
 8059cb3:	83 c4 20             	add    $0x20,%esp
 8059cb6:	83 f8 4f             	cmp    $0x4f,%eax
 8059cb9:	7e 81                	jle    8059c3c <movzx_rm2r_b+0x4c>
 8059cbb:	68 ef 4b 06 08       	push   $0x8064bef
 8059cc0:	6a 09                	push   $0x9
 8059cc2:	68 78 4a 06 08       	push   $0x8064a78
 8059cc7:	68 74 4b 06 08       	push   $0x8064b74
 8059ccc:	e8 df ee fe ff       	call   8048bb0 <__assert_fail@plt>
 8059cd1:	eb 0d                	jmp    8059ce0 <movzx_rm2r_v>
 8059cd3:	90                   	nop
 8059cd4:	90                   	nop
 8059cd5:	90                   	nop
 8059cd6:	90                   	nop
 8059cd7:	90                   	nop
 8059cd8:	90                   	nop
 8059cd9:	90                   	nop
 8059cda:	90                   	nop
 8059cdb:	90                   	nop
 8059cdc:	90                   	nop
 8059cdd:	90                   	nop
 8059cde:	90                   	nop
 8059cdf:	90                   	nop

08059ce0 <movzx_rm2r_v>:
#include "movzx-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(movzx_rm2r)
 8059ce0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8059ce7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8059ceb:	b8 00 9b 05 08       	mov    $0x8059b00,%eax
 8059cf0:	75 05                	jne    8059cf7 <movzx_rm2r_v+0x17>
 8059cf2:	b8 10 9a 05 08       	mov    $0x8059a10,%eax
 8059cf7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8059cfb:	ff e0                	jmp    *%eax
 8059cfd:	66 90                	xchg   %ax,%ax
 8059cff:	90                   	nop

08059d00 <mul_rm_w>:
	 */

	print_asm_template1();
}

make_instr_helper(rm)
 8059d00:	53                   	push   %ebx
 8059d01:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059d04:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059d08:	83 c0 01             	add    $0x1,%eax
 8059d0b:	50                   	push   %eax
 8059d0c:	e8 4f 2c 00 00       	call   805c960 <decode_rm_w>

#define instr mul

static void do_execute() {
	uint64_t src = op_src->val;
	uint64_t result = REG(R_EAX) * src;
 8059d11:	0f b7 0d c0 af 0f 10 	movzwl 0x100fafc0,%ecx
 8059d18:	89 c3                	mov    %eax,%ebx

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 8059d1a:	68 18 af 0f 10       	push   $0x100faf18
 8059d1f:	68 d2 51 06 08       	push   $0x80651d2
 8059d24:	6a 50                	push   $0x50
 8059d26:	68 00 8a 0c 08       	push   $0x80c8a00

#define instr mul

static void do_execute() {
	uint64_t src = op_src->val;
	uint64_t result = REG(R_EAX) * src;
 8059d2b:	89 c8                	mov    %ecx,%eax
 8059d2d:	f7 25 14 af 0f 10    	mull   0x100faf14
#if DATA_BYTE == 1
	reg_w(R_AX) = result;
#elif DATA_BYTE == 2
	REG(R_EAX) = result & 0xffff;
 8059d33:	66 a3 c0 af 0f 10    	mov    %ax,0x100fafc0
	REG(R_EDX) = result >> 16;
 8059d39:	0f ac d0 10          	shrd   $0x10,%edx,%eax
 8059d3d:	66 a3 c8 af 0f 10    	mov    %ax,0x100fafc8

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 8059d43:	e8 b8 ed fe ff       	call   8048b00 <snprintf@plt>
 8059d48:	83 c4 20             	add    $0x20,%esp
 8059d4b:	83 f8 4f             	cmp    $0x4f,%eax
 8059d4e:	7f 10                	jg     8059d60 <mul_rm_w+0x60>
}

make_instr_helper(rm)
 8059d50:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8059d53:	8d 43 01             	lea    0x1(%ebx),%eax
 8059d56:	5b                   	pop    %ebx
 8059d57:	c3                   	ret    
 8059d58:	90                   	nop
 8059d59:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 8059d60:	83 ec 0c             	sub    $0xc,%esp
 8059d63:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8059d69:	e8 f2 eb fe ff       	call   8048960 <fflush@plt>
 8059d6e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059d74:	6a 07                	push   $0x7
 8059d76:	6a 01                	push   $0x1
 8059d78:	68 92 e8 05 08       	push   $0x805e892
 8059d7d:	e8 8e ec fe ff       	call   8048a10 <fwrite@plt>
 8059d82:	83 c4 20             	add    $0x20,%esp
 8059d85:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059d8b:	6a 10                	push   $0x10
 8059d8d:	6a 01                	push   $0x1
 8059d8f:	68 b4 f3 05 08       	push   $0x805f3b4
 8059d94:	e8 77 ec fe ff       	call   8048a10 <fwrite@plt>
 8059d99:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059d9f:	6a 05                	push   $0x5
 8059da1:	6a 01                	push   $0x1
 8059da3:	68 42 f3 05 08       	push   $0x805f342
 8059da8:	e8 63 ec fe ff       	call   8048a10 <fwrite@plt>
 8059dad:	83 c4 20             	add    $0x20,%esp
 8059db0:	68 18 af 0f 10       	push   $0x100faf18
 8059db5:	68 d2 51 06 08       	push   $0x80651d2
 8059dba:	6a 50                	push   $0x50
 8059dbc:	68 00 8a 0c 08       	push   $0x80c8a00
 8059dc1:	e8 3a ed fe ff       	call   8048b00 <snprintf@plt>
 8059dc6:	83 c4 10             	add    $0x10,%esp
 8059dc9:	83 f8 4f             	cmp    $0x4f,%eax
 8059dcc:	7e 82                	jle    8059d50 <mul_rm_w+0x50>
 8059dce:	68 03 4d 06 08       	push   $0x8064d03
 8059dd3:	6a 16                	push   $0x16
 8059dd5:	68 fc 4b 06 08       	push   $0x8064bfc
 8059dda:	68 24 4c 06 08       	push   $0x8064c24
 8059ddf:	e8 cc ed fe ff       	call   8048bb0 <__assert_fail@plt>
 8059de4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8059dea:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08059df0 <mul_rm_l>:
}

make_instr_helper(rm)
 8059df0:	53                   	push   %ebx
 8059df1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059df4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059df8:	83 c0 01             	add    $0x1,%eax
 8059dfb:	50                   	push   %eax
 8059dfc:	e8 2f 2f 00 00       	call   805cd30 <decode_rm_l>
 8059e01:	89 c3                	mov    %eax,%ebx

#define instr mul

static void do_execute() {
	uint64_t src = op_src->val;
	uint64_t result = REG(R_EAX) * src;
 8059e03:	a1 c0 af 0f 10       	mov    0x100fafc0,%eax

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 8059e08:	68 18 af 0f 10       	push   $0x100faf18

#define instr mul

static void do_execute() {
	uint64_t src = op_src->val;
	uint64_t result = REG(R_EAX) * src;
 8059e0d:	f7 25 14 af 0f 10    	mull   0x100faf14

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 8059e13:	68 db 51 06 08       	push   $0x80651db
 8059e18:	6a 50                	push   $0x50
 8059e1a:	68 00 8a 0c 08       	push   $0x80c8a00
	reg_w(R_AX) = result;
#elif DATA_BYTE == 2
	REG(R_EAX) = result & 0xffff;
	REG(R_EDX) = result >> 16;
#else
	REG(R_EAX) = result & 0xffffffff;
 8059e1f:	a3 c0 af 0f 10       	mov    %eax,0x100fafc0
	REG(R_EDX) = result >> 32;
 8059e24:	89 15 c8 af 0f 10    	mov    %edx,0x100fafc8

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 8059e2a:	e8 d1 ec fe ff       	call   8048b00 <snprintf@plt>
 8059e2f:	83 c4 20             	add    $0x20,%esp
 8059e32:	83 f8 4f             	cmp    $0x4f,%eax
 8059e35:	7f 09                	jg     8059e40 <mul_rm_l+0x50>
}

make_instr_helper(rm)
 8059e37:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8059e3a:	8d 43 01             	lea    0x1(%ebx),%eax
 8059e3d:	5b                   	pop    %ebx
 8059e3e:	c3                   	ret    
 8059e3f:	90                   	nop

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 8059e40:	83 ec 0c             	sub    $0xc,%esp
 8059e43:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8059e49:	e8 12 eb fe ff       	call   8048960 <fflush@plt>
 8059e4e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059e54:	6a 07                	push   $0x7
 8059e56:	6a 01                	push   $0x1
 8059e58:	68 92 e8 05 08       	push   $0x805e892
 8059e5d:	e8 ae eb fe ff       	call   8048a10 <fwrite@plt>
 8059e62:	83 c4 20             	add    $0x20,%esp
 8059e65:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059e6b:	6a 10                	push   $0x10
 8059e6d:	6a 01                	push   $0x1
 8059e6f:	68 b4 f3 05 08       	push   $0x805f3b4
 8059e74:	e8 97 eb fe ff       	call   8048a10 <fwrite@plt>
 8059e79:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059e7f:	6a 05                	push   $0x5
 8059e81:	6a 01                	push   $0x1
 8059e83:	68 42 f3 05 08       	push   $0x805f342
 8059e88:	e8 83 eb fe ff       	call   8048a10 <fwrite@plt>
 8059e8d:	83 c4 20             	add    $0x20,%esp
 8059e90:	68 18 af 0f 10       	push   $0x100faf18
 8059e95:	68 db 51 06 08       	push   $0x80651db
 8059e9a:	6a 50                	push   $0x50
 8059e9c:	68 00 8a 0c 08       	push   $0x80c8a00
 8059ea1:	e8 5a ec fe ff       	call   8048b00 <snprintf@plt>
 8059ea6:	83 c4 10             	add    $0x10,%esp
 8059ea9:	83 f8 4f             	cmp    $0x4f,%eax
 8059eac:	7e 89                	jle    8059e37 <mul_rm_l+0x47>
 8059eae:	68 fa 4c 06 08       	push   $0x8064cfa
 8059eb3:	6a 16                	push   $0x16
 8059eb5:	68 fc 4b 06 08       	push   $0x8064bfc
 8059eba:	68 6c 4c 06 08       	push   $0x8064c6c
 8059ebf:	e8 ec ec fe ff       	call   8048bb0 <__assert_fail@plt>
 8059ec4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8059eca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08059ed0 <mul_rm_b>:
}

make_instr_helper(rm)
 8059ed0:	53                   	push   %ebx
 8059ed1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059ed4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059ed8:	83 c0 01             	add    $0x1,%eax
 8059edb:	50                   	push   %eax
 8059edc:	e8 4f 27 00 00       	call   805c630 <decode_rm_b>
 8059ee1:	89 c3                	mov    %eax,%ebx

#define instr mul

static void do_execute() {
	uint64_t src = op_src->val;
	uint64_t result = REG(R_EAX) * src;
 8059ee3:	0f b6 05 c0 af 0f 10 	movzbl 0x100fafc0,%eax

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 8059eea:	68 18 af 0f 10       	push   $0x100faf18

#define instr mul

static void do_execute() {
	uint64_t src = op_src->val;
	uint64_t result = REG(R_EAX) * src;
 8059eef:	f7 25 14 af 0f 10    	mull   0x100faf14

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 8059ef5:	68 02 52 06 08       	push   $0x8065202
 8059efa:	6a 50                	push   $0x50
 8059efc:	68 00 8a 0c 08       	push   $0x80c8a00

static void do_execute() {
	uint64_t src = op_src->val;
	uint64_t result = REG(R_EAX) * src;
#if DATA_BYTE == 1
	reg_w(R_AX) = result;
 8059f01:	66 a3 c0 af 0f 10    	mov    %ax,0x100fafc0

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 8059f07:	e8 f4 eb fe ff       	call   8048b00 <snprintf@plt>
 8059f0c:	83 c4 20             	add    $0x20,%esp
 8059f0f:	83 f8 4f             	cmp    $0x4f,%eax
 8059f12:	7f 0c                	jg     8059f20 <mul_rm_b+0x50>
}

make_instr_helper(rm)
 8059f14:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 8059f17:	8d 43 01             	lea    0x1(%ebx),%eax
 8059f1a:	5b                   	pop    %ebx
 8059f1b:	c3                   	ret    
 8059f1c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 8059f20:	83 ec 0c             	sub    $0xc,%esp
 8059f23:	ff 35 20 5d 07 08    	pushl  0x8075d20
 8059f29:	e8 32 ea fe ff       	call   8048960 <fflush@plt>
 8059f2e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059f34:	6a 07                	push   $0x7
 8059f36:	6a 01                	push   $0x1
 8059f38:	68 92 e8 05 08       	push   $0x805e892
 8059f3d:	e8 ce ea fe ff       	call   8048a10 <fwrite@plt>
 8059f42:	83 c4 20             	add    $0x20,%esp
 8059f45:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059f4b:	6a 10                	push   $0x10
 8059f4d:	6a 01                	push   $0x1
 8059f4f:	68 b4 f3 05 08       	push   $0x805f3b4
 8059f54:	e8 b7 ea fe ff       	call   8048a10 <fwrite@plt>
 8059f59:	ff 35 00 5d 07 08    	pushl  0x8075d00
 8059f5f:	6a 05                	push   $0x5
 8059f61:	6a 01                	push   $0x1
 8059f63:	68 42 f3 05 08       	push   $0x805f342
 8059f68:	e8 a3 ea fe ff       	call   8048a10 <fwrite@plt>
 8059f6d:	83 c4 20             	add    $0x20,%esp
 8059f70:	68 18 af 0f 10       	push   $0x100faf18
 8059f75:	68 02 52 06 08       	push   $0x8065202
 8059f7a:	6a 50                	push   $0x50
 8059f7c:	68 00 8a 0c 08       	push   $0x80c8a00
 8059f81:	e8 7a eb fe ff       	call   8048b00 <snprintf@plt>
 8059f86:	83 c4 10             	add    $0x10,%esp
 8059f89:	83 f8 4f             	cmp    $0x4f,%eax
 8059f8c:	7e 86                	jle    8059f14 <mul_rm_b+0x44>
 8059f8e:	68 0c 4d 06 08       	push   $0x8064d0c
 8059f93:	6a 16                	push   $0x16
 8059f95:	68 fc 4b 06 08       	push   $0x8064bfc
 8059f9a:	68 b4 4c 06 08       	push   $0x8064cb4
 8059f9f:	e8 0c ec fe ff       	call   8048bb0 <__assert_fail@plt>
 8059fa4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 8059faa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

08059fb0 <mul_rm_v>:
#include "mul-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(mul_rm)
 8059fb0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 8059fb7:	8b 54 24 04          	mov    0x4(%esp),%edx
 8059fbb:	b8 00 9d 05 08       	mov    $0x8059d00,%eax
 8059fc0:	75 05                	jne    8059fc7 <mul_rm_v+0x17>
 8059fc2:	b8 f0 9d 05 08       	mov    $0x8059df0,%eax
 8059fc7:	89 54 24 04          	mov    %edx,0x4(%esp)
 8059fcb:	ff e0                	jmp    *%eax
 8059fcd:	66 90                	xchg   %ax,%ax
 8059fcf:	90                   	nop

08059fd0 <neg_rm_l>:
	 */

	print_asm_template1();
}

make_instr_helper(rm)
 8059fd0:	53                   	push   %ebx
 8059fd1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 8059fd4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 8059fd8:	83 c0 01             	add    $0x1,%eax
 8059fdb:	50                   	push   %eax
 8059fdc:	e8 4f 2d 00 00       	call   805cd30 <decode_rm_l>
 8059fe1:	89 c3                	mov    %eax,%ebx

#define instr neg

static void do_execute() {
	DATA_TYPE result = -op_src->val;
	OPERAND_W(op_src, result);
 8059fe3:	58                   	pop    %eax
 8059fe4:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr neg

static void do_execute() {
	DATA_TYPE result = -op_src->val;
 8059fe5:	8b 15 14 af 0f 10    	mov    0x100faf14,%edx
 8059feb:	f7 da                	neg    %edx
	OPERAND_W(op_src, result);
 8059fed:	52                   	push   %edx
 8059fee:	68 08 af 0f 10       	push   $0x100faf08
 8059ff3:	e8 a8 2e 00 00       	call   805cea0 <write_operand_l>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 8059ff8:	68 18 af 0f 10       	push   $0x100faf18
 8059ffd:	68 15 4d 06 08       	push   $0x8064d15
 805a002:	6a 50                	push   $0x50
 805a004:	68 00 8a 0c 08       	push   $0x80c8a00
 805a009:	e8 f2 ea fe ff       	call   8048b00 <snprintf@plt>
 805a00e:	83 c4 20             	add    $0x20,%esp
 805a011:	83 f8 4f             	cmp    $0x4f,%eax
 805a014:	7f 0a                	jg     805a020 <neg_rm_l+0x50>
}

make_instr_helper(rm)
 805a016:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805a019:	8d 43 01             	lea    0x1(%ebx),%eax
 805a01c:	5b                   	pop    %ebx
 805a01d:	c3                   	ret    
 805a01e:	66 90                	xchg   %ax,%ax

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a020:	83 ec 0c             	sub    $0xc,%esp
 805a023:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805a029:	e8 32 e9 fe ff       	call   8048960 <fflush@plt>
 805a02e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a034:	6a 07                	push   $0x7
 805a036:	6a 01                	push   $0x1
 805a038:	68 92 e8 05 08       	push   $0x805e892
 805a03d:	e8 ce e9 fe ff       	call   8048a10 <fwrite@plt>
 805a042:	83 c4 20             	add    $0x20,%esp
 805a045:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a04b:	6a 10                	push   $0x10
 805a04d:	6a 01                	push   $0x1
 805a04f:	68 b4 f3 05 08       	push   $0x805f3b4
 805a054:	e8 b7 e9 fe ff       	call   8048a10 <fwrite@plt>
 805a059:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a05f:	6a 05                	push   $0x5
 805a061:	6a 01                	push   $0x1
 805a063:	68 42 f3 05 08       	push   $0x805f342
 805a068:	e8 a3 e9 fe ff       	call   8048a10 <fwrite@plt>
 805a06d:	83 c4 20             	add    $0x20,%esp
 805a070:	68 18 af 0f 10       	push   $0x100faf18
 805a075:	68 15 4d 06 08       	push   $0x8064d15
 805a07a:	6a 50                	push   $0x50
 805a07c:	68 00 8a 0c 08       	push   $0x80c8a00
 805a081:	e8 7a ea fe ff       	call   8048b00 <snprintf@plt>
 805a086:	83 c4 10             	add    $0x10,%esp
 805a089:	83 f8 4f             	cmp    $0x4f,%eax
 805a08c:	7e 88                	jle    805a016 <neg_rm_l+0x46>
 805a08e:	68 2e 4e 06 08       	push   $0x8064e2e
 805a093:	6a 0d                	push   $0xd
 805a095:	68 30 4d 06 08       	push   $0x8064d30
 805a09a:	68 58 4d 06 08       	push   $0x8064d58
 805a09f:	e8 0c eb fe ff       	call   8048bb0 <__assert_fail@plt>
 805a0a4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805a0aa:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805a0b0 <neg_rm_w>:
}

make_instr_helper(rm)
 805a0b0:	53                   	push   %ebx
 805a0b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a0b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a0b8:	83 c0 01             	add    $0x1,%eax
 805a0bb:	50                   	push   %eax
 805a0bc:	e8 9f 28 00 00       	call   805c960 <decode_rm_w>
 805a0c1:	89 c3                	mov    %eax,%ebx

#define instr neg

static void do_execute() {
	DATA_TYPE result = -op_src->val;
	OPERAND_W(op_src, result);
 805a0c3:	58                   	pop    %eax
 805a0c4:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr neg

static void do_execute() {
	DATA_TYPE result = -op_src->val;
 805a0c5:	0f b7 15 14 af 0f 10 	movzwl 0x100faf14,%edx
 805a0cc:	f7 da                	neg    %edx
	OPERAND_W(op_src, result);
 805a0ce:	0f b7 d2             	movzwl %dx,%edx
 805a0d1:	52                   	push   %edx
 805a0d2:	68 08 af 0f 10       	push   $0x100faf08
 805a0d7:	e8 f4 29 00 00       	call   805cad0 <write_operand_w>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a0dc:	68 18 af 0f 10       	push   $0x100faf18
 805a0e1:	68 1d 4d 06 08       	push   $0x8064d1d
 805a0e6:	6a 50                	push   $0x50
 805a0e8:	68 00 8a 0c 08       	push   $0x80c8a00
 805a0ed:	e8 0e ea fe ff       	call   8048b00 <snprintf@plt>
 805a0f2:	83 c4 20             	add    $0x20,%esp
 805a0f5:	83 f8 4f             	cmp    $0x4f,%eax
 805a0f8:	7f 0e                	jg     805a108 <neg_rm_w+0x58>
}

make_instr_helper(rm)
 805a0fa:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805a0fd:	8d 43 01             	lea    0x1(%ebx),%eax
 805a100:	5b                   	pop    %ebx
 805a101:	c3                   	ret    
 805a102:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a108:	83 ec 0c             	sub    $0xc,%esp
 805a10b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805a111:	e8 4a e8 fe ff       	call   8048960 <fflush@plt>
 805a116:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a11c:	6a 07                	push   $0x7
 805a11e:	6a 01                	push   $0x1
 805a120:	68 92 e8 05 08       	push   $0x805e892
 805a125:	e8 e6 e8 fe ff       	call   8048a10 <fwrite@plt>
 805a12a:	83 c4 20             	add    $0x20,%esp
 805a12d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a133:	6a 10                	push   $0x10
 805a135:	6a 01                	push   $0x1
 805a137:	68 b4 f3 05 08       	push   $0x805f3b4
 805a13c:	e8 cf e8 fe ff       	call   8048a10 <fwrite@plt>
 805a141:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a147:	6a 05                	push   $0x5
 805a149:	6a 01                	push   $0x1
 805a14b:	68 42 f3 05 08       	push   $0x805f342
 805a150:	e8 bb e8 fe ff       	call   8048a10 <fwrite@plt>
 805a155:	83 c4 20             	add    $0x20,%esp
 805a158:	68 18 af 0f 10       	push   $0x100faf18
 805a15d:	68 1d 4d 06 08       	push   $0x8064d1d
 805a162:	6a 50                	push   $0x50
 805a164:	68 00 8a 0c 08       	push   $0x80c8a00
 805a169:	e8 92 e9 fe ff       	call   8048b00 <snprintf@plt>
 805a16e:	83 c4 10             	add    $0x10,%esp
 805a171:	83 f8 4f             	cmp    $0x4f,%eax
 805a174:	7e 84                	jle    805a0fa <neg_rm_w+0x4a>
 805a176:	68 37 4e 06 08       	push   $0x8064e37
 805a17b:	6a 0d                	push   $0xd
 805a17d:	68 30 4d 06 08       	push   $0x8064d30
 805a182:	68 a0 4d 06 08       	push   $0x8064da0
 805a187:	e8 24 ea fe ff       	call   8048bb0 <__assert_fail@plt>
 805a18c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805a190 <neg_rm_b>:
}

make_instr_helper(rm)
 805a190:	53                   	push   %ebx
 805a191:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a194:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a198:	83 c0 01             	add    $0x1,%eax
 805a19b:	50                   	push   %eax
 805a19c:	e8 8f 24 00 00       	call   805c630 <decode_rm_b>
 805a1a1:	89 c3                	mov    %eax,%ebx

#define instr neg

static void do_execute() {
	DATA_TYPE result = -op_src->val;
	OPERAND_W(op_src, result);
 805a1a3:	58                   	pop    %eax
 805a1a4:	5a                   	pop    %edx
#include "cpu/exec/template-start.h"

#define instr neg

static void do_execute() {
	DATA_TYPE result = -op_src->val;
 805a1a5:	0f b6 15 14 af 0f 10 	movzbl 0x100faf14,%edx
 805a1ac:	f7 da                	neg    %edx
	OPERAND_W(op_src, result);
 805a1ae:	0f b6 d2             	movzbl %dl,%edx
 805a1b1:	52                   	push   %edx
 805a1b2:	68 08 af 0f 10       	push   $0x100faf08
 805a1b7:	e8 84 25 00 00       	call   805c740 <write_operand_b>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a1bc:	68 18 af 0f 10       	push   $0x100faf18
 805a1c1:	68 25 4d 06 08       	push   $0x8064d25
 805a1c6:	6a 50                	push   $0x50
 805a1c8:	68 00 8a 0c 08       	push   $0x80c8a00
 805a1cd:	e8 2e e9 fe ff       	call   8048b00 <snprintf@plt>
 805a1d2:	83 c4 20             	add    $0x20,%esp
 805a1d5:	83 f8 4f             	cmp    $0x4f,%eax
 805a1d8:	7f 0e                	jg     805a1e8 <neg_rm_b+0x58>
}

make_instr_helper(rm)
 805a1da:	83 c4 08             	add    $0x8,%esp
	execute();
	return len + 1;	// "1" for opcode
 805a1dd:	8d 43 01             	lea    0x1(%ebx),%eax
 805a1e0:	5b                   	pop    %ebx
 805a1e1:	c3                   	ret    
 805a1e2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805a1e8:	83 ec 0c             	sub    $0xc,%esp
 805a1eb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805a1f1:	e8 6a e7 fe ff       	call   8048960 <fflush@plt>
 805a1f6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a1fc:	6a 07                	push   $0x7
 805a1fe:	6a 01                	push   $0x1
 805a200:	68 92 e8 05 08       	push   $0x805e892
 805a205:	e8 06 e8 fe ff       	call   8048a10 <fwrite@plt>
 805a20a:	83 c4 20             	add    $0x20,%esp
 805a20d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a213:	6a 10                	push   $0x10
 805a215:	6a 01                	push   $0x1
 805a217:	68 b4 f3 05 08       	push   $0x805f3b4
 805a21c:	e8 ef e7 fe ff       	call   8048a10 <fwrite@plt>
 805a221:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a227:	6a 05                	push   $0x5
 805a229:	6a 01                	push   $0x1
 805a22b:	68 42 f3 05 08       	push   $0x805f342
 805a230:	e8 db e7 fe ff       	call   8048a10 <fwrite@plt>
 805a235:	83 c4 20             	add    $0x20,%esp
 805a238:	68 18 af 0f 10       	push   $0x100faf18
 805a23d:	68 25 4d 06 08       	push   $0x8064d25
 805a242:	6a 50                	push   $0x50
 805a244:	68 00 8a 0c 08       	push   $0x80c8a00
 805a249:	e8 b2 e8 fe ff       	call   8048b00 <snprintf@plt>
 805a24e:	83 c4 10             	add    $0x10,%esp
 805a251:	83 f8 4f             	cmp    $0x4f,%eax
 805a254:	7e 84                	jle    805a1da <neg_rm_b+0x4a>
 805a256:	68 40 4e 06 08       	push   $0x8064e40
 805a25b:	6a 0d                	push   $0xd
 805a25d:	68 30 4d 06 08       	push   $0x8064d30
 805a262:	68 e8 4d 06 08       	push   $0x8064de8
 805a267:	e8 44 e9 fe ff       	call   8048bb0 <__assert_fail@plt>
 805a26c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805a270 <neg_rm_v>:
#include "neg-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(neg_rm)
 805a270:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805a277:	8b 54 24 04          	mov    0x4(%esp),%edx
 805a27b:	b8 b0 a0 05 08       	mov    $0x805a0b0,%eax
 805a280:	75 05                	jne    805a287 <neg_rm_v+0x17>
 805a282:	b8 d0 9f 05 08       	mov    $0x8059fd0,%eax
 805a287:	89 54 24 04          	mov    %edx,0x4(%esp)
 805a28b:	ff e0                	jmp    *%eax
 805a28d:	66 90                	xchg   %ax,%ax
 805a28f:	90                   	nop

0805a290 <do_inc_w>:
#include "cpu/exec/template-start.h"

#define instr inc

static void do_execute () {
 805a290:	55                   	push   %ebp
 805a291:	57                   	push   %edi
 805a292:	56                   	push   %esi
 805a293:	53                   	push   %ebx
 805a294:	83 ec 24             	sub    $0x24,%esp
	DATA_TYPE result = op_src->val + 1;
 805a297:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
 805a29e:	8d 58 01             	lea    0x1(%eax),%ebx
	OPERAND_W(op_src, result);
 805a2a1:	0f b7 c3             	movzwl %bx,%eax
 805a2a4:	50                   	push   %eax
 805a2a5:	68 08 af 0f 10       	push   $0x100faf08
 805a2aa:	e8 21 28 00 00       	call   805cad0 <write_operand_w>

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
 805a2af:	0f b6 c3             	movzbl %bl,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805a2b2:	8b 0d 4c af 0f 10    	mov    0x100faf4c,%ecx
 805a2b8:	8b 35 14 af 0f 10    	mov    0x100faf14,%esi
	DATA_TYPE result = op_src->val + 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805a2be:	89 c2                	mov    %eax,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805a2c0:	0f b6 2d e4 af 0f 10 	movzbl 0x100fafe4,%ebp
	DATA_TYPE result = op_src->val + 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805a2c7:	c1 ea 04             	shr    $0x4,%edx
 805a2ca:	31 d0                	xor    %edx,%eax
	pf = (pf >> 2) ^ pf;
 805a2cc:	89 c2                	mov    %eax,%edx
 805a2ce:	c1 ea 02             	shr    $0x2,%edx
 805a2d1:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 805a2d3:	89 c2                	mov    %eax,%edx
 805a2d5:	d1 ea                	shr    %edx
 805a2d7:	89 54 24 1c          	mov    %edx,0x1c(%esp)
	cpu.CF = op_dest->val < op_src->val;
 805a2db:	83 c4 10             	add    $0x10,%esp
 805a2de:	39 f1                	cmp    %esi,%ecx
 805a2e0:	0f 92 c2             	setb   %dl

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805a2e3:	33 44 24 0c          	xor    0xc(%esp),%eax
	cpu.CF = op_dest->val < op_src->val;
 805a2e7:	83 e5 fa             	and    $0xfffffffa,%ebp
 805a2ea:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805a2ec:	68 18 af 0f 10       	push   $0x100faf18
 805a2f1:	68 49 4e 06 08       	push   $0x8064e49
 805a2f6:	6a 50                	push   $0x50
 805a2f8:	68 00 8a 0c 08       	push   $0x80c8a00
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
 805a2fd:	83 e0 01             	and    $0x1,%eax
 805a300:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805a307:	89 e8                	mov    %ebp,%eax
 805a309:	09 f8                	or     %edi,%eax
 805a30b:	09 d0                	or     %edx,%eax
	cpu.ZF = (result == 0);
 805a30d:	66 85 db             	test   %bx,%bx
 805a310:	0f 94 c2             	sete   %dl
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a313:	c1 e9 1f             	shr    $0x1f,%ecx
 805a316:	c1 ee 1f             	shr    $0x1f,%esi
 805a319:	31 ce                	xor    %ecx,%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
 805a31b:	c1 e2 06             	shl    $0x6,%edx
 805a31e:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a321:	21 f1                	and    %esi,%ecx
 805a323:	0f b6 35 e5 af 0f 10 	movzbl 0x100fafe5,%esi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805a32a:	09 d0                	or     %edx,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a32c:	c1 e1 03             	shl    $0x3,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805a32f:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a334:	83 e6 f7             	and    $0xfffffff7,%esi
 805a337:	09 f1                	or     %esi,%ecx
 805a339:	88 0d e5 af 0f 10    	mov    %cl,0x100fafe5

	print_asm_template1();
 805a33f:	e8 bc e7 fe ff       	call   8048b00 <snprintf@plt>
 805a344:	83 c4 10             	add    $0x10,%esp
 805a347:	83 f8 4f             	cmp    $0x4f,%eax
 805a34a:	7f 0c                	jg     805a358 <do_inc_w+0xc8>
}
 805a34c:	83 c4 1c             	add    $0x1c,%esp
 805a34f:	5b                   	pop    %ebx
 805a350:	5e                   	pop    %esi
 805a351:	5f                   	pop    %edi
 805a352:	5d                   	pop    %ebp
 805a353:	c3                   	ret    
 805a354:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805a358:	83 ec 0c             	sub    $0xc,%esp
 805a35b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805a361:	e8 fa e5 fe ff       	call   8048960 <fflush@plt>
 805a366:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a36c:	6a 07                	push   $0x7
 805a36e:	6a 01                	push   $0x1
 805a370:	68 92 e8 05 08       	push   $0x805e892
 805a375:	e8 96 e6 fe ff       	call   8048a10 <fwrite@plt>
 805a37a:	83 c4 20             	add    $0x20,%esp
 805a37d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a383:	6a 10                	push   $0x10
 805a385:	6a 01                	push   $0x1
 805a387:	68 b4 f3 05 08       	push   $0x805f3b4
 805a38c:	e8 7f e6 fe ff       	call   8048a10 <fwrite@plt>
 805a391:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a397:	6a 05                	push   $0x5
 805a399:	6a 01                	push   $0x1
 805a39b:	68 42 f3 05 08       	push   $0x805f342
 805a3a0:	e8 6b e6 fe ff       	call   8048a10 <fwrite@plt>
 805a3a5:	83 c4 20             	add    $0x20,%esp
 805a3a8:	68 18 af 0f 10       	push   $0x100faf18
 805a3ad:	68 49 4e 06 08       	push   $0x8064e49
 805a3b2:	6a 50                	push   $0x50
 805a3b4:	68 00 8a 0c 08       	push   $0x80c8a00
 805a3b9:	e8 42 e7 fe ff       	call   8048b00 <snprintf@plt>
 805a3be:	83 c4 10             	add    $0x10,%esp
 805a3c1:	83 f8 4f             	cmp    $0x4f,%eax
 805a3c4:	7e 86                	jle    805a34c <do_inc_w+0xbc>
 805a3c6:	68 6b 4f 06 08       	push   $0x8064f6b
 805a3cb:	6a 14                	push   $0x14
 805a3cd:	68 64 4e 06 08       	push   $0x8064e64
 805a3d2:	68 8c 4e 06 08       	push   $0x8064e8c
 805a3d7:	e8 d4 e7 fe ff       	call   8048bb0 <__assert_fail@plt>
 805a3dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805a3e0 <inc_rm_w>:
}

make_instr_helper(rm)
 805a3e0:	53                   	push   %ebx
 805a3e1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a3e4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a3e8:	83 c0 01             	add    $0x1,%eax
 805a3eb:	50                   	push   %eax
 805a3ec:	e8 6f 25 00 00       	call   805c960 <decode_rm_w>
 805a3f1:	89 c3                	mov    %eax,%ebx
	execute();
 805a3f3:	e8 98 fe ff ff       	call   805a290 <do_inc_w>
 805a3f8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805a3fb:	8d 43 01             	lea    0x1(%ebx),%eax
 805a3fe:	5b                   	pop    %ebx
 805a3ff:	c3                   	ret    

0805a400 <inc_r_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(r)
 805a400:	53                   	push   %ebx
 805a401:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a404:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a408:	83 c0 01             	add    $0x1,%eax
 805a40b:	50                   	push   %eax
 805a40c:	e8 6f 25 00 00       	call   805c980 <decode_r_w>
 805a411:	89 c3                	mov    %eax,%ebx
	execute();
 805a413:	e8 78 fe ff ff       	call   805a290 <do_inc_w>
 805a418:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805a41b:	8d 43 01             	lea    0x1(%ebx),%eax
 805a41e:	5b                   	pop    %ebx
 805a41f:	c3                   	ret    

0805a420 <do_inc_l>:
#include "cpu/exec/template-start.h"

#define instr inc

static void do_execute () {
 805a420:	55                   	push   %ebp
 805a421:	57                   	push   %edi
 805a422:	56                   	push   %esi
 805a423:	53                   	push   %ebx
 805a424:	83 ec 24             	sub    $0x24,%esp
	DATA_TYPE result = op_src->val + 1;
 805a427:	a1 14 af 0f 10       	mov    0x100faf14,%eax
 805a42c:	8d 58 01             	lea    0x1(%eax),%ebx
	OPERAND_W(op_src, result);
 805a42f:	53                   	push   %ebx
 805a430:	68 08 af 0f 10       	push   $0x100faf08
 805a435:	e8 66 2a 00 00       	call   805cea0 <write_operand_l>

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
 805a43a:	0f b6 c3             	movzbl %bl,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805a43d:	8b 0d 14 af 0f 10    	mov    0x100faf14,%ecx
 805a443:	8b 35 4c af 0f 10    	mov    0x100faf4c,%esi
	DATA_TYPE result = op_src->val + 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805a449:	89 c2                	mov    %eax,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805a44b:	0f b6 2d e4 af 0f 10 	movzbl 0x100fafe4,%ebp
	DATA_TYPE result = op_src->val + 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805a452:	c1 ea 04             	shr    $0x4,%edx
 805a455:	31 d0                	xor    %edx,%eax
	pf = (pf >> 2) ^ pf;
 805a457:	89 c2                	mov    %eax,%edx
 805a459:	c1 ea 02             	shr    $0x2,%edx
 805a45c:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 805a45e:	89 c2                	mov    %eax,%edx
 805a460:	d1 ea                	shr    %edx
 805a462:	89 54 24 1c          	mov    %edx,0x1c(%esp)
	cpu.CF = op_dest->val < op_src->val;
 805a466:	83 c4 10             	add    $0x10,%esp
 805a469:	39 ce                	cmp    %ecx,%esi
 805a46b:	0f 92 c2             	setb   %dl

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805a46e:	33 44 24 0c          	xor    0xc(%esp),%eax
	cpu.CF = op_dest->val < op_src->val;
 805a472:	83 e5 fa             	and    $0xfffffffa,%ebp
 805a475:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805a477:	68 18 af 0f 10       	push   $0x100faf18
 805a47c:	68 51 4e 06 08       	push   $0x8064e51
 805a481:	6a 50                	push   $0x50
 805a483:	68 00 8a 0c 08       	push   $0x80c8a00
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
 805a488:	83 e0 01             	and    $0x1,%eax
 805a48b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805a492:	89 e8                	mov    %ebp,%eax
 805a494:	09 f8                	or     %edi,%eax
 805a496:	09 d0                	or     %edx,%eax
	cpu.ZF = (result == 0);
 805a498:	85 db                	test   %ebx,%ebx
 805a49a:	0f 94 c2             	sete   %dl
	cpu.SF = (result >> 31) & 1;
 805a49d:	c1 eb 1f             	shr    $0x1f,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
 805a4a0:	83 e0 3f             	and    $0x3f,%eax
 805a4a3:	c1 e2 06             	shl    $0x6,%edx
	cpu.SF = (result >> 31) & 1;
 805a4a6:	89 df                	mov    %ebx,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a4a8:	c1 ee 1f             	shr    $0x1f,%esi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805a4ab:	09 d0                	or     %edx,%eax
 805a4ad:	c1 e7 07             	shl    $0x7,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a4b0:	31 f3                	xor    %esi,%ebx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805a4b2:	09 f8                	or     %edi,%eax
 805a4b4:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a4b9:	89 c8                	mov    %ecx,%eax
 805a4bb:	89 f1                	mov    %esi,%ecx
 805a4bd:	c1 e8 1f             	shr    $0x1f,%eax
 805a4c0:	31 c1                	xor    %eax,%ecx
 805a4c2:	21 d9                	and    %ebx,%ecx
 805a4c4:	0f b6 1d e5 af 0f 10 	movzbl 0x100fafe5,%ebx
 805a4cb:	c1 e1 03             	shl    $0x3,%ecx
 805a4ce:	83 e3 f7             	and    $0xfffffff7,%ebx
 805a4d1:	09 d9                	or     %ebx,%ecx
 805a4d3:	88 0d e5 af 0f 10    	mov    %cl,0x100fafe5

	print_asm_template1();
 805a4d9:	e8 22 e6 fe ff       	call   8048b00 <snprintf@plt>
 805a4de:	83 c4 10             	add    $0x10,%esp
 805a4e1:	83 f8 4f             	cmp    $0x4f,%eax
 805a4e4:	7f 0a                	jg     805a4f0 <do_inc_l+0xd0>
}
 805a4e6:	83 c4 1c             	add    $0x1c,%esp
 805a4e9:	5b                   	pop    %ebx
 805a4ea:	5e                   	pop    %esi
 805a4eb:	5f                   	pop    %edi
 805a4ec:	5d                   	pop    %ebp
 805a4ed:	c3                   	ret    
 805a4ee:	66 90                	xchg   %ax,%ax
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805a4f0:	83 ec 0c             	sub    $0xc,%esp
 805a4f3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805a4f9:	e8 62 e4 fe ff       	call   8048960 <fflush@plt>
 805a4fe:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a504:	6a 07                	push   $0x7
 805a506:	6a 01                	push   $0x1
 805a508:	68 92 e8 05 08       	push   $0x805e892
 805a50d:	e8 fe e4 fe ff       	call   8048a10 <fwrite@plt>
 805a512:	83 c4 20             	add    $0x20,%esp
 805a515:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a51b:	6a 10                	push   $0x10
 805a51d:	6a 01                	push   $0x1
 805a51f:	68 b4 f3 05 08       	push   $0x805f3b4
 805a524:	e8 e7 e4 fe ff       	call   8048a10 <fwrite@plt>
 805a529:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a52f:	6a 05                	push   $0x5
 805a531:	6a 01                	push   $0x1
 805a533:	68 42 f3 05 08       	push   $0x805f342
 805a538:	e8 d3 e4 fe ff       	call   8048a10 <fwrite@plt>
 805a53d:	83 c4 20             	add    $0x20,%esp
 805a540:	68 18 af 0f 10       	push   $0x100faf18
 805a545:	68 51 4e 06 08       	push   $0x8064e51
 805a54a:	6a 50                	push   $0x50
 805a54c:	68 00 8a 0c 08       	push   $0x80c8a00
 805a551:	e8 aa e5 fe ff       	call   8048b00 <snprintf@plt>
 805a556:	83 c4 10             	add    $0x10,%esp
 805a559:	83 f8 4f             	cmp    $0x4f,%eax
 805a55c:	7e 88                	jle    805a4e6 <do_inc_l+0xc6>
 805a55e:	68 62 4f 06 08       	push   $0x8064f62
 805a563:	6a 14                	push   $0x14
 805a565:	68 64 4e 06 08       	push   $0x8064e64
 805a56a:	68 d4 4e 06 08       	push   $0x8064ed4
 805a56f:	e8 3c e6 fe ff       	call   8048bb0 <__assert_fail@plt>
 805a574:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805a57a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805a580 <inc_rm_l>:
}

make_instr_helper(rm)
 805a580:	53                   	push   %ebx
 805a581:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a584:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a588:	83 c0 01             	add    $0x1,%eax
 805a58b:	50                   	push   %eax
 805a58c:	e8 9f 27 00 00       	call   805cd30 <decode_rm_l>
 805a591:	89 c3                	mov    %eax,%ebx
	execute();
 805a593:	e8 88 fe ff ff       	call   805a420 <do_inc_l>
 805a598:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805a59b:	8d 43 01             	lea    0x1(%ebx),%eax
 805a59e:	5b                   	pop    %ebx
 805a59f:	c3                   	ret    

0805a5a0 <inc_r_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(r)
 805a5a0:	53                   	push   %ebx
 805a5a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a5a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805a5a8:	83 c0 01             	add    $0x1,%eax
 805a5ab:	50                   	push   %eax
 805a5ac:	e8 9f 27 00 00       	call   805cd50 <decode_r_l>
 805a5b1:	89 c3                	mov    %eax,%ebx
	execute();
 805a5b3:	e8 68 fe ff ff       	call   805a420 <do_inc_l>
 805a5b8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805a5bb:	8d 43 01             	lea    0x1(%ebx),%eax
 805a5be:	5b                   	pop    %ebx
 805a5bf:	c3                   	ret    

0805a5c0 <inc_rm_b>:
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
}

make_instr_helper(rm)
 805a5c0:	55                   	push   %ebp
 805a5c1:	57                   	push   %edi
 805a5c2:	56                   	push   %esi
 805a5c3:	53                   	push   %ebx
 805a5c4:	83 ec 18             	sub    $0x18,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a5c7:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 805a5cb:	83 c0 01             	add    $0x1,%eax
 805a5ce:	50                   	push   %eax
 805a5cf:	e8 5c 20 00 00       	call   805c630 <decode_rm_b>
 805a5d4:	89 c6                	mov    %eax,%esi
#include "cpu/exec/template-start.h"

#define instr inc

static void do_execute () {
	DATA_TYPE result = op_src->val + 1;
 805a5d6:	0f b6 05 14 af 0f 10 	movzbl 0x100faf14,%eax
 805a5dd:	8d 58 01             	lea    0x1(%eax),%ebx
	OPERAND_W(op_src, result);
 805a5e0:	58                   	pop    %eax
 805a5e1:	5a                   	pop    %edx
 805a5e2:	0f b6 fb             	movzbl %bl,%edi
 805a5e5:	57                   	push   %edi
 805a5e6:	68 08 af 0f 10       	push   $0x100faf08
 805a5eb:	e8 50 21 00 00       	call   805c740 <write_operand_b>

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805a5f0:	89 fa                	mov    %edi,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805a5f2:	83 c4 10             	add    $0x10,%esp
 805a5f5:	8b 0d 4c af 0f 10    	mov    0x100faf4c,%ecx
	DATA_TYPE result = op_src->val + 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805a5fb:	c1 ea 04             	shr    $0x4,%edx
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805a5fe:	68 18 af 0f 10       	push   $0x100faf18
 805a603:	68 59 4e 06 08       	push   $0x8064e59
	DATA_TYPE result = op_src->val + 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805a608:	31 d7                	xor    %edx,%edi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805a60a:	6a 50                	push   $0x50
 805a60c:	68 00 8a 0c 08       	push   $0x80c8a00
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 805a611:	89 fa                	mov    %edi,%edx
 805a613:	c1 ea 02             	shr    $0x2,%edx
 805a616:	31 fa                	xor    %edi,%edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805a618:	0f b6 3d e4 af 0f 10 	movzbl 0x100fafe4,%edi

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805a61f:	89 d5                	mov    %edx,%ebp
 805a621:	d1 ed                	shr    %ebp
	cpu.CF = op_dest->val < op_src->val;
 805a623:	3b 0d 14 af 0f 10    	cmp    0x100faf14,%ecx
 805a629:	0f 92 c0             	setb   %al

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805a62c:	31 ea                	xor    %ebp,%edx
	cpu.CF = op_dest->val < op_src->val;
 805a62e:	83 e7 fa             	and    $0xfffffffa,%edi
	cpu.PF = (pf & 1);
 805a631:	83 e2 01             	and    $0x1,%edx
 805a634:	09 f8                	or     %edi,%eax
 805a636:	c1 e2 02             	shl    $0x2,%edx
 805a639:	09 d0                	or     %edx,%eax
	cpu.ZF = (result == 0);
 805a63b:	84 db                	test   %bl,%bl
 805a63d:	0f 94 c3             	sete   %bl
 805a640:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a643:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
 805a646:	c1 e3 06             	shl    $0x6,%ebx
	cpu.SF = (result >> 31) & 1;
 805a649:	09 d8                	or     %ebx,%eax
 805a64b:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805a650:	a1 14 af 0f 10       	mov    0x100faf14,%eax
 805a655:	c1 e8 1f             	shr    $0x1f,%eax
 805a658:	31 c8                	xor    %ecx,%eax
 805a65a:	21 c1                	and    %eax,%ecx
 805a65c:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
 805a663:	c1 e1 03             	shl    $0x3,%ecx
 805a666:	83 e0 f7             	and    $0xfffffff7,%eax
 805a669:	09 c1                	or     %eax,%ecx
 805a66b:	88 0d e5 af 0f 10    	mov    %cl,0x100fafe5

	print_asm_template1();
 805a671:	e8 8a e4 fe ff       	call   8048b00 <snprintf@plt>
 805a676:	83 c4 10             	add    $0x10,%esp
 805a679:	83 f8 4f             	cmp    $0x4f,%eax
 805a67c:	7f 12                	jg     805a690 <inc_rm_b+0xd0>
}

make_instr_helper(rm)
 805a67e:	83 c4 0c             	add    $0xc,%esp
	execute();
	return len + 1;	// "1" for opcode
 805a681:	8d 46 01             	lea    0x1(%esi),%eax
 805a684:	5b                   	pop    %ebx
 805a685:	5e                   	pop    %esi
 805a686:	5f                   	pop    %edi
 805a687:	5d                   	pop    %ebp
 805a688:	c3                   	ret    
 805a689:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805a690:	83 ec 0c             	sub    $0xc,%esp
 805a693:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805a699:	e8 c2 e2 fe ff       	call   8048960 <fflush@plt>
 805a69e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a6a4:	6a 07                	push   $0x7
 805a6a6:	6a 01                	push   $0x1
 805a6a8:	68 92 e8 05 08       	push   $0x805e892
 805a6ad:	e8 5e e3 fe ff       	call   8048a10 <fwrite@plt>
 805a6b2:	83 c4 20             	add    $0x20,%esp
 805a6b5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a6bb:	6a 10                	push   $0x10
 805a6bd:	6a 01                	push   $0x1
 805a6bf:	68 b4 f3 05 08       	push   $0x805f3b4
 805a6c4:	e8 47 e3 fe ff       	call   8048a10 <fwrite@plt>
 805a6c9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a6cf:	6a 05                	push   $0x5
 805a6d1:	6a 01                	push   $0x1
 805a6d3:	68 42 f3 05 08       	push   $0x805f342
 805a6d8:	e8 33 e3 fe ff       	call   8048a10 <fwrite@plt>
 805a6dd:	83 c4 20             	add    $0x20,%esp
 805a6e0:	68 18 af 0f 10       	push   $0x100faf18
 805a6e5:	68 59 4e 06 08       	push   $0x8064e59
 805a6ea:	6a 50                	push   $0x50
 805a6ec:	68 00 8a 0c 08       	push   $0x80c8a00
 805a6f1:	e8 0a e4 fe ff       	call   8048b00 <snprintf@plt>
 805a6f6:	83 c4 10             	add    $0x10,%esp
 805a6f9:	83 f8 4f             	cmp    $0x4f,%eax
 805a6fc:	7e 80                	jle    805a67e <inc_rm_b+0xbe>
 805a6fe:	68 74 4f 06 08       	push   $0x8064f74
 805a703:	6a 14                	push   $0x14
 805a705:	68 64 4e 06 08       	push   $0x8064e64
 805a70a:	68 1c 4f 06 08       	push   $0x8064f1c
 805a70f:	e8 9c e4 fe ff       	call   8048bb0 <__assert_fail@plt>
 805a714:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805a71a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805a720 <inc_rm_v>:
#include "inc-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(inc_rm)
 805a720:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805a727:	8b 54 24 04          	mov    0x4(%esp),%edx
 805a72b:	b8 e0 a3 05 08       	mov    $0x805a3e0,%eax
 805a730:	75 05                	jne    805a737 <inc_rm_v+0x17>
 805a732:	b8 80 a5 05 08       	mov    $0x805a580,%eax
 805a737:	89 54 24 04          	mov    %edx,0x4(%esp)
 805a73b:	ff e0                	jmp    *%eax
 805a73d:	8d 76 00             	lea    0x0(%esi),%esi

0805a740 <inc_r_v>:
make_helper_v(inc_r)
 805a740:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805a747:	8b 54 24 04          	mov    0x4(%esp),%edx
 805a74b:	b8 00 a4 05 08       	mov    $0x805a400,%eax
 805a750:	75 05                	jne    805a757 <inc_r_v+0x17>
 805a752:	b8 a0 a5 05 08       	mov    $0x805a5a0,%eax
 805a757:	89 54 24 04          	mov    %edx,0x4(%esp)
 805a75b:	ff e0                	jmp    *%eax
 805a75d:	66 90                	xchg   %ax,%ax
 805a75f:	90                   	nop

0805a760 <idiv_rm_w>:
	REG(R_EDX) = a % b;

	print_asm_template1();
}

make_instr_helper(rm)
 805a760:	55                   	push   %ebp
 805a761:	57                   	push   %edi
 805a762:	56                   	push   %esi
 805a763:	53                   	push   %ebx
 805a764:	83 ec 28             	sub    $0x28,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a767:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 805a76b:	83 c0 01             	add    $0x1,%eax
 805a76e:	50                   	push   %eax
 805a76f:	e8 ec 21 00 00       	call   805c960 <decode_rm_w>
 805a774:	89 c5                	mov    %eax,%ebp
	int64_t a;
	int32_t b = (DATA_TYPE_S)op_src->val;
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
 805a776:	0f b7 05 c8 af 0f 10 	movzwl 0x100fafc8,%eax
 805a77d:	0f b7 0d c0 af 0f 10 	movzwl 0x100fafc0,%ecx
 805a784:	31 d2                	xor    %edx,%edx
 805a786:	0f a4 c2 10          	shld   $0x10,%eax,%edx
 805a78a:	c1 e0 10             	shl    $0x10,%eax
 805a78d:	09 c1                	or     %eax,%ecx
 805a78f:	89 d7                	mov    %edx,%edi
 805a791:	89 ce                	mov    %ecx,%esi
#endif
	REG(R_EAX) = a / b;
 805a793:	0f bf 0d 14 af 0f 10 	movswl 0x100faf14,%ecx
 805a79a:	89 cb                	mov    %ecx,%ebx
 805a79c:	c1 fb 1f             	sar    $0x1f,%ebx
 805a79f:	53                   	push   %ebx
 805a7a0:	51                   	push   %ecx
 805a7a1:	89 4c 24 20          	mov    %ecx,0x20(%esp)
 805a7a5:	89 5c 24 24          	mov    %ebx,0x24(%esp)
 805a7a9:	52                   	push   %edx
 805a7aa:	56                   	push   %esi
 805a7ab:	e8 90 39 00 00       	call   805e140 <__divdi3>
 805a7b0:	83 c4 10             	add    $0x10,%esp
	REG(R_EDX) = a % b;
 805a7b3:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 805a7b7:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805a7bb:	66 a3 c0 af 0f 10    	mov    %ax,0x100fafc0
	REG(R_EDX) = a % b;
 805a7c1:	53                   	push   %ebx
 805a7c2:	51                   	push   %ecx
 805a7c3:	57                   	push   %edi
 805a7c4:	56                   	push   %esi
 805a7c5:	e8 46 3b 00 00       	call   805e310 <__moddi3>
 805a7ca:	83 c4 10             	add    $0x10,%esp
 805a7cd:	66 a3 c8 af 0f 10    	mov    %ax,0x100fafc8

	print_asm_template1();
 805a7d3:	68 18 af 0f 10       	push   $0x100faf18
 805a7d8:	68 7d 4f 06 08       	push   $0x8064f7d
 805a7dd:	6a 50                	push   $0x50
 805a7df:	68 00 8a 0c 08       	push   $0x80c8a00
 805a7e4:	e8 17 e3 fe ff       	call   8048b00 <snprintf@plt>
 805a7e9:	83 c4 20             	add    $0x20,%esp
 805a7ec:	83 f8 4f             	cmp    $0x4f,%eax
 805a7ef:	7f 0f                	jg     805a800 <idiv_rm_w+0xa0>
}

make_instr_helper(rm)
 805a7f1:	83 c4 1c             	add    $0x1c,%esp
	execute();
	return len + 1;	// "1" for opcode
 805a7f4:	8d 45 01             	lea    0x1(%ebp),%eax
 805a7f7:	5b                   	pop    %ebx
 805a7f8:	5e                   	pop    %esi
 805a7f9:	5f                   	pop    %edi
 805a7fa:	5d                   	pop    %ebp
 805a7fb:	c3                   	ret    
 805a7fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
	REG(R_EDX) = a % b;

	print_asm_template1();
 805a800:	83 ec 0c             	sub    $0xc,%esp
 805a803:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805a809:	e8 52 e1 fe ff       	call   8048960 <fflush@plt>
 805a80e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a814:	6a 07                	push   $0x7
 805a816:	6a 01                	push   $0x1
 805a818:	68 92 e8 05 08       	push   $0x805e892
 805a81d:	e8 ee e1 fe ff       	call   8048a10 <fwrite@plt>
 805a822:	83 c4 20             	add    $0x20,%esp
 805a825:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a82b:	6a 10                	push   $0x10
 805a82d:	6a 01                	push   $0x1
 805a82f:	68 b4 f3 05 08       	push   $0x805f3b4
 805a834:	e8 d7 e1 fe ff       	call   8048a10 <fwrite@plt>
 805a839:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a83f:	6a 05                	push   $0x5
 805a841:	6a 01                	push   $0x1
 805a843:	68 42 f3 05 08       	push   $0x805f342
 805a848:	e8 c3 e1 fe ff       	call   8048a10 <fwrite@plt>
 805a84d:	83 c4 20             	add    $0x20,%esp
 805a850:	68 18 af 0f 10       	push   $0x100faf18
 805a855:	68 7d 4f 06 08       	push   $0x8064f7d
 805a85a:	6a 50                	push   $0x50
 805a85c:	68 00 8a 0c 08       	push   $0x80c8a00
 805a861:	e8 9a e2 fe ff       	call   8048b00 <snprintf@plt>
 805a866:	83 c4 10             	add    $0x10,%esp
 805a869:	83 f8 4f             	cmp    $0x4f,%eax
 805a86c:	7e 83                	jle    805a7f1 <idiv_rm_w+0x91>
 805a86e:	68 a1 50 06 08       	push   $0x80650a1
 805a873:	6a 10                	push   $0x10
 805a875:	68 98 4f 06 08       	push   $0x8064f98
 805a87a:	68 c0 4f 06 08       	push   $0x8064fc0
 805a87f:	e8 2c e3 fe ff       	call   8048bb0 <__assert_fail@plt>
 805a884:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805a88a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805a890 <idiv_rm_l>:
}

make_instr_helper(rm)
 805a890:	55                   	push   %ebp
 805a891:	57                   	push   %edi
 805a892:	56                   	push   %esi
 805a893:	53                   	push   %ebx
 805a894:	83 ec 28             	sub    $0x28,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a897:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 805a89b:	83 c0 01             	add    $0x1,%eax
 805a89e:	50                   	push   %eax
 805a89f:	e8 8c 24 00 00       	call   805cd30 <decode_rm_l>
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805a8a4:	8b 0d 14 af 0f 10    	mov    0x100faf14,%ecx
	int64_t a;
	int32_t b = (DATA_TYPE_S)op_src->val;
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
 805a8aa:	8b 35 c0 af 0f 10    	mov    0x100fafc0,%esi
 805a8b0:	89 c5                	mov    %eax,%ebp
 805a8b2:	8b 3d c8 af 0f 10    	mov    0x100fafc8,%edi
#endif
	REG(R_EAX) = a / b;
 805a8b8:	89 cb                	mov    %ecx,%ebx
 805a8ba:	c1 fb 1f             	sar    $0x1f,%ebx
 805a8bd:	53                   	push   %ebx
 805a8be:	51                   	push   %ecx
 805a8bf:	89 4c 24 20          	mov    %ecx,0x20(%esp)
 805a8c3:	89 5c 24 24          	mov    %ebx,0x24(%esp)
 805a8c7:	57                   	push   %edi
 805a8c8:	56                   	push   %esi
 805a8c9:	e8 72 38 00 00       	call   805e140 <__divdi3>
 805a8ce:	83 c4 10             	add    $0x10,%esp
	REG(R_EDX) = a % b;
 805a8d1:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 805a8d5:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805a8d9:	a3 c0 af 0f 10       	mov    %eax,0x100fafc0
	REG(R_EDX) = a % b;
 805a8de:	53                   	push   %ebx
 805a8df:	51                   	push   %ecx
 805a8e0:	57                   	push   %edi
 805a8e1:	56                   	push   %esi
 805a8e2:	e8 29 3a 00 00       	call   805e310 <__moddi3>
 805a8e7:	83 c4 10             	add    $0x10,%esp
 805a8ea:	a3 c8 af 0f 10       	mov    %eax,0x100fafc8

	print_asm_template1();
 805a8ef:	68 18 af 0f 10       	push   $0x100faf18
 805a8f4:	68 86 4f 06 08       	push   $0x8064f86
 805a8f9:	6a 50                	push   $0x50
 805a8fb:	68 00 8a 0c 08       	push   $0x80c8a00
 805a900:	e8 fb e1 fe ff       	call   8048b00 <snprintf@plt>
 805a905:	83 c4 20             	add    $0x20,%esp
 805a908:	83 f8 4f             	cmp    $0x4f,%eax
 805a90b:	7f 13                	jg     805a920 <idiv_rm_l+0x90>
}

make_instr_helper(rm)
 805a90d:	83 c4 1c             	add    $0x1c,%esp
	execute();
	return len + 1;	// "1" for opcode
 805a910:	8d 45 01             	lea    0x1(%ebp),%eax
 805a913:	5b                   	pop    %ebx
 805a914:	5e                   	pop    %esi
 805a915:	5f                   	pop    %edi
 805a916:	5d                   	pop    %ebp
 805a917:	c3                   	ret    
 805a918:	90                   	nop
 805a919:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
	REG(R_EDX) = a % b;

	print_asm_template1();
 805a920:	83 ec 0c             	sub    $0xc,%esp
 805a923:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805a929:	e8 32 e0 fe ff       	call   8048960 <fflush@plt>
 805a92e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a934:	6a 07                	push   $0x7
 805a936:	6a 01                	push   $0x1
 805a938:	68 92 e8 05 08       	push   $0x805e892
 805a93d:	e8 ce e0 fe ff       	call   8048a10 <fwrite@plt>
 805a942:	83 c4 20             	add    $0x20,%esp
 805a945:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a94b:	6a 10                	push   $0x10
 805a94d:	6a 01                	push   $0x1
 805a94f:	68 b4 f3 05 08       	push   $0x805f3b4
 805a954:	e8 b7 e0 fe ff       	call   8048a10 <fwrite@plt>
 805a959:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805a95f:	6a 05                	push   $0x5
 805a961:	6a 01                	push   $0x1
 805a963:	68 42 f3 05 08       	push   $0x805f342
 805a968:	e8 a3 e0 fe ff       	call   8048a10 <fwrite@plt>
 805a96d:	83 c4 20             	add    $0x20,%esp
 805a970:	68 18 af 0f 10       	push   $0x100faf18
 805a975:	68 86 4f 06 08       	push   $0x8064f86
 805a97a:	6a 50                	push   $0x50
 805a97c:	68 00 8a 0c 08       	push   $0x80c8a00
 805a981:	e8 7a e1 fe ff       	call   8048b00 <snprintf@plt>
 805a986:	83 c4 10             	add    $0x10,%esp
 805a989:	83 f8 4f             	cmp    $0x4f,%eax
 805a98c:	0f 8e 7b ff ff ff    	jle    805a90d <idiv_rm_l+0x7d>
 805a992:	68 97 50 06 08       	push   $0x8065097
 805a997:	6a 10                	push   $0x10
 805a999:	68 98 4f 06 08       	push   $0x8064f98
 805a99e:	68 08 50 06 08       	push   $0x8065008
 805a9a3:	e8 08 e2 fe ff       	call   8048bb0 <__assert_fail@plt>
 805a9a8:	90                   	nop
 805a9a9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0805a9b0 <idiv_rm_b>:
}

make_instr_helper(rm)
 805a9b0:	55                   	push   %ebp
 805a9b1:	57                   	push   %edi
 805a9b2:	56                   	push   %esi
 805a9b3:	53                   	push   %ebx
 805a9b4:	83 ec 28             	sub    $0x28,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805a9b7:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 805a9bb:	83 c0 01             	add    $0x1,%eax
 805a9be:	50                   	push   %eax
 805a9bf:	e8 6c 1c 00 00       	call   805c630 <decode_rm_b>
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805a9c4:	0f be 0d 14 af 0f 10 	movsbl 0x100faf14,%ecx

static void do_execute() {
	int64_t a;
	int32_t b = (DATA_TYPE_S)op_src->val;
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
 805a9cb:	0f bf 35 c0 af 0f 10 	movswl 0x100fafc0,%esi
 805a9d2:	89 c5                	mov    %eax,%ebp
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805a9d4:	89 cb                	mov    %ecx,%ebx

static void do_execute() {
	int64_t a;
	int32_t b = (DATA_TYPE_S)op_src->val;
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
 805a9d6:	89 f7                	mov    %esi,%edi
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805a9d8:	c1 fb 1f             	sar    $0x1f,%ebx

static void do_execute() {
	int64_t a;
	int32_t b = (DATA_TYPE_S)op_src->val;
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
 805a9db:	c1 ff 1f             	sar    $0x1f,%edi
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805a9de:	53                   	push   %ebx
 805a9df:	51                   	push   %ecx
 805a9e0:	89 4c 24 20          	mov    %ecx,0x20(%esp)
 805a9e4:	89 5c 24 24          	mov    %ebx,0x24(%esp)
 805a9e8:	57                   	push   %edi
 805a9e9:	56                   	push   %esi
 805a9ea:	e8 51 37 00 00       	call   805e140 <__divdi3>
 805a9ef:	83 c4 10             	add    $0x10,%esp
	REG(R_EDX) = a % b;
 805a9f2:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 805a9f6:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
#if DATA_BYTE == 1
	a = (int16_t)reg_w(R_EAX);
#else
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805a9fa:	a2 c0 af 0f 10       	mov    %al,0x100fafc0
	REG(R_EDX) = a % b;
 805a9ff:	53                   	push   %ebx
 805aa00:	51                   	push   %ecx
 805aa01:	57                   	push   %edi
 805aa02:	56                   	push   %esi
 805aa03:	e8 08 39 00 00       	call   805e310 <__moddi3>
 805aa08:	83 c4 10             	add    $0x10,%esp
 805aa0b:	a2 c8 af 0f 10       	mov    %al,0x100fafc8

	print_asm_template1();
 805aa10:	68 18 af 0f 10       	push   $0x100faf18
 805aa15:	68 8f 4f 06 08       	push   $0x8064f8f
 805aa1a:	6a 50                	push   $0x50
 805aa1c:	68 00 8a 0c 08       	push   $0x80c8a00
 805aa21:	e8 da e0 fe ff       	call   8048b00 <snprintf@plt>
 805aa26:	83 c4 20             	add    $0x20,%esp
 805aa29:	83 f8 4f             	cmp    $0x4f,%eax
 805aa2c:	7f 12                	jg     805aa40 <idiv_rm_b+0x90>
}

make_instr_helper(rm)
 805aa2e:	83 c4 1c             	add    $0x1c,%esp
	execute();
	return len + 1;	// "1" for opcode
 805aa31:	8d 45 01             	lea    0x1(%ebp),%eax
 805aa34:	5b                   	pop    %ebx
 805aa35:	5e                   	pop    %esi
 805aa36:	5f                   	pop    %edi
 805aa37:	5d                   	pop    %ebp
 805aa38:	c3                   	ret    
 805aa39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	a = ((int64_t)REG(R_EDX) << (DATA_BYTE * 8)) | (int64_t)REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
	REG(R_EDX) = a % b;

	print_asm_template1();
 805aa40:	83 ec 0c             	sub    $0xc,%esp
 805aa43:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805aa49:	e8 12 df fe ff       	call   8048960 <fflush@plt>
 805aa4e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805aa54:	6a 07                	push   $0x7
 805aa56:	6a 01                	push   $0x1
 805aa58:	68 92 e8 05 08       	push   $0x805e892
 805aa5d:	e8 ae df fe ff       	call   8048a10 <fwrite@plt>
 805aa62:	83 c4 20             	add    $0x20,%esp
 805aa65:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805aa6b:	6a 10                	push   $0x10
 805aa6d:	6a 01                	push   $0x1
 805aa6f:	68 b4 f3 05 08       	push   $0x805f3b4
 805aa74:	e8 97 df fe ff       	call   8048a10 <fwrite@plt>
 805aa79:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805aa7f:	6a 05                	push   $0x5
 805aa81:	6a 01                	push   $0x1
 805aa83:	68 42 f3 05 08       	push   $0x805f342
 805aa88:	e8 83 df fe ff       	call   8048a10 <fwrite@plt>
 805aa8d:	83 c4 20             	add    $0x20,%esp
 805aa90:	68 18 af 0f 10       	push   $0x100faf18
 805aa95:	68 8f 4f 06 08       	push   $0x8064f8f
 805aa9a:	6a 50                	push   $0x50
 805aa9c:	68 00 8a 0c 08       	push   $0x80c8a00
 805aaa1:	e8 5a e0 fe ff       	call   8048b00 <snprintf@plt>
 805aaa6:	83 c4 10             	add    $0x10,%esp
 805aaa9:	83 f8 4f             	cmp    $0x4f,%eax
 805aaac:	7e 80                	jle    805aa2e <idiv_rm_b+0x7e>
 805aaae:	68 ab 50 06 08       	push   $0x80650ab
 805aab3:	6a 10                	push   $0x10
 805aab5:	68 98 4f 06 08       	push   $0x8064f98
 805aaba:	68 50 50 06 08       	push   $0x8065050
 805aabf:	e8 ec e0 fe ff       	call   8048bb0 <__assert_fail@plt>
 805aac4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805aaca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805aad0 <idiv_rm_v>:
#include "idiv-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(idiv_rm)
 805aad0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805aad7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805aadb:	b8 60 a7 05 08       	mov    $0x805a760,%eax
 805aae0:	75 05                	jne    805aae7 <idiv_rm_v+0x17>
 805aae2:	b8 90 a8 05 08       	mov    $0x805a890,%eax
 805aae7:	89 54 24 04          	mov    %edx,0x4(%esp)
 805aaeb:	ff e0                	jmp    *%eax
 805aaed:	66 90                	xchg   %ax,%ax
 805aaef:	90                   	nop

0805aaf0 <div_rm_l>:
	REG(R_EDX) = a % b;

	print_asm_template1();
}

make_instr_helper(rm)
 805aaf0:	55                   	push   %ebp
 805aaf1:	57                   	push   %edi
 805aaf2:	56                   	push   %esi
 805aaf3:	53                   	push   %ebx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805aaf4:	31 db                	xor    %ebx,%ebx
	REG(R_EDX) = a % b;

	print_asm_template1();
}

make_instr_helper(rm)
 805aaf6:	83 ec 28             	sub    $0x28,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805aaf9:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 805aafd:	83 c0 01             	add    $0x1,%eax
 805ab00:	50                   	push   %eax
 805ab01:	e8 2a 22 00 00       	call   805cd30 <decode_rm_l>
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805ab06:	8b 0d 14 af 0f 10    	mov    0x100faf14,%ecx
	uint64_t a;
	uint32_t b = (DATA_TYPE)op_src->val;
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
 805ab0c:	8b 35 c0 af 0f 10    	mov    0x100fafc0,%esi
 805ab12:	89 c5                	mov    %eax,%ebp
 805ab14:	8b 3d c8 af 0f 10    	mov    0x100fafc8,%edi
#endif
	REG(R_EAX) = a / b;
 805ab1a:	53                   	push   %ebx
 805ab1b:	51                   	push   %ecx
 805ab1c:	89 4c 24 20          	mov    %ecx,0x20(%esp)
 805ab20:	89 5c 24 24          	mov    %ebx,0x24(%esp)
 805ab24:	57                   	push   %edi
 805ab25:	56                   	push   %esi
 805ab26:	e8 05 3a 00 00       	call   805e530 <__udivdi3>
 805ab2b:	83 c4 10             	add    $0x10,%esp
	REG(R_EDX) = a % b;
 805ab2e:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 805ab32:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805ab36:	a3 c0 af 0f 10       	mov    %eax,0x100fafc0
	REG(R_EDX) = a % b;
 805ab3b:	53                   	push   %ebx
 805ab3c:	51                   	push   %ecx
 805ab3d:	57                   	push   %edi
 805ab3e:	56                   	push   %esi
 805ab3f:	e8 1c 3b 00 00       	call   805e660 <__umoddi3>
 805ab44:	83 c4 10             	add    $0x10,%esp
 805ab47:	a3 c8 af 0f 10       	mov    %eax,0x100fafc8

	print_asm_template1();
 805ab4c:	68 18 af 0f 10       	push   $0x100faf18
 805ab51:	68 87 4f 06 08       	push   $0x8064f87
 805ab56:	6a 50                	push   $0x50
 805ab58:	68 00 8a 0c 08       	push   $0x80c8a00
 805ab5d:	e8 9e df fe ff       	call   8048b00 <snprintf@plt>
 805ab62:	83 c4 20             	add    $0x20,%esp
 805ab65:	83 f8 4f             	cmp    $0x4f,%eax
 805ab68:	7f 0e                	jg     805ab78 <div_rm_l+0x88>
}

make_instr_helper(rm)
 805ab6a:	83 c4 1c             	add    $0x1c,%esp
	execute();
	return len + 1;	// "1" for opcode
 805ab6d:	8d 45 01             	lea    0x1(%ebp),%eax
 805ab70:	5b                   	pop    %ebx
 805ab71:	5e                   	pop    %esi
 805ab72:	5f                   	pop    %edi
 805ab73:	5d                   	pop    %ebp
 805ab74:	c3                   	ret    
 805ab75:	8d 76 00             	lea    0x0(%esi),%esi
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
	REG(R_EDX) = a % b;

	print_asm_template1();
 805ab78:	83 ec 0c             	sub    $0xc,%esp
 805ab7b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805ab81:	e8 da dd fe ff       	call   8048960 <fflush@plt>
 805ab86:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805ab8c:	6a 07                	push   $0x7
 805ab8e:	6a 01                	push   $0x1
 805ab90:	68 92 e8 05 08       	push   $0x805e892
 805ab95:	e8 76 de fe ff       	call   8048a10 <fwrite@plt>
 805ab9a:	83 c4 20             	add    $0x20,%esp
 805ab9d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805aba3:	6a 10                	push   $0x10
 805aba5:	6a 01                	push   $0x1
 805aba7:	68 b4 f3 05 08       	push   $0x805f3b4
 805abac:	e8 5f de fe ff       	call   8048a10 <fwrite@plt>
 805abb1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805abb7:	6a 05                	push   $0x5
 805abb9:	6a 01                	push   $0x1
 805abbb:	68 42 f3 05 08       	push   $0x805f342
 805abc0:	e8 4b de fe ff       	call   8048a10 <fwrite@plt>
 805abc5:	83 c4 20             	add    $0x20,%esp
 805abc8:	68 18 af 0f 10       	push   $0x100faf18
 805abcd:	68 87 4f 06 08       	push   $0x8064f87
 805abd2:	6a 50                	push   $0x50
 805abd4:	68 00 8a 0c 08       	push   $0x80c8a00
 805abd9:	e8 22 df fe ff       	call   8048b00 <snprintf@plt>
 805abde:	83 c4 10             	add    $0x10,%esp
 805abe1:	83 f8 4f             	cmp    $0x4f,%eax
 805abe4:	7e 84                	jle    805ab6a <div_rm_l+0x7a>
 805abe6:	68 b6 51 06 08       	push   $0x80651b6
 805abeb:	6a 10                	push   $0x10
 805abed:	68 b8 50 06 08       	push   $0x80650b8
 805abf2:	68 e0 50 06 08       	push   $0x80650e0
 805abf7:	e8 b4 df fe ff       	call   8048bb0 <__assert_fail@plt>
 805abfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805ac00 <div_rm_w>:
}

make_instr_helper(rm)
 805ac00:	55                   	push   %ebp
 805ac01:	57                   	push   %edi
 805ac02:	56                   	push   %esi
 805ac03:	53                   	push   %ebx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805ac04:	31 db                	xor    %ebx,%ebx
	REG(R_EDX) = a % b;

	print_asm_template1();
}

make_instr_helper(rm)
 805ac06:	83 ec 28             	sub    $0x28,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805ac09:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 805ac0d:	83 c0 01             	add    $0x1,%eax
 805ac10:	50                   	push   %eax
 805ac11:	e8 4a 1d 00 00       	call   805c960 <decode_rm_w>
 805ac16:	89 c5                	mov    %eax,%ebp
	uint64_t a;
	uint32_t b = (DATA_TYPE)op_src->val;
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
 805ac18:	0f b7 05 c8 af 0f 10 	movzwl 0x100fafc8,%eax
 805ac1f:	0f b7 0d c0 af 0f 10 	movzwl 0x100fafc0,%ecx
 805ac26:	31 d2                	xor    %edx,%edx
#endif
	REG(R_EAX) = a / b;
 805ac28:	53                   	push   %ebx
	uint64_t a;
	uint32_t b = (DATA_TYPE)op_src->val;
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
 805ac29:	0f a4 c2 10          	shld   $0x10,%eax,%edx
 805ac2d:	c1 e0 10             	shl    $0x10,%eax
 805ac30:	09 c1                	or     %eax,%ecx
 805ac32:	89 d7                	mov    %edx,%edi
 805ac34:	89 ce                	mov    %ecx,%esi

#define instr div

static void do_execute() {
	uint64_t a;
	uint32_t b = (DATA_TYPE)op_src->val;
 805ac36:	0f b7 0d 14 af 0f 10 	movzwl 0x100faf14,%ecx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805ac3d:	51                   	push   %ecx
 805ac3e:	89 4c 24 20          	mov    %ecx,0x20(%esp)
 805ac42:	89 5c 24 24          	mov    %ebx,0x24(%esp)
 805ac46:	52                   	push   %edx
 805ac47:	56                   	push   %esi
 805ac48:	e8 e3 38 00 00       	call   805e530 <__udivdi3>
 805ac4d:	83 c4 10             	add    $0x10,%esp
	REG(R_EDX) = a % b;
 805ac50:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 805ac54:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805ac58:	66 a3 c0 af 0f 10    	mov    %ax,0x100fafc0
	REG(R_EDX) = a % b;
 805ac5e:	53                   	push   %ebx
 805ac5f:	51                   	push   %ecx
 805ac60:	57                   	push   %edi
 805ac61:	56                   	push   %esi
 805ac62:	e8 f9 39 00 00       	call   805e660 <__umoddi3>
 805ac67:	83 c4 10             	add    $0x10,%esp
 805ac6a:	66 a3 c8 af 0f 10    	mov    %ax,0x100fafc8

	print_asm_template1();
 805ac70:	68 18 af 0f 10       	push   $0x100faf18
 805ac75:	68 7e 4f 06 08       	push   $0x8064f7e
 805ac7a:	6a 50                	push   $0x50
 805ac7c:	68 00 8a 0c 08       	push   $0x80c8a00
 805ac81:	e8 7a de fe ff       	call   8048b00 <snprintf@plt>
 805ac86:	83 c4 20             	add    $0x20,%esp
 805ac89:	83 f8 4f             	cmp    $0x4f,%eax
 805ac8c:	7f 12                	jg     805aca0 <div_rm_w+0xa0>
}

make_instr_helper(rm)
 805ac8e:	83 c4 1c             	add    $0x1c,%esp
	execute();
	return len + 1;	// "1" for opcode
 805ac91:	8d 45 01             	lea    0x1(%ebp),%eax
 805ac94:	5b                   	pop    %ebx
 805ac95:	5e                   	pop    %esi
 805ac96:	5f                   	pop    %edi
 805ac97:	5d                   	pop    %ebp
 805ac98:	c3                   	ret    
 805ac99:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
	REG(R_EDX) = a % b;

	print_asm_template1();
 805aca0:	83 ec 0c             	sub    $0xc,%esp
 805aca3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805aca9:	e8 b2 dc fe ff       	call   8048960 <fflush@plt>
 805acae:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805acb4:	6a 07                	push   $0x7
 805acb6:	6a 01                	push   $0x1
 805acb8:	68 92 e8 05 08       	push   $0x805e892
 805acbd:	e8 4e dd fe ff       	call   8048a10 <fwrite@plt>
 805acc2:	83 c4 20             	add    $0x20,%esp
 805acc5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805accb:	6a 10                	push   $0x10
 805accd:	6a 01                	push   $0x1
 805accf:	68 b4 f3 05 08       	push   $0x805f3b4
 805acd4:	e8 37 dd fe ff       	call   8048a10 <fwrite@plt>
 805acd9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805acdf:	6a 05                	push   $0x5
 805ace1:	6a 01                	push   $0x1
 805ace3:	68 42 f3 05 08       	push   $0x805f342
 805ace8:	e8 23 dd fe ff       	call   8048a10 <fwrite@plt>
 805aced:	83 c4 20             	add    $0x20,%esp
 805acf0:	68 18 af 0f 10       	push   $0x100faf18
 805acf5:	68 7e 4f 06 08       	push   $0x8064f7e
 805acfa:	6a 50                	push   $0x50
 805acfc:	68 00 8a 0c 08       	push   $0x80c8a00
 805ad01:	e8 fa dd fe ff       	call   8048b00 <snprintf@plt>
 805ad06:	83 c4 10             	add    $0x10,%esp
 805ad09:	83 f8 4f             	cmp    $0x4f,%eax
 805ad0c:	7e 80                	jle    805ac8e <div_rm_w+0x8e>
 805ad0e:	68 bf 51 06 08       	push   $0x80651bf
 805ad13:	6a 10                	push   $0x10
 805ad15:	68 b8 50 06 08       	push   $0x80650b8
 805ad1a:	68 28 51 06 08       	push   $0x8065128
 805ad1f:	e8 8c de fe ff       	call   8048bb0 <__assert_fail@plt>
 805ad24:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805ad2a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805ad30 <div_rm_b>:
}

make_instr_helper(rm)
 805ad30:	55                   	push   %ebp
 805ad31:	57                   	push   %edi

static void do_execute() {
	uint64_t a;
	uint32_t b = (DATA_TYPE)op_src->val;
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
 805ad32:	31 ff                	xor    %edi,%edi
	REG(R_EDX) = a % b;

	print_asm_template1();
}

make_instr_helper(rm)
 805ad34:	56                   	push   %esi
 805ad35:	53                   	push   %ebx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805ad36:	31 db                	xor    %ebx,%ebx
	REG(R_EDX) = a % b;

	print_asm_template1();
}

make_instr_helper(rm)
 805ad38:	83 ec 28             	sub    $0x28,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805ad3b:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 805ad3f:	83 c0 01             	add    $0x1,%eax
 805ad42:	50                   	push   %eax
 805ad43:	e8 e8 18 00 00       	call   805c630 <decode_rm_b>

#define instr div

static void do_execute() {
	uint64_t a;
	uint32_t b = (DATA_TYPE)op_src->val;
 805ad48:	0f b6 0d 14 af 0f 10 	movzbl 0x100faf14,%ecx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
 805ad4f:	0f b7 35 c0 af 0f 10 	movzwl 0x100fafc0,%esi
 805ad56:	89 c5                	mov    %eax,%ebp
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805ad58:	53                   	push   %ebx
 805ad59:	51                   	push   %ecx
 805ad5a:	89 4c 24 20          	mov    %ecx,0x20(%esp)
 805ad5e:	89 5c 24 24          	mov    %ebx,0x24(%esp)
 805ad62:	57                   	push   %edi
 805ad63:	56                   	push   %esi
 805ad64:	e8 c7 37 00 00       	call   805e530 <__udivdi3>
 805ad69:	83 c4 10             	add    $0x10,%esp
	REG(R_EDX) = a % b;
 805ad6c:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 805ad70:	8b 5c 24 1c          	mov    0x1c(%esp),%ebx
#if DATA_BYTE == 1
	a = reg_w(R_EAX);
#else
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
 805ad74:	a2 c0 af 0f 10       	mov    %al,0x100fafc0
	REG(R_EDX) = a % b;
 805ad79:	53                   	push   %ebx
 805ad7a:	51                   	push   %ecx
 805ad7b:	57                   	push   %edi
 805ad7c:	56                   	push   %esi
 805ad7d:	e8 de 38 00 00       	call   805e660 <__umoddi3>
 805ad82:	83 c4 10             	add    $0x10,%esp
 805ad85:	a2 c8 af 0f 10       	mov    %al,0x100fafc8

	print_asm_template1();
 805ad8a:	68 18 af 0f 10       	push   $0x100faf18
 805ad8f:	68 90 4f 06 08       	push   $0x8064f90
 805ad94:	6a 50                	push   $0x50
 805ad96:	68 00 8a 0c 08       	push   $0x80c8a00
 805ad9b:	e8 60 dd fe ff       	call   8048b00 <snprintf@plt>
 805ada0:	83 c4 20             	add    $0x20,%esp
 805ada3:	83 f8 4f             	cmp    $0x4f,%eax
 805ada6:	7f 10                	jg     805adb8 <div_rm_b+0x88>
}

make_instr_helper(rm)
 805ada8:	83 c4 1c             	add    $0x1c,%esp
	execute();
	return len + 1;	// "1" for opcode
 805adab:	8d 45 01             	lea    0x1(%ebp),%eax
 805adae:	5b                   	pop    %ebx
 805adaf:	5e                   	pop    %esi
 805adb0:	5f                   	pop    %edi
 805adb1:	5d                   	pop    %ebp
 805adb2:	c3                   	ret    
 805adb3:	90                   	nop
 805adb4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	a = ((uint64_t)REG(R_EDX) << (DATA_BYTE * 8)) | REG(R_EAX);
#endif
	REG(R_EAX) = a / b;
	REG(R_EDX) = a % b;

	print_asm_template1();
 805adb8:	83 ec 0c             	sub    $0xc,%esp
 805adbb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805adc1:	e8 9a db fe ff       	call   8048960 <fflush@plt>
 805adc6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805adcc:	6a 07                	push   $0x7
 805adce:	6a 01                	push   $0x1
 805add0:	68 92 e8 05 08       	push   $0x805e892
 805add5:	e8 36 dc fe ff       	call   8048a10 <fwrite@plt>
 805adda:	83 c4 20             	add    $0x20,%esp
 805addd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805ade3:	6a 10                	push   $0x10
 805ade5:	6a 01                	push   $0x1
 805ade7:	68 b4 f3 05 08       	push   $0x805f3b4
 805adec:	e8 1f dc fe ff       	call   8048a10 <fwrite@plt>
 805adf1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805adf7:	6a 05                	push   $0x5
 805adf9:	6a 01                	push   $0x1
 805adfb:	68 42 f3 05 08       	push   $0x805f342
 805ae00:	e8 0b dc fe ff       	call   8048a10 <fwrite@plt>
 805ae05:	83 c4 20             	add    $0x20,%esp
 805ae08:	68 18 af 0f 10       	push   $0x100faf18
 805ae0d:	68 90 4f 06 08       	push   $0x8064f90
 805ae12:	6a 50                	push   $0x50
 805ae14:	68 00 8a 0c 08       	push   $0x80c8a00
 805ae19:	e8 e2 dc fe ff       	call   8048b00 <snprintf@plt>
 805ae1e:	83 c4 10             	add    $0x10,%esp
 805ae21:	83 f8 4f             	cmp    $0x4f,%eax
 805ae24:	7e 82                	jle    805ada8 <div_rm_b+0x78>
 805ae26:	68 c8 51 06 08       	push   $0x80651c8
 805ae2b:	6a 10                	push   $0x10
 805ae2d:	68 b8 50 06 08       	push   $0x80650b8
 805ae32:	68 70 51 06 08       	push   $0x8065170
 805ae37:	e8 74 dd fe ff       	call   8048bb0 <__assert_fail@plt>
 805ae3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805ae40 <div_rm_v>:
#include "div-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(div_rm)
 805ae40:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805ae47:	8b 54 24 04          	mov    0x4(%esp),%edx
 805ae4b:	b8 00 ac 05 08       	mov    $0x805ac00,%eax
 805ae50:	75 05                	jne    805ae57 <div_rm_v+0x17>
 805ae52:	b8 f0 aa 05 08       	mov    $0x805aaf0,%eax
 805ae57:	89 54 24 04          	mov    %edx,0x4(%esp)
 805ae5b:	ff e0                	jmp    *%eax
 805ae5d:	66 90                	xchg   %ax,%ax
 805ae5f:	90                   	nop

0805ae60 <imul_rm2a_w>:

make_instr_helper(si_rm2r)
make_instr_helper(i_rm2r)
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
 805ae60:	53                   	push   %ebx
 805ae61:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
 805ae64:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805ae68:	83 c0 01             	add    $0x1,%eax
 805ae6b:	50                   	push   %eax
 805ae6c:	e8 ef 1a 00 00       	call   805c960 <decode_rm_w>
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805ae71:	0f bf 15 c0 af 0f 10 	movswl 0x100fafc0,%edx
make_instr_helper(si_rm2r)
make_instr_helper(i_rm2r)
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
 805ae78:	89 c3                	mov    %eax,%ebx
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805ae7a:	0f bf 05 14 af 0f 10 	movswl 0x100faf14,%eax

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805ae81:	68 18 af 0f 10       	push   $0x100faf18
 805ae86:	68 d1 51 06 08       	push   $0x80651d1
 805ae8b:	6a 50                	push   $0x50
 805ae8d:	68 00 8a 0c 08       	push   $0x80c8a00
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805ae92:	f7 ea                	imul   %edx
#if DATA_BYTE == 1
	reg_w(R_AX) = result;
#elif DATA_BYTE == 2
	REG(R_EAX) = result & 0xffff;
 805ae94:	66 a3 c0 af 0f 10    	mov    %ax,0x100fafc0
	REG(R_EDX) = result >> 16;
 805ae9a:	0f ac d0 10          	shrd   $0x10,%edx,%eax
 805ae9e:	66 a3 c8 af 0f 10    	mov    %ax,0x100fafc8

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805aea4:	e8 57 dc fe ff       	call   8048b00 <snprintf@plt>
 805aea9:	83 c4 20             	add    $0x20,%esp
 805aeac:	83 f8 4f             	cmp    $0x4f,%eax
 805aeaf:	7f 0f                	jg     805aec0 <imul_rm2a_w+0x60>
	return len + 1;
}
 805aeb1:	83 c4 08             	add    $0x8,%esp
	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
	return len + 1;
 805aeb4:	8d 43 01             	lea    0x1(%ebx),%eax
}
 805aeb7:	5b                   	pop    %ebx
 805aeb8:	c3                   	ret    
 805aeb9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805aec0:	83 ec 0c             	sub    $0xc,%esp
 805aec3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805aec9:	e8 92 da fe ff       	call   8048960 <fflush@plt>
 805aece:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805aed4:	6a 07                	push   $0x7
 805aed6:	6a 01                	push   $0x1
 805aed8:	68 92 e8 05 08       	push   $0x805e892
 805aedd:	e8 2e db fe ff       	call   8048a10 <fwrite@plt>
 805aee2:	83 c4 20             	add    $0x20,%esp
 805aee5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805aeeb:	6a 10                	push   $0x10
 805aeed:	6a 01                	push   $0x1
 805aeef:	68 b4 f3 05 08       	push   $0x805f3b4
 805aef4:	e8 17 db fe ff       	call   8048a10 <fwrite@plt>
 805aef9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805aeff:	6a 05                	push   $0x5
 805af01:	6a 01                	push   $0x1
 805af03:	68 42 f3 05 08       	push   $0x805f342
 805af08:	e8 03 db fe ff       	call   8048a10 <fwrite@plt>
 805af0d:	83 c4 20             	add    $0x20,%esp
 805af10:	68 18 af 0f 10       	push   $0x100faf18
 805af15:	68 d1 51 06 08       	push   $0x80651d1
 805af1a:	6a 50                	push   $0x50
 805af1c:	68 00 8a 0c 08       	push   $0x80c8a00
 805af21:	e8 da db fe ff       	call   8048b00 <snprintf@plt>
 805af26:	83 c4 10             	add    $0x10,%esp
 805af29:	83 f8 4f             	cmp    $0x4f,%eax
 805af2c:	7e 83                	jle    805aeb1 <imul_rm2a_w+0x51>
 805af2e:	68 29 54 06 08       	push   $0x8065429
 805af33:	6a 36                	push   $0x36
 805af35:	68 0c 52 06 08       	push   $0x806520c
 805af3a:	68 34 52 06 08       	push   $0x8065234
 805af3f:	e8 6c dc fe ff       	call   8048bb0 <__assert_fail@plt>
 805af44:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805af4a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805af50 <imul_rm2a_l>:

make_instr_helper(si_rm2r)
make_instr_helper(i_rm2r)
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
 805af50:	53                   	push   %ebx
 805af51:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
 805af54:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805af58:	83 c0 01             	add    $0x1,%eax
 805af5b:	50                   	push   %eax
 805af5c:	e8 cf 1d 00 00       	call   805cd30 <decode_rm_l>
 805af61:	89 c3                	mov    %eax,%ebx
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805af63:	a1 c0 af 0f 10       	mov    0x100fafc0,%eax

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805af68:	68 18 af 0f 10       	push   $0x100faf18
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805af6d:	f7 2d 14 af 0f 10    	imull  0x100faf14

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805af73:	68 da 51 06 08       	push   $0x80651da
 805af78:	6a 50                	push   $0x50
 805af7a:	68 00 8a 0c 08       	push   $0x80c8a00
	reg_w(R_AX) = result;
#elif DATA_BYTE == 2
	REG(R_EAX) = result & 0xffff;
	REG(R_EDX) = result >> 16;
#else
	REG(R_EAX) = result & 0xffffffff;
 805af7f:	a3 c0 af 0f 10       	mov    %eax,0x100fafc0
	REG(R_EDX) = result >> 32;
 805af84:	89 15 c8 af 0f 10    	mov    %edx,0x100fafc8

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805af8a:	e8 71 db fe ff       	call   8048b00 <snprintf@plt>
 805af8f:	83 c4 20             	add    $0x20,%esp
 805af92:	83 f8 4f             	cmp    $0x4f,%eax
 805af95:	7f 09                	jg     805afa0 <imul_rm2a_l+0x50>
	return len + 1;
}
 805af97:	83 c4 08             	add    $0x8,%esp
	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
	return len + 1;
 805af9a:	8d 43 01             	lea    0x1(%ebx),%eax
}
 805af9d:	5b                   	pop    %ebx
 805af9e:	c3                   	ret    
 805af9f:	90                   	nop

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805afa0:	83 ec 0c             	sub    $0xc,%esp
 805afa3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805afa9:	e8 b2 d9 fe ff       	call   8048960 <fflush@plt>
 805afae:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805afb4:	6a 07                	push   $0x7
 805afb6:	6a 01                	push   $0x1
 805afb8:	68 92 e8 05 08       	push   $0x805e892
 805afbd:	e8 4e da fe ff       	call   8048a10 <fwrite@plt>
 805afc2:	83 c4 20             	add    $0x20,%esp
 805afc5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805afcb:	6a 10                	push   $0x10
 805afcd:	6a 01                	push   $0x1
 805afcf:	68 b4 f3 05 08       	push   $0x805f3b4
 805afd4:	e8 37 da fe ff       	call   8048a10 <fwrite@plt>
 805afd9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805afdf:	6a 05                	push   $0x5
 805afe1:	6a 01                	push   $0x1
 805afe3:	68 42 f3 05 08       	push   $0x805f342
 805afe8:	e8 23 da fe ff       	call   8048a10 <fwrite@plt>
 805afed:	83 c4 20             	add    $0x20,%esp
 805aff0:	68 18 af 0f 10       	push   $0x100faf18
 805aff5:	68 da 51 06 08       	push   $0x80651da
 805affa:	6a 50                	push   $0x50
 805affc:	68 00 8a 0c 08       	push   $0x80c8a00
 805b001:	e8 fa da fe ff       	call   8048b00 <snprintf@plt>
 805b006:	83 c4 10             	add    $0x10,%esp
 805b009:	83 f8 4f             	cmp    $0x4f,%eax
 805b00c:	7e 89                	jle    805af97 <imul_rm2a_l+0x47>
 805b00e:	68 13 54 06 08       	push   $0x8065413
 805b013:	6a 36                	push   $0x36
 805b015:	68 0c 52 06 08       	push   $0x806520c
 805b01a:	68 7c 52 06 08       	push   $0x806527c
 805b01f:	e8 8c db fe ff       	call   8048bb0 <__assert_fail@plt>
 805b024:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805b02a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805b030 <do_imul_w>:
#endif

#define instr imul

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute() {
 805b030:	83 ec 14             	sub    $0x14,%esp
	RET_DATA_TYPE result = (RET_DATA_TYPE)op_src->val * (RET_DATA_TYPE)op_src2->val;
 805b033:	a1 14 af 0f 10       	mov    0x100faf14,%eax
 805b038:	0f af 05 84 af 0f 10 	imul   0x100faf84,%eax
	OPERAND_W(op_dest, result);
 805b03f:	0f b7 c0             	movzwl %ax,%eax
 805b042:	50                   	push   %eax
 805b043:	68 40 af 0f 10       	push   $0x100faf40
 805b048:	e8 83 1a 00 00       	call   805cad0 <write_operand_w>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template3();
 805b04d:	58                   	pop    %eax
 805b04e:	5a                   	pop    %edx
 805b04f:	68 50 af 0f 10       	push   $0x100faf50
 805b054:	68 88 af 0f 10       	push   $0x100faf88
 805b059:	68 18 af 0f 10       	push   $0x100faf18
 805b05e:	68 e3 51 06 08       	push   $0x80651e3
 805b063:	6a 50                	push   $0x50
 805b065:	68 00 8a 0c 08       	push   $0x80c8a00
 805b06a:	e8 91 da fe ff       	call   8048b00 <snprintf@plt>
 805b06f:	83 c4 20             	add    $0x20,%esp
 805b072:	83 f8 4f             	cmp    $0x4f,%eax
 805b075:	7f 09                	jg     805b080 <do_imul_w+0x50>
}
 805b077:	83 c4 0c             	add    $0xc,%esp
 805b07a:	c3                   	ret    
 805b07b:	90                   	nop
 805b07c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template3();
 805b080:	83 ec 0c             	sub    $0xc,%esp
 805b083:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805b089:	e8 d2 d8 fe ff       	call   8048960 <fflush@plt>
 805b08e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b094:	6a 07                	push   $0x7
 805b096:	6a 01                	push   $0x1
 805b098:	68 92 e8 05 08       	push   $0x805e892
 805b09d:	e8 6e d9 fe ff       	call   8048a10 <fwrite@plt>
 805b0a2:	83 c4 20             	add    $0x20,%esp
 805b0a5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b0ab:	6a 10                	push   $0x10
 805b0ad:	6a 01                	push   $0x1
 805b0af:	68 b4 f3 05 08       	push   $0x805f3b4
 805b0b4:	e8 57 d9 fe ff       	call   8048a10 <fwrite@plt>
 805b0b9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b0bf:	6a 05                	push   $0x5
 805b0c1:	6a 01                	push   $0x1
 805b0c3:	68 42 f3 05 08       	push   $0x805f342
 805b0c8:	e8 43 d9 fe ff       	call   8048a10 <fwrite@plt>
 805b0cd:	83 c4 18             	add    $0x18,%esp
 805b0d0:	68 50 af 0f 10       	push   $0x100faf50
 805b0d5:	68 88 af 0f 10       	push   $0x100faf88
 805b0da:	68 18 af 0f 10       	push   $0x100faf18
 805b0df:	68 e3 51 06 08       	push   $0x80651e3
 805b0e4:	6a 50                	push   $0x50
 805b0e6:	68 00 8a 0c 08       	push   $0x80c8a00
 805b0eb:	e8 10 da fe ff       	call   8048b00 <snprintf@plt>
 805b0f0:	83 c4 20             	add    $0x20,%esp
 805b0f3:	83 f8 4f             	cmp    $0x4f,%eax
 805b0f6:	0f 8e 7b ff ff ff    	jle    805b077 <do_imul_w+0x47>
 805b0fc:	68 35 54 06 08       	push   $0x8065435
 805b101:	6a 16                	push   $0x16
 805b103:	68 0c 52 06 08       	push   $0x806520c
 805b108:	68 c4 52 06 08       	push   $0x80652c4
 805b10d:	e8 9e da fe ff       	call   8048bb0 <__assert_fail@plt>
 805b112:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805b119:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805b120 <imul_si_rm2r_w>:
	ops_decoded.src2 = ops_decoded.dest;
	do_execute();
	return len + 1;
}

make_instr_helper(si_rm2r)
 805b120:	53                   	push   %ebx
 805b121:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b124:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b128:	83 c0 01             	add    $0x1,%eax
 805b12b:	50                   	push   %eax
 805b12c:	e8 8f 18 00 00       	call   805c9c0 <decode_si_rm2r_w>
 805b131:	89 c3                	mov    %eax,%ebx
	execute();
 805b133:	e8 f8 fe ff ff       	call   805b030 <do_imul_w>
 805b138:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805b13b:	8d 43 01             	lea    0x1(%ebx),%eax
 805b13e:	5b                   	pop    %ebx
 805b13f:	c3                   	ret    

0805b140 <imul_i_rm2r_w>:
make_instr_helper(i_rm2r)
 805b140:	53                   	push   %ebx
 805b141:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b144:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b148:	83 c0 01             	add    $0x1,%eax
 805b14b:	50                   	push   %eax
 805b14c:	e8 8f 17 00 00       	call   805c8e0 <decode_i_rm2r_w>
 805b151:	89 c3                	mov    %eax,%ebx
	execute();
 805b153:	e8 d8 fe ff ff       	call   805b030 <do_imul_w>
 805b158:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805b15b:	8d 43 01             	lea    0x1(%ebx),%eax
 805b15e:	5b                   	pop    %ebx
 805b15f:	c3                   	ret    

0805b160 <imul_rm2r_w>:
	 */

	print_asm_template3();
}

make_helper(concat(imul_rm2r_, SUFFIX)) {
 805b160:	53                   	push   %ebx
 805b161:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_rm2r_, SUFFIX)(eip + 1);
 805b164:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b168:	83 c0 01             	add    $0x1,%eax
 805b16b:	50                   	push   %eax
 805b16c:	e8 ff 16 00 00       	call   805c870 <decode_rm2r_w>
 805b171:	89 c3                	mov    %eax,%ebx
	ops_decoded.src2 = ops_decoded.dest;
 805b173:	a1 40 af 0f 10       	mov    0x100faf40,%eax
 805b178:	a3 78 af 0f 10       	mov    %eax,0x100faf78
 805b17d:	a1 44 af 0f 10       	mov    0x100faf44,%eax
 805b182:	a3 7c af 0f 10       	mov    %eax,0x100faf7c
 805b187:	a1 48 af 0f 10       	mov    0x100faf48,%eax
 805b18c:	a3 80 af 0f 10       	mov    %eax,0x100faf80
 805b191:	a1 4c af 0f 10       	mov    0x100faf4c,%eax
 805b196:	a3 84 af 0f 10       	mov    %eax,0x100faf84
 805b19b:	a1 50 af 0f 10       	mov    0x100faf50,%eax
 805b1a0:	a3 88 af 0f 10       	mov    %eax,0x100faf88
 805b1a5:	a1 54 af 0f 10       	mov    0x100faf54,%eax
 805b1aa:	a3 8c af 0f 10       	mov    %eax,0x100faf8c
 805b1af:	a1 58 af 0f 10       	mov    0x100faf58,%eax
 805b1b4:	a3 90 af 0f 10       	mov    %eax,0x100faf90
 805b1b9:	a1 5c af 0f 10       	mov    0x100faf5c,%eax
 805b1be:	a3 94 af 0f 10       	mov    %eax,0x100faf94
 805b1c3:	a1 60 af 0f 10       	mov    0x100faf60,%eax
 805b1c8:	a3 98 af 0f 10       	mov    %eax,0x100faf98
 805b1cd:	a1 64 af 0f 10       	mov    0x100faf64,%eax
 805b1d2:	a3 9c af 0f 10       	mov    %eax,0x100faf9c
 805b1d7:	a1 68 af 0f 10       	mov    0x100faf68,%eax
 805b1dc:	a3 a0 af 0f 10       	mov    %eax,0x100fafa0
 805b1e1:	a1 6c af 0f 10       	mov    0x100faf6c,%eax
 805b1e6:	a3 a4 af 0f 10       	mov    %eax,0x100fafa4
 805b1eb:	a1 70 af 0f 10       	mov    0x100faf70,%eax
 805b1f0:	a3 a8 af 0f 10       	mov    %eax,0x100fafa8
 805b1f5:	a1 74 af 0f 10       	mov    0x100faf74,%eax
 805b1fa:	a3 ac af 0f 10       	mov    %eax,0x100fafac
	do_execute();
 805b1ff:	e8 2c fe ff ff       	call   805b030 <do_imul_w>
	return len + 1;
}
 805b204:	83 c4 18             	add    $0x18,%esp

make_helper(concat(imul_rm2r_, SUFFIX)) {
	int len = concat(decode_rm2r_, SUFFIX)(eip + 1);
	ops_decoded.src2 = ops_decoded.dest;
	do_execute();
	return len + 1;
 805b207:	8d 43 01             	lea    0x1(%ebx),%eax
}
 805b20a:	5b                   	pop    %ebx
 805b20b:	c3                   	ret    
 805b20c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805b210 <do_imul_l>:
#endif

#define instr imul

#if DATA_BYTE == 2 || DATA_BYTE == 4
static void do_execute() {
 805b210:	83 ec 14             	sub    $0x14,%esp
	RET_DATA_TYPE result = (RET_DATA_TYPE)op_src->val * (RET_DATA_TYPE)op_src2->val;
 805b213:	a1 84 af 0f 10       	mov    0x100faf84,%eax
 805b218:	f7 25 14 af 0f 10    	mull   0x100faf14
	OPERAND_W(op_dest, result);
 805b21e:	50                   	push   %eax
 805b21f:	68 40 af 0f 10       	push   $0x100faf40
 805b224:	e8 77 1c 00 00       	call   805cea0 <write_operand_l>

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template3();
 805b229:	58                   	pop    %eax
 805b22a:	5a                   	pop    %edx
 805b22b:	68 50 af 0f 10       	push   $0x100faf50
 805b230:	68 88 af 0f 10       	push   $0x100faf88
 805b235:	68 18 af 0f 10       	push   $0x100faf18
 805b23a:	68 f2 51 06 08       	push   $0x80651f2
 805b23f:	6a 50                	push   $0x50
 805b241:	68 00 8a 0c 08       	push   $0x80c8a00
 805b246:	e8 b5 d8 fe ff       	call   8048b00 <snprintf@plt>
 805b24b:	83 c4 20             	add    $0x20,%esp
 805b24e:	83 f8 4f             	cmp    $0x4f,%eax
 805b251:	7f 0d                	jg     805b260 <do_imul_l+0x50>
}
 805b253:	83 c4 0c             	add    $0xc,%esp
 805b256:	c3                   	ret    
 805b257:	89 f6                	mov    %esi,%esi
 805b259:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template3();
 805b260:	83 ec 0c             	sub    $0xc,%esp
 805b263:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805b269:	e8 f2 d6 fe ff       	call   8048960 <fflush@plt>
 805b26e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b274:	6a 07                	push   $0x7
 805b276:	6a 01                	push   $0x1
 805b278:	68 92 e8 05 08       	push   $0x805e892
 805b27d:	e8 8e d7 fe ff       	call   8048a10 <fwrite@plt>
 805b282:	83 c4 20             	add    $0x20,%esp
 805b285:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b28b:	6a 10                	push   $0x10
 805b28d:	6a 01                	push   $0x1
 805b28f:	68 b4 f3 05 08       	push   $0x805f3b4
 805b294:	e8 77 d7 fe ff       	call   8048a10 <fwrite@plt>
 805b299:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b29f:	6a 05                	push   $0x5
 805b2a1:	6a 01                	push   $0x1
 805b2a3:	68 42 f3 05 08       	push   $0x805f342
 805b2a8:	e8 63 d7 fe ff       	call   8048a10 <fwrite@plt>
 805b2ad:	83 c4 18             	add    $0x18,%esp
 805b2b0:	68 50 af 0f 10       	push   $0x100faf50
 805b2b5:	68 88 af 0f 10       	push   $0x100faf88
 805b2ba:	68 18 af 0f 10       	push   $0x100faf18
 805b2bf:	68 f2 51 06 08       	push   $0x80651f2
 805b2c4:	6a 50                	push   $0x50
 805b2c6:	68 00 8a 0c 08       	push   $0x80c8a00
 805b2cb:	e8 30 d8 fe ff       	call   8048b00 <snprintf@plt>
 805b2d0:	83 c4 20             	add    $0x20,%esp
 805b2d3:	83 f8 4f             	cmp    $0x4f,%eax
 805b2d6:	0f 8e 77 ff ff ff    	jle    805b253 <do_imul_l+0x43>
 805b2dc:	68 1f 54 06 08       	push   $0x806541f
 805b2e1:	6a 16                	push   $0x16
 805b2e3:	68 0c 52 06 08       	push   $0x806520c
 805b2e8:	68 48 53 06 08       	push   $0x8065348
 805b2ed:	e8 be d8 fe ff       	call   8048bb0 <__assert_fail@plt>
 805b2f2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805b2f9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805b300 <imul_si_rm2r_l>:
	ops_decoded.src2 = ops_decoded.dest;
	do_execute();
	return len + 1;
}

make_instr_helper(si_rm2r)
 805b300:	53                   	push   %ebx
 805b301:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b304:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b308:	83 c0 01             	add    $0x1,%eax
 805b30b:	50                   	push   %eax
 805b30c:	e8 7f 1a 00 00       	call   805cd90 <decode_si_rm2r_l>
 805b311:	89 c3                	mov    %eax,%ebx
	execute();
 805b313:	e8 f8 fe ff ff       	call   805b210 <do_imul_l>
 805b318:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805b31b:	8d 43 01             	lea    0x1(%ebx),%eax
 805b31e:	5b                   	pop    %ebx
 805b31f:	c3                   	ret    

0805b320 <imul_i_rm2r_l>:
make_instr_helper(i_rm2r)
 805b320:	53                   	push   %ebx
 805b321:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b324:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b328:	83 c0 01             	add    $0x1,%eax
 805b32b:	50                   	push   %eax
 805b32c:	e8 7f 19 00 00       	call   805ccb0 <decode_i_rm2r_l>
 805b331:	89 c3                	mov    %eax,%ebx
	execute();
 805b333:	e8 d8 fe ff ff       	call   805b210 <do_imul_l>
 805b338:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805b33b:	8d 43 01             	lea    0x1(%ebx),%eax
 805b33e:	5b                   	pop    %ebx
 805b33f:	c3                   	ret    

0805b340 <imul_rm2r_l>:
	 */

	print_asm_template3();
}

make_helper(concat(imul_rm2r_, SUFFIX)) {
 805b340:	53                   	push   %ebx
 805b341:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_rm2r_, SUFFIX)(eip + 1);
 805b344:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b348:	83 c0 01             	add    $0x1,%eax
 805b34b:	50                   	push   %eax
 805b34c:	e8 ef 18 00 00       	call   805cc40 <decode_rm2r_l>
 805b351:	89 c3                	mov    %eax,%ebx
	ops_decoded.src2 = ops_decoded.dest;
 805b353:	a1 40 af 0f 10       	mov    0x100faf40,%eax
 805b358:	a3 78 af 0f 10       	mov    %eax,0x100faf78
 805b35d:	a1 44 af 0f 10       	mov    0x100faf44,%eax
 805b362:	a3 7c af 0f 10       	mov    %eax,0x100faf7c
 805b367:	a1 48 af 0f 10       	mov    0x100faf48,%eax
 805b36c:	a3 80 af 0f 10       	mov    %eax,0x100faf80
 805b371:	a1 4c af 0f 10       	mov    0x100faf4c,%eax
 805b376:	a3 84 af 0f 10       	mov    %eax,0x100faf84
 805b37b:	a1 50 af 0f 10       	mov    0x100faf50,%eax
 805b380:	a3 88 af 0f 10       	mov    %eax,0x100faf88
 805b385:	a1 54 af 0f 10       	mov    0x100faf54,%eax
 805b38a:	a3 8c af 0f 10       	mov    %eax,0x100faf8c
 805b38f:	a1 58 af 0f 10       	mov    0x100faf58,%eax
 805b394:	a3 90 af 0f 10       	mov    %eax,0x100faf90
 805b399:	a1 5c af 0f 10       	mov    0x100faf5c,%eax
 805b39e:	a3 94 af 0f 10       	mov    %eax,0x100faf94
 805b3a3:	a1 60 af 0f 10       	mov    0x100faf60,%eax
 805b3a8:	a3 98 af 0f 10       	mov    %eax,0x100faf98
 805b3ad:	a1 64 af 0f 10       	mov    0x100faf64,%eax
 805b3b2:	a3 9c af 0f 10       	mov    %eax,0x100faf9c
 805b3b7:	a1 68 af 0f 10       	mov    0x100faf68,%eax
 805b3bc:	a3 a0 af 0f 10       	mov    %eax,0x100fafa0
 805b3c1:	a1 6c af 0f 10       	mov    0x100faf6c,%eax
 805b3c6:	a3 a4 af 0f 10       	mov    %eax,0x100fafa4
 805b3cb:	a1 70 af 0f 10       	mov    0x100faf70,%eax
 805b3d0:	a3 a8 af 0f 10       	mov    %eax,0x100fafa8
 805b3d5:	a1 74 af 0f 10       	mov    0x100faf74,%eax
 805b3da:	a3 ac af 0f 10       	mov    %eax,0x100fafac
	do_execute();
 805b3df:	e8 2c fe ff ff       	call   805b210 <do_imul_l>
	return len + 1;
}
 805b3e4:	83 c4 18             	add    $0x18,%esp

make_helper(concat(imul_rm2r_, SUFFIX)) {
	int len = concat(decode_rm2r_, SUFFIX)(eip + 1);
	ops_decoded.src2 = ops_decoded.dest;
	do_execute();
	return len + 1;
 805b3e7:	8d 43 01             	lea    0x1(%ebx),%eax
}
 805b3ea:	5b                   	pop    %ebx
 805b3eb:	c3                   	ret    
 805b3ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805b3f0 <imul_rm2a_b>:

make_instr_helper(si_rm2r)
make_instr_helper(i_rm2r)
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
 805b3f0:	53                   	push   %ebx
 805b3f1:	83 ec 14             	sub    $0x14,%esp
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
 805b3f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b3f8:	83 c0 01             	add    $0x1,%eax
 805b3fb:	50                   	push   %eax
 805b3fc:	e8 2f 12 00 00       	call   805c630 <decode_rm_b>
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805b401:	0f be 15 c0 af 0f 10 	movsbl 0x100fafc0,%edx
make_instr_helper(si_rm2r)
make_instr_helper(i_rm2r)
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
 805b408:	89 c3                	mov    %eax,%ebx
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805b40a:	0f be 05 14 af 0f 10 	movsbl 0x100faf14,%eax

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805b411:	68 18 af 0f 10       	push   $0x100faf18
 805b416:	68 01 52 06 08       	push   $0x8065201
 805b41b:	6a 50                	push   $0x50
 805b41d:	68 00 8a 0c 08       	push   $0x80c8a00
#endif

make_helper(concat(imul_rm2a_, SUFFIX)) {
	int len = concat(decode_rm_, SUFFIX)(eip + 1);
	int64_t src = (DATA_TYPE_S)op_src->val;
	int64_t result = (DATA_TYPE_S)REG(R_EAX) * src;
 805b422:	f7 ea                	imul   %edx
#if DATA_BYTE == 1
	reg_w(R_AX) = result;
 805b424:	66 a3 c0 af 0f 10    	mov    %ax,0x100fafc0

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805b42a:	e8 d1 d6 fe ff       	call   8048b00 <snprintf@plt>
 805b42f:	83 c4 20             	add    $0x20,%esp
 805b432:	83 f8 4f             	cmp    $0x4f,%eax
 805b435:	7f 09                	jg     805b440 <imul_rm2a_b+0x50>
	return len + 1;
}
 805b437:	83 c4 08             	add    $0x8,%esp
	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
	return len + 1;
 805b43a:	8d 43 01             	lea    0x1(%ebx),%eax
}
 805b43d:	5b                   	pop    %ebx
 805b43e:	c3                   	ret    
 805b43f:	90                   	nop

	/* There is no need to update EFLAGS, since no other instructions 
	 * in PA will test the flags updated by this instruction.
	 */

	print_asm_template1();
 805b440:	83 ec 0c             	sub    $0xc,%esp
 805b443:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805b449:	e8 12 d5 fe ff       	call   8048960 <fflush@plt>
 805b44e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b454:	6a 07                	push   $0x7
 805b456:	6a 01                	push   $0x1
 805b458:	68 92 e8 05 08       	push   $0x805e892
 805b45d:	e8 ae d5 fe ff       	call   8048a10 <fwrite@plt>
 805b462:	83 c4 20             	add    $0x20,%esp
 805b465:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b46b:	6a 10                	push   $0x10
 805b46d:	6a 01                	push   $0x1
 805b46f:	68 b4 f3 05 08       	push   $0x805f3b4
 805b474:	e8 97 d5 fe ff       	call   8048a10 <fwrite@plt>
 805b479:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b47f:	6a 05                	push   $0x5
 805b481:	6a 01                	push   $0x1
 805b483:	68 42 f3 05 08       	push   $0x805f342
 805b488:	e8 83 d5 fe ff       	call   8048a10 <fwrite@plt>
 805b48d:	83 c4 20             	add    $0x20,%esp
 805b490:	68 18 af 0f 10       	push   $0x100faf18
 805b495:	68 01 52 06 08       	push   $0x8065201
 805b49a:	6a 50                	push   $0x50
 805b49c:	68 00 8a 0c 08       	push   $0x80c8a00
 805b4a1:	e8 5a d6 fe ff       	call   8048b00 <snprintf@plt>
 805b4a6:	83 c4 10             	add    $0x10,%esp
 805b4a9:	83 f8 4f             	cmp    $0x4f,%eax
 805b4ac:	7e 89                	jle    805b437 <imul_rm2a_b+0x47>
 805b4ae:	68 3f 54 06 08       	push   $0x806543f
 805b4b3:	6a 36                	push   $0x36
 805b4b5:	68 0c 52 06 08       	push   $0x806520c
 805b4ba:	68 cc 53 06 08       	push   $0x80653cc
 805b4bf:	e8 ec d6 fe ff       	call   8048bb0 <__assert_fail@plt>
 805b4c4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805b4ca:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805b4d0 <imul_rm2a_v>:
#include "imul-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(imul_rm2a)
 805b4d0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805b4d7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805b4db:	b8 60 ae 05 08       	mov    $0x805ae60,%eax
 805b4e0:	75 05                	jne    805b4e7 <imul_rm2a_v+0x17>
 805b4e2:	b8 50 af 05 08       	mov    $0x805af50,%eax
 805b4e7:	89 54 24 04          	mov    %edx,0x4(%esp)
 805b4eb:	ff e0                	jmp    *%eax
 805b4ed:	8d 76 00             	lea    0x0(%esi),%esi

0805b4f0 <imul_rm2r_v>:
make_helper_v(imul_rm2r)
 805b4f0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805b4f7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805b4fb:	b8 60 b1 05 08       	mov    $0x805b160,%eax
 805b500:	75 05                	jne    805b507 <imul_rm2r_v+0x17>
 805b502:	b8 40 b3 05 08       	mov    $0x805b340,%eax
 805b507:	89 54 24 04          	mov    %edx,0x4(%esp)
 805b50b:	ff e0                	jmp    *%eax
 805b50d:	8d 76 00             	lea    0x0(%esi),%esi

0805b510 <imul_si_rm2r_v>:
make_helper_v(imul_si_rm2r)
 805b510:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805b517:	8b 54 24 04          	mov    0x4(%esp),%edx
 805b51b:	b8 20 b1 05 08       	mov    $0x805b120,%eax
 805b520:	75 05                	jne    805b527 <imul_si_rm2r_v+0x17>
 805b522:	b8 00 b3 05 08       	mov    $0x805b300,%eax
 805b527:	89 54 24 04          	mov    %edx,0x4(%esp)
 805b52b:	ff e0                	jmp    *%eax
 805b52d:	8d 76 00             	lea    0x0(%esi),%esi

0805b530 <imul_i_rm2r_v>:
make_helper_v(imul_i_rm2r)
 805b530:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805b537:	8b 54 24 04          	mov    0x4(%esp),%edx
 805b53b:	b8 40 b1 05 08       	mov    $0x805b140,%eax
 805b540:	75 05                	jne    805b547 <imul_i_rm2r_v+0x17>
 805b542:	b8 20 b3 05 08       	mov    $0x805b320,%eax
 805b547:	89 54 24 04          	mov    %edx,0x4(%esp)
 805b54b:	ff e0                	jmp    *%eax
 805b54d:	66 90                	xchg   %ax,%ax
 805b54f:	90                   	nop

0805b550 <do_dec_w>:
#include "cpu/exec/template-start.h"

#define instr dec

static void do_execute () {
 805b550:	55                   	push   %ebp
 805b551:	57                   	push   %edi
 805b552:	56                   	push   %esi
 805b553:	53                   	push   %ebx
 805b554:	83 ec 24             	sub    $0x24,%esp
	DATA_TYPE result = op_src->val - 1;
 805b557:	0f b7 05 14 af 0f 10 	movzwl 0x100faf14,%eax
 805b55e:	8d 58 ff             	lea    -0x1(%eax),%ebx
	OPERAND_W(op_src, result);
 805b561:	0f b7 c3             	movzwl %bx,%eax
 805b564:	50                   	push   %eax
 805b565:	68 08 af 0f 10       	push   $0x100faf08
 805b56a:	e8 61 15 00 00       	call   805cad0 <write_operand_w>

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
 805b56f:	0f b6 c3             	movzbl %bl,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805b572:	8b 0d 4c af 0f 10    	mov    0x100faf4c,%ecx
 805b578:	8b 35 14 af 0f 10    	mov    0x100faf14,%esi
	DATA_TYPE result = op_src->val - 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805b57e:	89 c2                	mov    %eax,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805b580:	0f b6 2d e4 af 0f 10 	movzbl 0x100fafe4,%ebp
	DATA_TYPE result = op_src->val - 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805b587:	c1 ea 04             	shr    $0x4,%edx
 805b58a:	31 d0                	xor    %edx,%eax
	pf = (pf >> 2) ^ pf;
 805b58c:	89 c2                	mov    %eax,%edx
 805b58e:	c1 ea 02             	shr    $0x2,%edx
 805b591:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 805b593:	89 c2                	mov    %eax,%edx
 805b595:	d1 ea                	shr    %edx
 805b597:	89 54 24 1c          	mov    %edx,0x1c(%esp)
	cpu.CF = op_dest->val < op_src->val;
 805b59b:	83 c4 10             	add    $0x10,%esp
 805b59e:	39 f1                	cmp    %esi,%ecx
 805b5a0:	0f 92 c2             	setb   %dl

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805b5a3:	33 44 24 0c          	xor    0xc(%esp),%eax
	cpu.CF = op_dest->val < op_src->val;
 805b5a7:	83 e5 fa             	and    $0xfffffffa,%ebp
 805b5aa:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805b5ac:	68 18 af 0f 10       	push   $0x100faf18
 805b5b1:	68 4b 54 06 08       	push   $0x806544b
 805b5b6:	6a 50                	push   $0x50
 805b5b8:	68 00 8a 0c 08       	push   $0x80c8a00
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
 805b5bd:	83 e0 01             	and    $0x1,%eax
 805b5c0:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805b5c7:	89 e8                	mov    %ebp,%eax
 805b5c9:	09 f8                	or     %edi,%eax
 805b5cb:	09 d0                	or     %edx,%eax
	cpu.ZF = (result == 0);
 805b5cd:	66 85 db             	test   %bx,%bx
 805b5d0:	0f 94 c2             	sete   %dl
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805b5d3:	c1 e9 1f             	shr    $0x1f,%ecx
 805b5d6:	c1 ee 1f             	shr    $0x1f,%esi
 805b5d9:	31 ce                	xor    %ecx,%esi
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
 805b5db:	c1 e2 06             	shl    $0x6,%edx
 805b5de:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805b5e1:	21 f1                	and    %esi,%ecx
 805b5e3:	0f b6 35 e5 af 0f 10 	movzbl 0x100fafe5,%esi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805b5ea:	09 d0                	or     %edx,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805b5ec:	c1 e1 03             	shl    $0x3,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805b5ef:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805b5f4:	83 e6 f7             	and    $0xfffffff7,%esi
 805b5f7:	09 f1                	or     %esi,%ecx
 805b5f9:	88 0d e5 af 0f 10    	mov    %cl,0x100fafe5

	print_asm_template1();
 805b5ff:	e8 fc d4 fe ff       	call   8048b00 <snprintf@plt>
 805b604:	83 c4 10             	add    $0x10,%esp
 805b607:	83 f8 4f             	cmp    $0x4f,%eax
 805b60a:	7f 0c                	jg     805b618 <do_dec_w+0xc8>
}
 805b60c:	83 c4 1c             	add    $0x1c,%esp
 805b60f:	5b                   	pop    %ebx
 805b610:	5e                   	pop    %esi
 805b611:	5f                   	pop    %edi
 805b612:	5d                   	pop    %ebp
 805b613:	c3                   	ret    
 805b614:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805b618:	83 ec 0c             	sub    $0xc,%esp
 805b61b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805b621:	e8 3a d3 fe ff       	call   8048960 <fflush@plt>
 805b626:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b62c:	6a 07                	push   $0x7
 805b62e:	6a 01                	push   $0x1
 805b630:	68 92 e8 05 08       	push   $0x805e892
 805b635:	e8 d6 d3 fe ff       	call   8048a10 <fwrite@plt>
 805b63a:	83 c4 20             	add    $0x20,%esp
 805b63d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b643:	6a 10                	push   $0x10
 805b645:	6a 01                	push   $0x1
 805b647:	68 b4 f3 05 08       	push   $0x805f3b4
 805b64c:	e8 bf d3 fe ff       	call   8048a10 <fwrite@plt>
 805b651:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b657:	6a 05                	push   $0x5
 805b659:	6a 01                	push   $0x1
 805b65b:	68 42 f3 05 08       	push   $0x805f342
 805b660:	e8 ab d3 fe ff       	call   8048a10 <fwrite@plt>
 805b665:	83 c4 20             	add    $0x20,%esp
 805b668:	68 18 af 0f 10       	push   $0x100faf18
 805b66d:	68 4b 54 06 08       	push   $0x806544b
 805b672:	6a 50                	push   $0x50
 805b674:	68 00 8a 0c 08       	push   $0x80c8a00
 805b679:	e8 82 d4 fe ff       	call   8048b00 <snprintf@plt>
 805b67e:	83 c4 10             	add    $0x10,%esp
 805b681:	83 f8 4f             	cmp    $0x4f,%eax
 805b684:	7e 86                	jle    805b60c <do_dec_w+0xbc>
 805b686:	68 6b 55 06 08       	push   $0x806556b
 805b68b:	6a 14                	push   $0x14
 805b68d:	68 64 54 06 08       	push   $0x8065464
 805b692:	68 8c 54 06 08       	push   $0x806548c
 805b697:	e8 14 d5 fe ff       	call   8048bb0 <__assert_fail@plt>
 805b69c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805b6a0 <dec_rm_w>:
}

make_instr_helper(rm)
 805b6a0:	53                   	push   %ebx
 805b6a1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b6a4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b6a8:	83 c0 01             	add    $0x1,%eax
 805b6ab:	50                   	push   %eax
 805b6ac:	e8 af 12 00 00       	call   805c960 <decode_rm_w>
 805b6b1:	89 c3                	mov    %eax,%ebx
	execute();
 805b6b3:	e8 98 fe ff ff       	call   805b550 <do_dec_w>
 805b6b8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805b6bb:	8d 43 01             	lea    0x1(%ebx),%eax
 805b6be:	5b                   	pop    %ebx
 805b6bf:	c3                   	ret    

0805b6c0 <dec_r_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(r)
 805b6c0:	53                   	push   %ebx
 805b6c1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b6c4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b6c8:	83 c0 01             	add    $0x1,%eax
 805b6cb:	50                   	push   %eax
 805b6cc:	e8 af 12 00 00       	call   805c980 <decode_r_w>
 805b6d1:	89 c3                	mov    %eax,%ebx
	execute();
 805b6d3:	e8 78 fe ff ff       	call   805b550 <do_dec_w>
 805b6d8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805b6db:	8d 43 01             	lea    0x1(%ebx),%eax
 805b6de:	5b                   	pop    %ebx
 805b6df:	c3                   	ret    

0805b6e0 <do_dec_l>:
#include "cpu/exec/template-start.h"

#define instr dec

static void do_execute () {
 805b6e0:	55                   	push   %ebp
 805b6e1:	57                   	push   %edi
 805b6e2:	56                   	push   %esi
 805b6e3:	53                   	push   %ebx
 805b6e4:	83 ec 24             	sub    $0x24,%esp
	DATA_TYPE result = op_src->val - 1;
 805b6e7:	a1 14 af 0f 10       	mov    0x100faf14,%eax
 805b6ec:	8d 58 ff             	lea    -0x1(%eax),%ebx
	OPERAND_W(op_src, result);
 805b6ef:	53                   	push   %ebx
 805b6f0:	68 08 af 0f 10       	push   $0x100faf08
 805b6f5:	e8 a6 17 00 00       	call   805cea0 <write_operand_l>

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
 805b6fa:	0f b6 c3             	movzbl %bl,%eax
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805b6fd:	8b 0d 14 af 0f 10    	mov    0x100faf14,%ecx
 805b703:	8b 35 4c af 0f 10    	mov    0x100faf4c,%esi
	DATA_TYPE result = op_src->val - 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805b709:	89 c2                	mov    %eax,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805b70b:	0f b6 2d e4 af 0f 10 	movzbl 0x100fafe4,%ebp
	DATA_TYPE result = op_src->val - 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805b712:	c1 ea 04             	shr    $0x4,%edx
 805b715:	31 d0                	xor    %edx,%eax
	pf = (pf >> 2) ^ pf;
 805b717:	89 c2                	mov    %eax,%edx
 805b719:	c1 ea 02             	shr    $0x2,%edx
 805b71c:	31 d0                	xor    %edx,%eax
	pf = (pf >> 1) ^ pf;
 805b71e:	89 c2                	mov    %eax,%edx
 805b720:	d1 ea                	shr    %edx
 805b722:	89 54 24 1c          	mov    %edx,0x1c(%esp)
	cpu.CF = op_dest->val < op_src->val;
 805b726:	83 c4 10             	add    $0x10,%esp
 805b729:	39 ce                	cmp    %ecx,%esi
 805b72b:	0f 92 c2             	setb   %dl

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805b72e:	33 44 24 0c          	xor    0xc(%esp),%eax
	cpu.CF = op_dest->val < op_src->val;
 805b732:	83 e5 fa             	and    $0xfffffffa,%ebp
 805b735:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805b737:	68 18 af 0f 10       	push   $0x100faf18
 805b73c:	68 53 54 06 08       	push   $0x8065453
 805b741:	6a 50                	push   $0x50
 805b743:	68 00 8a 0c 08       	push   $0x80c8a00
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
 805b748:	83 e0 01             	and    $0x1,%eax
 805b74b:	8d 14 85 00 00 00 00 	lea    0x0(,%eax,4),%edx
 805b752:	89 e8                	mov    %ebp,%eax
 805b754:	09 f8                	or     %edi,%eax
 805b756:	09 d0                	or     %edx,%eax
	cpu.ZF = (result == 0);
 805b758:	85 db                	test   %ebx,%ebx
 805b75a:	0f 94 c2             	sete   %dl
	cpu.SF = (result >> 31) & 1;
 805b75d:	c1 eb 1f             	shr    $0x1f,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
 805b760:	83 e0 3f             	and    $0x3f,%eax
 805b763:	c1 e2 06             	shl    $0x6,%edx
	cpu.SF = (result >> 31) & 1;
 805b766:	89 df                	mov    %ebx,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805b768:	c1 ee 1f             	shr    $0x1f,%esi
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805b76b:	09 d0                	or     %edx,%eax
 805b76d:	c1 e7 07             	shl    $0x7,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805b770:	31 f3                	xor    %esi,%ebx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
 805b772:	09 f8                	or     %edi,%eax
 805b774:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805b779:	89 c8                	mov    %ecx,%eax
 805b77b:	89 f1                	mov    %esi,%ecx
 805b77d:	c1 e8 1f             	shr    $0x1f,%eax
 805b780:	31 c1                	xor    %eax,%ecx
 805b782:	21 d9                	and    %ebx,%ecx
 805b784:	0f b6 1d e5 af 0f 10 	movzbl 0x100fafe5,%ebx
 805b78b:	c1 e1 03             	shl    $0x3,%ecx
 805b78e:	83 e3 f7             	and    $0xfffffff7,%ebx
 805b791:	09 d9                	or     %ebx,%ecx
 805b793:	88 0d e5 af 0f 10    	mov    %cl,0x100fafe5

	print_asm_template1();
 805b799:	e8 62 d3 fe ff       	call   8048b00 <snprintf@plt>
 805b79e:	83 c4 10             	add    $0x10,%esp
 805b7a1:	83 f8 4f             	cmp    $0x4f,%eax
 805b7a4:	7f 0a                	jg     805b7b0 <do_dec_l+0xd0>
}
 805b7a6:	83 c4 1c             	add    $0x1c,%esp
 805b7a9:	5b                   	pop    %ebx
 805b7aa:	5e                   	pop    %esi
 805b7ab:	5f                   	pop    %edi
 805b7ac:	5d                   	pop    %ebp
 805b7ad:	c3                   	ret    
 805b7ae:	66 90                	xchg   %ax,%ax
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805b7b0:	83 ec 0c             	sub    $0xc,%esp
 805b7b3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805b7b9:	e8 a2 d1 fe ff       	call   8048960 <fflush@plt>
 805b7be:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b7c4:	6a 07                	push   $0x7
 805b7c6:	6a 01                	push   $0x1
 805b7c8:	68 92 e8 05 08       	push   $0x805e892
 805b7cd:	e8 3e d2 fe ff       	call   8048a10 <fwrite@plt>
 805b7d2:	83 c4 20             	add    $0x20,%esp
 805b7d5:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b7db:	6a 10                	push   $0x10
 805b7dd:	6a 01                	push   $0x1
 805b7df:	68 b4 f3 05 08       	push   $0x805f3b4
 805b7e4:	e8 27 d2 fe ff       	call   8048a10 <fwrite@plt>
 805b7e9:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b7ef:	6a 05                	push   $0x5
 805b7f1:	6a 01                	push   $0x1
 805b7f3:	68 42 f3 05 08       	push   $0x805f342
 805b7f8:	e8 13 d2 fe ff       	call   8048a10 <fwrite@plt>
 805b7fd:	83 c4 20             	add    $0x20,%esp
 805b800:	68 18 af 0f 10       	push   $0x100faf18
 805b805:	68 53 54 06 08       	push   $0x8065453
 805b80a:	6a 50                	push   $0x50
 805b80c:	68 00 8a 0c 08       	push   $0x80c8a00
 805b811:	e8 ea d2 fe ff       	call   8048b00 <snprintf@plt>
 805b816:	83 c4 10             	add    $0x10,%esp
 805b819:	83 f8 4f             	cmp    $0x4f,%eax
 805b81c:	7e 88                	jle    805b7a6 <do_dec_l+0xc6>
 805b81e:	68 62 55 06 08       	push   $0x8065562
 805b823:	6a 14                	push   $0x14
 805b825:	68 64 54 06 08       	push   $0x8065464
 805b82a:	68 d4 54 06 08       	push   $0x80654d4
 805b82f:	e8 7c d3 fe ff       	call   8048bb0 <__assert_fail@plt>
 805b834:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805b83a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805b840 <dec_rm_l>:
}

make_instr_helper(rm)
 805b840:	53                   	push   %ebx
 805b841:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b844:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b848:	83 c0 01             	add    $0x1,%eax
 805b84b:	50                   	push   %eax
 805b84c:	e8 df 14 00 00       	call   805cd30 <decode_rm_l>
 805b851:	89 c3                	mov    %eax,%ebx
	execute();
 805b853:	e8 88 fe ff ff       	call   805b6e0 <do_dec_l>
 805b858:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805b85b:	8d 43 01             	lea    0x1(%ebx),%eax
 805b85e:	5b                   	pop    %ebx
 805b85f:	c3                   	ret    

0805b860 <dec_r_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(r)
 805b860:	53                   	push   %ebx
 805b861:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b864:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805b868:	83 c0 01             	add    $0x1,%eax
 805b86b:	50                   	push   %eax
 805b86c:	e8 df 14 00 00       	call   805cd50 <decode_r_l>
 805b871:	89 c3                	mov    %eax,%ebx
	execute();
 805b873:	e8 68 fe ff ff       	call   805b6e0 <do_dec_l>
 805b878:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805b87b:	8d 43 01             	lea    0x1(%ebx),%eax
 805b87e:	5b                   	pop    %ebx
 805b87f:	c3                   	ret    

0805b880 <dec_rm_b>:
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
}

make_instr_helper(rm)
 805b880:	55                   	push   %ebp
 805b881:	57                   	push   %edi
 805b882:	56                   	push   %esi
 805b883:	53                   	push   %ebx
 805b884:	83 ec 18             	sub    $0x18,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805b887:	8b 44 24 2c          	mov    0x2c(%esp),%eax
 805b88b:	83 c0 01             	add    $0x1,%eax
 805b88e:	50                   	push   %eax
 805b88f:	e8 9c 0d 00 00       	call   805c630 <decode_rm_b>
 805b894:	89 c6                	mov    %eax,%esi
#include "cpu/exec/template-start.h"

#define instr dec

static void do_execute () {
	DATA_TYPE result = op_src->val - 1;
 805b896:	0f b6 05 14 af 0f 10 	movzbl 0x100faf14,%eax
 805b89d:	8d 58 ff             	lea    -0x1(%eax),%ebx
	OPERAND_W(op_src, result);
 805b8a0:	58                   	pop    %eax
 805b8a1:	5a                   	pop    %edx
 805b8a2:	0f b6 fb             	movzbl %bl,%edi
 805b8a5:	57                   	push   %edi
 805b8a6:	68 08 af 0f 10       	push   $0x100faf08
 805b8ab:	e8 90 0e 00 00       	call   805c740 <write_operand_b>

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805b8b0:	89 fa                	mov    %edi,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805b8b2:	83 c4 10             	add    $0x10,%esp
 805b8b5:	8b 0d 4c af 0f 10    	mov    0x100faf4c,%ecx
	DATA_TYPE result = op_src->val - 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805b8bb:	c1 ea 04             	shr    $0x4,%edx
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805b8be:	68 18 af 0f 10       	push   $0x100faf18
 805b8c3:	68 5b 54 06 08       	push   $0x806545b
	DATA_TYPE result = op_src->val - 1;
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
 805b8c8:	31 d7                	xor    %edx,%edi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805b8ca:	6a 50                	push   $0x50
 805b8cc:	68 00 8a 0c 08       	push   $0x80c8a00
	OPERAND_W(op_src, result);

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
 805b8d1:	89 fa                	mov    %edi,%edx
 805b8d3:	c1 ea 02             	shr    $0x2,%edx
 805b8d6:	31 fa                	xor    %edi,%edx
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805b8d8:	0f b6 3d e4 af 0f 10 	movzbl 0x100fafe4,%edi

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805b8df:	89 d5                	mov    %edx,%ebp
 805b8e1:	d1 ed                	shr    %ebp
	cpu.CF = op_dest->val < op_src->val;
 805b8e3:	3b 0d 14 af 0f 10    	cmp    0x100faf14,%ecx
 805b8e9:	0f 92 c0             	setb   %al

	/* TODO: Update EFLAGS. */
	uint32_t pf = (result & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805b8ec:	31 ea                	xor    %ebp,%edx
	cpu.CF = op_dest->val < op_src->val;
 805b8ee:	83 e7 fa             	and    $0xfffffffa,%edi
	cpu.PF = (pf & 1);
 805b8f1:	83 e2 01             	and    $0x1,%edx
 805b8f4:	09 f8                	or     %edi,%eax
 805b8f6:	c1 e2 02             	shl    $0x2,%edx
 805b8f9:	09 d0                	or     %edx,%eax
	cpu.ZF = (result == 0);
 805b8fb:	84 db                	test   %bl,%bl
 805b8fd:	0f 94 c3             	sete   %bl
 805b900:	83 e0 3f             	and    $0x3f,%eax
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805b903:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
 805b906:	c1 e3 06             	shl    $0x6,%ebx
	cpu.SF = (result >> 31) & 1;
 805b909:	09 d8                	or     %ebx,%eax
 805b90b:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;
 805b910:	a1 14 af 0f 10       	mov    0x100faf14,%eax
 805b915:	c1 e8 1f             	shr    $0x1f,%eax
 805b918:	31 c8                	xor    %ecx,%eax
 805b91a:	21 c1                	and    %eax,%ecx
 805b91c:	0f b6 05 e5 af 0f 10 	movzbl 0x100fafe5,%eax
 805b923:	c1 e1 03             	shl    $0x3,%ecx
 805b926:	83 e0 f7             	and    $0xfffffff7,%eax
 805b929:	09 c1                	or     %eax,%ecx
 805b92b:	88 0d e5 af 0f 10    	mov    %cl,0x100fafe5

	print_asm_template1();
 805b931:	e8 ca d1 fe ff       	call   8048b00 <snprintf@plt>
 805b936:	83 c4 10             	add    $0x10,%esp
 805b939:	83 f8 4f             	cmp    $0x4f,%eax
 805b93c:	7f 12                	jg     805b950 <dec_rm_b+0xd0>
}

make_instr_helper(rm)
 805b93e:	83 c4 0c             	add    $0xc,%esp
	execute();
	return len + 1;	// "1" for opcode
 805b941:	8d 46 01             	lea    0x1(%esi),%eax
 805b944:	5b                   	pop    %ebx
 805b945:	5e                   	pop    %esi
 805b946:	5f                   	pop    %edi
 805b947:	5d                   	pop    %ebp
 805b948:	c3                   	ret    
 805b949:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	cpu.PF = (pf & 1);
	cpu.ZF = (result == 0);
	cpu.SF = (result >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (result >> 31)) & 1;

	print_asm_template1();
 805b950:	83 ec 0c             	sub    $0xc,%esp
 805b953:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805b959:	e8 02 d0 fe ff       	call   8048960 <fflush@plt>
 805b95e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b964:	6a 07                	push   $0x7
 805b966:	6a 01                	push   $0x1
 805b968:	68 92 e8 05 08       	push   $0x805e892
 805b96d:	e8 9e d0 fe ff       	call   8048a10 <fwrite@plt>
 805b972:	83 c4 20             	add    $0x20,%esp
 805b975:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b97b:	6a 10                	push   $0x10
 805b97d:	6a 01                	push   $0x1
 805b97f:	68 b4 f3 05 08       	push   $0x805f3b4
 805b984:	e8 87 d0 fe ff       	call   8048a10 <fwrite@plt>
 805b989:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805b98f:	6a 05                	push   $0x5
 805b991:	6a 01                	push   $0x1
 805b993:	68 42 f3 05 08       	push   $0x805f342
 805b998:	e8 73 d0 fe ff       	call   8048a10 <fwrite@plt>
 805b99d:	83 c4 20             	add    $0x20,%esp
 805b9a0:	68 18 af 0f 10       	push   $0x100faf18
 805b9a5:	68 5b 54 06 08       	push   $0x806545b
 805b9aa:	6a 50                	push   $0x50
 805b9ac:	68 00 8a 0c 08       	push   $0x80c8a00
 805b9b1:	e8 4a d1 fe ff       	call   8048b00 <snprintf@plt>
 805b9b6:	83 c4 10             	add    $0x10,%esp
 805b9b9:	83 f8 4f             	cmp    $0x4f,%eax
 805b9bc:	7e 80                	jle    805b93e <dec_rm_b+0xbe>
 805b9be:	68 74 55 06 08       	push   $0x8065574
 805b9c3:	6a 14                	push   $0x14
 805b9c5:	68 64 54 06 08       	push   $0x8065464
 805b9ca:	68 1c 55 06 08       	push   $0x806551c
 805b9cf:	e8 dc d1 fe ff       	call   8048bb0 <__assert_fail@plt>
 805b9d4:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805b9da:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805b9e0 <dec_rm_v>:
#include "dec-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(dec_rm)
 805b9e0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805b9e7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805b9eb:	b8 a0 b6 05 08       	mov    $0x805b6a0,%eax
 805b9f0:	75 05                	jne    805b9f7 <dec_rm_v+0x17>
 805b9f2:	b8 40 b8 05 08       	mov    $0x805b840,%eax
 805b9f7:	89 54 24 04          	mov    %edx,0x4(%esp)
 805b9fb:	ff e0                	jmp    *%eax
 805b9fd:	8d 76 00             	lea    0x0(%esi),%esi

0805ba00 <dec_r_v>:
make_helper_v(dec_r)
 805ba00:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805ba07:	8b 54 24 04          	mov    0x4(%esp),%edx
 805ba0b:	b8 c0 b6 05 08       	mov    $0x805b6c0,%eax
 805ba10:	75 05                	jne    805ba17 <dec_r_v+0x17>
 805ba12:	b8 60 b8 05 08       	mov    $0x805b860,%eax
 805ba17:	89 54 24 04          	mov    %edx,0x4(%esp)
 805ba1b:	ff e0                	jmp    *%eax
 805ba1d:	66 90                	xchg   %ax,%ax
 805ba1f:	90                   	nop

0805ba20 <inv>:
#include "cpu/exec/helper.h"
#include "monitor/monitor.h"

make_helper(inv) {
 805ba20:	53                   	push   %ebx
 805ba21:	83 ec 30             	sub    $0x30,%esp
 805ba24:	8b 5c 24 38          	mov    0x38(%esp),%ebx

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 805ba28:	6a 04                	push   $0x4
 805ba2a:	53                   	push   %ebx
 805ba2b:	e8 20 f5 fe ff       	call   804af50 <swaddr_read>
	/* invalid opcode */

	uint32_t temp[8];
	temp[0] = instr_fetch(eip, 4);
 805ba30:	89 44 24 10          	mov    %eax,0x10(%esp)
 805ba34:	58                   	pop    %eax
	temp[1] = instr_fetch(eip + 4, 4);
 805ba35:	8d 43 04             	lea    0x4(%ebx),%eax
 805ba38:	5a                   	pop    %edx
 805ba39:	6a 04                	push   $0x4
 805ba3b:	50                   	push   %eax
 805ba3c:	e8 0f f5 fe ff       	call   804af50 <swaddr_read>
 805ba41:	89 c1                	mov    %eax,%ecx

	uint8_t *p = (void *)temp;
	printf("invalid opcode(eip = 0x%08x): %02x %02x %02x %02x %02x %02x %02x %02x ...\n\n", 
 805ba43:	83 c4 08             	add    $0x8,%esp
make_helper(inv) {
	/* invalid opcode */

	uint32_t temp[8];
	temp[0] = instr_fetch(eip, 4);
	temp[1] = instr_fetch(eip + 4, 4);
 805ba46:	c1 e9 10             	shr    $0x10,%ecx
 805ba49:	89 ca                	mov    %ecx,%edx

	uint8_t *p = (void *)temp;
	printf("invalid opcode(eip = 0x%08x): %02x %02x %02x %02x %02x %02x %02x %02x ...\n\n", 
 805ba4b:	89 c1                	mov    %eax,%ecx
 805ba4d:	c1 e9 18             	shr    $0x18,%ecx
 805ba50:	0f b6 d2             	movzbl %dl,%edx
 805ba53:	51                   	push   %ecx
 805ba54:	52                   	push   %edx
 805ba55:	0f b6 d4             	movzbl %ah,%edx
 805ba58:	0f b6 c0             	movzbl %al,%eax
 805ba5b:	52                   	push   %edx
 805ba5c:	50                   	push   %eax
 805ba5d:	0f b6 44 24 1b       	movzbl 0x1b(%esp),%eax
 805ba62:	50                   	push   %eax
 805ba63:	0f b6 44 24 1e       	movzbl 0x1e(%esp),%eax
 805ba68:	50                   	push   %eax
 805ba69:	0f b6 44 24 21       	movzbl 0x21(%esp),%eax
 805ba6e:	50                   	push   %eax
 805ba6f:	0f b6 44 24 24       	movzbl 0x24(%esp),%eax
 805ba74:	50                   	push   %eax
 805ba75:	53                   	push   %ebx
 805ba76:	68 80 55 06 08       	push   $0x8065580
 805ba7b:	e8 d0 ce fe ff       	call   8048950 <printf@plt>
			eip, p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);

	extern char logo [];
	printf("There are two cases which will trigger this unexpected exception:\n\
 805ba80:	83 c4 28             	add    $0x28,%esp
 805ba83:	53                   	push   %ebx
 805ba84:	68 cc 55 06 08       	push   $0x80655cc
 805ba89:	e8 c2 ce fe ff       	call   8048950 <printf@plt>
1. The instruction at eip = 0x%08x is not implemented.\n\
2. Something is implemented incorrectly.\n", eip);
	printf("Find this eip value(0x%08x) in the disassembling result to distinguish which case it is.\n\n", eip);
 805ba8e:	58                   	pop    %eax
 805ba8f:	5a                   	pop    %edx
 805ba90:	53                   	push   %ebx
 805ba91:	68 70 56 06 08       	push   $0x8065670
 805ba96:	e8 b5 ce fe ff       	call   8048950 <printf@plt>
	printf("\33[1;31mIf it is the first case, see\n%s\nfor more details.\n\nIf it is the second case, remember:\n\
 805ba9b:	59                   	pop    %ecx
 805ba9c:	5b                   	pop    %ebx
 805ba9d:	68 00 53 07 08       	push   $0x8075300
 805baa2:	68 cc 56 06 08       	push   $0x80656cc
 805baa7:	e8 a4 ce fe ff       	call   8048950 <printf@plt>
* The machine is always right!\n\
* Every line of untested code is always wrong!\33[0m\n\n", logo);

	assert(0);
 805baac:	68 3b 58 06 08       	push   $0x806583b
 805bab1:	6a 18                	push   $0x18
 805bab3:	68 80 57 06 08       	push   $0x8065780
 805bab8:	68 1c ea 05 08       	push   $0x805ea1c
 805babd:	e8 ee d0 fe ff       	call   8048bb0 <__assert_fail@plt>
 805bac2:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805bac9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805bad0 <nemu_trap>:
}

make_helper(nemu_trap) {
 805bad0:	83 ec 0c             	sub    $0xc,%esp
	print_asm("nemu trap (eax = %d)", cpu.eax);
 805bad3:	ff 35 c0 af 0f 10    	pushl  0x100fafc0
 805bad9:	68 1c 58 06 08       	push   $0x806581c
 805bade:	6a 50                	push   $0x50
 805bae0:	68 00 8a 0c 08       	push   $0x80c8a00
 805bae5:	e8 16 d0 fe ff       	call   8048b00 <snprintf@plt>
 805baea:	83 c4 10             	add    $0x10,%esp
 805baed:	83 f8 4f             	cmp    $0x4f,%eax
 805baf0:	7f 4e                	jg     805bb40 <nemu_trap+0x70>

	switch(cpu.eax) {
 805baf2:	a1 c0 af 0f 10       	mov    0x100fafc0,%eax
 805baf7:	83 f8 02             	cmp    $0x2,%eax
 805bafa:	74 2b                	je     805bb27 <nemu_trap+0x57>
		case 2:
		   	break;

		default:
			printf("\33[1;31mnemu: HIT %s TRAP\33[0m at eip = 0x%08x\n\n",
 805bafc:	85 c0                	test   %eax,%eax
 805bafe:	8b 0d e0 af 0f 10    	mov    0x100fafe0,%ecx
 805bb04:	ba 13 58 06 08       	mov    $0x8065813,%edx
 805bb09:	75 25                	jne    805bb30 <nemu_trap+0x60>
 805bb0b:	83 ec 04             	sub    $0x4,%esp
 805bb0e:	51                   	push   %ecx
 805bb0f:	52                   	push   %edx
 805bb10:	68 e4 57 06 08       	push   $0x80657e4
 805bb15:	e8 36 ce fe ff       	call   8048950 <printf@plt>
					(cpu.eax == 0 ? "GOOD" : "BAD"), cpu.eip);
			nemu_state = END;
 805bb1a:	c7 05 80 82 07 08 02 	movl   $0x2,0x8078280
 805bb21:	00 00 00 
 805bb24:	83 c4 10             	add    $0x10,%esp
	}

	return 1;
}
 805bb27:	b8 01 00 00 00       	mov    $0x1,%eax
 805bb2c:	83 c4 0c             	add    $0xc,%esp
 805bb2f:	c3                   	ret    
	switch(cpu.eax) {
		case 2:
		   	break;

		default:
			printf("\33[1;31mnemu: HIT %s TRAP\33[0m at eip = 0x%08x\n\n",
 805bb30:	ba 18 58 06 08       	mov    $0x8065818,%edx
 805bb35:	eb d4                	jmp    805bb0b <nemu_trap+0x3b>
 805bb37:	89 f6                	mov    %esi,%esi
 805bb39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

	assert(0);
}

make_helper(nemu_trap) {
	print_asm("nemu trap (eax = %d)", cpu.eax);
 805bb40:	83 ec 0c             	sub    $0xc,%esp
 805bb43:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805bb49:	e8 12 ce fe ff       	call   8048960 <fflush@plt>
 805bb4e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805bb54:	6a 07                	push   $0x7
 805bb56:	6a 01                	push   $0x1
 805bb58:	68 92 e8 05 08       	push   $0x805e892
 805bb5d:	e8 ae ce fe ff       	call   8048a10 <fwrite@plt>
 805bb62:	83 c4 20             	add    $0x20,%esp
 805bb65:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805bb6b:	6a 10                	push   $0x10
 805bb6d:	6a 01                	push   $0x1
 805bb6f:	68 b4 f3 05 08       	push   $0x805f3b4
 805bb74:	e8 97 ce fe ff       	call   8048a10 <fwrite@plt>
 805bb79:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805bb7f:	6a 05                	push   $0x5
 805bb81:	6a 01                	push   $0x1
 805bb83:	68 42 f3 05 08       	push   $0x805f342
 805bb88:	e8 83 ce fe ff       	call   8048a10 <fwrite@plt>
 805bb8d:	83 c4 20             	add    $0x20,%esp
 805bb90:	ff 35 c0 af 0f 10    	pushl  0x100fafc0
 805bb96:	68 1c 58 06 08       	push   $0x806581c
 805bb9b:	6a 50                	push   $0x50
 805bb9d:	68 00 8a 0c 08       	push   $0x80c8a00
 805bba2:	e8 59 cf fe ff       	call   8048b00 <snprintf@plt>
 805bba7:	83 c4 10             	add    $0x10,%esp
 805bbaa:	83 f8 4f             	cmp    $0x4f,%eax
 805bbad:	0f 8e 3f ff ff ff    	jle    805baf2 <nemu_trap+0x22>
 805bbb3:	68 31 58 06 08       	push   $0x8065831
 805bbb8:	6a 1c                	push   $0x1c
 805bbba:	68 80 57 06 08       	push   $0x8065780
 805bbbf:	68 a4 57 06 08       	push   $0x80657a4
 805bbc4:	e8 e7 cf fe ff       	call   8048bb0 <__assert_fail@plt>
 805bbc9:	66 90                	xchg   %ax,%ax
 805bbcb:	66 90                	xchg   %ax,%ax
 805bbcd:	66 90                	xchg   %ax,%ax
 805bbcf:	90                   	nop

0805bbd0 <do_cmp_b>:
#include "cpu/exec/template-start.h"

#define instr cmp

static void do_execute() {
 805bbd0:	55                   	push   %ebp
 805bbd1:	57                   	push   %edi
 805bbd2:	56                   	push   %esi
 805bbd3:	53                   	push   %ebx
 805bbd4:	83 ec 18             	sub    $0x18,%esp
	uint32_t res = op_dest->val - op_src->val;
 805bbd7:	8b 1d 4c af 0f 10    	mov    0x100faf4c,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805bbdd:	0f b6 2d e4 af 0f 10 	movzbl 0x100fafe4,%ebp
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805bbe4:	68 50 af 0f 10       	push   $0x100faf50
 805bbe9:	68 18 af 0f 10       	push   $0x100faf18
 805bbee:	68 3f 58 06 08       	push   $0x806583f
 805bbf3:	6a 50                	push   $0x50
#include "cpu/exec/template-start.h"

#define instr cmp

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
 805bbf5:	89 d9                	mov    %ebx,%ecx
 805bbf7:	2b 0d 14 af 0f 10    	sub    0x100faf14,%ecx
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805bbfd:	68 00 8a 0c 08       	push   $0x80c8a00

#define instr cmp

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
 805bc02:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
 805bc05:	89 c6                	mov    %eax,%esi
 805bc07:	c1 ee 04             	shr    $0x4,%esi
 805bc0a:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 805bc0c:	89 c6                	mov    %eax,%esi
 805bc0e:	c1 ee 02             	shr    $0x2,%esi
 805bc11:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 805bc13:	89 c6                	mov    %eax,%esi
 805bc15:	d1 ee                	shr    %esi
	cpu.CF = op_dest->val < op_src->val;
 805bc17:	3b 1d 14 af 0f 10    	cmp    0x100faf14,%ebx
 805bc1d:	0f 92 c2             	setb   %dl
static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805bc20:	31 f0                	xor    %esi,%eax
	cpu.CF = op_dest->val < op_src->val;
 805bc22:	83 e5 fa             	and    $0xfffffffa,%ebp
	cpu.PF = (pf & 1);
 805bc25:	83 e0 01             	and    $0x1,%eax
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805bc28:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
 805bc2a:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 805bc31:	89 e8                	mov    %ebp,%eax
 805bc33:	09 f8                	or     %edi,%eax
 805bc35:	09 f0                	or     %esi,%eax
	cpu.ZF = (res == 0);
 805bc37:	85 c9                	test   %ecx,%ecx
 805bc39:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 805bc3c:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 805bc3f:	83 e0 3f             	and    $0x3f,%eax
 805bc42:	89 d6                	mov    %edx,%esi
	cpu.SF = (res >> 31) & 1;
 805bc44:	89 cf                	mov    %ecx,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805bc46:	c1 eb 1f             	shr    $0x1f,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 805bc49:	c1 e6 06             	shl    $0x6,%esi
	cpu.SF = (res >> 31) & 1;
 805bc4c:	c1 e7 07             	shl    $0x7,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805bc4f:	89 da                	mov    %ebx,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 805bc51:	09 f0                	or     %esi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805bc53:	31 d9                	xor    %ebx,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 805bc55:	09 f8                	or     %edi,%eax
 805bc57:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805bc5c:	a1 14 af 0f 10       	mov    0x100faf14,%eax
 805bc61:	c1 e8 1f             	shr    $0x1f,%eax
 805bc64:	31 c2                	xor    %eax,%edx
 805bc66:	21 ca                	and    %ecx,%edx
 805bc68:	0f b6 0d e5 af 0f 10 	movzbl 0x100fafe5,%ecx
 805bc6f:	c1 e2 03             	shl    $0x3,%edx
 805bc72:	83 e1 f7             	and    $0xfffffff7,%ecx
 805bc75:	09 ca                	or     %ecx,%edx
 805bc77:	88 15 e5 af 0f 10    	mov    %dl,0x100fafe5
	print_asm_template2();
 805bc7d:	e8 7e ce fe ff       	call   8048b00 <snprintf@plt>
 805bc82:	83 c4 20             	add    $0x20,%esp
 805bc85:	83 f8 4f             	cmp    $0x4f,%eax
 805bc88:	7f 0e                	jg     805bc98 <do_cmp_b+0xc8>
}
 805bc8a:	83 c4 0c             	add    $0xc,%esp
 805bc8d:	5b                   	pop    %ebx
 805bc8e:	5e                   	pop    %esi
 805bc8f:	5f                   	pop    %edi
 805bc90:	5d                   	pop    %ebp
 805bc91:	c3                   	ret    
 805bc92:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805bc98:	83 ec 0c             	sub    $0xc,%esp
 805bc9b:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805bca1:	e8 ba cc fe ff       	call   8048960 <fflush@plt>
 805bca6:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805bcac:	6a 07                	push   $0x7
 805bcae:	6a 01                	push   $0x1
 805bcb0:	68 92 e8 05 08       	push   $0x805e892
 805bcb5:	e8 56 cd fe ff       	call   8048a10 <fwrite@plt>
 805bcba:	83 c4 20             	add    $0x20,%esp
 805bcbd:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805bcc3:	6a 10                	push   $0x10
 805bcc5:	6a 01                	push   $0x1
 805bcc7:	68 b4 f3 05 08       	push   $0x805f3b4
 805bccc:	e8 3f cd fe ff       	call   8048a10 <fwrite@plt>
 805bcd1:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805bcd7:	6a 05                	push   $0x5
 805bcd9:	6a 01                	push   $0x1
 805bcdb:	68 42 f3 05 08       	push   $0x805f342
 805bce0:	e8 2b cd fe ff       	call   8048a10 <fwrite@plt>
 805bce5:	83 c4 14             	add    $0x14,%esp
 805bce8:	68 50 af 0f 10       	push   $0x100faf50
 805bced:	68 18 af 0f 10       	push   $0x100faf18
 805bcf2:	68 3f 58 06 08       	push   $0x806583f
 805bcf7:	6a 50                	push   $0x50
 805bcf9:	68 00 8a 0c 08       	push   $0x80c8a00
 805bcfe:	e8 fd cd fe ff       	call   8048b00 <snprintf@plt>
 805bd03:	83 c4 20             	add    $0x20,%esp
 805bd06:	83 f8 4f             	cmp    $0x4f,%eax
 805bd09:	0f 8e 7b ff ff ff    	jle    805bc8a <do_cmp_b+0xba>
 805bd0f:	68 c5 59 06 08       	push   $0x80659c5
 805bd14:	6a 10                	push   $0x10
 805bd16:	68 60 58 06 08       	push   $0x8065860
 805bd1b:	68 88 58 06 08       	push   $0x8065888
 805bd20:	e8 8b ce fe ff       	call   8048bb0 <__assert_fail@plt>
 805bd25:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805bd29:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805bd30 <do_cmp_w>:
#include "cpu/exec/template-start.h"

#define instr cmp

static void do_execute() {
 805bd30:	55                   	push   %ebp
 805bd31:	57                   	push   %edi
 805bd32:	56                   	push   %esi
 805bd33:	53                   	push   %ebx
 805bd34:	83 ec 18             	sub    $0x18,%esp
	uint32_t res = op_dest->val - op_src->val;
 805bd37:	8b 1d 4c af 0f 10    	mov    0x100faf4c,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805bd3d:	0f b6 2d e4 af 0f 10 	movzbl 0x100fafe4,%ebp
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805bd44:	68 50 af 0f 10       	push   $0x100faf50
 805bd49:	68 18 af 0f 10       	push   $0x100faf18
 805bd4e:	68 4a 58 06 08       	push   $0x806584a
 805bd53:	6a 50                	push   $0x50
#include "cpu/exec/template-start.h"

#define instr cmp

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
 805bd55:	89 d9                	mov    %ebx,%ecx
 805bd57:	2b 0d 14 af 0f 10    	sub    0x100faf14,%ecx
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805bd5d:	68 00 8a 0c 08       	push   $0x80c8a00

#define instr cmp

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
 805bd62:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
 805bd65:	89 c6                	mov    %eax,%esi
 805bd67:	c1 ee 04             	shr    $0x4,%esi
 805bd6a:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 805bd6c:	89 c6                	mov    %eax,%esi
 805bd6e:	c1 ee 02             	shr    $0x2,%esi
 805bd71:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 805bd73:	89 c6                	mov    %eax,%esi
 805bd75:	d1 ee                	shr    %esi
	cpu.CF = op_dest->val < op_src->val;
 805bd77:	3b 1d 14 af 0f 10    	cmp    0x100faf14,%ebx
 805bd7d:	0f 92 c2             	setb   %dl
static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805bd80:	31 f0                	xor    %esi,%eax
	cpu.CF = op_dest->val < op_src->val;
 805bd82:	83 e5 fa             	and    $0xfffffffa,%ebp
	cpu.PF = (pf & 1);
 805bd85:	83 e0 01             	and    $0x1,%eax
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805bd88:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
 805bd8a:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 805bd91:	89 e8                	mov    %ebp,%eax
 805bd93:	09 f8                	or     %edi,%eax
 805bd95:	09 f0                	or     %esi,%eax
	cpu.ZF = (res == 0);
 805bd97:	85 c9                	test   %ecx,%ecx
 805bd99:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 805bd9c:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 805bd9f:	83 e0 3f             	and    $0x3f,%eax
 805bda2:	89 d6                	mov    %edx,%esi
	cpu.SF = (res >> 31) & 1;
 805bda4:	89 cf                	mov    %ecx,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805bda6:	c1 eb 1f             	shr    $0x1f,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 805bda9:	c1 e6 06             	shl    $0x6,%esi
	cpu.SF = (res >> 31) & 1;
 805bdac:	c1 e7 07             	shl    $0x7,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805bdaf:	89 da                	mov    %ebx,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 805bdb1:	09 f0                	or     %esi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805bdb3:	31 d9                	xor    %ebx,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 805bdb5:	09 f8                	or     %edi,%eax
 805bdb7:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805bdbc:	a1 14 af 0f 10       	mov    0x100faf14,%eax
 805bdc1:	c1 e8 1f             	shr    $0x1f,%eax
 805bdc4:	31 c2                	xor    %eax,%edx
 805bdc6:	21 ca                	and    %ecx,%edx
 805bdc8:	0f b6 0d e5 af 0f 10 	movzbl 0x100fafe5,%ecx
 805bdcf:	c1 e2 03             	shl    $0x3,%edx
 805bdd2:	83 e1 f7             	and    $0xfffffff7,%ecx
 805bdd5:	09 ca                	or     %ecx,%edx
 805bdd7:	88 15 e5 af 0f 10    	mov    %dl,0x100fafe5
	print_asm_template2();
 805bddd:	e8 1e cd fe ff       	call   8048b00 <snprintf@plt>
 805bde2:	83 c4 20             	add    $0x20,%esp
 805bde5:	83 f8 4f             	cmp    $0x4f,%eax
 805bde8:	7f 0e                	jg     805bdf8 <do_cmp_w+0xc8>
}
 805bdea:	83 c4 0c             	add    $0xc,%esp
 805bded:	5b                   	pop    %ebx
 805bdee:	5e                   	pop    %esi
 805bdef:	5f                   	pop    %edi
 805bdf0:	5d                   	pop    %ebp
 805bdf1:	c3                   	ret    
 805bdf2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805bdf8:	83 ec 0c             	sub    $0xc,%esp
 805bdfb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805be01:	e8 5a cb fe ff       	call   8048960 <fflush@plt>
 805be06:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805be0c:	6a 07                	push   $0x7
 805be0e:	6a 01                	push   $0x1
 805be10:	68 92 e8 05 08       	push   $0x805e892
 805be15:	e8 f6 cb fe ff       	call   8048a10 <fwrite@plt>
 805be1a:	83 c4 20             	add    $0x20,%esp
 805be1d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805be23:	6a 10                	push   $0x10
 805be25:	6a 01                	push   $0x1
 805be27:	68 b4 f3 05 08       	push   $0x805f3b4
 805be2c:	e8 df cb fe ff       	call   8048a10 <fwrite@plt>
 805be31:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805be37:	6a 05                	push   $0x5
 805be39:	6a 01                	push   $0x1
 805be3b:	68 42 f3 05 08       	push   $0x805f342
 805be40:	e8 cb cb fe ff       	call   8048a10 <fwrite@plt>
 805be45:	83 c4 14             	add    $0x14,%esp
 805be48:	68 50 af 0f 10       	push   $0x100faf50
 805be4d:	68 18 af 0f 10       	push   $0x100faf18
 805be52:	68 4a 58 06 08       	push   $0x806584a
 805be57:	6a 50                	push   $0x50
 805be59:	68 00 8a 0c 08       	push   $0x80c8a00
 805be5e:	e8 9d cc fe ff       	call   8048b00 <snprintf@plt>
 805be63:	83 c4 20             	add    $0x20,%esp
 805be66:	83 f8 4f             	cmp    $0x4f,%eax
 805be69:	0f 8e 7b ff ff ff    	jle    805bdea <do_cmp_w+0xba>
 805be6f:	68 bc 59 06 08       	push   $0x80659bc
 805be74:	6a 10                	push   $0x10
 805be76:	68 60 58 06 08       	push   $0x8065860
 805be7b:	68 ec 58 06 08       	push   $0x80658ec
 805be80:	e8 2b cd fe ff       	call   8048bb0 <__assert_fail@plt>
 805be85:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805be89:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805be90 <cmp_i2rm_w>:
}

make_instr_helper(i2rm)
 805be90:	53                   	push   %ebx
 805be91:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805be94:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805be98:	83 c0 01             	add    $0x1,%eax
 805be9b:	50                   	push   %eax
 805be9c:	e8 6f 0a 00 00       	call   805c910 <decode_i2rm_w>
 805bea1:	89 c3                	mov    %eax,%ebx
	execute();
 805bea3:	e8 88 fe ff ff       	call   805bd30 <do_cmp_w>
 805bea8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805beab:	8d 43 01             	lea    0x1(%ebx),%eax
 805beae:	5b                   	pop    %ebx
 805beaf:	c3                   	ret    

0805beb0 <cmp_i2a_w>:
make_instr_helper(i2a)
 805beb0:	53                   	push   %ebx
 805beb1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805beb4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805beb8:	83 c0 01             	add    $0x1,%eax
 805bebb:	50                   	push   %eax
 805bebc:	e8 cf 09 00 00       	call   805c890 <decode_i2a_w>
 805bec1:	89 c3                	mov    %eax,%ebx
	execute();
 805bec3:	e8 68 fe ff ff       	call   805bd30 <do_cmp_w>
 805bec8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805becb:	8d 43 01             	lea    0x1(%ebx),%eax
 805bece:	5b                   	pop    %ebx
 805becf:	c3                   	ret    

0805bed0 <cmp_r2rm_w>:
make_instr_helper(r2rm)
 805bed0:	53                   	push   %ebx
 805bed1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805bed4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805bed8:	83 c0 01             	add    $0x1,%eax
 805bedb:	50                   	push   %eax
 805bedc:	e8 6f 09 00 00       	call   805c850 <decode_r2rm_w>
 805bee1:	89 c3                	mov    %eax,%ebx
	execute();
 805bee3:	e8 48 fe ff ff       	call   805bd30 <do_cmp_w>
 805bee8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805beeb:	8d 43 01             	lea    0x1(%ebx),%eax
 805beee:	5b                   	pop    %ebx
 805beef:	c3                   	ret    

0805bef0 <cmp_rm2r_w>:
make_instr_helper(rm2r)
 805bef0:	53                   	push   %ebx
 805bef1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805bef4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805bef8:	83 c0 01             	add    $0x1,%eax
 805befb:	50                   	push   %eax
 805befc:	e8 6f 09 00 00       	call   805c870 <decode_rm2r_w>
 805bf01:	89 c3                	mov    %eax,%ebx
	execute();
 805bf03:	e8 28 fe ff ff       	call   805bd30 <do_cmp_w>
 805bf08:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805bf0b:	8d 43 01             	lea    0x1(%ebx),%eax
 805bf0e:	5b                   	pop    %ebx
 805bf0f:	c3                   	ret    

0805bf10 <cmp_si2rm_w>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 805bf10:	53                   	push   %ebx
 805bf11:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805bf14:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805bf18:	83 c0 01             	add    $0x1,%eax
 805bf1b:	50                   	push   %eax
 805bf1c:	e8 6f 0a 00 00       	call   805c990 <decode_si2rm_w>
 805bf21:	89 c3                	mov    %eax,%ebx
	execute();
 805bf23:	e8 08 fe ff ff       	call   805bd30 <do_cmp_w>
 805bf28:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805bf2b:	8d 43 01             	lea    0x1(%ebx),%eax
 805bf2e:	5b                   	pop    %ebx
 805bf2f:	c3                   	ret    

0805bf30 <do_cmp_l>:
#include "cpu/exec/template-start.h"

#define instr cmp

static void do_execute() {
 805bf30:	55                   	push   %ebp
 805bf31:	57                   	push   %edi
 805bf32:	56                   	push   %esi
 805bf33:	53                   	push   %ebx
 805bf34:	83 ec 18             	sub    $0x18,%esp
	uint32_t res = op_dest->val - op_src->val;
 805bf37:	8b 1d 4c af 0f 10    	mov    0x100faf4c,%ebx
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805bf3d:	0f b6 2d e4 af 0f 10 	movzbl 0x100fafe4,%ebp
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805bf44:	68 50 af 0f 10       	push   $0x100faf50
 805bf49:	68 18 af 0f 10       	push   $0x100faf18
 805bf4e:	68 55 58 06 08       	push   $0x8065855
 805bf53:	6a 50                	push   $0x50
#include "cpu/exec/template-start.h"

#define instr cmp

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
 805bf55:	89 d9                	mov    %ebx,%ecx
 805bf57:	2b 0d 14 af 0f 10    	sub    0x100faf14,%ecx
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805bf5d:	68 00 8a 0c 08       	push   $0x80c8a00

#define instr cmp

static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
 805bf62:	0f b6 c1             	movzbl %cl,%eax
	pf = (pf >> 4) ^ pf;
 805bf65:	89 c6                	mov    %eax,%esi
 805bf67:	c1 ee 04             	shr    $0x4,%esi
 805bf6a:	31 f0                	xor    %esi,%eax
	pf = (pf >> 2) ^ pf;
 805bf6c:	89 c6                	mov    %eax,%esi
 805bf6e:	c1 ee 02             	shr    $0x2,%esi
 805bf71:	31 f0                	xor    %esi,%eax
	pf = (pf >> 1) ^ pf;
 805bf73:	89 c6                	mov    %eax,%esi
 805bf75:	d1 ee                	shr    %esi
	cpu.CF = op_dest->val < op_src->val;
 805bf77:	3b 1d 14 af 0f 10    	cmp    0x100faf14,%ebx
 805bf7d:	0f 92 c2             	setb   %dl
static void do_execute() {
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
 805bf80:	31 f0                	xor    %esi,%eax
	cpu.CF = op_dest->val < op_src->val;
 805bf82:	83 e5 fa             	and    $0xfffffffa,%ebp
	cpu.PF = (pf & 1);
 805bf85:	83 e0 01             	and    $0x1,%eax
	uint32_t res = op_dest->val - op_src->val;
	uint32_t pf = (res & 255);
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
 805bf88:	89 d7                	mov    %edx,%edi
	cpu.PF = (pf & 1);
 805bf8a:	8d 34 85 00 00 00 00 	lea    0x0(,%eax,4),%esi
 805bf91:	89 e8                	mov    %ebp,%eax
 805bf93:	09 f8                	or     %edi,%eax
 805bf95:	09 f0                	or     %esi,%eax
	cpu.ZF = (res == 0);
 805bf97:	85 c9                	test   %ecx,%ecx
 805bf99:	0f 94 c2             	sete   %dl
	cpu.SF = (res >> 31) & 1;
 805bf9c:	c1 e9 1f             	shr    $0x1f,%ecx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 805bf9f:	83 e0 3f             	and    $0x3f,%eax
 805bfa2:	89 d6                	mov    %edx,%esi
	cpu.SF = (res >> 31) & 1;
 805bfa4:	89 cf                	mov    %ecx,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805bfa6:	c1 eb 1f             	shr    $0x1f,%ebx
	pf = (pf >> 4) ^ pf;
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
 805bfa9:	c1 e6 06             	shl    $0x6,%esi
	cpu.SF = (res >> 31) & 1;
 805bfac:	c1 e7 07             	shl    $0x7,%edi
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805bfaf:	89 da                	mov    %ebx,%edx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 805bfb1:	09 f0                	or     %esi,%eax
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805bfb3:	31 d9                	xor    %ebx,%ecx
	pf = (pf >> 2) ^ pf;
	pf = (pf >> 1) ^ pf;
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
 805bfb5:	09 f8                	or     %edi,%eax
 805bfb7:	a2 e4 af 0f 10       	mov    %al,0x100fafe4
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
 805bfbc:	a1 14 af 0f 10       	mov    0x100faf14,%eax
 805bfc1:	c1 e8 1f             	shr    $0x1f,%eax
 805bfc4:	31 c2                	xor    %eax,%edx
 805bfc6:	21 ca                	and    %ecx,%edx
 805bfc8:	0f b6 0d e5 af 0f 10 	movzbl 0x100fafe5,%ecx
 805bfcf:	c1 e2 03             	shl    $0x3,%edx
 805bfd2:	83 e1 f7             	and    $0xfffffff7,%ecx
 805bfd5:	09 ca                	or     %ecx,%edx
 805bfd7:	88 15 e5 af 0f 10    	mov    %dl,0x100fafe5
	print_asm_template2();
 805bfdd:	e8 1e cb fe ff       	call   8048b00 <snprintf@plt>
 805bfe2:	83 c4 20             	add    $0x20,%esp
 805bfe5:	83 f8 4f             	cmp    $0x4f,%eax
 805bfe8:	7f 0e                	jg     805bff8 <do_cmp_l+0xc8>
}
 805bfea:	83 c4 0c             	add    $0xc,%esp
 805bfed:	5b                   	pop    %ebx
 805bfee:	5e                   	pop    %esi
 805bfef:	5f                   	pop    %edi
 805bff0:	5d                   	pop    %ebp
 805bff1:	c3                   	ret    
 805bff2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	cpu.CF = op_dest->val < op_src->val;
	cpu.PF = (pf & 1);
	cpu.ZF = (res == 0);
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
 805bff8:	83 ec 0c             	sub    $0xc,%esp
 805bffb:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805c001:	e8 5a c9 fe ff       	call   8048960 <fflush@plt>
 805c006:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805c00c:	6a 07                	push   $0x7
 805c00e:	6a 01                	push   $0x1
 805c010:	68 92 e8 05 08       	push   $0x805e892
 805c015:	e8 f6 c9 fe ff       	call   8048a10 <fwrite@plt>
 805c01a:	83 c4 20             	add    $0x20,%esp
 805c01d:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805c023:	6a 10                	push   $0x10
 805c025:	6a 01                	push   $0x1
 805c027:	68 b4 f3 05 08       	push   $0x805f3b4
 805c02c:	e8 df c9 fe ff       	call   8048a10 <fwrite@plt>
 805c031:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805c037:	6a 05                	push   $0x5
 805c039:	6a 01                	push   $0x1
 805c03b:	68 42 f3 05 08       	push   $0x805f342
 805c040:	e8 cb c9 fe ff       	call   8048a10 <fwrite@plt>
 805c045:	83 c4 14             	add    $0x14,%esp
 805c048:	68 50 af 0f 10       	push   $0x100faf50
 805c04d:	68 18 af 0f 10       	push   $0x100faf18
 805c052:	68 55 58 06 08       	push   $0x8065855
 805c057:	6a 50                	push   $0x50
 805c059:	68 00 8a 0c 08       	push   $0x80c8a00
 805c05e:	e8 9d ca fe ff       	call   8048b00 <snprintf@plt>
 805c063:	83 c4 20             	add    $0x20,%esp
 805c066:	83 f8 4f             	cmp    $0x4f,%eax
 805c069:	0f 8e 7b ff ff ff    	jle    805bfea <do_cmp_l+0xba>
 805c06f:	68 b3 59 06 08       	push   $0x80659b3
 805c074:	6a 10                	push   $0x10
 805c076:	68 60 58 06 08       	push   $0x8065860
 805c07b:	68 50 59 06 08       	push   $0x8065950
 805c080:	e8 2b cb fe ff       	call   8048bb0 <__assert_fail@plt>
 805c085:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805c089:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c090 <cmp_i2rm_l>:
}

make_instr_helper(i2rm)
 805c090:	53                   	push   %ebx
 805c091:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c094:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c098:	83 c0 01             	add    $0x1,%eax
 805c09b:	50                   	push   %eax
 805c09c:	e8 3f 0c 00 00       	call   805cce0 <decode_i2rm_l>
 805c0a1:	89 c3                	mov    %eax,%ebx
	execute();
 805c0a3:	e8 88 fe ff ff       	call   805bf30 <do_cmp_l>
 805c0a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c0ab:	8d 43 01             	lea    0x1(%ebx),%eax
 805c0ae:	5b                   	pop    %ebx
 805c0af:	c3                   	ret    

0805c0b0 <cmp_i2a_l>:
make_instr_helper(i2a)
 805c0b0:	53                   	push   %ebx
 805c0b1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c0b4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c0b8:	83 c0 01             	add    $0x1,%eax
 805c0bb:	50                   	push   %eax
 805c0bc:	e8 9f 0b 00 00       	call   805cc60 <decode_i2a_l>
 805c0c1:	89 c3                	mov    %eax,%ebx
	execute();
 805c0c3:	e8 68 fe ff ff       	call   805bf30 <do_cmp_l>
 805c0c8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c0cb:	8d 43 01             	lea    0x1(%ebx),%eax
 805c0ce:	5b                   	pop    %ebx
 805c0cf:	c3                   	ret    

0805c0d0 <cmp_r2rm_l>:
make_instr_helper(r2rm)
 805c0d0:	53                   	push   %ebx
 805c0d1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c0d4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c0d8:	83 c0 01             	add    $0x1,%eax
 805c0db:	50                   	push   %eax
 805c0dc:	e8 3f 0b 00 00       	call   805cc20 <decode_r2rm_l>
 805c0e1:	89 c3                	mov    %eax,%ebx
	execute();
 805c0e3:	e8 48 fe ff ff       	call   805bf30 <do_cmp_l>
 805c0e8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c0eb:	8d 43 01             	lea    0x1(%ebx),%eax
 805c0ee:	5b                   	pop    %ebx
 805c0ef:	c3                   	ret    

0805c0f0 <cmp_rm2r_l>:
make_instr_helper(rm2r)
 805c0f0:	53                   	push   %ebx
 805c0f1:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c0f4:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c0f8:	83 c0 01             	add    $0x1,%eax
 805c0fb:	50                   	push   %eax
 805c0fc:	e8 3f 0b 00 00       	call   805cc40 <decode_rm2r_l>
 805c101:	89 c3                	mov    %eax,%ebx
	execute();
 805c103:	e8 28 fe ff ff       	call   805bf30 <do_cmp_l>
 805c108:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c10b:	8d 43 01             	lea    0x1(%ebx),%eax
 805c10e:	5b                   	pop    %ebx
 805c10f:	c3                   	ret    

0805c110 <cmp_si2rm_l>:
#if DATA_BYTE == 2 || DATA_BYTE == 4
make_instr_helper(si2rm)
 805c110:	53                   	push   %ebx
 805c111:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c114:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c118:	83 c0 01             	add    $0x1,%eax
 805c11b:	50                   	push   %eax
 805c11c:	e8 3f 0c 00 00       	call   805cd60 <decode_si2rm_l>
 805c121:	89 c3                	mov    %eax,%ebx
	execute();
 805c123:	e8 08 fe ff ff       	call   805bf30 <do_cmp_l>
 805c128:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c12b:	8d 43 01             	lea    0x1(%ebx),%eax
 805c12e:	5b                   	pop    %ebx
 805c12f:	c3                   	ret    

0805c130 <cmp_i2rm_b>:
	cpu.SF = (res >> 31) & 1;
	cpu.OF = ((op_dest->val >> 31) ^ (op_src->val >> 31)) & ((op_dest->val >> 31) ^ (res >> 31)) & 1;
	print_asm_template2();
}

make_instr_helper(i2rm)
 805c130:	53                   	push   %ebx
 805c131:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c134:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c138:	83 c0 01             	add    $0x1,%eax
 805c13b:	50                   	push   %eax
 805c13c:	e8 9f 04 00 00       	call   805c5e0 <decode_i2rm_b>
 805c141:	89 c3                	mov    %eax,%ebx
	execute();
 805c143:	e8 88 fa ff ff       	call   805bbd0 <do_cmp_b>
 805c148:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c14b:	8d 43 01             	lea    0x1(%ebx),%eax
 805c14e:	5b                   	pop    %ebx
 805c14f:	c3                   	ret    

0805c150 <cmp_i2a_b>:
make_instr_helper(i2a)
 805c150:	53                   	push   %ebx
 805c151:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c154:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c158:	83 c0 01             	add    $0x1,%eax
 805c15b:	50                   	push   %eax
 805c15c:	e8 ff 03 00 00       	call   805c560 <decode_i2a_b>
 805c161:	89 c3                	mov    %eax,%ebx
	execute();
 805c163:	e8 68 fa ff ff       	call   805bbd0 <do_cmp_b>
 805c168:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c16b:	8d 43 01             	lea    0x1(%ebx),%eax
 805c16e:	5b                   	pop    %ebx
 805c16f:	c3                   	ret    

0805c170 <cmp_r2rm_b>:
make_instr_helper(r2rm)
 805c170:	53                   	push   %ebx
 805c171:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c174:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c178:	83 c0 01             	add    $0x1,%eax
 805c17b:	50                   	push   %eax
 805c17c:	e8 9f 03 00 00       	call   805c520 <decode_r2rm_b>
 805c181:	89 c3                	mov    %eax,%ebx
	execute();
 805c183:	e8 48 fa ff ff       	call   805bbd0 <do_cmp_b>
 805c188:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c18b:	8d 43 01             	lea    0x1(%ebx),%eax
 805c18e:	5b                   	pop    %ebx
 805c18f:	c3                   	ret    

0805c190 <cmp_rm2r_b>:
make_instr_helper(rm2r)
 805c190:	53                   	push   %ebx
 805c191:	83 ec 14             	sub    $0x14,%esp
}

/* Instruction Decode and EXecute */
static inline int idex(swaddr_t eip, int (*decode)(swaddr_t), void (*execute) (void)) {
	/* eip is pointing to the opcode */
	int len = decode(eip + 1);
 805c194:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805c198:	83 c0 01             	add    $0x1,%eax
 805c19b:	50                   	push   %eax
 805c19c:	e8 9f 03 00 00       	call   805c540 <decode_rm2r_b>
 805c1a1:	89 c3                	mov    %eax,%ebx
	execute();
 805c1a3:	e8 28 fa ff ff       	call   805bbd0 <do_cmp_b>
 805c1a8:	83 c4 18             	add    $0x18,%esp
	return len + 1;	// "1" for opcode
 805c1ab:	8d 43 01             	lea    0x1(%ebx),%eax
 805c1ae:	5b                   	pop    %ebx
 805c1af:	c3                   	ret    

0805c1b0 <cmp_si2rm_v>:
#include "cmp-template.h"
#undef DATA_BYTE

/* for instruction encoding overloading */

make_helper_v(cmp_si2rm)
 805c1b0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805c1b7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805c1bb:	b8 10 bf 05 08       	mov    $0x805bf10,%eax
 805c1c0:	75 05                	jne    805c1c7 <cmp_si2rm_v+0x17>
 805c1c2:	b8 10 c1 05 08       	mov    $0x805c110,%eax
 805c1c7:	89 54 24 04          	mov    %edx,0x4(%esp)
 805c1cb:	ff e0                	jmp    *%eax
 805c1cd:	8d 76 00             	lea    0x0(%esi),%esi

0805c1d0 <cmp_i2rm_v>:
make_helper_v(cmp_i2rm)
 805c1d0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805c1d7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805c1db:	b8 90 be 05 08       	mov    $0x805be90,%eax
 805c1e0:	75 05                	jne    805c1e7 <cmp_i2rm_v+0x17>
 805c1e2:	b8 90 c0 05 08       	mov    $0x805c090,%eax
 805c1e7:	89 54 24 04          	mov    %edx,0x4(%esp)
 805c1eb:	ff e0                	jmp    *%eax
 805c1ed:	8d 76 00             	lea    0x0(%esi),%esi

0805c1f0 <cmp_r2rm_v>:
make_helper_v(cmp_r2rm)
 805c1f0:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805c1f7:	8b 54 24 04          	mov    0x4(%esp),%edx
 805c1fb:	b8 d0 be 05 08       	mov    $0x805bed0,%eax
 805c200:	75 05                	jne    805c207 <cmp_r2rm_v+0x17>
 805c202:	b8 d0 c0 05 08       	mov    $0x805c0d0,%eax
 805c207:	89 54 24 04          	mov    %edx,0x4(%esp)
 805c20b:	ff e0                	jmp    *%eax
 805c20d:	8d 76 00             	lea    0x0(%esi),%esi

0805c210 <cmp_rm2r_v>:
make_helper_v(cmp_rm2r)
 805c210:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805c217:	8b 54 24 04          	mov    0x4(%esp),%edx
 805c21b:	b8 f0 be 05 08       	mov    $0x805bef0,%eax
 805c220:	75 05                	jne    805c227 <cmp_rm2r_v+0x17>
 805c222:	b8 f0 c0 05 08       	mov    $0x805c0f0,%eax
 805c227:	89 54 24 04          	mov    %edx,0x4(%esp)
 805c22b:	ff e0                	jmp    *%eax
 805c22d:	8d 76 00             	lea    0x0(%esi),%esi

0805c230 <cmp_i2a_v>:
make_helper_v(cmp_i2a)
 805c230:	80 3d 04 af 0f 10 00 	cmpb   $0x0,0x100faf04
 805c237:	8b 54 24 04          	mov    0x4(%esp),%edx
 805c23b:	b8 b0 be 05 08       	mov    $0x805beb0,%eax
 805c240:	75 05                	jne    805c247 <cmp_i2a_v+0x17>
 805c242:	b8 b0 c0 05 08       	mov    $0x805c0b0,%eax
 805c247:	89 54 24 04          	mov    %edx,0x4(%esp)
 805c24b:	ff e0                	jmp    *%eax
 805c24d:	66 90                	xchg   %ax,%ax
 805c24f:	90                   	nop

0805c250 <decode_rm_b_internal>:
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
#endif
	return 0;
}

static int concat3(decode_rm_, SUFFIX, _internal) (swaddr_t eip, Operand *rm, Operand *reg) {
 805c250:	56                   	push   %esi
 805c251:	53                   	push   %ebx
 805c252:	89 cb                	mov    %ecx,%ebx
 805c254:	83 ec 08             	sub    $0x8,%esp
	rm->size = DATA_BYTE;
 805c257:	c7 42 04 01 00 00 00 	movl   $0x1,0x4(%edx)
	int len = read_ModR_M(eip, rm, reg);
 805c25e:	51                   	push   %ecx
 805c25f:	52                   	push   %edx
 805c260:	50                   	push   %eax
 805c261:	e8 2a 0f 00 00       	call   805d190 <read_ModR_M>
	reg->val = REG(reg->reg);
 805c266:	8b 53 08             	mov    0x8(%ebx),%edx
 805c269:	83 c4 10             	add    $0x10,%esp
 805c26c:	83 fa 07             	cmp    $0x7,%edx
 805c26f:	77 36                	ja     805c2a7 <decode_rm_b_internal+0x57>
 805c271:	89 c6                	mov    %eax,%esi
 805c273:	89 d1                	mov    %edx,%ecx
 805c275:	89 d0                	mov    %edx,%eax
 805c277:	83 e1 03             	and    $0x3,%ecx
 805c27a:	c1 e8 02             	shr    $0x2,%eax

#ifdef DEBUG
	snprintf(reg->str, OP_STR_SIZE, "%%%s", REG_NAME(reg->reg));
 805c27d:	83 c3 10             	add    $0x10,%ebx
}

static int concat3(decode_rm_, SUFFIX, _internal) (swaddr_t eip, Operand *rm, Operand *reg) {
	rm->size = DATA_BYTE;
	int len = read_ModR_M(eip, rm, reg);
	reg->val = REG(reg->reg);
 805c280:	0f b6 84 88 c0 af 0f 	movzbl 0x100fafc0(%eax,%ecx,4),%eax
 805c287:	10 
 805c288:	89 43 fc             	mov    %eax,-0x4(%ebx)

#ifdef DEBUG
	snprintf(reg->str, OP_STR_SIZE, "%%%s", REG_NAME(reg->reg));
 805c28b:	ff 34 95 80 5c 07 08 	pushl  0x8075c80(,%edx,4)
 805c292:	68 3a 29 06 08       	push   $0x806293a
 805c297:	6a 28                	push   $0x28
 805c299:	53                   	push   %ebx
 805c29a:	e8 61 c8 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return len;
}
 805c29f:	83 c4 14             	add    $0x14,%esp
 805c2a2:	89 f0                	mov    %esi,%eax
 805c2a4:	5b                   	pop    %ebx
 805c2a5:	5e                   	pop    %esi
 805c2a6:	c3                   	ret    
 805c2a7:	e8 5f c9 fe ff       	call   8048c0b <check_reg_index.part.0>
 805c2ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805c2b0 <decode_rm_w_internal>:
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
#endif
	return 0;
}

static int concat3(decode_rm_, SUFFIX, _internal) (swaddr_t eip, Operand *rm, Operand *reg) {
 805c2b0:	56                   	push   %esi
 805c2b1:	53                   	push   %ebx
 805c2b2:	89 cb                	mov    %ecx,%ebx
 805c2b4:	83 ec 08             	sub    $0x8,%esp
	rm->size = DATA_BYTE;
 805c2b7:	c7 42 04 02 00 00 00 	movl   $0x2,0x4(%edx)
	int len = read_ModR_M(eip, rm, reg);
 805c2be:	51                   	push   %ecx
 805c2bf:	52                   	push   %edx
 805c2c0:	50                   	push   %eax
 805c2c1:	e8 ca 0e 00 00       	call   805d190 <read_ModR_M>
	reg->val = REG(reg->reg);
 805c2c6:	8b 53 08             	mov    0x8(%ebx),%edx
 805c2c9:	83 c4 10             	add    $0x10,%esp
 805c2cc:	83 fa 07             	cmp    $0x7,%edx
 805c2cf:	77 2c                	ja     805c2fd <decode_rm_w_internal+0x4d>
 805c2d1:	89 c6                	mov    %eax,%esi
 805c2d3:	0f b7 04 95 c0 af 0f 	movzwl 0x100fafc0(,%edx,4),%eax
 805c2da:	10 

#ifdef DEBUG
	snprintf(reg->str, OP_STR_SIZE, "%%%s", REG_NAME(reg->reg));
 805c2db:	83 c3 10             	add    $0x10,%ebx
}

static int concat3(decode_rm_, SUFFIX, _internal) (swaddr_t eip, Operand *rm, Operand *reg) {
	rm->size = DATA_BYTE;
	int len = read_ModR_M(eip, rm, reg);
	reg->val = REG(reg->reg);
 805c2de:	89 43 fc             	mov    %eax,-0x4(%ebx)

#ifdef DEBUG
	snprintf(reg->str, OP_STR_SIZE, "%%%s", REG_NAME(reg->reg));
 805c2e1:	ff 34 95 a0 5c 07 08 	pushl  0x8075ca0(,%edx,4)
 805c2e8:	68 3a 29 06 08       	push   $0x806293a
 805c2ed:	6a 28                	push   $0x28
 805c2ef:	53                   	push   %ebx
 805c2f0:	e8 0b c8 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return len;
}
 805c2f5:	83 c4 14             	add    $0x14,%esp
 805c2f8:	89 f0                	mov    %esi,%eax
 805c2fa:	5b                   	pop    %ebx
 805c2fb:	5e                   	pop    %esi
 805c2fc:	c3                   	ret    
 805c2fd:	e8 09 c9 fe ff       	call   8048c0b <check_reg_index.part.0>
 805c302:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805c309:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c310 <decode_rm_l_internal>:
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
#endif
	return 0;
}

static int concat3(decode_rm_, SUFFIX, _internal) (swaddr_t eip, Operand *rm, Operand *reg) {
 805c310:	56                   	push   %esi
 805c311:	53                   	push   %ebx
 805c312:	89 cb                	mov    %ecx,%ebx
 805c314:	83 ec 08             	sub    $0x8,%esp
	rm->size = DATA_BYTE;
 805c317:	c7 42 04 04 00 00 00 	movl   $0x4,0x4(%edx)
	int len = read_ModR_M(eip, rm, reg);
 805c31e:	51                   	push   %ecx
 805c31f:	52                   	push   %edx
 805c320:	50                   	push   %eax
 805c321:	e8 6a 0e 00 00       	call   805d190 <read_ModR_M>
	reg->val = REG(reg->reg);
 805c326:	8b 53 08             	mov    0x8(%ebx),%edx
 805c329:	83 c4 10             	add    $0x10,%esp
 805c32c:	83 fa 07             	cmp    $0x7,%edx
 805c32f:	77 2b                	ja     805c35c <decode_rm_l_internal+0x4c>
 805c331:	89 c6                	mov    %eax,%esi
 805c333:	8b 04 95 c0 af 0f 10 	mov    0x100fafc0(,%edx,4),%eax

#ifdef DEBUG
	snprintf(reg->str, OP_STR_SIZE, "%%%s", REG_NAME(reg->reg));
 805c33a:	83 c3 10             	add    $0x10,%ebx
}

static int concat3(decode_rm_, SUFFIX, _internal) (swaddr_t eip, Operand *rm, Operand *reg) {
	rm->size = DATA_BYTE;
	int len = read_ModR_M(eip, rm, reg);
	reg->val = REG(reg->reg);
 805c33d:	89 43 fc             	mov    %eax,-0x4(%ebx)

#ifdef DEBUG
	snprintf(reg->str, OP_STR_SIZE, "%%%s", REG_NAME(reg->reg));
 805c340:	ff 34 95 c0 5c 07 08 	pushl  0x8075cc0(,%edx,4)
 805c347:	68 3a 29 06 08       	push   $0x806293a
 805c34c:	6a 28                	push   $0x28
 805c34e:	53                   	push   %ebx
 805c34f:	e8 ac c7 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return len;
}
 805c354:	83 c4 14             	add    $0x14,%esp
 805c357:	89 f0                	mov    %esi,%eax
 805c359:	5b                   	pop    %ebx
 805c35a:	5e                   	pop    %esi
 805c35b:	c3                   	ret    
 805c35c:	e8 aa c8 fe ff       	call   8048c0b <check_reg_index.part.0>
 805c361:	eb 0d                	jmp    805c370 <decode_r_b_internal.isra.2>
 805c363:	90                   	nop
 805c364:	90                   	nop
 805c365:	90                   	nop
 805c366:	90                   	nop
 805c367:	90                   	nop
 805c368:	90                   	nop
 805c369:	90                   	nop
 805c36a:	90                   	nop
 805c36b:	90                   	nop
 805c36c:	90                   	nop
 805c36d:	90                   	nop
 805c36e:	90                   	nop
 805c36f:	90                   	nop

0805c370 <decode_r_b_internal.isra.2>:
#endif
	return 0;
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
 805c370:	53                   	push   %ebx
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
	op->val = REG(op->reg);

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
 805c371:	83 c0 10             	add    $0x10,%eax
#endif
	return 0;
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
 805c374:	83 ec 08             	sub    $0x8,%esp
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
 805c377:	8b 15 00 af 0f 10    	mov    0x100faf00,%edx
	return 0;
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
 805c37d:	c7 40 f0 00 00 00 00 	movl   $0x0,-0x10(%eax)
	op->reg = ops_decoded.opcode & 0x7;
 805c384:	89 d1                	mov    %edx,%ecx
	op->val = REG(op->reg);
 805c386:	83 e2 03             	and    $0x3,%edx
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
 805c389:	83 e1 07             	and    $0x7,%ecx
	op->val = REG(op->reg);
 805c38c:	89 cb                	mov    %ecx,%ebx
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
 805c38e:	89 48 f8             	mov    %ecx,-0x8(%eax)
	op->val = REG(op->reg);
 805c391:	c1 eb 02             	shr    $0x2,%ebx
 805c394:	0f b6 94 93 c0 af 0f 	movzbl 0x100fafc0(%ebx,%edx,4),%edx
 805c39b:	10 
 805c39c:	89 50 fc             	mov    %edx,-0x4(%eax)

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
 805c39f:	ff 34 8d 80 5c 07 08 	pushl  0x8075c80(,%ecx,4)
 805c3a6:	68 3a 29 06 08       	push   $0x806293a
 805c3ab:	6a 28                	push   $0x28
 805c3ad:	50                   	push   %eax
 805c3ae:	e8 4d c7 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return 0;
}
 805c3b3:	83 c4 18             	add    $0x18,%esp
 805c3b6:	31 c0                	xor    %eax,%eax
 805c3b8:	5b                   	pop    %ebx
 805c3b9:	c3                   	ret    
 805c3ba:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0805c3c0 <decode_r_w_internal.isra.4>:
#endif
	return 0;
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
 805c3c0:	83 ec 0c             	sub    $0xc,%esp
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
 805c3c3:	8b 15 00 af 0f 10    	mov    0x100faf00,%edx
	return 0;
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
 805c3c9:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	op->reg = ops_decoded.opcode & 0x7;
	op->val = REG(op->reg);

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
 805c3cf:	83 c0 10             	add    $0x10,%eax
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
 805c3d2:	83 e2 07             	and    $0x7,%edx
 805c3d5:	89 50 f8             	mov    %edx,-0x8(%eax)
	op->val = REG(op->reg);
 805c3d8:	0f b7 0c 95 c0 af 0f 	movzwl 0x100fafc0(,%edx,4),%ecx
 805c3df:	10 
 805c3e0:	89 48 fc             	mov    %ecx,-0x4(%eax)

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
 805c3e3:	ff 34 95 a0 5c 07 08 	pushl  0x8075ca0(,%edx,4)
 805c3ea:	68 3a 29 06 08       	push   $0x806293a
 805c3ef:	6a 28                	push   $0x28
 805c3f1:	50                   	push   %eax
 805c3f2:	e8 09 c7 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return 0;
}
 805c3f7:	31 c0                	xor    %eax,%eax
 805c3f9:	83 c4 1c             	add    $0x1c,%esp
 805c3fc:	c3                   	ret    
 805c3fd:	8d 76 00             	lea    0x0(%esi),%esi

0805c400 <decode_r_l_internal.isra.6>:
#endif
	return 0;
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
 805c400:	83 ec 0c             	sub    $0xc,%esp
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
 805c403:	8b 15 00 af 0f 10    	mov    0x100faf00,%edx
	return 0;
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
 805c409:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
	op->reg = ops_decoded.opcode & 0x7;
	op->val = REG(op->reg);

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
 805c40f:	83 c0 10             	add    $0x10,%eax
}

/* eXX: eAX, eCX, eDX, eBX, eSP, eBP, eSI, eDI */
static int concat3(decode_r_, SUFFIX, _internal) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = ops_decoded.opcode & 0x7;
 805c412:	83 e2 07             	and    $0x7,%edx
 805c415:	89 50 f8             	mov    %edx,-0x8(%eax)
	op->val = REG(op->reg);
 805c418:	8b 0c 95 c0 af 0f 10 	mov    0x100fafc0(,%edx,4),%ecx
 805c41f:	89 48 fc             	mov    %ecx,-0x4(%eax)

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(op->reg));
 805c422:	ff 34 95 c0 5c 07 08 	pushl  0x8075cc0(,%edx,4)
 805c429:	68 3a 29 06 08       	push   $0x806293a
 805c42e:	6a 28                	push   $0x28
 805c430:	50                   	push   %eax
 805c431:	e8 ca c6 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return 0;
}
 805c436:	31 c0                	xor    %eax,%eax
 805c438:	83 c4 1c             	add    $0x1c,%esp
 805c43b:	c3                   	ret    
 805c43c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805c440 <decode_i_b>:
#define decode_m_internal concat3(decode_m_, SUFFIX, _internal)
#define decode_a concat(decode_a_, SUFFIX)
#define decode_r2rm concat(decode_r2rm_, SUFFIX)

/* Ib, Iv */
make_helper(concat(decode_i_, SUFFIX)) {
 805c440:	83 ec 14             	sub    $0x14,%esp
	/* eip here is pointing to the immediate */
	op_src->type = OP_TYPE_IMM;
 805c443:	c7 05 08 af 0f 10 02 	movl   $0x2,0x100faf08
 805c44a:	00 00 00 

/* All function defined with 'make_helper' return the length of the operation. */
#define make_helper(name) int name(swaddr_t eip)

static inline uint32_t instr_fetch(swaddr_t addr, size_t len) {
	return swaddr_read(addr, len);
 805c44d:	6a 01                	push   $0x1
 805c44f:	ff 74 24 1c          	pushl  0x1c(%esp)
 805c453:	e8 f8 ea fe ff       	call   804af50 <swaddr_read>
	op_src->imm = instr_fetch(eip, DATA_BYTE);
	op_src->val = op_src->imm;

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->imm);
 805c458:	50                   	push   %eax
 805c459:	68 ce 59 06 08       	push   $0x80659ce
 805c45e:	6a 28                	push   $0x28
 805c460:	68 18 af 0f 10       	push   $0x100faf18

/* Ib, Iv */
make_helper(concat(decode_i_, SUFFIX)) {
	/* eip here is pointing to the immediate */
	op_src->type = OP_TYPE_IMM;
	op_src->imm = instr_fetch(eip, DATA_BYTE);
 805c465:	a3 10 af 0f 10       	mov    %eax,0x100faf10
	op_src->val = op_src->imm;
 805c46a:	a3 14 af 0f 10       	mov    %eax,0x100faf14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->imm);
 805c46f:	e8 8c c6 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805c474:	b8 01 00 00 00       	mov    $0x1,%eax
 805c479:	83 c4 2c             	add    $0x2c,%esp
 805c47c:	c3                   	ret    
 805c47d:	8d 76 00             	lea    0x0(%esi),%esi

0805c480 <decode_si_b>:

#if DATA_BYTE == 1 || DATA_BYTE == 4
/* sign immediate */
make_helper(concat(decode_si_, SUFFIX)) {
 805c480:	83 ec 14             	sub    $0x14,%esp
	op_src->type = OP_TYPE_IMM;
 805c483:	c7 05 08 af 0f 10 02 	movl   $0x2,0x100faf08
 805c48a:	00 00 00 
 805c48d:	6a 01                	push   $0x1
 805c48f:	ff 74 24 1c          	pushl  0x1c(%esp)
 805c493:	e8 b8 ea fe ff       	call   804af50 <swaddr_read>
	 * by ``eip''. Interpret the result as an signed immediate, and assign
	 * it to op_src->simm.
	 */
	op_src->simm = instr_fetch(eip, DATA_BYTE);
#if DATA_BYTE == 1
	op_src->simm = op_src->simm << 24 >> 24;
 805c498:	0f be c0             	movsbl %al,%eax
//	panic("please implement me");

	op_src->val = op_src->simm;

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->val);
 805c49b:	50                   	push   %eax
 805c49c:	68 ce 59 06 08       	push   $0x80659ce
 805c4a1:	6a 28                	push   $0x28
 805c4a3:	68 18 af 0f 10       	push   $0x100faf18
	 * by ``eip''. Interpret the result as an signed immediate, and assign
	 * it to op_src->simm.
	 */
	op_src->simm = instr_fetch(eip, DATA_BYTE);
#if DATA_BYTE == 1
	op_src->simm = op_src->simm << 24 >> 24;
 805c4a8:	a3 10 af 0f 10       	mov    %eax,0x100faf10
#endif
//	panic("please implement me");

	op_src->val = op_src->simm;
 805c4ad:	a3 14 af 0f 10       	mov    %eax,0x100faf14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->val);
 805c4b2:	e8 49 c6 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805c4b7:	b8 01 00 00 00       	mov    $0x1,%eax
 805c4bc:	83 c4 2c             	add    $0x2c,%esp
 805c4bf:	c3                   	ret    

0805c4c0 <decode_m_b_internal>:
#endif
	return len;
}

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
 805c4c0:	83 ec 14             	sub    $0x14,%esp
	op_src->type = OP_TYPE_MEM;
 805c4c3:	c7 05 08 af 0f 10 01 	movl   $0x1,0x100faf08
 805c4ca:	00 00 00 
 805c4cd:	6a 01                	push   $0x1
 805c4cf:	ff 74 24 1c          	pushl  0x1c(%esp)
 805c4d3:	e8 78 ea fe ff       	call   804af50 <swaddr_read>
	op_src->addr = instr_fetch(eip, DATA_BYTE);
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805c4d8:	5a                   	pop    %edx
 805c4d9:	59                   	pop    %ecx
 805c4da:	6a 01                	push   $0x1
 805c4dc:	50                   	push   %eax
}

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
	op_src->type = OP_TYPE_MEM;
	op_src->addr = instr_fetch(eip, DATA_BYTE);
 805c4dd:	a3 10 af 0f 10       	mov    %eax,0x100faf10
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805c4e2:	e8 e9 e9 fe ff       	call   804aed0 <hwaddr_read>

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->addr);
 805c4e7:	ff 35 10 af 0f 10    	pushl  0x100faf10
 805c4ed:	68 ce 59 06 08       	push   $0x80659ce
 805c4f2:	6a 28                	push   $0x28
 805c4f4:	68 18 af 0f 10       	push   $0x100faf18

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
	op_src->type = OP_TYPE_MEM;
	op_src->addr = instr_fetch(eip, DATA_BYTE);
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805c4f9:	a3 14 af 0f 10       	mov    %eax,0x100faf14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->addr);
 805c4fe:	e8 fd c5 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805c503:	b8 01 00 00 00       	mov    $0x1,%eax
 805c508:	83 c4 2c             	add    $0x2c,%esp
 805c50b:	c3                   	ret    
 805c50c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805c510 <decode_m_b>:

/* Mb, Mv */
make_helper(concat(decode_m_, SUFFIX)) {
	return decode_m_internal(eip);
 805c510:	e9 ab ff ff ff       	jmp    805c4c0 <decode_m_b_internal>
 805c515:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805c519:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c520 <decode_r2rm_b>:

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805c520:	8b 44 24 04          	mov    0x4(%esp),%eax
 805c524:	b9 08 af 0f 10       	mov    $0x100faf08,%ecx
 805c529:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
 805c52e:	e9 1d fd ff ff       	jmp    805c250 <decode_rm_b_internal>
 805c533:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805c539:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c540 <decode_rm2r_b>:

/* Gb <- Eb
 * Gv <- Ev
 */
make_helper(concat(decode_rm2r_, SUFFIX)) {
	return decode_rm_internal(eip, op_src, op_dest);
 805c540:	8b 44 24 04          	mov    0x4(%esp),%eax
 805c544:	b9 40 af 0f 10       	mov    $0x100faf40,%ecx
 805c549:	ba 08 af 0f 10       	mov    $0x100faf08,%edx
 805c54e:	e9 fd fc ff ff       	jmp    805c250 <decode_rm_b_internal>
 805c553:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805c559:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c560 <decode_i2a_b>:


/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
 805c560:	53                   	push   %ebx
 805c561:	83 ec 08             	sub    $0x8,%esp

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
	op->val = REG(R_EAX);
 805c564:	0f b6 05 c0 af 0f 10 	movzbl 0x100fafc0,%eax
}
#endif

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
 805c56b:	c7 05 40 af 0f 10 00 	movl   $0x0,0x100faf40
 805c572:	00 00 00 


/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
 805c575:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
	op->val = REG(R_EAX);

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(R_EAX));
 805c579:	ff 35 80 5c 07 08    	pushl  0x8075c80
 805c57f:	68 3a 29 06 08       	push   $0x806293a
 805c584:	6a 28                	push   $0x28
 805c586:	68 50 af 0f 10       	push   $0x100faf50
#endif

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
 805c58b:	c7 05 48 af 0f 10 00 	movl   $0x0,0x100faf48
 805c592:	00 00 00 
	op->val = REG(R_EAX);
 805c595:	a3 4c af 0f 10       	mov    %eax,0x100faf4c

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(R_EAX));
 805c59a:	e8 61 c5 fe ff       	call   8048b00 <snprintf@plt>
/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
	decode_a(eip, op_dest);
	return decode_i(eip);
 805c59f:	89 5c 24 20          	mov    %ebx,0x20(%esp)
}
 805c5a3:	83 c4 18             	add    $0x18,%esp
 805c5a6:	5b                   	pop    %ebx
/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
	decode_a(eip, op_dest);
	return decode_i(eip);
 805c5a7:	e9 94 fe ff ff       	jmp    805c440 <decode_i_b>
 805c5ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805c5b0 <decode_i_rm2r_b>:
}

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
 805c5b0:	56                   	push   %esi
 805c5b1:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805c5b2:	b9 40 af 0f 10       	mov    $0x100faf40,%ecx
 805c5b7:	ba 78 af 0f 10       	mov    $0x100faf78,%edx
}

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
 805c5bc:	83 ec 04             	sub    $0x4,%esp
 805c5bf:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805c5c3:	89 f0                	mov    %esi,%eax
 805c5c5:	e8 86 fc ff ff       	call   805c250 <decode_rm_b_internal>
	len += decode_i(eip + len);
 805c5ca:	83 ec 0c             	sub    $0xc,%esp
 805c5cd:	01 c6                	add    %eax,%esi

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805c5cf:	89 c3                	mov    %eax,%ebx
	len += decode_i(eip + len);
 805c5d1:	56                   	push   %esi
 805c5d2:	e8 69 fe ff ff       	call   805c440 <decode_i_b>
	return len;
}
 805c5d7:	83 c4 14             	add    $0x14,%esp
/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
	len += decode_i(eip + len);
 805c5da:	01 d8                	add    %ebx,%eax
	return len;
}
 805c5dc:	5b                   	pop    %ebx
 805c5dd:	5e                   	pop    %esi
 805c5de:	c3                   	ret    
 805c5df:	90                   	nop

0805c5e0 <decode_i2rm_b>:

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
 805c5e0:	56                   	push   %esi
 805c5e1:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805c5e2:	b9 78 af 0f 10       	mov    $0x100faf78,%ecx
 805c5e7:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
}

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
 805c5ec:	83 ec 04             	sub    $0x4,%esp
 805c5ef:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805c5f3:	89 f0                	mov    %esi,%eax
 805c5f5:	e8 56 fc ff ff       	call   805c250 <decode_rm_b_internal>
	len += decode_i(eip + len);
 805c5fa:	83 ec 0c             	sub    $0xc,%esp
 805c5fd:	01 c6                	add    %eax,%esi

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805c5ff:	89 c3                	mov    %eax,%ebx
	len += decode_i(eip + len);
 805c601:	56                   	push   %esi
 805c602:	e8 39 fe ff ff       	call   805c440 <decode_i_b>
	return len;
}
 805c607:	83 c4 14             	add    $0x14,%esp
/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
	len += decode_i(eip + len);
 805c60a:	01 d8                	add    %ebx,%eax
	return len;
}
 805c60c:	5b                   	pop    %ebx
 805c60d:	5e                   	pop    %esi
 805c60e:	c3                   	ret    
 805c60f:	90                   	nop

0805c610 <decode_i2r_b>:

/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
 805c610:	53                   	push   %ebx
	decode_r_internal(eip, op_dest);
 805c611:	b8 40 af 0f 10       	mov    $0x100faf40,%eax
}

/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
 805c616:	83 ec 08             	sub    $0x8,%esp
 805c619:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	decode_r_internal(eip, op_dest);
 805c61d:	e8 4e fd ff ff       	call   805c370 <decode_r_b_internal.isra.2>
	return decode_i(eip);
 805c622:	89 5c 24 10          	mov    %ebx,0x10(%esp)
}
 805c626:	83 c4 08             	add    $0x8,%esp
 805c629:	5b                   	pop    %ebx
/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
	decode_r_internal(eip, op_dest);
	return decode_i(eip);
 805c62a:	e9 11 fe ff ff       	jmp    805c440 <decode_i_b>
 805c62f:	90                   	nop

0805c630 <decode_rm_b>:
}

/* used by unary operations */
make_helper(concat(decode_rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_src, op_src2);		/* op_src2 not use here */
 805c630:	8b 44 24 04          	mov    0x4(%esp),%eax
 805c634:	b9 78 af 0f 10       	mov    $0x100faf78,%ecx
 805c639:	ba 08 af 0f 10       	mov    $0x100faf08,%edx
 805c63e:	e9 0d fc ff ff       	jmp    805c250 <decode_rm_b_internal>
 805c643:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805c649:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c650 <decode_r_b>:
}

make_helper(concat(decode_r_, SUFFIX)) {
	return decode_r_internal(eip, op_src);
 805c650:	b8 08 af 0f 10       	mov    $0x100faf08,%eax
 805c655:	e9 16 fd ff ff       	jmp    805c370 <decode_r_b_internal.isra.2>
 805c65a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0805c660 <decode_rm_1_b>:
	return len;
}
#endif

/* used by shift instructions */
make_helper(concat(decode_rm_1_, SUFFIX)) {
 805c660:	83 ec 0c             	sub    $0xc,%esp

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805c663:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
 805c668:	b9 08 af 0f 10       	mov    $0x100faf08,%ecx
 805c66d:	8b 44 24 10          	mov    0x10(%esp),%eax
 805c671:	e8 da fb ff ff       	call   805c250 <decode_rm_b_internal>
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_IMM;
	op_src->imm = 1;
	op_src->val = 1;
#ifdef DEBUG
	sprintf(op_src->str, "$1");
 805c676:	ba 24 31 00 00       	mov    $0x3124,%edx
#endif

/* used by shift instructions */
make_helper(concat(decode_rm_1_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_IMM;
 805c67b:	c7 05 08 af 0f 10 02 	movl   $0x2,0x100faf08
 805c682:	00 00 00 
	op_src->imm = 1;
 805c685:	c7 05 10 af 0f 10 01 	movl   $0x1,0x100faf10
 805c68c:	00 00 00 
	op_src->val = 1;
 805c68f:	c7 05 14 af 0f 10 01 	movl   $0x1,0x100faf14
 805c696:	00 00 00 
#ifdef DEBUG
	sprintf(op_src->str, "$1");
 805c699:	66 89 15 18 af 0f 10 	mov    %dx,0x100faf18
 805c6a0:	c6 05 1a af 0f 10 00 	movb   $0x0,0x100faf1a
#endif
	return len;
}
 805c6a7:	83 c4 0c             	add    $0xc,%esp
 805c6aa:	c3                   	ret    
 805c6ab:	90                   	nop
 805c6ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805c6b0 <decode_rm_cl_b>:

make_helper(concat(decode_rm_cl_, SUFFIX)) {
 805c6b0:	53                   	push   %ebx

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805c6b1:	b9 08 af 0f 10       	mov    $0x100faf08,%ecx
 805c6b6:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
	sprintf(op_src->str, "$1");
#endif
	return len;
}

make_helper(concat(decode_rm_cl_, SUFFIX)) {
 805c6bb:	83 ec 08             	sub    $0x8,%esp

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805c6be:	8b 44 24 10          	mov    0x10(%esp),%eax
 805c6c2:	e8 89 fb ff ff       	call   805c250 <decode_rm_b_internal>
 805c6c7:	89 c3                	mov    %eax,%ebx

make_helper(concat(decode_rm_cl_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_REG;
	op_src->reg = R_CL;
	op_src->val = reg_b(R_CL);
 805c6c9:	0f b6 05 c4 af 0f 10 	movzbl 0x100fafc4,%eax
#ifdef DEBUG
	sprintf(op_src->str, "%%cl");
 805c6d0:	83 ec 08             	sub    $0x8,%esp
 805c6d3:	68 d4 59 06 08       	push   $0x80659d4
 805c6d8:	68 18 af 0f 10       	push   $0x100faf18
	return len;
}

make_helper(concat(decode_rm_cl_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_REG;
 805c6dd:	c7 05 08 af 0f 10 00 	movl   $0x0,0x100faf08
 805c6e4:	00 00 00 
	op_src->reg = R_CL;
 805c6e7:	c7 05 10 af 0f 10 01 	movl   $0x1,0x100faf10
 805c6ee:	00 00 00 
	op_src->val = reg_b(R_CL);
 805c6f1:	a3 14 af 0f 10       	mov    %eax,0x100faf14
#ifdef DEBUG
	sprintf(op_src->str, "%%cl");
 805c6f6:	e8 95 c4 fe ff       	call   8048b90 <sprintf@plt>
#endif
	return len;
}
 805c6fb:	83 c4 18             	add    $0x18,%esp
 805c6fe:	89 d8                	mov    %ebx,%eax
 805c700:	5b                   	pop    %ebx
 805c701:	c3                   	ret    
 805c702:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805c709:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c710 <decode_rm_imm_b>:

make_helper(concat(decode_rm_imm_, SUFFIX)) {
 805c710:	56                   	push   %esi
 805c711:	53                   	push   %ebx

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805c712:	b9 08 af 0f 10       	mov    $0x100faf08,%ecx
 805c717:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
	sprintf(op_src->str, "%%cl");
#endif
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
 805c71c:	83 ec 04             	sub    $0x4,%esp
 805c71f:	8b 74 24 10          	mov    0x10(%esp),%esi

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805c723:	89 f0                	mov    %esi,%eax
 805c725:	e8 26 fb ff ff       	call   805c250 <decode_rm_b_internal>
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805c72a:	83 ec 0c             	sub    $0xc,%esp
 805c72d:	01 c6                	add    %eax,%esi

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805c72f:	89 c3                	mov    %eax,%ebx
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805c731:	56                   	push   %esi
 805c732:	e8 09 fd ff ff       	call   805c440 <decode_i_b>
	return len;
}
 805c737:	83 c4 14             	add    $0x14,%esp
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805c73a:	01 d8                	add    %ebx,%eax
	return len;
}
 805c73c:	5b                   	pop    %ebx
 805c73d:	5e                   	pop    %esi
 805c73e:	c3                   	ret    
 805c73f:	90                   	nop

0805c740 <write_operand_b>:

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
 805c740:	83 ec 0c             	sub    $0xc,%esp
 805c743:	8b 44 24 10          	mov    0x10(%esp),%eax
 805c747:	8b 54 24 14          	mov    0x14(%esp),%edx
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
 805c74b:	8b 08                	mov    (%eax),%ecx
 805c74d:	85 c9                	test   %ecx,%ecx
 805c74f:	75 1f                	jne    805c770 <write_operand_b+0x30>
 805c751:	8b 40 08             	mov    0x8(%eax),%eax
 805c754:	83 f8 07             	cmp    $0x7,%eax
 805c757:	77 35                	ja     805c78e <write_operand_b+0x4e>
 805c759:	89 c1                	mov    %eax,%ecx
 805c75b:	c1 e8 02             	shr    $0x2,%eax
 805c75e:	83 e1 03             	and    $0x3,%ecx
 805c761:	88 94 88 c0 af 0f 10 	mov    %dl,0x100fafc0(%eax,%ecx,4)
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
	else { assert(0); }
}
 805c768:	83 c4 0c             	add    $0xc,%esp
 805c76b:	c3                   	ret    
 805c76c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return len;
}

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
 805c770:	83 f9 01             	cmp    $0x1,%ecx
 805c773:	75 1e                	jne    805c793 <write_operand_b+0x53>
 805c775:	83 ec 04             	sub    $0x4,%esp
 805c778:	0f b6 d2             	movzbl %dl,%edx
 805c77b:	52                   	push   %edx
 805c77c:	ff 70 04             	pushl  0x4(%eax)
 805c77f:	ff 70 08             	pushl  0x8(%eax)
 805c782:	e8 19 e8 fe ff       	call   804afa0 <swaddr_write>
 805c787:	83 c4 10             	add    $0x10,%esp
	else { assert(0); }
}
 805c78a:	83 c4 0c             	add    $0xc,%esp
 805c78d:	c3                   	ret    
 805c78e:	e8 78 c4 fe ff       	call   8048c0b <check_reg_index.part.0>
}

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
	else { assert(0); }
 805c793:	68 22 5a 06 08       	push   $0x8065a22
 805c798:	68 cd 00 00 00       	push   $0xcd
 805c79d:	68 dc 59 06 08       	push   $0x80659dc
 805c7a2:	68 1c ea 05 08       	push   $0x805ea1c
 805c7a7:	e8 04 c4 fe ff       	call   8048bb0 <__assert_fail@plt>
 805c7ac:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805c7b0 <decode_i_w>:
#define decode_m_internal concat3(decode_m_, SUFFIX, _internal)
#define decode_a concat(decode_a_, SUFFIX)
#define decode_r2rm concat(decode_r2rm_, SUFFIX)

/* Ib, Iv */
make_helper(concat(decode_i_, SUFFIX)) {
 805c7b0:	83 ec 14             	sub    $0x14,%esp
	/* eip here is pointing to the immediate */
	op_src->type = OP_TYPE_IMM;
 805c7b3:	c7 05 08 af 0f 10 02 	movl   $0x2,0x100faf08
 805c7ba:	00 00 00 
 805c7bd:	6a 02                	push   $0x2
 805c7bf:	ff 74 24 1c          	pushl  0x1c(%esp)
 805c7c3:	e8 88 e7 fe ff       	call   804af50 <swaddr_read>
	op_src->imm = instr_fetch(eip, DATA_BYTE);
	op_src->val = op_src->imm;

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->imm);
 805c7c8:	50                   	push   %eax
 805c7c9:	68 ce 59 06 08       	push   $0x80659ce
 805c7ce:	6a 28                	push   $0x28
 805c7d0:	68 18 af 0f 10       	push   $0x100faf18

/* Ib, Iv */
make_helper(concat(decode_i_, SUFFIX)) {
	/* eip here is pointing to the immediate */
	op_src->type = OP_TYPE_IMM;
	op_src->imm = instr_fetch(eip, DATA_BYTE);
 805c7d5:	a3 10 af 0f 10       	mov    %eax,0x100faf10
	op_src->val = op_src->imm;
 805c7da:	a3 14 af 0f 10       	mov    %eax,0x100faf14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->imm);
 805c7df:	e8 1c c3 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805c7e4:	b8 02 00 00 00       	mov    $0x2,%eax
 805c7e9:	83 c4 2c             	add    $0x2c,%esp
 805c7ec:	c3                   	ret    
 805c7ed:	8d 76 00             	lea    0x0(%esi),%esi

0805c7f0 <decode_m_w_internal>:
#endif
	return len;
}

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
 805c7f0:	83 ec 14             	sub    $0x14,%esp
	op_src->type = OP_TYPE_MEM;
 805c7f3:	c7 05 08 af 0f 10 01 	movl   $0x1,0x100faf08
 805c7fa:	00 00 00 
 805c7fd:	6a 02                	push   $0x2
 805c7ff:	ff 74 24 1c          	pushl  0x1c(%esp)
 805c803:	e8 48 e7 fe ff       	call   804af50 <swaddr_read>
	op_src->addr = instr_fetch(eip, DATA_BYTE);
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805c808:	5a                   	pop    %edx
 805c809:	59                   	pop    %ecx
 805c80a:	6a 02                	push   $0x2
 805c80c:	50                   	push   %eax
}

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
	op_src->type = OP_TYPE_MEM;
	op_src->addr = instr_fetch(eip, DATA_BYTE);
 805c80d:	a3 10 af 0f 10       	mov    %eax,0x100faf10
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805c812:	e8 b9 e6 fe ff       	call   804aed0 <hwaddr_read>

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->addr);
 805c817:	ff 35 10 af 0f 10    	pushl  0x100faf10
 805c81d:	68 ce 59 06 08       	push   $0x80659ce
 805c822:	6a 28                	push   $0x28
 805c824:	68 18 af 0f 10       	push   $0x100faf18

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
	op_src->type = OP_TYPE_MEM;
	op_src->addr = instr_fetch(eip, DATA_BYTE);
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805c829:	a3 14 af 0f 10       	mov    %eax,0x100faf14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->addr);
 805c82e:	e8 cd c2 fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805c833:	b8 02 00 00 00       	mov    $0x2,%eax
 805c838:	83 c4 2c             	add    $0x2c,%esp
 805c83b:	c3                   	ret    
 805c83c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805c840 <decode_m_w>:

/* Mb, Mv */
make_helper(concat(decode_m_, SUFFIX)) {
	return decode_m_internal(eip);
 805c840:	e9 ab ff ff ff       	jmp    805c7f0 <decode_m_w_internal>
 805c845:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805c849:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c850 <decode_r2rm_w>:

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805c850:	8b 44 24 04          	mov    0x4(%esp),%eax
 805c854:	b9 08 af 0f 10       	mov    $0x100faf08,%ecx
 805c859:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
 805c85e:	e9 4d fa ff ff       	jmp    805c2b0 <decode_rm_w_internal>
 805c863:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805c869:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c870 <decode_rm2r_w>:

/* Gb <- Eb
 * Gv <- Ev
 */
make_helper(concat(decode_rm2r_, SUFFIX)) {
	return decode_rm_internal(eip, op_src, op_dest);
 805c870:	8b 44 24 04          	mov    0x4(%esp),%eax
 805c874:	b9 40 af 0f 10       	mov    $0x100faf40,%ecx
 805c879:	ba 08 af 0f 10       	mov    $0x100faf08,%edx
 805c87e:	e9 2d fa ff ff       	jmp    805c2b0 <decode_rm_w_internal>
 805c883:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805c889:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c890 <decode_i2a_w>:


/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
 805c890:	53                   	push   %ebx
 805c891:	83 ec 08             	sub    $0x8,%esp

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
	op->val = REG(R_EAX);
 805c894:	0f b7 05 c0 af 0f 10 	movzwl 0x100fafc0,%eax
}
#endif

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
 805c89b:	c7 05 40 af 0f 10 00 	movl   $0x0,0x100faf40
 805c8a2:	00 00 00 


/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
 805c8a5:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
	op->val = REG(R_EAX);

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(R_EAX));
 805c8a9:	ff 35 a0 5c 07 08    	pushl  0x8075ca0
 805c8af:	68 3a 29 06 08       	push   $0x806293a
 805c8b4:	6a 28                	push   $0x28
 805c8b6:	68 50 af 0f 10       	push   $0x100faf50
#endif

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
 805c8bb:	c7 05 48 af 0f 10 00 	movl   $0x0,0x100faf48
 805c8c2:	00 00 00 
	op->val = REG(R_EAX);
 805c8c5:	a3 4c af 0f 10       	mov    %eax,0x100faf4c

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(R_EAX));
 805c8ca:	e8 31 c2 fe ff       	call   8048b00 <snprintf@plt>
/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
	decode_a(eip, op_dest);
	return decode_i(eip);
 805c8cf:	89 5c 24 20          	mov    %ebx,0x20(%esp)
}
 805c8d3:	83 c4 18             	add    $0x18,%esp
 805c8d6:	5b                   	pop    %ebx
/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
	decode_a(eip, op_dest);
	return decode_i(eip);
 805c8d7:	e9 d4 fe ff ff       	jmp    805c7b0 <decode_i_w>
 805c8dc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805c8e0 <decode_i_rm2r_w>:
}

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
 805c8e0:	56                   	push   %esi
 805c8e1:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805c8e2:	b9 40 af 0f 10       	mov    $0x100faf40,%ecx
 805c8e7:	ba 78 af 0f 10       	mov    $0x100faf78,%edx
}

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
 805c8ec:	83 ec 04             	sub    $0x4,%esp
 805c8ef:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805c8f3:	89 f0                	mov    %esi,%eax
 805c8f5:	e8 b6 f9 ff ff       	call   805c2b0 <decode_rm_w_internal>
	len += decode_i(eip + len);
 805c8fa:	83 ec 0c             	sub    $0xc,%esp
 805c8fd:	01 c6                	add    %eax,%esi

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805c8ff:	89 c3                	mov    %eax,%ebx
	len += decode_i(eip + len);
 805c901:	56                   	push   %esi
 805c902:	e8 a9 fe ff ff       	call   805c7b0 <decode_i_w>
	return len;
}
 805c907:	83 c4 14             	add    $0x14,%esp
/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
	len += decode_i(eip + len);
 805c90a:	01 d8                	add    %ebx,%eax
	return len;
}
 805c90c:	5b                   	pop    %ebx
 805c90d:	5e                   	pop    %esi
 805c90e:	c3                   	ret    
 805c90f:	90                   	nop

0805c910 <decode_i2rm_w>:

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
 805c910:	56                   	push   %esi
 805c911:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805c912:	b9 78 af 0f 10       	mov    $0x100faf78,%ecx
 805c917:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
}

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
 805c91c:	83 ec 04             	sub    $0x4,%esp
 805c91f:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805c923:	89 f0                	mov    %esi,%eax
 805c925:	e8 86 f9 ff ff       	call   805c2b0 <decode_rm_w_internal>
	len += decode_i(eip + len);
 805c92a:	83 ec 0c             	sub    $0xc,%esp
 805c92d:	01 c6                	add    %eax,%esi

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805c92f:	89 c3                	mov    %eax,%ebx
	len += decode_i(eip + len);
 805c931:	56                   	push   %esi
 805c932:	e8 79 fe ff ff       	call   805c7b0 <decode_i_w>
	return len;
}
 805c937:	83 c4 14             	add    $0x14,%esp
/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
	len += decode_i(eip + len);
 805c93a:	01 d8                	add    %ebx,%eax
	return len;
}
 805c93c:	5b                   	pop    %ebx
 805c93d:	5e                   	pop    %esi
 805c93e:	c3                   	ret    
 805c93f:	90                   	nop

0805c940 <decode_i2r_w>:

/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
 805c940:	53                   	push   %ebx
	decode_r_internal(eip, op_dest);
 805c941:	b8 40 af 0f 10       	mov    $0x100faf40,%eax
}

/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
 805c946:	83 ec 08             	sub    $0x8,%esp
 805c949:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	decode_r_internal(eip, op_dest);
 805c94d:	e8 6e fa ff ff       	call   805c3c0 <decode_r_w_internal.isra.4>
	return decode_i(eip);
 805c952:	89 5c 24 10          	mov    %ebx,0x10(%esp)
}
 805c956:	83 c4 08             	add    $0x8,%esp
 805c959:	5b                   	pop    %ebx
/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
	decode_r_internal(eip, op_dest);
	return decode_i(eip);
 805c95a:	e9 51 fe ff ff       	jmp    805c7b0 <decode_i_w>
 805c95f:	90                   	nop

0805c960 <decode_rm_w>:
}

/* used by unary operations */
make_helper(concat(decode_rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_src, op_src2);		/* op_src2 not use here */
 805c960:	8b 44 24 04          	mov    0x4(%esp),%eax
 805c964:	b9 78 af 0f 10       	mov    $0x100faf78,%ecx
 805c969:	ba 08 af 0f 10       	mov    $0x100faf08,%edx
 805c96e:	e9 3d f9 ff ff       	jmp    805c2b0 <decode_rm_w_internal>
 805c973:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805c979:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805c980 <decode_r_w>:
}

make_helper(concat(decode_r_, SUFFIX)) {
	return decode_r_internal(eip, op_src);
 805c980:	b8 08 af 0f 10       	mov    $0x100faf08,%eax
 805c985:	e9 36 fa ff ff       	jmp    805c3c0 <decode_r_w_internal.isra.4>
 805c98a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0805c990 <decode_si2rm_w>:
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
 805c990:	56                   	push   %esi
 805c991:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
 805c992:	b9 78 af 0f 10       	mov    $0x100faf78,%ecx
 805c997:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
make_helper(concat(decode_r_, SUFFIX)) {
	return decode_r_internal(eip, op_src);
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
 805c99c:	83 ec 04             	sub    $0x4,%esp
 805c99f:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
 805c9a3:	89 f0                	mov    %esi,%eax
 805c9a5:	e8 06 f9 ff ff       	call   805c2b0 <decode_rm_w_internal>
	len += decode_si_b(eip + len);
 805c9aa:	83 ec 0c             	sub    $0xc,%esp
 805c9ad:	01 c6                	add    %eax,%esi
	return decode_r_internal(eip, op_src);
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
 805c9af:	89 c3                	mov    %eax,%ebx
	len += decode_si_b(eip + len);
 805c9b1:	56                   	push   %esi
 805c9b2:	e8 c9 fa ff ff       	call   805c480 <decode_si_b>
	return len;
}
 805c9b7:	83 c4 14             	add    $0x14,%esp
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
	len += decode_si_b(eip + len);
 805c9ba:	01 d8                	add    %ebx,%eax
	return len;
}
 805c9bc:	5b                   	pop    %ebx
 805c9bd:	5e                   	pop    %esi
 805c9be:	c3                   	ret    
 805c9bf:	90                   	nop

0805c9c0 <decode_si_rm2r_w>:

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
 805c9c0:	56                   	push   %esi
 805c9c1:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805c9c2:	b9 40 af 0f 10       	mov    $0x100faf40,%ecx
 805c9c7:	ba 78 af 0f 10       	mov    $0x100faf78,%edx
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
	len += decode_si_b(eip + len);
	return len;
}

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
 805c9cc:	83 ec 04             	sub    $0x4,%esp
 805c9cf:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805c9d3:	89 f0                	mov    %esi,%eax
 805c9d5:	e8 d6 f8 ff ff       	call   805c2b0 <decode_rm_w_internal>
	len += decode_si_b(eip + len);
 805c9da:	83 ec 0c             	sub    $0xc,%esp
 805c9dd:	01 c6                	add    %eax,%esi
	len += decode_si_b(eip + len);
	return len;
}

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805c9df:	89 c3                	mov    %eax,%ebx
	len += decode_si_b(eip + len);
 805c9e1:	56                   	push   %esi
 805c9e2:	e8 99 fa ff ff       	call   805c480 <decode_si_b>
	return len;
}
 805c9e7:	83 c4 14             	add    $0x14,%esp
	return len;
}

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
	len += decode_si_b(eip + len);
 805c9ea:	01 d8                	add    %ebx,%eax
	return len;
}
 805c9ec:	5b                   	pop    %ebx
 805c9ed:	5e                   	pop    %esi
 805c9ee:	c3                   	ret    
 805c9ef:	90                   	nop

0805c9f0 <decode_rm_1_w>:
#endif

/* used by shift instructions */
make_helper(concat(decode_rm_1_, SUFFIX)) {
 805c9f0:	83 ec 0c             	sub    $0xc,%esp

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805c9f3:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
 805c9f8:	b9 08 af 0f 10       	mov    $0x100faf08,%ecx
 805c9fd:	8b 44 24 10          	mov    0x10(%esp),%eax
 805ca01:	e8 aa f8 ff ff       	call   805c2b0 <decode_rm_w_internal>
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_IMM;
	op_src->imm = 1;
	op_src->val = 1;
#ifdef DEBUG
	sprintf(op_src->str, "$1");
 805ca06:	ba 24 31 00 00       	mov    $0x3124,%edx
#endif

/* used by shift instructions */
make_helper(concat(decode_rm_1_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_IMM;
 805ca0b:	c7 05 08 af 0f 10 02 	movl   $0x2,0x100faf08
 805ca12:	00 00 00 
	op_src->imm = 1;
 805ca15:	c7 05 10 af 0f 10 01 	movl   $0x1,0x100faf10
 805ca1c:	00 00 00 
	op_src->val = 1;
 805ca1f:	c7 05 14 af 0f 10 01 	movl   $0x1,0x100faf14
 805ca26:	00 00 00 
#ifdef DEBUG
	sprintf(op_src->str, "$1");
 805ca29:	66 89 15 18 af 0f 10 	mov    %dx,0x100faf18
 805ca30:	c6 05 1a af 0f 10 00 	movb   $0x0,0x100faf1a
#endif
	return len;
}
 805ca37:	83 c4 0c             	add    $0xc,%esp
 805ca3a:	c3                   	ret    
 805ca3b:	90                   	nop
 805ca3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805ca40 <decode_rm_cl_w>:

make_helper(concat(decode_rm_cl_, SUFFIX)) {
 805ca40:	53                   	push   %ebx

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805ca41:	b9 08 af 0f 10       	mov    $0x100faf08,%ecx
 805ca46:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
	sprintf(op_src->str, "$1");
#endif
	return len;
}

make_helper(concat(decode_rm_cl_, SUFFIX)) {
 805ca4b:	83 ec 08             	sub    $0x8,%esp

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805ca4e:	8b 44 24 10          	mov    0x10(%esp),%eax
 805ca52:	e8 59 f8 ff ff       	call   805c2b0 <decode_rm_w_internal>
 805ca57:	89 c3                	mov    %eax,%ebx

make_helper(concat(decode_rm_cl_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_REG;
	op_src->reg = R_CL;
	op_src->val = reg_b(R_CL);
 805ca59:	0f b6 05 c4 af 0f 10 	movzbl 0x100fafc4,%eax
#ifdef DEBUG
	sprintf(op_src->str, "%%cl");
 805ca60:	83 ec 08             	sub    $0x8,%esp
 805ca63:	68 d4 59 06 08       	push   $0x80659d4
 805ca68:	68 18 af 0f 10       	push   $0x100faf18
	return len;
}

make_helper(concat(decode_rm_cl_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_REG;
 805ca6d:	c7 05 08 af 0f 10 00 	movl   $0x0,0x100faf08
 805ca74:	00 00 00 
	op_src->reg = R_CL;
 805ca77:	c7 05 10 af 0f 10 01 	movl   $0x1,0x100faf10
 805ca7e:	00 00 00 
	op_src->val = reg_b(R_CL);
 805ca81:	a3 14 af 0f 10       	mov    %eax,0x100faf14
#ifdef DEBUG
	sprintf(op_src->str, "%%cl");
 805ca86:	e8 05 c1 fe ff       	call   8048b90 <sprintf@plt>
#endif
	return len;
}
 805ca8b:	83 c4 18             	add    $0x18,%esp
 805ca8e:	89 d8                	mov    %ebx,%eax
 805ca90:	5b                   	pop    %ebx
 805ca91:	c3                   	ret    
 805ca92:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805ca99:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805caa0 <decode_rm_imm_w>:

make_helper(concat(decode_rm_imm_, SUFFIX)) {
 805caa0:	56                   	push   %esi
 805caa1:	53                   	push   %ebx

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805caa2:	b9 08 af 0f 10       	mov    $0x100faf08,%ecx
 805caa7:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
	sprintf(op_src->str, "%%cl");
#endif
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
 805caac:	83 ec 04             	sub    $0x4,%esp
 805caaf:	8b 74 24 10          	mov    0x10(%esp),%esi

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cab3:	89 f0                	mov    %esi,%eax
 805cab5:	e8 f6 f7 ff ff       	call   805c2b0 <decode_rm_w_internal>
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805caba:	83 ec 0c             	sub    $0xc,%esp
 805cabd:	01 c6                	add    %eax,%esi

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cabf:	89 c3                	mov    %eax,%ebx
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805cac1:	56                   	push   %esi
 805cac2:	e8 79 f9 ff ff       	call   805c440 <decode_i_b>
	return len;
}
 805cac7:	83 c4 14             	add    $0x14,%esp
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805caca:	01 d8                	add    %ebx,%eax
	return len;
}
 805cacc:	5b                   	pop    %ebx
 805cacd:	5e                   	pop    %esi
 805cace:	c3                   	ret    
 805cacf:	90                   	nop

0805cad0 <write_operand_w>:

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
 805cad0:	83 ec 0c             	sub    $0xc,%esp
 805cad3:	8b 44 24 10          	mov    0x10(%esp),%eax
 805cad7:	8b 54 24 14          	mov    0x14(%esp),%edx
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
 805cadb:	8b 08                	mov    (%eax),%ecx
 805cadd:	85 c9                	test   %ecx,%ecx
 805cadf:	75 17                	jne    805caf8 <write_operand_w+0x28>
 805cae1:	8b 40 08             	mov    0x8(%eax),%eax
 805cae4:	83 f8 07             	cmp    $0x7,%eax
 805cae7:	77 2d                	ja     805cb16 <write_operand_w+0x46>
 805cae9:	66 89 14 85 c0 af 0f 	mov    %dx,0x100fafc0(,%eax,4)
 805caf0:	10 
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
	else { assert(0); }
}
 805caf1:	83 c4 0c             	add    $0xc,%esp
 805caf4:	c3                   	ret    
 805caf5:	8d 76 00             	lea    0x0(%esi),%esi
	return len;
}

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
 805caf8:	83 f9 01             	cmp    $0x1,%ecx
 805cafb:	75 1e                	jne    805cb1b <write_operand_w+0x4b>
 805cafd:	83 ec 04             	sub    $0x4,%esp
 805cb00:	0f b7 d2             	movzwl %dx,%edx
 805cb03:	52                   	push   %edx
 805cb04:	ff 70 04             	pushl  0x4(%eax)
 805cb07:	ff 70 08             	pushl  0x8(%eax)
 805cb0a:	e8 91 e4 fe ff       	call   804afa0 <swaddr_write>
 805cb0f:	83 c4 10             	add    $0x10,%esp
	else { assert(0); }
}
 805cb12:	83 c4 0c             	add    $0xc,%esp
 805cb15:	c3                   	ret    
 805cb16:	e8 f0 c0 fe ff       	call   8048c0b <check_reg_index.part.0>
}

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
	else { assert(0); }
 805cb1b:	68 12 5a 06 08       	push   $0x8065a12
 805cb20:	68 cd 00 00 00       	push   $0xcd
 805cb25:	68 dc 59 06 08       	push   $0x80659dc
 805cb2a:	68 1c ea 05 08       	push   $0x805ea1c
 805cb2f:	e8 7c c0 fe ff       	call   8048bb0 <__assert_fail@plt>
 805cb34:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805cb3a:	8d bf 00 00 00 00    	lea    0x0(%edi),%edi

0805cb40 <decode_i_l>:
#define decode_m_internal concat3(decode_m_, SUFFIX, _internal)
#define decode_a concat(decode_a_, SUFFIX)
#define decode_r2rm concat(decode_r2rm_, SUFFIX)

/* Ib, Iv */
make_helper(concat(decode_i_, SUFFIX)) {
 805cb40:	83 ec 14             	sub    $0x14,%esp
	/* eip here is pointing to the immediate */
	op_src->type = OP_TYPE_IMM;
 805cb43:	c7 05 08 af 0f 10 02 	movl   $0x2,0x100faf08
 805cb4a:	00 00 00 
 805cb4d:	6a 04                	push   $0x4
 805cb4f:	ff 74 24 1c          	pushl  0x1c(%esp)
 805cb53:	e8 f8 e3 fe ff       	call   804af50 <swaddr_read>
	op_src->imm = instr_fetch(eip, DATA_BYTE);
	op_src->val = op_src->imm;

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->imm);
 805cb58:	50                   	push   %eax
 805cb59:	68 ce 59 06 08       	push   $0x80659ce
 805cb5e:	6a 28                	push   $0x28
 805cb60:	68 18 af 0f 10       	push   $0x100faf18

/* Ib, Iv */
make_helper(concat(decode_i_, SUFFIX)) {
	/* eip here is pointing to the immediate */
	op_src->type = OP_TYPE_IMM;
	op_src->imm = instr_fetch(eip, DATA_BYTE);
 805cb65:	a3 10 af 0f 10       	mov    %eax,0x100faf10
	op_src->val = op_src->imm;
 805cb6a:	a3 14 af 0f 10       	mov    %eax,0x100faf14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->imm);
 805cb6f:	e8 8c bf fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805cb74:	b8 04 00 00 00       	mov    $0x4,%eax
 805cb79:	83 c4 2c             	add    $0x2c,%esp
 805cb7c:	c3                   	ret    
 805cb7d:	8d 76 00             	lea    0x0(%esi),%esi

0805cb80 <decode_si_l>:

#if DATA_BYTE == 1 || DATA_BYTE == 4
/* sign immediate */
make_helper(concat(decode_si_, SUFFIX)) {
 805cb80:	83 ec 14             	sub    $0x14,%esp
	op_src->type = OP_TYPE_IMM;
 805cb83:	c7 05 08 af 0f 10 02 	movl   $0x2,0x100faf08
 805cb8a:	00 00 00 
 805cb8d:	6a 04                	push   $0x4
 805cb8f:	ff 74 24 1c          	pushl  0x1c(%esp)
 805cb93:	e8 b8 e3 fe ff       	call   804af50 <swaddr_read>
//	panic("please implement me");

	op_src->val = op_src->simm;

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->val);
 805cb98:	50                   	push   %eax
 805cb99:	68 ce 59 06 08       	push   $0x80659ce
 805cb9e:	6a 28                	push   $0x28
 805cba0:	68 18 af 0f 10       	push   $0x100faf18

	/* TODO: Use instr_fetch() to read ``DATA_BYTE'' bytes of memory pointed 
	 * by ``eip''. Interpret the result as an signed immediate, and assign
	 * it to op_src->simm.
	 */
	op_src->simm = instr_fetch(eip, DATA_BYTE);
 805cba5:	a3 10 af 0f 10       	mov    %eax,0x100faf10
#if DATA_BYTE == 1
	op_src->simm = op_src->simm << 24 >> 24;
#endif
//	panic("please implement me");

	op_src->val = op_src->simm;
 805cbaa:	a3 14 af 0f 10       	mov    %eax,0x100faf14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->val);
 805cbaf:	e8 4c bf fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805cbb4:	b8 04 00 00 00       	mov    $0x4,%eax
 805cbb9:	83 c4 2c             	add    $0x2c,%esp
 805cbbc:	c3                   	ret    
 805cbbd:	8d 76 00             	lea    0x0(%esi),%esi

0805cbc0 <decode_m_l_internal>:
#endif
	return len;
}

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
 805cbc0:	83 ec 14             	sub    $0x14,%esp
	op_src->type = OP_TYPE_MEM;
 805cbc3:	c7 05 08 af 0f 10 01 	movl   $0x1,0x100faf08
 805cbca:	00 00 00 
 805cbcd:	6a 04                	push   $0x4
 805cbcf:	ff 74 24 1c          	pushl  0x1c(%esp)
 805cbd3:	e8 78 e3 fe ff       	call   804af50 <swaddr_read>
	op_src->addr = instr_fetch(eip, DATA_BYTE);
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805cbd8:	5a                   	pop    %edx
 805cbd9:	59                   	pop    %ecx
 805cbda:	6a 04                	push   $0x4
 805cbdc:	50                   	push   %eax
}

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
	op_src->type = OP_TYPE_MEM;
	op_src->addr = instr_fetch(eip, DATA_BYTE);
 805cbdd:	a3 10 af 0f 10       	mov    %eax,0x100faf10
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805cbe2:	e8 e9 e2 fe ff       	call   804aed0 <hwaddr_read>

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->addr);
 805cbe7:	ff 35 10 af 0f 10    	pushl  0x100faf10
 805cbed:	68 ce 59 06 08       	push   $0x80659ce
 805cbf2:	6a 28                	push   $0x28
 805cbf4:	68 18 af 0f 10       	push   $0x100faf18

/* memory */
make_helper(concat3(decode_m_, SUFFIX, _internal)) {
	op_src->type = OP_TYPE_MEM;
	op_src->addr = instr_fetch(eip, DATA_BYTE);
	op_src->val = hwaddr_read(op_src->addr, DATA_BYTE);
 805cbf9:	a3 14 af 0f 10       	mov    %eax,0x100faf14

#ifdef DEBUG
	snprintf(op_src->str, OP_STR_SIZE, "$0x%x", op_src->addr);
 805cbfe:	e8 fd be fe ff       	call   8048b00 <snprintf@plt>
#endif
	return DATA_BYTE;
}
 805cc03:	b8 04 00 00 00       	mov    $0x4,%eax
 805cc08:	83 c4 2c             	add    $0x2c,%esp
 805cc0b:	c3                   	ret    
 805cc0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805cc10 <decode_m_l>:

/* Mb, Mv */
make_helper(concat(decode_m_, SUFFIX)) {
	return decode_m_internal(eip);
 805cc10:	e9 ab ff ff ff       	jmp    805cbc0 <decode_m_l_internal>
 805cc15:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805cc19:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805cc20 <decode_r2rm_l>:

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cc20:	8b 44 24 04          	mov    0x4(%esp),%eax
 805cc24:	b9 08 af 0f 10       	mov    $0x100faf08,%ecx
 805cc29:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
 805cc2e:	e9 dd f6 ff ff       	jmp    805c310 <decode_rm_l_internal>
 805cc33:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805cc39:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805cc40 <decode_rm2r_l>:

/* Gb <- Eb
 * Gv <- Ev
 */
make_helper(concat(decode_rm2r_, SUFFIX)) {
	return decode_rm_internal(eip, op_src, op_dest);
 805cc40:	8b 44 24 04          	mov    0x4(%esp),%eax
 805cc44:	b9 40 af 0f 10       	mov    $0x100faf40,%ecx
 805cc49:	ba 08 af 0f 10       	mov    $0x100faf08,%edx
 805cc4e:	e9 bd f6 ff ff       	jmp    805c310 <decode_rm_l_internal>
 805cc53:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805cc59:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805cc60 <decode_i2a_l>:


/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
 805cc60:	53                   	push   %ebx
 805cc61:	83 ec 08             	sub    $0x8,%esp

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
	op->val = REG(R_EAX);
 805cc64:	a1 c0 af 0f 10       	mov    0x100fafc0,%eax
}
#endif

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
 805cc69:	c7 05 40 af 0f 10 00 	movl   $0x0,0x100faf40
 805cc70:	00 00 00 


/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
 805cc73:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
	op->val = REG(R_EAX);

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(R_EAX));
 805cc77:	ff 35 c0 5c 07 08    	pushl  0x8075cc0
 805cc7d:	68 3a 29 06 08       	push   $0x806293a
 805cc82:	6a 28                	push   $0x28
 805cc84:	68 50 af 0f 10       	push   $0x100faf50
#endif

/* eAX */
static int concat(decode_a_, SUFFIX) (swaddr_t eip, Operand *op) {
	op->type = OP_TYPE_REG;
	op->reg = R_EAX;
 805cc89:	c7 05 48 af 0f 10 00 	movl   $0x0,0x100faf48
 805cc90:	00 00 00 
	op->val = REG(R_EAX);
 805cc93:	a3 4c af 0f 10       	mov    %eax,0x100faf4c

#ifdef DEBUG
	snprintf(op->str, OP_STR_SIZE, "%%%s", REG_NAME(R_EAX));
 805cc98:	e8 63 be fe ff       	call   8048b00 <snprintf@plt>
/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
	decode_a(eip, op_dest);
	return decode_i(eip);
 805cc9d:	89 5c 24 20          	mov    %ebx,0x20(%esp)
}
 805cca1:	83 c4 18             	add    $0x18,%esp
 805cca4:	5b                   	pop    %ebx
/* AL <- Ib
 * eAX <- Iv
 */
make_helper(concat(decode_i2a_, SUFFIX)) {
	decode_a(eip, op_dest);
	return decode_i(eip);
 805cca5:	e9 96 fe ff ff       	jmp    805cb40 <decode_i_l>
 805ccaa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0805ccb0 <decode_i_rm2r_l>:
}

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
 805ccb0:	56                   	push   %esi
 805ccb1:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805ccb2:	b9 40 af 0f 10       	mov    $0x100faf40,%ecx
 805ccb7:	ba 78 af 0f 10       	mov    $0x100faf78,%edx
}

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
 805ccbc:	83 ec 04             	sub    $0x4,%esp
 805ccbf:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805ccc3:	89 f0                	mov    %esi,%eax
 805ccc5:	e8 46 f6 ff ff       	call   805c310 <decode_rm_l_internal>
	len += decode_i(eip + len);
 805ccca:	83 ec 0c             	sub    $0xc,%esp
 805cccd:	01 c6                	add    %eax,%esi

/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805cccf:	89 c3                	mov    %eax,%ebx
	len += decode_i(eip + len);
 805ccd1:	56                   	push   %esi
 805ccd2:	e8 69 fe ff ff       	call   805cb40 <decode_i_l>
	return len;
}
 805ccd7:	83 c4 14             	add    $0x14,%esp
/* Gv <- EvIb
 * Gv <- EvIv
 * use for imul */
make_helper(concat(decode_i_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
	len += decode_i(eip + len);
 805ccda:	01 d8                	add    %ebx,%eax
	return len;
}
 805ccdc:	5b                   	pop    %ebx
 805ccdd:	5e                   	pop    %esi
 805ccde:	c3                   	ret    
 805ccdf:	90                   	nop

0805cce0 <decode_i2rm_l>:

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
 805cce0:	56                   	push   %esi
 805cce1:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805cce2:	b9 78 af 0f 10       	mov    $0x100faf78,%ecx
 805cce7:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
}

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
 805ccec:	83 ec 04             	sub    $0x4,%esp
 805ccef:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805ccf3:	89 f0                	mov    %esi,%eax
 805ccf5:	e8 16 f6 ff ff       	call   805c310 <decode_rm_l_internal>
	len += decode_i(eip + len);
 805ccfa:	83 ec 0c             	sub    $0xc,%esp
 805ccfd:	01 c6                	add    %eax,%esi

/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
 805ccff:	89 c3                	mov    %eax,%ebx
	len += decode_i(eip + len);
 805cd01:	56                   	push   %esi
 805cd02:	e8 39 fe ff ff       	call   805cb40 <decode_i_l>
	return len;
}
 805cd07:	83 c4 14             	add    $0x14,%esp
/* Eb <- Ib
 * Ev <- Iv
 */
make_helper(concat(decode_i2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);		/* op_src2 not use here */
	len += decode_i(eip + len);
 805cd0a:	01 d8                	add    %ebx,%eax
	return len;
}
 805cd0c:	5b                   	pop    %ebx
 805cd0d:	5e                   	pop    %esi
 805cd0e:	c3                   	ret    
 805cd0f:	90                   	nop

0805cd10 <decode_i2r_l>:

/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
 805cd10:	53                   	push   %ebx
	decode_r_internal(eip, op_dest);
 805cd11:	b8 40 af 0f 10       	mov    $0x100faf40,%eax
}

/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
 805cd16:	83 ec 08             	sub    $0x8,%esp
 805cd19:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	decode_r_internal(eip, op_dest);
 805cd1d:	e8 de f6 ff ff       	call   805c400 <decode_r_l_internal.isra.6>
	return decode_i(eip);
 805cd22:	89 5c 24 10          	mov    %ebx,0x10(%esp)
}
 805cd26:	83 c4 08             	add    $0x8,%esp
 805cd29:	5b                   	pop    %ebx
/* XX <- Ib 
 * eXX <- Iv 
 */
make_helper(concat(decode_i2r_, SUFFIX)) {
	decode_r_internal(eip, op_dest);
	return decode_i(eip);
 805cd2a:	e9 11 fe ff ff       	jmp    805cb40 <decode_i_l>
 805cd2f:	90                   	nop

0805cd30 <decode_rm_l>:
}

/* used by unary operations */
make_helper(concat(decode_rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_src, op_src2);		/* op_src2 not use here */
 805cd30:	8b 44 24 04          	mov    0x4(%esp),%eax
 805cd34:	b9 78 af 0f 10       	mov    $0x100faf78,%ecx
 805cd39:	ba 08 af 0f 10       	mov    $0x100faf08,%edx
 805cd3e:	e9 cd f5 ff ff       	jmp    805c310 <decode_rm_l_internal>
 805cd43:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805cd49:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805cd50 <decode_r_l>:
}

make_helper(concat(decode_r_, SUFFIX)) {
	return decode_r_internal(eip, op_src);
 805cd50:	b8 08 af 0f 10       	mov    $0x100faf08,%eax
 805cd55:	e9 a6 f6 ff ff       	jmp    805c400 <decode_r_l_internal.isra.6>
 805cd5a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0805cd60 <decode_si2rm_l>:
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
 805cd60:	56                   	push   %esi
 805cd61:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
 805cd62:	b9 78 af 0f 10       	mov    $0x100faf78,%ecx
 805cd67:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
make_helper(concat(decode_r_, SUFFIX)) {
	return decode_r_internal(eip, op_src);
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
 805cd6c:	83 ec 04             	sub    $0x4,%esp
 805cd6f:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
 805cd73:	89 f0                	mov    %esi,%eax
 805cd75:	e8 96 f5 ff ff       	call   805c310 <decode_rm_l_internal>
	len += decode_si_b(eip + len);
 805cd7a:	83 ec 0c             	sub    $0xc,%esp
 805cd7d:	01 c6                	add    %eax,%esi
	return decode_r_internal(eip, op_src);
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
 805cd7f:	89 c3                	mov    %eax,%ebx
	len += decode_si_b(eip + len);
 805cd81:	56                   	push   %esi
 805cd82:	e8 f9 f6 ff ff       	call   805c480 <decode_si_b>
	return len;
}
 805cd87:	83 c4 14             	add    $0x14,%esp
}

#if DATA_BYTE == 2 || DATA_BYTE == 4
make_helper(concat(decode_si2rm_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
	len += decode_si_b(eip + len);
 805cd8a:	01 d8                	add    %ebx,%eax
	return len;
}
 805cd8c:	5b                   	pop    %ebx
 805cd8d:	5e                   	pop    %esi
 805cd8e:	c3                   	ret    
 805cd8f:	90                   	nop

0805cd90 <decode_si_rm2r_l>:

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
 805cd90:	56                   	push   %esi
 805cd91:	53                   	push   %ebx
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805cd92:	b9 40 af 0f 10       	mov    $0x100faf40,%ecx
 805cd97:	ba 78 af 0f 10       	mov    $0x100faf78,%edx
	int len = decode_rm_internal(eip, op_dest, op_src2);	/* op_src2 not use here */
	len += decode_si_b(eip + len);
	return len;
}

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
 805cd9c:	83 ec 04             	sub    $0x4,%esp
 805cd9f:	8b 74 24 10          	mov    0x10(%esp),%esi
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805cda3:	89 f0                	mov    %esi,%eax
 805cda5:	e8 66 f5 ff ff       	call   805c310 <decode_rm_l_internal>
	len += decode_si_b(eip + len);
 805cdaa:	83 ec 0c             	sub    $0xc,%esp
 805cdad:	01 c6                	add    %eax,%esi
	len += decode_si_b(eip + len);
	return len;
}

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
 805cdaf:	89 c3                	mov    %eax,%ebx
	len += decode_si_b(eip + len);
 805cdb1:	56                   	push   %esi
 805cdb2:	e8 c9 f6 ff ff       	call   805c480 <decode_si_b>
	return len;
}
 805cdb7:	83 c4 14             	add    $0x14,%esp
	return len;
}

make_helper(concat(decode_si_rm2r_, SUFFIX)) {
	int len = decode_rm_internal(eip, op_src2, op_dest);
	len += decode_si_b(eip + len);
 805cdba:	01 d8                	add    %ebx,%eax
	return len;
}
 805cdbc:	5b                   	pop    %ebx
 805cdbd:	5e                   	pop    %esi
 805cdbe:	c3                   	ret    
 805cdbf:	90                   	nop

0805cdc0 <decode_rm_1_l>:
#endif

/* used by shift instructions */
make_helper(concat(decode_rm_1_, SUFFIX)) {
 805cdc0:	83 ec 0c             	sub    $0xc,%esp

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805cdc3:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
 805cdc8:	b9 08 af 0f 10       	mov    $0x100faf08,%ecx
 805cdcd:	8b 44 24 10          	mov    0x10(%esp),%eax
 805cdd1:	e8 3a f5 ff ff       	call   805c310 <decode_rm_l_internal>
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_IMM;
	op_src->imm = 1;
	op_src->val = 1;
#ifdef DEBUG
	sprintf(op_src->str, "$1");
 805cdd6:	ba 24 31 00 00       	mov    $0x3124,%edx
#endif

/* used by shift instructions */
make_helper(concat(decode_rm_1_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_IMM;
 805cddb:	c7 05 08 af 0f 10 02 	movl   $0x2,0x100faf08
 805cde2:	00 00 00 
	op_src->imm = 1;
 805cde5:	c7 05 10 af 0f 10 01 	movl   $0x1,0x100faf10
 805cdec:	00 00 00 
	op_src->val = 1;
 805cdef:	c7 05 14 af 0f 10 01 	movl   $0x1,0x100faf14
 805cdf6:	00 00 00 
#ifdef DEBUG
	sprintf(op_src->str, "$1");
 805cdf9:	66 89 15 18 af 0f 10 	mov    %dx,0x100faf18
 805ce00:	c6 05 1a af 0f 10 00 	movb   $0x0,0x100faf1a
#endif
	return len;
}
 805ce07:	83 c4 0c             	add    $0xc,%esp
 805ce0a:	c3                   	ret    
 805ce0b:	90                   	nop
 805ce0c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805ce10 <decode_rm_cl_l>:

make_helper(concat(decode_rm_cl_, SUFFIX)) {
 805ce10:	53                   	push   %ebx

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805ce11:	b9 08 af 0f 10       	mov    $0x100faf08,%ecx
 805ce16:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
	sprintf(op_src->str, "$1");
#endif
	return len;
}

make_helper(concat(decode_rm_cl_, SUFFIX)) {
 805ce1b:	83 ec 08             	sub    $0x8,%esp

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805ce1e:	8b 44 24 10          	mov    0x10(%esp),%eax
 805ce22:	e8 e9 f4 ff ff       	call   805c310 <decode_rm_l_internal>
 805ce27:	89 c3                	mov    %eax,%ebx

make_helper(concat(decode_rm_cl_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_REG;
	op_src->reg = R_CL;
	op_src->val = reg_b(R_CL);
 805ce29:	0f b6 05 c4 af 0f 10 	movzbl 0x100fafc4,%eax
#ifdef DEBUG
	sprintf(op_src->str, "%%cl");
 805ce30:	83 ec 08             	sub    $0x8,%esp
 805ce33:	68 d4 59 06 08       	push   $0x80659d4
 805ce38:	68 18 af 0f 10       	push   $0x100faf18
	return len;
}

make_helper(concat(decode_rm_cl_, SUFFIX)) {
	int len = decode_r2rm(eip);
	op_src->type = OP_TYPE_REG;
 805ce3d:	c7 05 08 af 0f 10 00 	movl   $0x0,0x100faf08
 805ce44:	00 00 00 
	op_src->reg = R_CL;
 805ce47:	c7 05 10 af 0f 10 01 	movl   $0x1,0x100faf10
 805ce4e:	00 00 00 
	op_src->val = reg_b(R_CL);
 805ce51:	a3 14 af 0f 10       	mov    %eax,0x100faf14
#ifdef DEBUG
	sprintf(op_src->str, "%%cl");
 805ce56:	e8 35 bd fe ff       	call   8048b90 <sprintf@plt>
#endif
	return len;
}
 805ce5b:	83 c4 18             	add    $0x18,%esp
 805ce5e:	89 d8                	mov    %ebx,%eax
 805ce60:	5b                   	pop    %ebx
 805ce61:	c3                   	ret    
 805ce62:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805ce69:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805ce70 <decode_rm_imm_l>:

make_helper(concat(decode_rm_imm_, SUFFIX)) {
 805ce70:	56                   	push   %esi
 805ce71:	53                   	push   %ebx

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805ce72:	b9 08 af 0f 10       	mov    $0x100faf08,%ecx
 805ce77:	ba 40 af 0f 10       	mov    $0x100faf40,%edx
	sprintf(op_src->str, "%%cl");
#endif
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
 805ce7c:	83 ec 04             	sub    $0x4,%esp
 805ce7f:	8b 74 24 10          	mov    0x10(%esp),%esi

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805ce83:	89 f0                	mov    %esi,%eax
 805ce85:	e8 86 f4 ff ff       	call   805c310 <decode_rm_l_internal>
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805ce8a:	83 ec 0c             	sub    $0xc,%esp
 805ce8d:	01 c6                	add    %eax,%esi

/* Eb <- Gb
 * Ev <- Gv
 */
make_helper(concat(decode_r2rm_, SUFFIX)) {
	return decode_rm_internal(eip, op_dest, op_src);
 805ce8f:	89 c3                	mov    %eax,%ebx
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805ce91:	56                   	push   %esi
 805ce92:	e8 a9 f5 ff ff       	call   805c440 <decode_i_b>
	return len;
}
 805ce97:	83 c4 14             	add    $0x14,%esp
	return len;
}

make_helper(concat(decode_rm_imm_, SUFFIX)) {
	int len = decode_r2rm(eip);
	len += decode_i_b(eip + len);
 805ce9a:	01 d8                	add    %ebx,%eax
	return len;
}
 805ce9c:	5b                   	pop    %ebx
 805ce9d:	5e                   	pop    %esi
 805ce9e:	c3                   	ret    
 805ce9f:	90                   	nop

0805cea0 <write_operand_l>:

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
 805cea0:	83 ec 0c             	sub    $0xc,%esp
 805cea3:	8b 44 24 10          	mov    0x10(%esp),%eax
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
 805cea7:	8b 10                	mov    (%eax),%edx
 805cea9:	85 d2                	test   %edx,%edx
 805ceab:	75 1b                	jne    805cec8 <write_operand_l+0x28>
 805cead:	8b 40 08             	mov    0x8(%eax),%eax
 805ceb0:	83 f8 07             	cmp    $0x7,%eax
 805ceb3:	77 31                	ja     805cee6 <write_operand_l+0x46>
 805ceb5:	8b 4c 24 14          	mov    0x14(%esp),%ecx
 805ceb9:	89 0c 85 c0 af 0f 10 	mov    %ecx,0x100fafc0(,%eax,4)
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
	else { assert(0); }
}
 805cec0:	83 c4 0c             	add    $0xc,%esp
 805cec3:	c3                   	ret    
 805cec4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	return len;
}

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
 805cec8:	83 fa 01             	cmp    $0x1,%edx
 805cecb:	75 1e                	jne    805ceeb <write_operand_l+0x4b>
 805cecd:	83 ec 04             	sub    $0x4,%esp
 805ced0:	ff 74 24 18          	pushl  0x18(%esp)
 805ced4:	ff 70 04             	pushl  0x4(%eax)
 805ced7:	ff 70 08             	pushl  0x8(%eax)
 805ceda:	e8 c1 e0 fe ff       	call   804afa0 <swaddr_write>
 805cedf:	83 c4 10             	add    $0x10,%esp
	else { assert(0); }
}
 805cee2:	83 c4 0c             	add    $0xc,%esp
 805cee5:	c3                   	ret    
 805cee6:	e8 20 bd fe ff       	call   8048c0b <check_reg_index.part.0>
}

void concat(write_operand_, SUFFIX) (Operand *op, DATA_TYPE src) {
	if(op->type == OP_TYPE_REG) { REG(op->reg) = src; }
	else if(op->type == OP_TYPE_MEM) { swaddr_write(op->addr, op->size, src); }
	else { assert(0); }
 805ceeb:	68 02 5a 06 08       	push   $0x8065a02
 805cef0:	68 cd 00 00 00       	push   $0xcd
 805cef5:	68 dc 59 06 08       	push   $0x80659dc
 805cefa:	68 1c ea 05 08       	push   $0x805ea1c
 805ceff:	e8 ac bc fe ff       	call   8048bb0 <__assert_fail@plt>
 805cf04:	66 90                	xchg   %ax,%ax
 805cf06:	66 90                	xchg   %ax,%ax
 805cf08:	66 90                	xchg   %ax,%ax
 805cf0a:	66 90                	xchg   %ax,%ax
 805cf0c:	66 90                	xchg   %ax,%ax
 805cf0e:	66 90                	xchg   %ax,%ax

0805cf10 <load_addr>:
#include "cpu/decode/modrm.h"
#include "cpu/helper.h"

int load_addr(swaddr_t eip, ModR_M *m, Operand *rm) {
 805cf10:	55                   	push   %ebp
 805cf11:	57                   	push   %edi
 805cf12:	56                   	push   %esi
 805cf13:	53                   	push   %ebx
 805cf14:	83 ec 3c             	sub    $0x3c,%esp
 805cf17:	8b 7c 24 54          	mov    0x54(%esp),%edi
	assert(m->mod != 3);
 805cf1b:	0f b6 1f             	movzbl (%edi),%ebx
 805cf1e:	89 d8                	mov    %ebx,%eax
 805cf20:	83 e0 c0             	and    $0xffffffc0,%eax
 805cf23:	3c c0                	cmp    $0xc0,%al
 805cf25:	0f 84 4a 02 00 00    	je     805d175 <load_addr+0x265>
	int32_t disp;
	int instr_len, disp_offset, disp_size = 4;
	int base_reg = -1, index_reg = -1, scale = 0;
	swaddr_t addr = 0;

	if(m->R_M == R_ESP) {
 805cf2b:	83 e3 07             	and    $0x7,%ebx
 805cf2e:	80 fb 04             	cmp    $0x4,%bl
 805cf31:	0f 84 f1 01 00 00    	je     805d128 <load_addr+0x218>

		if(s.index != R_ESP) { index_reg = s.index; }
	}
	else {
		/* no SIB */
		base_reg = m->R_M;
 805cf37:	0f b6 db             	movzbl %bl,%ebx
int load_addr(swaddr_t eip, ModR_M *m, Operand *rm) {
	assert(m->mod != 3);

	int32_t disp;
	int instr_len, disp_offset, disp_size = 4;
	int base_reg = -1, index_reg = -1, scale = 0;
 805cf3a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
 805cf41:	00 
 805cf42:	be ff ff ff ff       	mov    $0xffffffff,%esi
		if(s.index != R_ESP) { index_reg = s.index; }
	}
	else {
		/* no SIB */
		base_reg = m->R_M;
		disp_offset = 1;
 805cf47:	bf 01 00 00 00       	mov    $0x1,%edi
	}

	if(m->mod == 0) {
 805cf4c:	84 c0                	test   %al,%al
 805cf4e:	0f 85 ec 00 00 00    	jne    805d040 <load_addr+0x130>
		if(base_reg == R_EBP) { base_reg = -1; }
 805cf54:	83 fb 05             	cmp    $0x5,%ebx
 805cf57:	0f 84 bb 01 00 00    	je     805d118 <load_addr+0x208>
		else { disp_size = 0; }
 805cf5d:	31 c0                	xor    %eax,%eax
	assert(m->mod != 3);

	int32_t disp;
	int instr_len, disp_offset, disp_size = 4;
	int base_reg = -1, index_reg = -1, scale = 0;
	swaddr_t addr = 0;
 805cf5f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
 805cf66:	00 
		instr_len += disp_size;
		addr += disp;
	}

	if(base_reg != -1) {
		addr += reg_l(base_reg);
 805cf67:	8b 14 9d c0 af 0f 10 	mov    0x100fafc0(,%ebx,4),%edx
 805cf6e:	01 54 24 08          	add    %edx,0x8(%esp)
 805cf72:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
	}

	if(index_reg != -1) {
 805cf78:	83 fe ff             	cmp    $0xffffffff,%esi
 805cf7b:	74 13                	je     805cf90 <load_addr+0x80>
		addr += reg_l(index_reg) << scale;
 805cf7d:	0f b6 4c 24 0c       	movzbl 0xc(%esp),%ecx
 805cf82:	8b 14 b5 c0 af 0f 10 	mov    0x100fafc0(,%esi,4),%edx
 805cf89:	d3 e2                	shl    %cl,%edx
 805cf8b:	01 54 24 08          	add    %edx,0x8(%esp)
 805cf8f:	90                   	nop
#ifdef DEBUG
	char disp_buf[16];
	char base_buf[8];
	char index_buf[8];

	if(disp_size != 0) {
 805cf90:	85 c0                	test   %eax,%eax
 805cf92:	0f 84 20 01 00 00    	je     805d0b8 <load_addr+0x1a8>
		/* has disp */
		sprintf(disp_buf, "%s%#x", (disp < 0 ? "-" : ""), (disp < 0 ? -disp : disp));
 805cf98:	89 ea                	mov    %ebp,%edx
 805cf9a:	c1 fa 1f             	sar    $0x1f,%edx
 805cf9d:	89 d0                	mov    %edx,%eax
 805cf9f:	31 e8                	xor    %ebp,%eax
 805cfa1:	29 d0                	sub    %edx,%eax
 805cfa3:	85 ed                	test   %ebp,%ebp
 805cfa5:	ba 26 ef 05 08       	mov    $0x805ef26,%edx
 805cfaa:	78 05                	js     805cfb1 <load_addr+0xa1>
 805cfac:	ba 0c ec 05 08       	mov    $0x805ec0c,%edx
 805cfb1:	50                   	push   %eax
 805cfb2:	52                   	push   %edx
 805cfb3:	68 6a 5a 06 08       	push   $0x8065a6a
 805cfb8:	8d 6c 24 2c          	lea    0x2c(%esp),%ebp
 805cfbc:	55                   	push   %ebp
 805cfbd:	e8 ce bb fe ff       	call   8048b90 <sprintf@plt>
 805cfc2:	83 c4 10             	add    $0x10,%esp
	}
	else { disp_buf[0] = '\0'; }

	if(base_reg == -1) { base_buf[0] = '\0'; }
 805cfc5:	83 fb ff             	cmp    $0xffffffff,%ebx
 805cfc8:	0f 85 b2 00 00 00    	jne    805d080 <load_addr+0x170>
	else { 
		sprintf(base_buf, "%%%s", regsl[base_reg]); 
	}

	if(index_reg == -1) { index_buf[0] = '\0'; }
 805cfce:	83 fe ff             	cmp    $0xffffffff,%esi
		/* has disp */
		sprintf(disp_buf, "%s%#x", (disp < 0 ? "-" : ""), (disp < 0 ? -disp : disp));
	}
	else { disp_buf[0] = '\0'; }

	if(base_reg == -1) { base_buf[0] = '\0'; }
 805cfd1:	c6 44 24 10 00       	movb   $0x0,0x10(%esp)
 805cfd6:	8d 5c 24 10          	lea    0x10(%esp),%ebx
	else { 
		sprintf(base_buf, "%%%s", regsl[base_reg]); 
	}

	if(index_reg == -1) { index_buf[0] = '\0'; }
 805cfda:	0f 84 f0 00 00 00    	je     805d0d0 <load_addr+0x1c0>
	else { 
		sprintf(index_buf, ",%%%s,%d", regsl[index_reg], 1 << scale); 
 805cfe0:	0f b6 4c 24 0c       	movzbl 0xc(%esp),%ecx
 805cfe5:	b8 01 00 00 00       	mov    $0x1,%eax
 805cfea:	d3 e0                	shl    %cl,%eax
 805cfec:	50                   	push   %eax
 805cfed:	ff 34 b5 c0 5c 07 08 	pushl  0x8075cc0(,%esi,4)
 805cff4:	68 70 5a 06 08       	push   $0x8065a70
 805cff9:	8d 74 24 24          	lea    0x24(%esp),%esi
 805cffd:	56                   	push   %esi
 805cffe:	e8 8d bb fe ff       	call   8048b90 <sprintf@plt>
 805d003:	83 c4 10             	add    $0x10,%esp

	if(base_reg == -1 && index_reg == -1) {
		sprintf(rm->str, "%s", disp_buf);
	}
	else {
		sprintf(rm->str, "%s(%s%s)", disp_buf, base_buf, index_buf);
 805d006:	83 ec 0c             	sub    $0xc,%esp
 805d009:	56                   	push   %esi
 805d00a:	53                   	push   %ebx
 805d00b:	55                   	push   %ebp
 805d00c:	68 79 5a 06 08       	push   $0x8065a79
 805d011:	8b 44 24 74          	mov    0x74(%esp),%eax
 805d015:	83 c0 10             	add    $0x10,%eax
 805d018:	50                   	push   %eax
 805d019:	e8 72 bb fe ff       	call   8048b90 <sprintf@plt>
 805d01e:	83 c4 20             	add    $0x20,%esp
	}
#endif

	rm->type = OP_TYPE_MEM;
 805d021:	8b 44 24 58          	mov    0x58(%esp),%eax
	rm->addr = addr;
 805d025:	8b 4c 24 08          	mov    0x8(%esp),%ecx
	else {
		sprintf(rm->str, "%s(%s%s)", disp_buf, base_buf, index_buf);
	}
#endif

	rm->type = OP_TYPE_MEM;
 805d029:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	rm->addr = addr;
 805d02f:	89 48 08             	mov    %ecx,0x8(%eax)

	return instr_len;
}
 805d032:	83 c4 3c             	add    $0x3c,%esp
 805d035:	5b                   	pop    %ebx
 805d036:	89 f8                	mov    %edi,%eax
 805d038:	5e                   	pop    %esi
 805d039:	5f                   	pop    %edi
 805d03a:	5d                   	pop    %ebp
 805d03b:	c3                   	ret    
 805d03c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	if(m->mod == 0) {
		if(base_reg == R_EBP) { base_reg = -1; }
		else { disp_size = 0; }
	}
	else if(m->mod == 1) { disp_size = 1; }
 805d040:	3c 40                	cmp    $0x40,%al
 805d042:	0f 84 a8 00 00 00    	je     805d0f0 <load_addr+0x1e0>
 805d048:	83 ec 08             	sub    $0x8,%esp
 805d04b:	6a 04                	push   $0x4

	instr_len = disp_offset;
	if(disp_size != 0) {
		/* has disp */
		disp = instr_fetch(eip + disp_offset, disp_size);
 805d04d:	8b 44 24 5c          	mov    0x5c(%esp),%eax
 805d051:	01 f8                	add    %edi,%eax
 805d053:	50                   	push   %eax
 805d054:	e8 f7 de fe ff       	call   804af50 <swaddr_read>
 805d059:	83 c4 10             	add    $0x10,%esp
 805d05c:	89 c5                	mov    %eax,%ebp
 805d05e:	b8 04 00 00 00       	mov    $0x4,%eax
		if(disp_size == 1) { disp = (int8_t)disp; }

		instr_len += disp_size;
 805d063:	01 c7                	add    %eax,%edi
		addr += disp;
	}

	if(base_reg != -1) {
 805d065:	83 fb ff             	cmp    $0xffffffff,%ebx
		/* has disp */
		disp = instr_fetch(eip + disp_offset, disp_size);
		if(disp_size == 1) { disp = (int8_t)disp; }

		instr_len += disp_size;
		addr += disp;
 805d068:	89 6c 24 08          	mov    %ebp,0x8(%esp)
	}

	if(base_reg != -1) {
 805d06c:	0f 85 f5 fe ff ff    	jne    805cf67 <load_addr+0x57>
 805d072:	e9 01 ff ff ff       	jmp    805cf78 <load_addr+0x68>
 805d077:	89 f6                	mov    %esi,%esi
 805d079:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	}
	else { disp_buf[0] = '\0'; }

	if(base_reg == -1) { base_buf[0] = '\0'; }
	else { 
		sprintf(base_buf, "%%%s", regsl[base_reg]); 
 805d080:	83 ec 04             	sub    $0x4,%esp
 805d083:	ff 34 9d c0 5c 07 08 	pushl  0x8075cc0(,%ebx,4)
 805d08a:	68 3a 29 06 08       	push   $0x806293a
 805d08f:	8d 5c 24 1c          	lea    0x1c(%esp),%ebx
 805d093:	53                   	push   %ebx
 805d094:	e8 f7 ba fe ff       	call   8048b90 <sprintf@plt>
	}

	if(index_reg == -1) { index_buf[0] = '\0'; }
 805d099:	83 c4 10             	add    $0x10,%esp
 805d09c:	83 fe ff             	cmp    $0xffffffff,%esi
 805d09f:	0f 85 3b ff ff ff    	jne    805cfe0 <load_addr+0xd0>
 805d0a5:	c6 44 24 18 00       	movb   $0x0,0x18(%esp)
 805d0aa:	8d 74 24 18          	lea    0x18(%esp),%esi
 805d0ae:	e9 53 ff ff ff       	jmp    805d006 <load_addr+0xf6>
 805d0b3:	90                   	nop
 805d0b4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

	if(disp_size != 0) {
		/* has disp */
		sprintf(disp_buf, "%s%#x", (disp < 0 ? "-" : ""), (disp < 0 ? -disp : disp));
	}
	else { disp_buf[0] = '\0'; }
 805d0b8:	c6 44 24 20 00       	movb   $0x0,0x20(%esp)
 805d0bd:	8d 6c 24 20          	lea    0x20(%esp),%ebp
 805d0c1:	e9 ff fe ff ff       	jmp    805cfc5 <load_addr+0xb5>
 805d0c6:	8d 76 00             	lea    0x0(%esi),%esi
 805d0c9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	else { 
		sprintf(index_buf, ",%%%s,%d", regsl[index_reg], 1 << scale); 
	}

	if(base_reg == -1 && index_reg == -1) {
		sprintf(rm->str, "%s", disp_buf);
 805d0d0:	83 ec 08             	sub    $0x8,%esp
 805d0d3:	55                   	push   %ebp
 805d0d4:	8b 44 24 64          	mov    0x64(%esp),%eax
 805d0d8:	83 c0 10             	add    $0x10,%eax
 805d0db:	50                   	push   %eax
 805d0dc:	e8 5f b9 fe ff       	call   8048a40 <strcpy@plt>
 805d0e1:	83 c4 10             	add    $0x10,%esp
 805d0e4:	e9 38 ff ff ff       	jmp    805d021 <load_addr+0x111>
 805d0e9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805d0f0:	83 ec 08             	sub    $0x8,%esp
 805d0f3:	6a 01                	push   $0x1
	else if(m->mod == 1) { disp_size = 1; }

	instr_len = disp_offset;
	if(disp_size != 0) {
		/* has disp */
		disp = instr_fetch(eip + disp_offset, disp_size);
 805d0f5:	8b 44 24 5c          	mov    0x5c(%esp),%eax
 805d0f9:	01 f8                	add    %edi,%eax
 805d0fb:	50                   	push   %eax
 805d0fc:	e8 4f de fe ff       	call   804af50 <swaddr_read>
		if(disp_size == 1) { disp = (int8_t)disp; }
 805d101:	83 c4 10             	add    $0x10,%esp
 805d104:	0f be e8             	movsbl %al,%ebp

	if(m->mod == 0) {
		if(base_reg == R_EBP) { base_reg = -1; }
		else { disp_size = 0; }
	}
	else if(m->mod == 1) { disp_size = 1; }
 805d107:	b8 01 00 00 00       	mov    $0x1,%eax
 805d10c:	e9 52 ff ff ff       	jmp    805d063 <load_addr+0x153>
 805d111:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
		base_reg = m->R_M;
		disp_offset = 1;
	}

	if(m->mod == 0) {
		if(base_reg == R_EBP) { base_reg = -1; }
 805d118:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
 805d11d:	e9 26 ff ff ff       	jmp    805d048 <load_addr+0x138>
 805d122:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805d128:	83 ec 08             	sub    $0x8,%esp
int load_addr(swaddr_t eip, ModR_M *m, Operand *rm) {
	assert(m->mod != 3);

	int32_t disp;
	int instr_len, disp_offset, disp_size = 4;
	int base_reg = -1, index_reg = -1, scale = 0;
 805d12b:	be ff ff ff ff       	mov    $0xffffffff,%esi
 805d130:	6a 01                	push   $0x1
	swaddr_t addr = 0;

	if(m->R_M == R_ESP) {
		SIB s;
		s.val = instr_fetch(eip + 1, 1);
 805d132:	8b 44 24 5c          	mov    0x5c(%esp),%eax
 805d136:	83 c0 01             	add    $0x1,%eax
 805d139:	50                   	push   %eax
 805d13a:	e8 11 de fe ff       	call   804af50 <swaddr_read>
		base_reg = s.base;
		disp_offset = 2;
		scale = s.ss;
 805d13f:	89 c2                	mov    %eax,%edx
	swaddr_t addr = 0;

	if(m->R_M == R_ESP) {
		SIB s;
		s.val = instr_fetch(eip + 1, 1);
		base_reg = s.base;
 805d141:	89 c3                	mov    %eax,%ebx
		disp_offset = 2;
		scale = s.ss;
 805d143:	c0 ea 06             	shr    $0x6,%dl
	swaddr_t addr = 0;

	if(m->R_M == R_ESP) {
		SIB s;
		s.val = instr_fetch(eip + 1, 1);
		base_reg = s.base;
 805d146:	83 e3 07             	and    $0x7,%ebx
		disp_offset = 2;
		scale = s.ss;
 805d149:	0f b6 ca             	movzbl %dl,%ecx

		if(s.index != R_ESP) { index_reg = s.index; }
 805d14c:	89 c2                	mov    %eax,%edx
 805d14e:	83 e2 38             	and    $0x38,%edx
	if(m->R_M == R_ESP) {
		SIB s;
		s.val = instr_fetch(eip + 1, 1);
		base_reg = s.base;
		disp_offset = 2;
		scale = s.ss;
 805d151:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)

		if(s.index != R_ESP) { index_reg = s.index; }
 805d155:	83 c4 10             	add    $0x10,%esp
 805d158:	80 fa 20             	cmp    $0x20,%dl
 805d15b:	74 08                	je     805d165 <load_addr+0x255>
 805d15d:	c0 e8 03             	shr    $0x3,%al
 805d160:	89 c6                	mov    %eax,%esi
 805d162:	83 e6 07             	and    $0x7,%esi
 805d165:	0f b6 07             	movzbl (%edi),%eax

	if(m->R_M == R_ESP) {
		SIB s;
		s.val = instr_fetch(eip + 1, 1);
		base_reg = s.base;
		disp_offset = 2;
 805d168:	bf 02 00 00 00       	mov    $0x2,%edi
 805d16d:	83 e0 c0             	and    $0xffffffc0,%eax
 805d170:	e9 d7 fd ff ff       	jmp    805cf4c <load_addr+0x3c>
#include "cpu/decode/modrm.h"
#include "cpu/helper.h"

int load_addr(swaddr_t eip, ModR_M *m, Operand *rm) {
	assert(m->mod != 3);
 805d175:	68 9e 5a 06 08       	push   $0x8065a9e
 805d17a:	6a 05                	push   $0x5
 805d17c:	68 42 5a 06 08       	push   $0x8065a42
 805d181:	68 5e 5a 06 08       	push   $0x8065a5e
 805d186:	e8 25 ba fe ff       	call   8048bb0 <__assert_fail@plt>
 805d18b:	90                   	nop
 805d18c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805d190 <read_ModR_M>:
	rm->addr = addr;

	return instr_len;
}

int read_ModR_M(swaddr_t eip, Operand *rm, Operand *reg) {
 805d190:	57                   	push   %edi
 805d191:	56                   	push   %esi
 805d192:	53                   	push   %ebx
 805d193:	83 ec 18             	sub    $0x18,%esp
 805d196:	8b 7c 24 28          	mov    0x28(%esp),%edi
 805d19a:	8b 74 24 30          	mov    0x30(%esp),%esi
 805d19e:	8b 5c 24 2c          	mov    0x2c(%esp),%ebx
 805d1a2:	6a 01                	push   $0x1
 805d1a4:	57                   	push   %edi
 805d1a5:	e8 a6 dd fe ff       	call   804af50 <swaddr_read>
	ModR_M m;
	m.val = instr_fetch(eip, 1);
	reg->type = OP_TYPE_REG;
	reg->reg = m.reg;
 805d1aa:	89 c2                	mov    %eax,%edx
	return instr_len;
}

int read_ModR_M(swaddr_t eip, Operand *rm, Operand *reg) {
	ModR_M m;
	m.val = instr_fetch(eip, 1);
 805d1ac:	88 44 24 1f          	mov    %al,0x1f(%esp)
	reg->type = OP_TYPE_REG;
	reg->reg = m.reg;

	if(m.mod == 3) {
 805d1b0:	83 c4 10             	add    $0x10,%esp

int read_ModR_M(swaddr_t eip, Operand *rm, Operand *reg) {
	ModR_M m;
	m.val = instr_fetch(eip, 1);
	reg->type = OP_TYPE_REG;
	reg->reg = m.reg;
 805d1b3:	c0 ea 03             	shr    $0x3,%dl
}

int read_ModR_M(swaddr_t eip, Operand *rm, Operand *reg) {
	ModR_M m;
	m.val = instr_fetch(eip, 1);
	reg->type = OP_TYPE_REG;
 805d1b6:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
	reg->reg = m.reg;
 805d1bc:	83 e2 07             	and    $0x7,%edx
 805d1bf:	89 56 08             	mov    %edx,0x8(%esi)

	if(m.mod == 3) {
 805d1c2:	89 c2                	mov    %eax,%edx
 805d1c4:	83 e2 c0             	and    $0xffffffc0,%edx
 805d1c7:	80 fa c0             	cmp    $0xc0,%dl
 805d1ca:	74 34                	je     805d200 <read_ModR_M+0x70>
		}
#endif
		return 1;
	}
	else {
		int instr_len = load_addr(eip, &m, rm);
 805d1cc:	83 ec 04             	sub    $0x4,%esp
 805d1cf:	53                   	push   %ebx
 805d1d0:	8d 44 24 17          	lea    0x17(%esp),%eax
 805d1d4:	50                   	push   %eax
 805d1d5:	57                   	push   %edi
 805d1d6:	e8 35 fd ff ff       	call   805cf10 <load_addr>
 805d1db:	89 c6                	mov    %eax,%esi
		rm->val = swaddr_read(rm->addr, rm->size);
 805d1dd:	58                   	pop    %eax
 805d1de:	5a                   	pop    %edx
 805d1df:	ff 73 04             	pushl  0x4(%ebx)
 805d1e2:	ff 73 08             	pushl  0x8(%ebx)
 805d1e5:	e8 66 dd fe ff       	call   804af50 <swaddr_read>
		return instr_len;
 805d1ea:	83 c4 10             	add    $0x10,%esp
#endif
		return 1;
	}
	else {
		int instr_len = load_addr(eip, &m, rm);
		rm->val = swaddr_read(rm->addr, rm->size);
 805d1ed:	89 43 0c             	mov    %eax,0xc(%ebx)
		return instr_len;
 805d1f0:	89 f0                	mov    %esi,%eax
	}
}
 805d1f2:	83 c4 10             	add    $0x10,%esp
 805d1f5:	5b                   	pop    %ebx
 805d1f6:	5e                   	pop    %esi
 805d1f7:	5f                   	pop    %edi
 805d1f8:	c3                   	ret    
 805d1f9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
	reg->reg = m.reg;

	if(m.mod == 3) {
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
		switch(rm->size) {
 805d200:	8b 4b 04             	mov    0x4(%ebx),%ecx
	reg->type = OP_TYPE_REG;
	reg->reg = m.reg;

	if(m.mod == 3) {
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
 805d203:	89 c2                	mov    %eax,%edx
	m.val = instr_fetch(eip, 1);
	reg->type = OP_TYPE_REG;
	reg->reg = m.reg;

	if(m.mod == 3) {
		rm->type = OP_TYPE_REG;
 805d205:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		rm->reg = m.R_M;
 805d20b:	83 e2 07             	and    $0x7,%edx
 805d20e:	89 53 08             	mov    %edx,0x8(%ebx)
		switch(rm->size) {
 805d211:	83 f9 02             	cmp    $0x2,%ecx
 805d214:	0f 84 86 00 00 00    	je     805d2a0 <read_ModR_M+0x110>
 805d21a:	83 f9 04             	cmp    $0x4,%ecx
 805d21d:	74 61                	je     805d280 <read_ModR_M+0xf0>
 805d21f:	83 f9 01             	cmp    $0x1,%ecx
 805d222:	74 1c                	je     805d240 <read_ModR_M+0xb0>
			case 1: rm->val = reg_b(m.R_M); break;
			case 2: rm->val = reg_w(m.R_M); break;
			case 4: rm->val = reg_l(m.R_M); break;
			default: assert(0);
 805d224:	68 82 5a 06 08       	push   $0x8065a82
 805d229:	6a 63                	push   $0x63
 805d22b:	68 42 5a 06 08       	push   $0x8065a42
 805d230:	68 1c ea 05 08       	push   $0x805ea1c
 805d235:	e8 76 b9 fe ff       	call   8048bb0 <__assert_fail@plt>
 805d23a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

	if(m.mod == 3) {
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
		switch(rm->size) {
			case 1: rm->val = reg_b(m.R_M); break;
 805d240:	89 d1                	mov    %edx,%ecx
 805d242:	83 e0 03             	and    $0x3,%eax
			case 4: rm->val = reg_l(m.R_M); break;
			default: assert(0);
		}
#ifdef DEBUG
		switch(rm->size) {
			case 1: sprintf(rm->str, "%%%s", regsb[m.R_M]); break;
 805d245:	83 ec 04             	sub    $0x4,%esp

	if(m.mod == 3) {
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
		switch(rm->size) {
			case 1: rm->val = reg_b(m.R_M); break;
 805d248:	c1 f9 02             	sar    $0x2,%ecx
 805d24b:	0f b6 84 81 c0 af 0f 	movzbl 0x100fafc0(%ecx,%eax,4),%eax
 805d252:	10 
 805d253:	89 43 0c             	mov    %eax,0xc(%ebx)
			case 4: rm->val = reg_l(m.R_M); break;
			default: assert(0);
		}
#ifdef DEBUG
		switch(rm->size) {
			case 1: sprintf(rm->str, "%%%s", regsb[m.R_M]); break;
 805d256:	ff 34 95 80 5c 07 08 	pushl  0x8075c80(,%edx,4)
			case 2: sprintf(rm->str, "%%%s", regsw[m.R_M]); break;
			case 4: sprintf(rm->str, "%%%s", regsl[m.R_M]); break;
 805d25d:	83 c3 10             	add    $0x10,%ebx
 805d260:	68 3a 29 06 08       	push   $0x806293a
 805d265:	53                   	push   %ebx
 805d266:	e8 25 b9 fe ff       	call   8048b90 <sprintf@plt>
 805d26b:	83 c4 10             	add    $0x10,%esp
		}
#endif
		return 1;
 805d26e:	b8 01 00 00 00       	mov    $0x1,%eax
	else {
		int instr_len = load_addr(eip, &m, rm);
		rm->val = swaddr_read(rm->addr, rm->size);
		return instr_len;
	}
}
 805d273:	83 c4 10             	add    $0x10,%esp
 805d276:	5b                   	pop    %ebx
 805d277:	5e                   	pop    %esi
 805d278:	5f                   	pop    %edi
 805d279:	c3                   	ret    
 805d27a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
		switch(rm->size) {
			case 1: rm->val = reg_b(m.R_M); break;
			case 2: rm->val = reg_w(m.R_M); break;
			case 4: rm->val = reg_l(m.R_M); break;
 805d280:	8b 04 95 c0 af 0f 10 	mov    0x100fafc0(,%edx,4),%eax
		}
#ifdef DEBUG
		switch(rm->size) {
			case 1: sprintf(rm->str, "%%%s", regsb[m.R_M]); break;
			case 2: sprintf(rm->str, "%%%s", regsw[m.R_M]); break;
			case 4: sprintf(rm->str, "%%%s", regsl[m.R_M]); break;
 805d287:	83 ec 04             	sub    $0x4,%esp
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
		switch(rm->size) {
			case 1: rm->val = reg_b(m.R_M); break;
			case 2: rm->val = reg_w(m.R_M); break;
			case 4: rm->val = reg_l(m.R_M); break;
 805d28a:	89 43 0c             	mov    %eax,0xc(%ebx)
		}
#ifdef DEBUG
		switch(rm->size) {
			case 1: sprintf(rm->str, "%%%s", regsb[m.R_M]); break;
			case 2: sprintf(rm->str, "%%%s", regsw[m.R_M]); break;
			case 4: sprintf(rm->str, "%%%s", regsl[m.R_M]); break;
 805d28d:	ff 34 95 c0 5c 07 08 	pushl  0x8075cc0(,%edx,4)
 805d294:	eb c7                	jmp    805d25d <read_ModR_M+0xcd>
 805d296:	8d 76 00             	lea    0x0(%esi),%esi
 805d299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
	if(m.mod == 3) {
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
		switch(rm->size) {
			case 1: rm->val = reg_b(m.R_M); break;
			case 2: rm->val = reg_w(m.R_M); break;
 805d2a0:	0f b7 04 95 c0 af 0f 	movzwl 0x100fafc0(,%edx,4),%eax
 805d2a7:	10 
			default: assert(0);
		}
#ifdef DEBUG
		switch(rm->size) {
			case 1: sprintf(rm->str, "%%%s", regsb[m.R_M]); break;
			case 2: sprintf(rm->str, "%%%s", regsw[m.R_M]); break;
 805d2a8:	83 ec 04             	sub    $0x4,%esp
	if(m.mod == 3) {
		rm->type = OP_TYPE_REG;
		rm->reg = m.R_M;
		switch(rm->size) {
			case 1: rm->val = reg_b(m.R_M); break;
			case 2: rm->val = reg_w(m.R_M); break;
 805d2ab:	89 43 0c             	mov    %eax,0xc(%ebx)
			default: assert(0);
		}
#ifdef DEBUG
		switch(rm->size) {
			case 1: sprintf(rm->str, "%%%s", regsb[m.R_M]); break;
			case 2: sprintf(rm->str, "%%%s", regsw[m.R_M]); break;
 805d2ae:	ff 34 95 a0 5c 07 08 	pushl  0x8075ca0(,%edx,4)
 805d2b5:	eb a6                	jmp    805d25d <read_ModR_M+0xcd>
 805d2b7:	66 90                	xchg   %ax,%ax
 805d2b9:	66 90                	xchg   %ax,%ax
 805d2bb:	66 90                	xchg   %ax,%ax
 805d2bd:	66 90                	xchg   %ax,%ax
 805d2bf:	90                   	nop

0805d2c0 <reg_test>:

const char *regsl[] = {"eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"};
const char *regsw[] = {"ax", "cx", "dx", "bx", "sp", "bp", "si", "di"};
const char *regsb[] = {"al", "cl", "dl", "bl", "ah", "ch", "dh", "bh"};

void reg_test() {
 805d2c0:	55                   	push   %ebp
 805d2c1:	57                   	push   %edi
 805d2c2:	56                   	push   %esi
 805d2c3:	53                   	push   %ebx
	uint32_t sample[8];
	uint32_t eip_sample = rand();
	cpu.eip = eip_sample;

	int i;
	for(i = R_EAX; i <= R_EDI; i ++) {
 805d2c4:	31 db                	xor    %ebx,%ebx

const char *regsl[] = {"eax", "ecx", "edx", "ebx", "esp", "ebp", "esi", "edi"};
const char *regsw[] = {"ax", "cx", "dx", "bx", "sp", "bp", "si", "di"};
const char *regsb[] = {"al", "cl", "dl", "bl", "ah", "ch", "dh", "bh"};

void reg_test() {
 805d2c6:	83 ec 38             	sub    $0x38,%esp
	srand(time(0));
 805d2c9:	6a 00                	push   $0x0
 805d2cb:	e8 f0 b6 fe ff       	call   80489c0 <time@plt>
 805d2d0:	89 04 24             	mov    %eax,(%esp)
 805d2d3:	e8 b8 b7 fe ff       	call   8048a90 <srand@plt>
	uint32_t sample[8];
	uint32_t eip_sample = rand();
 805d2d8:	e8 73 b8 fe ff       	call   8048b50 <rand@plt>
	cpu.eip = eip_sample;
 805d2dd:	83 c4 10             	add    $0x10,%esp
const char *regsb[] = {"al", "cl", "dl", "bl", "ah", "ch", "dh", "bh"};

void reg_test() {
	srand(time(0));
	uint32_t sample[8];
	uint32_t eip_sample = rand();
 805d2e0:	89 c6                	mov    %eax,%esi
	cpu.eip = eip_sample;
 805d2e2:	a3 e0 af 0f 10       	mov    %eax,0x100fafe0

	int i;
	for(i = R_EAX; i <= R_EDI; i ++) {
		sample[i] = rand();
 805d2e7:	e8 64 b8 fe ff       	call   8048b50 <rand@plt>
 805d2ec:	89 04 9c             	mov    %eax,(%esp,%ebx,4)
		reg_l(i) = sample[i];
 805d2ef:	89 04 9d c0 af 0f 10 	mov    %eax,0x100fafc0(,%ebx,4)
	uint32_t sample[8];
	uint32_t eip_sample = rand();
	cpu.eip = eip_sample;

	int i;
	for(i = R_EAX; i <= R_EDI; i ++) {
 805d2f6:	83 c3 01             	add    $0x1,%ebx
 805d2f9:	83 fb 08             	cmp    $0x8,%ebx
 805d2fc:	75 e9                	jne    805d2e7 <reg_test+0x27>
		sample[i] = rand();
		reg_l(i) = sample[i];
		assert(reg_w(i) == (sample[i] & 0xffff));
	}

	assert(reg_b(R_AL) == (sample[R_EAX] & 0xff));
 805d2fe:	8b 14 24             	mov    (%esp),%edx
 805d301:	38 15 c0 af 0f 10    	cmp    %dl,0x100fafc0
 805d307:	0f 85 f8 00 00 00    	jne    805d405 <reg_test+0x145>
	assert(reg_b(R_AH) == ((sample[R_EAX] >> 8) & 0xff));
 805d30d:	89 d0                	mov    %edx,%eax
 805d30f:	c1 e8 08             	shr    $0x8,%eax
 805d312:	3a 05 c1 af 0f 10    	cmp    0x100fafc1,%al
 805d318:	0f 85 fd 00 00 00    	jne    805d41b <reg_test+0x15b>
	assert(reg_b(R_BL) == (sample[R_EBX] & 0xff));
 805d31e:	8b 44 24 0c          	mov    0xc(%esp),%eax
 805d322:	38 05 cc af 0f 10    	cmp    %al,0x100fafcc
 805d328:	0f 85 03 01 00 00    	jne    805d431 <reg_test+0x171>
	assert(reg_b(R_BH) == ((sample[R_EBX] >> 8) & 0xff));
 805d32e:	89 c1                	mov    %eax,%ecx
 805d330:	c1 e9 08             	shr    $0x8,%ecx
 805d333:	3a 0d cd af 0f 10    	cmp    0x100fafcd,%cl
 805d339:	0f 85 08 01 00 00    	jne    805d447 <reg_test+0x187>
	assert(reg_b(R_CL) == (sample[R_ECX] & 0xff));
 805d33f:	8b 5c 24 04          	mov    0x4(%esp),%ebx
 805d343:	38 1d c4 af 0f 10    	cmp    %bl,0x100fafc4
 805d349:	0f 85 0e 01 00 00    	jne    805d45d <reg_test+0x19d>
	assert(reg_b(R_CH) == ((sample[R_ECX] >> 8) & 0xff));
 805d34f:	89 d9                	mov    %ebx,%ecx
 805d351:	c1 e9 08             	shr    $0x8,%ecx
 805d354:	3a 0d c5 af 0f 10    	cmp    0x100fafc5,%cl
 805d35a:	0f 85 13 01 00 00    	jne    805d473 <reg_test+0x1b3>
	assert(reg_b(R_DL) == (sample[R_EDX] & 0xff));
 805d360:	8b 6c 24 08          	mov    0x8(%esp),%ebp
 805d364:	89 e9                	mov    %ebp,%ecx
 805d366:	38 0d c8 af 0f 10    	cmp    %cl,0x100fafc8
 805d36c:	0f 85 17 01 00 00    	jne    805d489 <reg_test+0x1c9>
	assert(reg_b(R_DH) == ((sample[R_EDX] >> 8) & 0xff));
 805d372:	89 ef                	mov    %ebp,%edi
 805d374:	c1 ef 08             	shr    $0x8,%edi
 805d377:	89 f9                	mov    %edi,%ecx
 805d379:	3a 0d c9 af 0f 10    	cmp    0x100fafc9,%cl
 805d37f:	0f 85 1a 01 00 00    	jne    805d49f <reg_test+0x1df>

	assert(sample[R_EAX] == cpu.eax);
 805d385:	3b 15 c0 af 0f 10    	cmp    0x100fafc0,%edx
 805d38b:	0f 85 24 01 00 00    	jne    805d4b5 <reg_test+0x1f5>
	assert(sample[R_ECX] == cpu.ecx);
 805d391:	3b 1d c4 af 0f 10    	cmp    0x100fafc4,%ebx
 805d397:	0f 85 2e 01 00 00    	jne    805d4cb <reg_test+0x20b>
	assert(sample[R_EDX] == cpu.edx);
 805d39d:	3b 2d c8 af 0f 10    	cmp    0x100fafc8,%ebp
 805d3a3:	0f 85 38 01 00 00    	jne    805d4e1 <reg_test+0x221>
	assert(sample[R_EBX] == cpu.ebx);
 805d3a9:	3b 05 cc af 0f 10    	cmp    0x100fafcc,%eax
 805d3af:	0f 85 42 01 00 00    	jne    805d4f7 <reg_test+0x237>
	assert(sample[R_ESP] == cpu.esp);
 805d3b5:	a1 d0 af 0f 10       	mov    0x100fafd0,%eax
 805d3ba:	39 44 24 10          	cmp    %eax,0x10(%esp)
 805d3be:	0f 85 49 01 00 00    	jne    805d50d <reg_test+0x24d>
	assert(sample[R_EBP] == cpu.ebp);
 805d3c4:	a1 d4 af 0f 10       	mov    0x100fafd4,%eax
 805d3c9:	39 44 24 14          	cmp    %eax,0x14(%esp)
 805d3cd:	0f 85 50 01 00 00    	jne    805d523 <reg_test+0x263>
	assert(sample[R_ESI] == cpu.esi);
 805d3d3:	a1 d8 af 0f 10       	mov    0x100fafd8,%eax
 805d3d8:	39 44 24 18          	cmp    %eax,0x18(%esp)
 805d3dc:	0f 85 57 01 00 00    	jne    805d539 <reg_test+0x279>
	assert(sample[R_EDI] == cpu.edi);
 805d3e2:	a1 dc af 0f 10       	mov    0x100fafdc,%eax
 805d3e7:	39 44 24 1c          	cmp    %eax,0x1c(%esp)
 805d3eb:	0f 85 5e 01 00 00    	jne    805d54f <reg_test+0x28f>

	assert(eip_sample == cpu.eip);
 805d3f1:	39 35 e0 af 0f 10    	cmp    %esi,0x100fafe0
 805d3f7:	0f 85 68 01 00 00    	jne    805d565 <reg_test+0x2a5>
}
 805d3fd:	83 c4 2c             	add    $0x2c,%esp
 805d400:	5b                   	pop    %ebx
 805d401:	5e                   	pop    %esi
 805d402:	5f                   	pop    %edi
 805d403:	5d                   	pop    %ebp
 805d404:	c3                   	ret    
		sample[i] = rand();
		reg_l(i) = sample[i];
		assert(reg_w(i) == (sample[i] & 0xffff));
	}

	assert(reg_b(R_AL) == (sample[R_EAX] & 0xff));
 805d405:	68 8a 5e 06 08       	push   $0x8065e8a
 805d40a:	6a 18                	push   $0x18
 805d40c:	68 a8 5a 06 08       	push   $0x8065aa8
 805d411:	68 ec 5b 06 08       	push   $0x8065bec
 805d416:	e8 95 b7 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(reg_b(R_AH) == ((sample[R_EAX] >> 8) & 0xff));
 805d41b:	68 8a 5e 06 08       	push   $0x8065e8a
 805d420:	6a 19                	push   $0x19
 805d422:	68 a8 5a 06 08       	push   $0x8065aa8
 805d427:	68 3c 5c 06 08       	push   $0x8065c3c
 805d42c:	e8 7f b7 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(reg_b(R_BL) == (sample[R_EBX] & 0xff));
 805d431:	68 8a 5e 06 08       	push   $0x8065e8a
 805d436:	6a 1a                	push   $0x1a
 805d438:	68 a8 5a 06 08       	push   $0x8065aa8
 805d43d:	68 94 5c 06 08       	push   $0x8065c94
 805d442:	e8 69 b7 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(reg_b(R_BH) == ((sample[R_EBX] >> 8) & 0xff));
 805d447:	68 8a 5e 06 08       	push   $0x8065e8a
 805d44c:	6a 1b                	push   $0x1b
 805d44e:	68 a8 5a 06 08       	push   $0x8065aa8
 805d453:	68 e4 5c 06 08       	push   $0x8065ce4
 805d458:	e8 53 b7 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(reg_b(R_CL) == (sample[R_ECX] & 0xff));
 805d45d:	68 8a 5e 06 08       	push   $0x8065e8a
 805d462:	6a 1c                	push   $0x1c
 805d464:	68 a8 5a 06 08       	push   $0x8065aa8
 805d469:	68 3c 5d 06 08       	push   $0x8065d3c
 805d46e:	e8 3d b7 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(reg_b(R_CH) == ((sample[R_ECX] >> 8) & 0xff));
 805d473:	68 8a 5e 06 08       	push   $0x8065e8a
 805d478:	6a 1d                	push   $0x1d
 805d47a:	68 a8 5a 06 08       	push   $0x8065aa8
 805d47f:	68 8c 5d 06 08       	push   $0x8065d8c
 805d484:	e8 27 b7 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(reg_b(R_DL) == (sample[R_EDX] & 0xff));
 805d489:	68 8a 5e 06 08       	push   $0x8065e8a
 805d48e:	6a 1e                	push   $0x1e
 805d490:	68 a8 5a 06 08       	push   $0x8065aa8
 805d495:	68 e4 5d 06 08       	push   $0x8065de4
 805d49a:	e8 11 b7 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(reg_b(R_DH) == ((sample[R_EDX] >> 8) & 0xff));
 805d49f:	68 8a 5e 06 08       	push   $0x8065e8a
 805d4a4:	6a 1f                	push   $0x1f
 805d4a6:	68 a8 5a 06 08       	push   $0x8065aa8
 805d4ab:	68 34 5e 06 08       	push   $0x8065e34
 805d4b0:	e8 fb b6 fe ff       	call   8048bb0 <__assert_fail@plt>

	assert(sample[R_EAX] == cpu.eax);
 805d4b5:	68 8a 5e 06 08       	push   $0x8065e8a
 805d4ba:	6a 21                	push   $0x21
 805d4bc:	68 a8 5a 06 08       	push   $0x8065aa8
 805d4c1:	68 bb 5a 06 08       	push   $0x8065abb
 805d4c6:	e8 e5 b6 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(sample[R_ECX] == cpu.ecx);
 805d4cb:	68 8a 5e 06 08       	push   $0x8065e8a
 805d4d0:	6a 22                	push   $0x22
 805d4d2:	68 a8 5a 06 08       	push   $0x8065aa8
 805d4d7:	68 d4 5a 06 08       	push   $0x8065ad4
 805d4dc:	e8 cf b6 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(sample[R_EDX] == cpu.edx);
 805d4e1:	68 8a 5e 06 08       	push   $0x8065e8a
 805d4e6:	6a 23                	push   $0x23
 805d4e8:	68 a8 5a 06 08       	push   $0x8065aa8
 805d4ed:	68 ed 5a 06 08       	push   $0x8065aed
 805d4f2:	e8 b9 b6 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(sample[R_EBX] == cpu.ebx);
 805d4f7:	68 8a 5e 06 08       	push   $0x8065e8a
 805d4fc:	6a 24                	push   $0x24
 805d4fe:	68 a8 5a 06 08       	push   $0x8065aa8
 805d503:	68 06 5b 06 08       	push   $0x8065b06
 805d508:	e8 a3 b6 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(sample[R_ESP] == cpu.esp);
 805d50d:	68 8a 5e 06 08       	push   $0x8065e8a
 805d512:	6a 25                	push   $0x25
 805d514:	68 a8 5a 06 08       	push   $0x8065aa8
 805d519:	68 1f 5b 06 08       	push   $0x8065b1f
 805d51e:	e8 8d b6 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(sample[R_EBP] == cpu.ebp);
 805d523:	68 8a 5e 06 08       	push   $0x8065e8a
 805d528:	6a 26                	push   $0x26
 805d52a:	68 a8 5a 06 08       	push   $0x8065aa8
 805d52f:	68 38 5b 06 08       	push   $0x8065b38
 805d534:	e8 77 b6 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(sample[R_ESI] == cpu.esi);
 805d539:	68 8a 5e 06 08       	push   $0x8065e8a
 805d53e:	6a 27                	push   $0x27
 805d540:	68 a8 5a 06 08       	push   $0x8065aa8
 805d545:	68 51 5b 06 08       	push   $0x8065b51
 805d54a:	e8 61 b6 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(sample[R_EDI] == cpu.edi);
 805d54f:	68 8a 5e 06 08       	push   $0x8065e8a
 805d554:	6a 28                	push   $0x28
 805d556:	68 a8 5a 06 08       	push   $0x8065aa8
 805d55b:	68 6a 5b 06 08       	push   $0x8065b6a
 805d560:	e8 4b b6 fe ff       	call   8048bb0 <__assert_fail@plt>

	assert(eip_sample == cpu.eip);
 805d565:	68 8a 5e 06 08       	push   $0x8065e8a
 805d56a:	6a 2a                	push   $0x2a
 805d56c:	68 a8 5a 06 08       	push   $0x8065aa8
 805d571:	68 83 5b 06 08       	push   $0x8065b83
 805d576:	e8 35 b6 fe ff       	call   8048bb0 <__assert_fail@plt>
 805d57b:	66 90                	xchg   %ax,%ax
 805d57d:	66 90                	xchg   %ax,%ax
 805d57f:	90                   	nop

0805d580 <add_mmio_map>:

static MMIO_t maps[NR_MAP];
static int nr_map = 0;

/* device interface */
void* add_mmio_map(hwaddr_t addr, size_t len, mmio_callback_t callback) {
 805d580:	55                   	push   %ebp
 805d581:	57                   	push   %edi
 805d582:	56                   	push   %esi
 805d583:	53                   	push   %ebx
 805d584:	83 ec 0c             	sub    $0xc,%esp
	assert(nr_map < NR_MAP);
 805d587:	8b 15 c0 82 07 08    	mov    0x80782c0,%edx

static MMIO_t maps[NR_MAP];
static int nr_map = 0;

/* device interface */
void* add_mmio_map(hwaddr_t addr, size_t len, mmio_callback_t callback) {
 805d58d:	8b 74 24 20          	mov    0x20(%esp),%esi
 805d591:	8b 5c 24 24          	mov    0x24(%esp),%ebx
	assert(nr_map < NR_MAP);
 805d595:	83 fa 07             	cmp    $0x7,%edx
 805d598:	7f 51                	jg     805d5eb <add_mmio_map+0x6b>
	assert(mmio_space_free_index + len <= MMIO_SPACE_MAX);
 805d59a:	a1 80 83 07 08       	mov    0x8078380,%eax
 805d59f:	8d 3c 03             	lea    (%ebx,%eax,1),%edi
 805d5a2:	81 ff 00 00 04 00    	cmp    $0x40000,%edi
 805d5a8:	77 57                	ja     805d601 <add_mmio_map+0x81>

	uint8_t *space_base = &mmio_space_pool[mmio_space_free_index];
	maps[nr_map].low = addr;
	maps[nr_map].high = addr + len - 1;
 805d5aa:	8d 5c 1e ff          	lea    -0x1(%esi,%ebx,1),%ebx
void* add_mmio_map(hwaddr_t addr, size_t len, mmio_callback_t callback) {
	assert(nr_map < NR_MAP);
	assert(mmio_space_free_index + len <= MMIO_SPACE_MAX);

	uint8_t *space_base = &mmio_space_pool[mmio_space_free_index];
	maps[nr_map].low = addr;
 805d5ae:	89 d5                	mov    %edx,%ebp
/* device interface */
void* add_mmio_map(hwaddr_t addr, size_t len, mmio_callback_t callback) {
	assert(nr_map < NR_MAP);
	assert(mmio_space_free_index + len <= MMIO_SPACE_MAX);

	uint8_t *space_base = &mmio_space_pool[mmio_space_free_index];
 805d5b0:	05 c0 83 07 08       	add    $0x80783c0,%eax
	maps[nr_map].low = addr;
 805d5b5:	c1 e5 04             	shl    $0x4,%ebp
	maps[nr_map].high = addr + len - 1;
	maps[nr_map].mmio_space = space_base;
	maps[nr_map].callback = callback;
	nr_map ++;
 805d5b8:	83 c2 01             	add    $0x1,%edx
	mmio_space_free_index += len;
 805d5bb:	89 3d 80 83 07 08    	mov    %edi,0x8078380
	assert(nr_map < NR_MAP);
	assert(mmio_space_free_index + len <= MMIO_SPACE_MAX);

	uint8_t *space_base = &mmio_space_pool[mmio_space_free_index];
	maps[nr_map].low = addr;
	maps[nr_map].high = addr + len - 1;
 805d5c1:	89 9d 04 83 07 08    	mov    %ebx,0x8078304(%ebp)
	maps[nr_map].mmio_space = space_base;
	maps[nr_map].callback = callback;
 805d5c7:	8b 5c 24 28          	mov    0x28(%esp),%ebx
void* add_mmio_map(hwaddr_t addr, size_t len, mmio_callback_t callback) {
	assert(nr_map < NR_MAP);
	assert(mmio_space_free_index + len <= MMIO_SPACE_MAX);

	uint8_t *space_base = &mmio_space_pool[mmio_space_free_index];
	maps[nr_map].low = addr;
 805d5cb:	89 b5 00 83 07 08    	mov    %esi,0x8078300(%ebp)
	maps[nr_map].high = addr + len - 1;
	maps[nr_map].mmio_space = space_base;
 805d5d1:	89 85 08 83 07 08    	mov    %eax,0x8078308(%ebp)
	maps[nr_map].callback = callback;
	nr_map ++;
 805d5d7:	89 15 c0 82 07 08    	mov    %edx,0x80782c0

	uint8_t *space_base = &mmio_space_pool[mmio_space_free_index];
	maps[nr_map].low = addr;
	maps[nr_map].high = addr + len - 1;
	maps[nr_map].mmio_space = space_base;
	maps[nr_map].callback = callback;
 805d5dd:	89 9d 0c 83 07 08    	mov    %ebx,0x807830c(%ebp)
	nr_map ++;
	mmio_space_free_index += len;
	return space_base;
}
 805d5e3:	83 c4 0c             	add    $0xc,%esp
 805d5e6:	5b                   	pop    %ebx
 805d5e7:	5e                   	pop    %esi
 805d5e8:	5f                   	pop    %edi
 805d5e9:	5d                   	pop    %ebp
 805d5ea:	c3                   	ret    
static MMIO_t maps[NR_MAP];
static int nr_map = 0;

/* device interface */
void* add_mmio_map(hwaddr_t addr, size_t len, mmio_callback_t callback) {
	assert(nr_map < NR_MAP);
 805d5eb:	68 f9 5e 06 08       	push   $0x8065ef9
 805d5f0:	6a 17                	push   $0x17
 805d5f2:	68 93 5e 06 08       	push   $0x8065e93
 805d5f7:	68 ad 5e 06 08       	push   $0x8065ead
 805d5fc:	e8 af b5 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(mmio_space_free_index + len <= MMIO_SPACE_MAX);
 805d601:	68 f9 5e 06 08       	push   $0x8065ef9
 805d606:	6a 18                	push   $0x18
 805d608:	68 93 5e 06 08       	push   $0x8065e93
 805d60d:	68 b8 5e 06 08       	push   $0x8065eb8
 805d612:	e8 99 b5 fe ff       	call   8048bb0 <__assert_fail@plt>
 805d617:	89 f6                	mov    %esi,%esi
 805d619:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805d620 <is_mmio>:
	mmio_space_free_index += len;
	return space_base;
}

/* bus interface */
int is_mmio(hwaddr_t addr) {
 805d620:	53                   	push   %ebx
	int i;
	for(i = 0; i < nr_map; i ++) {
 805d621:	8b 1d c0 82 07 08    	mov    0x80782c0,%ebx
	mmio_space_free_index += len;
	return space_base;
}

/* bus interface */
int is_mmio(hwaddr_t addr) {
 805d627:	8b 4c 24 08          	mov    0x8(%esp),%ecx
	int i;
	for(i = 0; i < nr_map; i ++) {
 805d62b:	85 db                	test   %ebx,%ebx
 805d62d:	7e 24                	jle    805d653 <is_mmio+0x33>
 805d62f:	ba 00 83 07 08       	mov    $0x8078300,%edx
 805d634:	31 c0                	xor    %eax,%eax
 805d636:	8d 76 00             	lea    0x0(%esi),%esi
 805d639:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
		if(addr >= maps[i].low && addr <= maps[i].high) {
 805d640:	39 0a                	cmp    %ecx,(%edx)
 805d642:	77 05                	ja     805d649 <is_mmio+0x29>
 805d644:	3b 4a 04             	cmp    0x4(%edx),%ecx
 805d647:	76 0f                	jbe    805d658 <is_mmio+0x38>
}

/* bus interface */
int is_mmio(hwaddr_t addr) {
	int i;
	for(i = 0; i < nr_map; i ++) {
 805d649:	83 c0 01             	add    $0x1,%eax
 805d64c:	83 c2 10             	add    $0x10,%edx
 805d64f:	39 d8                	cmp    %ebx,%eax
 805d651:	75 ed                	jne    805d640 <is_mmio+0x20>
		if(addr >= maps[i].low && addr <= maps[i].high) {
			return i;
		}
	}
	return -1;
 805d653:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
 805d658:	5b                   	pop    %ebx
 805d659:	c3                   	ret    
 805d65a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi

0805d660 <mmio_read>:

uint32_t mmio_read(hwaddr_t addr, size_t len, int map_NO) {
 805d660:	57                   	push   %edi
 805d661:	56                   	push   %esi
 805d662:	53                   	push   %ebx
 805d663:	8b 44 24 14          	mov    0x14(%esp),%eax
 805d667:	8b 54 24 10          	mov    0x10(%esp),%edx
	assert(len == 1 || len == 2 || len == 4);
 805d66b:	8d 48 ff             	lea    -0x1(%eax),%ecx
 805d66e:	83 f9 01             	cmp    $0x1,%ecx
 805d671:	76 05                	jbe    805d678 <mmio_read+0x18>
 805d673:	83 f8 04             	cmp    $0x4,%eax
 805d676:	75 41                	jne    805d6b9 <mmio_read+0x59>
	MMIO_t *map = &maps[map_NO];
	uint32_t data = *(uint32_t *)(map->mmio_space + (addr - map->low)) 
		& (~0u >> ((4 - len) << 3));
 805d678:	b9 04 00 00 00       	mov    $0x4,%ecx
 805d67d:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
}

uint32_t mmio_read(hwaddr_t addr, size_t len, int map_NO) {
	assert(len == 1 || len == 2 || len == 4);
	MMIO_t *map = &maps[map_NO];
	uint32_t data = *(uint32_t *)(map->mmio_space + (addr - map->low)) 
 805d682:	89 d7                	mov    %edx,%edi
		& (~0u >> ((4 - len) << 3));
 805d684:	29 c1                	sub    %eax,%ecx
	map->callback(addr, len, false);
 805d686:	83 ec 04             	sub    $0x4,%esp

uint32_t mmio_read(hwaddr_t addr, size_t len, int map_NO) {
	assert(len == 1 || len == 2 || len == 4);
	MMIO_t *map = &maps[map_NO];
	uint32_t data = *(uint32_t *)(map->mmio_space + (addr - map->low)) 
		& (~0u >> ((4 - len) << 3));
 805d689:	c1 e1 03             	shl    $0x3,%ecx
 805d68c:	d3 eb                	shr    %cl,%ebx
}

uint32_t mmio_read(hwaddr_t addr, size_t len, int map_NO) {
	assert(len == 1 || len == 2 || len == 4);
	MMIO_t *map = &maps[map_NO];
	uint32_t data = *(uint32_t *)(map->mmio_space + (addr - map->low)) 
 805d68e:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
 805d692:	c1 e1 04             	shl    $0x4,%ecx
 805d695:	2b b9 00 83 07 08    	sub    0x8078300(%ecx),%edi
 805d69b:	8d b1 00 83 07 08    	lea    0x8078300(%ecx),%esi
 805d6a1:	89 f9                	mov    %edi,%ecx
 805d6a3:	8b 7e 08             	mov    0x8(%esi),%edi
 805d6a6:	23 1c 0f             	and    (%edi,%ecx,1),%ebx
		& (~0u >> ((4 - len) << 3));
	map->callback(addr, len, false);
 805d6a9:	6a 00                	push   $0x0
 805d6ab:	50                   	push   %eax
 805d6ac:	52                   	push   %edx
 805d6ad:	ff 56 0c             	call   *0xc(%esi)
	return data;
 805d6b0:	83 c4 10             	add    $0x10,%esp
}
 805d6b3:	89 d8                	mov    %ebx,%eax
 805d6b5:	5b                   	pop    %ebx
 805d6b6:	5e                   	pop    %esi
 805d6b7:	5f                   	pop    %edi
 805d6b8:	c3                   	ret    
	}
	return -1;
}

uint32_t mmio_read(hwaddr_t addr, size_t len, int map_NO) {
	assert(len == 1 || len == 2 || len == 4);
 805d6b9:	68 ef 5e 06 08       	push   $0x8065eef
 805d6be:	6a 30                	push   $0x30
 805d6c0:	68 93 5e 06 08       	push   $0x8065e93
 805d6c5:	68 40 f2 05 08       	push   $0x805f240
 805d6ca:	e8 e1 b4 fe ff       	call   8048bb0 <__assert_fail@plt>
 805d6cf:	90                   	nop

0805d6d0 <mmio_write>:
		& (~0u >> ((4 - len) << 3));
	map->callback(addr, len, false);
	return data;
}

void mmio_write(hwaddr_t addr, size_t len, uint32_t data, int map_NO) {
 805d6d0:	57                   	push   %edi
 805d6d1:	56                   	push   %esi
 805d6d2:	53                   	push   %ebx
 805d6d3:	83 ec 10             	sub    $0x10,%esp
 805d6d6:	8b 54 24 24          	mov    0x24(%esp),%edx
 805d6da:	8b 7c 24 20          	mov    0x20(%esp),%edi
 805d6de:	8b 74 24 2c          	mov    0x2c(%esp),%esi
	assert(len == 1 || len == 2 || len == 4);
 805d6e2:	8d 42 ff             	lea    -0x1(%edx),%eax
 805d6e5:	83 f8 01             	cmp    $0x1,%eax
 805d6e8:	76 05                	jbe    805d6ef <mmio_write+0x1f>
 805d6ea:	83 fa 04             	cmp    $0x4,%edx
 805d6ed:	75 61                	jne    805d750 <mmio_write+0x80>
	MMIO_t *map = &maps[map_NO];
	uint32_t mask = (~0u >> ((4 - len) << 3));
 805d6ef:	b9 04 00 00 00       	mov    $0x4,%ecx
 805d6f4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 805d6f9:	29 d1                	sub    %edx,%ecx
 805d6fb:	c1 e1 03             	shl    $0x3,%ecx
 805d6fe:	d3 e8                	shr    %cl,%eax
	memcpy_with_mask(map->mmio_space + (addr - map->low), &data, len, (void *)&mask);
 805d700:	89 f9                	mov    %edi,%ecx
}

void mmio_write(hwaddr_t addr, size_t len, uint32_t data, int map_NO) {
	assert(len == 1 || len == 2 || len == 4);
	MMIO_t *map = &maps[map_NO];
	uint32_t mask = (~0u >> ((4 - len) << 3));
 805d702:	89 44 24 0c          	mov    %eax,0xc(%esp)
	memcpy_with_mask(map->mmio_space + (addr - map->low), &data, len, (void *)&mask);
 805d706:	89 f0                	mov    %esi,%eax
 805d708:	c1 e0 04             	shl    $0x4,%eax
 805d70b:	2b 88 00 83 07 08    	sub    0x8078300(%eax),%ecx
 805d711:	8b 98 08 83 07 08    	mov    0x8078308(%eax),%ebx
 805d717:	31 c0                	xor    %eax,%eax
 805d719:	01 cb                	add    %ecx,%ebx
 805d71b:	85 d2                	test   %edx,%edx
 805d71d:	74 17                	je     805d736 <mmio_write+0x66>
 805d71f:	90                   	nop
		if(mask[i]) {
 805d720:	80 7c 04 0c 00       	cmpb   $0x0,0xc(%esp,%eax,1)
 805d725:	74 08                	je     805d72f <mmio_write+0x5f>
			((uint8_t *)dest)[i] = ((uint8_t *)src)[i];
 805d727:	0f b6 4c 04 28       	movzbl 0x28(%esp,%eax,1),%ecx
 805d72c:	88 0c 03             	mov    %cl,(%ebx,%eax,1)

#include "common.h"

inline static void memcpy_with_mask(void *dest, const void *src, size_t len, uint8_t *mask) {
	int i;
	for(i = 0; i < len; i ++) {
 805d72f:	83 c0 01             	add    $0x1,%eax
 805d732:	39 d0                	cmp    %edx,%eax
 805d734:	75 ea                	jne    805d720 <mmio_write+0x50>
	maps[map_NO].callback(addr, len, true);
 805d736:	83 ec 04             	sub    $0x4,%esp
 805d739:	c1 e6 04             	shl    $0x4,%esi
 805d73c:	6a 01                	push   $0x1
 805d73e:	52                   	push   %edx
 805d73f:	57                   	push   %edi
 805d740:	ff 96 0c 83 07 08    	call   *0x807830c(%esi)
}
 805d746:	83 c4 10             	add    $0x10,%esp
 805d749:	83 c4 10             	add    $0x10,%esp
 805d74c:	5b                   	pop    %ebx
 805d74d:	5e                   	pop    %esi
 805d74e:	5f                   	pop    %edi
 805d74f:	c3                   	ret    
	map->callback(addr, len, false);
	return data;
}

void mmio_write(hwaddr_t addr, size_t len, uint32_t data, int map_NO) {
	assert(len == 1 || len == 2 || len == 4);
 805d750:	68 e4 5e 06 08       	push   $0x8065ee4
 805d755:	6a 39                	push   $0x39
 805d757:	68 93 5e 06 08       	push   $0x8065e93
 805d75c:	68 40 f2 05 08       	push   $0x805f240
 805d761:	e8 4a b4 fe ff       	call   8048bb0 <__assert_fail@plt>
 805d766:	66 90                	xchg   %ax,%ax
 805d768:	66 90                	xchg   %ax,%ax
 805d76a:	66 90                	xchg   %ax,%ax
 805d76c:	66 90                	xchg   %ax,%ax
 805d76e:	66 90                	xchg   %ax,%ax

0805d770 <pio_callback>:
} PIO_t;

static PIO_t maps[NR_MAP];
static int nr_map = 0;

static void pio_callback(ioaddr_t addr, size_t len, bool is_write) {
 805d770:	55                   	push   %ebp
 805d771:	57                   	push   %edi
 805d772:	56                   	push   %esi
 805d773:	53                   	push   %ebx
 805d774:	83 ec 1c             	sub    $0x1c,%esp
	int i;
	for(i = 0; i < nr_map; i ++) {
 805d777:	8b 1d c0 83 0b 08    	mov    0x80b83c0,%ebx
} PIO_t;

static PIO_t maps[NR_MAP];
static int nr_map = 0;

static void pio_callback(ioaddr_t addr, size_t len, bool is_write) {
 805d77d:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
	int i;
	for(i = 0; i < nr_map; i ++) {
 805d781:	85 db                	test   %ebx,%ebx
 805d783:	7e 28                	jle    805d7ad <pio_callback+0x3d>
		if(addr >= maps[i].low && addr + len - 1 <= maps[i].high) {
 805d785:	0f b7 e8             	movzwl %ax,%ebp
static PIO_t maps[NR_MAP];
static int nr_map = 0;

static void pio_callback(ioaddr_t addr, size_t len, bool is_write) {
	int i;
	for(i = 0; i < nr_map; i ++) {
 805d788:	31 c9                	xor    %ecx,%ecx
		if(addr >= maps[i].low && addr + len - 1 <= maps[i].high) {
 805d78a:	8d 7c 2a ff          	lea    -0x1(%edx,%ebp,1),%edi
 805d78e:	66 90                	xchg   %ax,%ax
 805d790:	66 39 04 cd 00 84 0b 	cmp    %ax,0x80b8400(,%ecx,8)
 805d797:	08 
 805d798:	77 0c                	ja     805d7a6 <pio_callback+0x36>
 805d79a:	0f b7 34 cd 02 84 0b 	movzwl 0x80b8402(,%ecx,8),%esi
 805d7a1:	08 
 805d7a2:	39 f7                	cmp    %esi,%edi
 805d7a4:	76 12                	jbe    805d7b8 <pio_callback+0x48>
static PIO_t maps[NR_MAP];
static int nr_map = 0;

static void pio_callback(ioaddr_t addr, size_t len, bool is_write) {
	int i;
	for(i = 0; i < nr_map; i ++) {
 805d7a6:	83 c1 01             	add    $0x1,%ecx
 805d7a9:	39 d9                	cmp    %ebx,%ecx
 805d7ab:	75 e3                	jne    805d790 <pio_callback+0x20>
		if(addr >= maps[i].low && addr + len - 1 <= maps[i].high) {
			maps[i].callback(addr, len, is_write);
			return;
		}
	}
}
 805d7ad:	83 c4 1c             	add    $0x1c,%esp
 805d7b0:	5b                   	pop    %ebx
 805d7b1:	5e                   	pop    %esi
 805d7b2:	5f                   	pop    %edi
 805d7b3:	5d                   	pop    %ebp
 805d7b4:	c3                   	ret    
 805d7b5:	8d 76 00             	lea    0x0(%esi),%esi

static void pio_callback(ioaddr_t addr, size_t len, bool is_write) {
	int i;
	for(i = 0; i < nr_map; i ++) {
		if(addr >= maps[i].low && addr + len - 1 <= maps[i].high) {
			maps[i].callback(addr, len, is_write);
 805d7b8:	83 ec 04             	sub    $0x4,%esp
 805d7bb:	0f b6 44 24 10       	movzbl 0x10(%esp),%eax
 805d7c0:	50                   	push   %eax
 805d7c1:	52                   	push   %edx
 805d7c2:	55                   	push   %ebp
 805d7c3:	ff 14 cd 04 84 0b 08 	call   *0x80b8404(,%ecx,8)
			return;
 805d7ca:	83 c4 10             	add    $0x10,%esp
		}
	}
}
 805d7cd:	83 c4 1c             	add    $0x1c,%esp
 805d7d0:	5b                   	pop    %ebx
 805d7d1:	5e                   	pop    %esi
 805d7d2:	5f                   	pop    %edi
 805d7d3:	5d                   	pop    %ebp
 805d7d4:	c3                   	ret    
 805d7d5:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805d7d9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805d7e0 <add_pio_map>:

/* device interface */
void* add_pio_map(ioaddr_t addr, size_t len, pio_callback_t callback) {
 805d7e0:	56                   	push   %esi
 805d7e1:	53                   	push   %ebx
 805d7e2:	83 ec 04             	sub    $0x4,%esp
	assert(nr_map < NR_MAP);
 805d7e5:	8b 15 c0 83 0b 08    	mov    0x80b83c0,%edx
		}
	}
}

/* device interface */
void* add_pio_map(ioaddr_t addr, size_t len, pio_callback_t callback) {
 805d7eb:	8b 4c 24 10          	mov    0x10(%esp),%ecx
 805d7ef:	8b 5c 24 14          	mov    0x14(%esp),%ebx
	assert(nr_map < NR_MAP);
 805d7f3:	83 fa 07             	cmp    $0x7,%edx
 805d7f6:	7f 41                	jg     805d839 <add_pio_map+0x59>
	assert(addr + len <= PORT_IO_SPACE_MAX);
 805d7f8:	0f b7 c1             	movzwl %cx,%eax
 805d7fb:	8d 34 18             	lea    (%eax,%ebx,1),%esi
 805d7fe:	81 fe 00 00 01 00    	cmp    $0x10000,%esi
 805d804:	77 49                	ja     805d84f <add_pio_map+0x6f>
	maps[nr_map].low = addr;
 805d806:	66 89 0c d5 00 84 0b 	mov    %cx,0x80b8400(,%edx,8)
 805d80d:	08 
	maps[nr_map].high = addr + len - 1;
 805d80e:	8d 4c 19 ff          	lea    -0x1(%ecx,%ebx,1),%ecx
	maps[nr_map].callback = callback;
	nr_map ++;
	return pio_space + addr;
 805d812:	05 40 84 0b 08       	add    $0x80b8440,%eax
/* device interface */
void* add_pio_map(ioaddr_t addr, size_t len, pio_callback_t callback) {
	assert(nr_map < NR_MAP);
	assert(addr + len <= PORT_IO_SPACE_MAX);
	maps[nr_map].low = addr;
	maps[nr_map].high = addr + len - 1;
 805d817:	66 89 0c d5 02 84 0b 	mov    %cx,0x80b8402(,%edx,8)
 805d81e:	08 
	maps[nr_map].callback = callback;
 805d81f:	8b 4c 24 18          	mov    0x18(%esp),%ecx
 805d823:	89 0c d5 04 84 0b 08 	mov    %ecx,0x80b8404(,%edx,8)
	nr_map ++;
 805d82a:	83 c2 01             	add    $0x1,%edx
 805d82d:	89 15 c0 83 0b 08    	mov    %edx,0x80b83c0
	return pio_space + addr;
}
 805d833:	83 c4 04             	add    $0x4,%esp
 805d836:	5b                   	pop    %ebx
 805d837:	5e                   	pop    %esi
 805d838:	c3                   	ret    
	}
}

/* device interface */
void* add_pio_map(ioaddr_t addr, size_t len, pio_callback_t callback) {
	assert(nr_map < NR_MAP);
 805d839:	68 61 5f 06 08       	push   $0x8065f61
 805d83e:	6a 1f                	push   $0x1f
 805d840:	68 06 5f 06 08       	push   $0x8065f06
 805d845:	68 ad 5e 06 08       	push   $0x8065ead
 805d84a:	e8 61 b3 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(addr + len <= PORT_IO_SPACE_MAX);
 805d84f:	68 61 5f 06 08       	push   $0x8065f61
 805d854:	6a 20                	push   $0x20
 805d856:	68 06 5f 06 08       	push   $0x8065f06
 805d85b:	68 23 5f 06 08       	push   $0x8065f23
 805d860:	e8 4b b3 fe ff       	call   8048bb0 <__assert_fail@plt>
 805d865:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805d869:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0805d870 <pio_read>:
	return pio_space + addr;
}


/* CPU interface */
uint32_t pio_read(ioaddr_t addr, size_t len) {
 805d870:	56                   	push   %esi
 805d871:	53                   	push   %ebx
 805d872:	83 ec 04             	sub    $0x4,%esp
 805d875:	8b 74 24 14          	mov    0x14(%esp),%esi
 805d879:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	assert(len == 1 || len == 2 || len == 4);
 805d87d:	8d 46 ff             	lea    -0x1(%esi),%eax
 805d880:	83 f8 01             	cmp    $0x1,%eax
 805d883:	76 05                	jbe    805d88a <pio_read+0x1a>
 805d885:	83 fe 04             	cmp    $0x4,%esi
 805d888:	75 36                	jne    805d8c0 <pio_read+0x50>
	assert(addr + len - 1 < PORT_IO_SPACE_MAX);
 805d88a:	0f b7 db             	movzwl %bx,%ebx
 805d88d:	8d 44 33 ff          	lea    -0x1(%ebx,%esi,1),%eax
 805d891:	3d ff ff 00 00       	cmp    $0xffff,%eax
 805d896:	77 3e                	ja     805d8d6 <pio_read+0x66>
	pio_callback(addr, len, false);		// prepare data to read
 805d898:	89 d8                	mov    %ebx,%eax
 805d89a:	31 c9                	xor    %ecx,%ecx
 805d89c:	89 f2                	mov    %esi,%edx
 805d89e:	e8 cd fe ff ff       	call   805d770 <pio_callback>
	uint32_t data = *(uint32_t *)(pio_space + addr) & (~0u >> ((4 - len) << 3));
 805d8a3:	b9 04 00 00 00       	mov    $0x4,%ecx
 805d8a8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
 805d8ad:	29 f1                	sub    %esi,%ecx
 805d8af:	c1 e1 03             	shl    $0x3,%ecx
 805d8b2:	d3 e8                	shr    %cl,%eax
 805d8b4:	23 83 40 84 0b 08    	and    0x80b8440(%ebx),%eax
	return data;
}
 805d8ba:	83 c4 04             	add    $0x4,%esp
 805d8bd:	5b                   	pop    %ebx
 805d8be:	5e                   	pop    %esi
 805d8bf:	c3                   	ret    
}


/* CPU interface */
uint32_t pio_read(ioaddr_t addr, size_t len) {
	assert(len == 1 || len == 2 || len == 4);
 805d8c0:	68 58 5f 06 08       	push   $0x8065f58
 805d8c5:	6a 2b                	push   $0x2b
 805d8c7:	68 06 5f 06 08       	push   $0x8065f06
 805d8cc:	68 40 f2 05 08       	push   $0x805f240
 805d8d1:	e8 da b2 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(addr + len - 1 < PORT_IO_SPACE_MAX);
 805d8d6:	68 58 5f 06 08       	push   $0x8065f58
 805d8db:	6a 2c                	push   $0x2c
 805d8dd:	68 06 5f 06 08       	push   $0x8065f06
 805d8e2:	68 37 5f 06 08       	push   $0x8065f37
 805d8e7:	e8 c4 b2 fe ff       	call   8048bb0 <__assert_fail@plt>
 805d8ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

0805d8f0 <pio_write>:
	pio_callback(addr, len, false);		// prepare data to read
	uint32_t data = *(uint32_t *)(pio_space + addr) & (~0u >> ((4 - len) << 3));
	return data;
}

void pio_write(ioaddr_t addr, size_t len, uint32_t data) {
 805d8f0:	56                   	push   %esi
 805d8f1:	53                   	push   %ebx
 805d8f2:	83 ec 04             	sub    $0x4,%esp
 805d8f5:	8b 74 24 14          	mov    0x14(%esp),%esi
 805d8f9:	8b 5c 24 10          	mov    0x10(%esp),%ebx
	assert(len == 1 || len == 2 || len == 4);
 805d8fd:	8d 46 ff             	lea    -0x1(%esi),%eax
 805d900:	83 f8 01             	cmp    $0x1,%eax
 805d903:	76 05                	jbe    805d90a <pio_write+0x1a>
 805d905:	83 fe 04             	cmp    $0x4,%esi
 805d908:	75 37                	jne    805d941 <pio_write+0x51>
	assert(addr + len - 1 < PORT_IO_SPACE_MAX);
 805d90a:	0f b7 db             	movzwl %bx,%ebx
 805d90d:	8d 44 33 ff          	lea    -0x1(%ebx,%esi,1),%eax
 805d911:	3d ff ff 00 00       	cmp    $0xffff,%eax
 805d916:	77 3f                	ja     805d957 <pio_write+0x67>
	memcpy(pio_space + addr, &data, len);
 805d918:	8d 54 24 18          	lea    0x18(%esp),%edx
 805d91c:	8d 83 40 84 0b 08    	lea    0x80b8440(%ebx),%eax
 805d922:	83 ec 04             	sub    $0x4,%esp
 805d925:	56                   	push   %esi
 805d926:	52                   	push   %edx
 805d927:	50                   	push   %eax
 805d928:	e8 73 b0 fe ff       	call   80489a0 <memcpy@plt>
	pio_callback(addr, len, true);
 805d92d:	89 f2                	mov    %esi,%edx
 805d92f:	89 d8                	mov    %ebx,%eax
 805d931:	b9 01 00 00 00       	mov    $0x1,%ecx
 805d936:	e8 35 fe ff ff       	call   805d770 <pio_callback>
}
 805d93b:	83 c4 14             	add    $0x14,%esp
 805d93e:	5b                   	pop    %ebx
 805d93f:	5e                   	pop    %esi
 805d940:	c3                   	ret    
	uint32_t data = *(uint32_t *)(pio_space + addr) & (~0u >> ((4 - len) << 3));
	return data;
}

void pio_write(ioaddr_t addr, size_t len, uint32_t data) {
	assert(len == 1 || len == 2 || len == 4);
 805d941:	68 4e 5f 06 08       	push   $0x8065f4e
 805d946:	6a 33                	push   $0x33
 805d948:	68 06 5f 06 08       	push   $0x8065f06
 805d94d:	68 40 f2 05 08       	push   $0x805f240
 805d952:	e8 59 b2 fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(addr + len - 1 < PORT_IO_SPACE_MAX);
 805d957:	68 4e 5f 06 08       	push   $0x8065f4e
 805d95c:	6a 34                	push   $0x34
 805d95e:	68 06 5f 06 08       	push   $0x8065f06
 805d963:	68 37 5f 06 08       	push   $0x8065f37
 805d968:	e8 43 b2 fe ff       	call   8048bb0 <__assert_fail@plt>
 805d96d:	66 90                	xchg   %ax,%ax
 805d96f:	90                   	nop

0805d970 <timer_intr>:
#include "monitor/monitor.h"

#define TIMER_IRQ 0

void timer_intr() {
	if(nemu_state == RUNNING) {
 805d970:	83 3d 80 82 07 08 01 	cmpl   $0x1,0x8078280
 805d977:	74 07                	je     805d980 <timer_intr+0x10>
		i8259_raise_intr(TIMER_IRQ);
	}
}
 805d979:	c3                   	ret    
 805d97a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
#include "device/i8259.h"
#include "monitor/monitor.h"

#define TIMER_IRQ 0

void timer_intr() {
 805d980:	83 ec 18             	sub    $0x18,%esp
	if(nemu_state == RUNNING) {
		i8259_raise_intr(TIMER_IRQ);
 805d983:	6a 00                	push   $0x0
 805d985:	e8 26 01 00 00       	call   805dab0 <i8259_raise_intr>
	}
}
 805d98a:	83 c4 1c             	add    $0x1c,%esp
 805d98d:	c3                   	ret    
 805d98e:	66 90                	xchg   %ax,%ax

0805d990 <init_timer>:

void init_timer() {
 805d990:	f3 c3                	repz ret 
 805d992:	66 90                	xchg   %ax,%ax
 805d994:	66 90                	xchg   %ax,%ax
 805d996:	66 90                	xchg   %ax,%ax
 805d998:	66 90                	xchg   %ax,%ax
 805d99a:	66 90                	xchg   %ax,%ax
 805d99c:	66 90                	xchg   %ax,%ax
 805d99e:	66 90                	xchg   %ax,%ax

0805d9a0 <do_i8259>:
	5, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0, 
	4, 0, 1, 0, 2, 0, 1, 0, 3, 0, 1, 0, 2, 0, 1, 0
};

/* i8259 internal */
static void do_i8259() {
 805d9a0:	83 ec 0c             	sub    $0xc,%esp
	int8_t master_irq = master.highest_irq;
 805d9a3:	0f b6 05 4b 84 0c 08 	movzbl 0x80c844b,%eax
	if(master_irq == NO_INTR) {
 805d9aa:	3c ff                	cmp    $0xff,%al
 805d9ac:	0f 84 97 00 00 00    	je     805da49 <do_i8259+0xa9>
		 */
		// cpu.INTR = false;
		panic("uncomment the line above");
		return;
	}
	else if(master_irq == 2) {
 805d9b2:	3c 02                	cmp    $0x2,%al
 805d9b4:	74 6e                	je     805da24 <do_i8259+0x84>
	intr_NO = master_irq + IRQ_BASE;
	/* TODO: Uncomment the following line after the ``INTR'' member
	 * is added to the CPU_state structure.
	 */
	// cpu.INTR = true;
	panic("uncomment the line above");
 805d9b6:	83 ec 0c             	sub    $0xc,%esp
 805d9b9:	ff 35 20 5d 07 08    	pushl  0x8075d20
	else if(master_irq == 2) {
		assert(slave.highest_irq != NO_INTR);
		master_irq = 8 + slave.highest_irq;
	}

	intr_NO = master_irq + IRQ_BASE;
 805d9bf:	83 c0 20             	add    $0x20,%eax
 805d9c2:	a2 43 84 0c 08       	mov    %al,0x80c8443
	/* TODO: Uncomment the following line after the ``INTR'' member
	 * is added to the CPU_state structure.
	 */
	// cpu.INTR = true;
	panic("uncomment the line above");
 805d9c7:	e8 94 af fe ff       	call   8048960 <fflush@plt>
 805d9cc:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805d9d2:	6a 07                	push   $0x7
 805d9d4:	6a 01                	push   $0x1
 805d9d6:	68 92 e8 05 08       	push   $0x805e892
 805d9db:	e8 30 b0 fe ff       	call   8048a10 <fwrite@plt>
 805d9e0:	83 c4 20             	add    $0x20,%esp
 805d9e3:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805d9e9:	6a 18                	push   $0x18
 805d9eb:	6a 01                	push   $0x1
 805d9ed:	68 6d 5f 06 08       	push   $0x8065f6d
 805d9f2:	e8 19 b0 fe ff       	call   8048a10 <fwrite@plt>
 805d9f7:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805d9fd:	6a 05                	push   $0x5
 805d9ff:	6a 01                	push   $0x1
 805da01:	68 42 f3 05 08       	push   $0x805f342
 805da06:	e8 05 b0 fe ff       	call   8048a10 <fwrite@plt>
 805da0b:	83 c4 20             	add    $0x20,%esp
 805da0e:	68 00 60 06 08       	push   $0x8066000
 805da13:	6a 3b                	push   $0x3b
 805da15:	68 86 5f 06 08       	push   $0x8065f86
 805da1a:	68 1c ea 05 08       	push   $0x805ea1c
 805da1f:	e8 8c b1 fe ff       	call   8048bb0 <__assert_fail@plt>
		// cpu.INTR = false;
		panic("uncomment the line above");
		return;
	}
	else if(master_irq == 2) {
		assert(slave.highest_irq != NO_INTR);
 805da24:	0f b6 15 47 84 0c 08 	movzbl 0x80c8447,%edx
		master_irq = 8 + slave.highest_irq;
 805da2b:	8d 42 08             	lea    0x8(%edx),%eax
		// cpu.INTR = false;
		panic("uncomment the line above");
		return;
	}
	else if(master_irq == 2) {
		assert(slave.highest_irq != NO_INTR);
 805da2e:	80 c2 01             	add    $0x1,%dl
 805da31:	75 83                	jne    805d9b6 <do_i8259+0x16>
 805da33:	68 00 60 06 08       	push   $0x8066000
 805da38:	6a 32                	push   $0x32
 805da3a:	68 86 5f 06 08       	push   $0x8065f86
 805da3f:	68 9e 5f 06 08       	push   $0x8065f9e
 805da44:	e8 67 b1 fe ff       	call   8048bb0 <__assert_fail@plt>
	if(master_irq == NO_INTR) {
		/* TODO: Uncomment the following line after the ``INTR'' member
		 * is added to the CPU_state structure.
		 */
		// cpu.INTR = false;
		panic("uncomment the line above");
 805da49:	83 ec 0c             	sub    $0xc,%esp
 805da4c:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805da52:	e8 09 af fe ff       	call   8048960 <fflush@plt>
 805da57:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805da5d:	6a 07                	push   $0x7
 805da5f:	6a 01                	push   $0x1
 805da61:	68 92 e8 05 08       	push   $0x805e892
 805da66:	e8 a5 af fe ff       	call   8048a10 <fwrite@plt>
 805da6b:	83 c4 20             	add    $0x20,%esp
 805da6e:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805da74:	6a 18                	push   $0x18
 805da76:	6a 01                	push   $0x1
 805da78:	68 6d 5f 06 08       	push   $0x8065f6d
 805da7d:	e8 8e af fe ff       	call   8048a10 <fwrite@plt>
 805da82:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805da88:	6a 05                	push   $0x5
 805da8a:	6a 01                	push   $0x1
 805da8c:	68 42 f3 05 08       	push   $0x805f342
 805da91:	e8 7a af fe ff       	call   8048a10 <fwrite@plt>
 805da96:	83 c4 20             	add    $0x20,%esp
 805da99:	68 00 60 06 08       	push   $0x8066000
 805da9e:	6a 2e                	push   $0x2e
 805daa0:	68 86 5f 06 08       	push   $0x8065f86
 805daa5:	68 1c ea 05 08       	push   $0x805ea1c
 805daaa:	e8 01 b1 fe ff       	call   8048bb0 <__assert_fail@plt>
 805daaf:	90                   	nop

0805dab0 <i8259_raise_intr>:
	// cpu.INTR = true;
	panic("uncomment the line above");
}

/* device interface */
void i8259_raise_intr(int n) {
 805dab0:	83 ec 0c             	sub    $0xc,%esp
 805dab3:	8b 4c 24 10          	mov    0x10(%esp),%ecx
	assert(n >= 0 && n < 16);
 805dab7:	83 f9 0f             	cmp    $0xf,%ecx
 805daba:	77 6d                	ja     805db29 <i8259_raise_intr+0x79>
	if(n < 8) {
 805dabc:	83 f9 07             	cmp    $0x7,%ecx
 805dabf:	7e 59                	jle    805db1a <i8259_raise_intr+0x6a>
		master.IRR |= MASK(n);
	}
	else {
		n -= 8;
 805dac1:	83 e9 08             	sub    $0x8,%ecx
		slave.IRR |= MASK(n);
 805dac4:	b8 01 00 00 00       	mov    $0x1,%eax
		master.IRR |= MASK(2);

		slave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];
 805dac9:	0f b6 15 46 84 0c 08 	movzbl 0x80c8446,%edx
	if(n < 8) {
		master.IRR |= MASK(n);
	}
	else {
		n -= 8;
		slave.IRR |= MASK(n);
 805dad0:	d3 e0                	shl    %cl,%eax
 805dad2:	0a 05 44 84 0c 08    	or     0x80c8444,%al
		master.IRR |= MASK(2);
 805dad8:	80 0d 48 84 0c 08 04 	orb    $0x4,0x80c8448

		slave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];
 805dadf:	f7 d2                	not    %edx
	if(n < 8) {
		master.IRR |= MASK(n);
	}
	else {
		n -= 8;
		slave.IRR |= MASK(n);
 805dae1:	a2 44 84 0c 08       	mov    %al,0x80c8444
		master.IRR |= MASK(2);

		slave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];
 805dae6:	0f b6 c0             	movzbl %al,%eax
 805dae9:	21 d0                	and    %edx,%eax
 805daeb:	0f b6 80 40 60 06 08 	movzbl 0x8066040(%eax),%eax
 805daf2:	a2 47 84 0c 08       	mov    %al,0x80c8447
	}

	master.highest_irq = ffo_table[master.IRR & ~master.IMR];
 805daf7:	0f b6 05 4a 84 0c 08 	movzbl 0x80c844a,%eax
 805dafe:	0f b6 15 48 84 0c 08 	movzbl 0x80c8448,%edx
 805db05:	f7 d0                	not    %eax
 805db07:	21 d0                	and    %edx,%eax
 805db09:	0f b6 80 40 60 06 08 	movzbl 0x8066040(%eax),%eax
 805db10:	a2 4b 84 0c 08       	mov    %al,0x80c844b

	do_i8259();
 805db15:	e8 86 fe ff ff       	call   805d9a0 <do_i8259>

/* device interface */
void i8259_raise_intr(int n) {
	assert(n >= 0 && n < 16);
	if(n < 8) {
		master.IRR |= MASK(n);
 805db1a:	b8 01 00 00 00       	mov    $0x1,%eax
 805db1f:	d3 e0                	shl    %cl,%eax
 805db21:	08 05 48 84 0c 08    	or     %al,0x80c8448
 805db27:	eb ce                	jmp    805daf7 <i8259_raise_intr+0x47>
	panic("uncomment the line above");
}

/* device interface */
void i8259_raise_intr(int n) {
	assert(n >= 0 && n < 16);
 805db29:	68 09 60 06 08       	push   $0x8066009
 805db2e:	6a 40                	push   $0x40
 805db30:	68 86 5f 06 08       	push   $0x8065f86
 805db35:	68 b6 5f 06 08       	push   $0x8065fb6
 805db3a:	e8 71 b0 fe ff       	call   8048bb0 <__assert_fail@plt>
 805db3f:	90                   	nop

0805db40 <i8259_query_intr>:
}

/* CPU interface */
uint8_t i8259_query_intr() {
	return intr_NO;
}
 805db40:	0f b6 05 43 84 0c 08 	movzbl 0x80c8443,%eax
 805db47:	c3                   	ret    
 805db48:	90                   	nop
 805db49:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0805db50 <i8259_ack_intr>:

void i8259_ack_intr() {
 805db50:	83 ec 0c             	sub    $0xc,%esp
	if(intr_NO == NO_INTR) {
		return;
	}

	int n = intr_NO - IRQ_BASE;
 805db53:	0f b6 05 43 84 0c 08 	movzbl 0x80c8443,%eax
 805db5a:	8d 48 e0             	lea    -0x20(%eax),%ecx
	if(n < 8) {
 805db5d:	83 f9 07             	cmp    $0x7,%ecx
 805db60:	7f 30                	jg     805db92 <i8259_ack_intr+0x42>
		master.IRR &= ~MASK(n);
 805db62:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
 805db67:	d3 c0                	rol    %cl,%eax
 805db69:	20 05 48 84 0c 08    	and    %al,0x80c8448
		master.IRR &= ~MASK(2);

		slave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];
	}

	master.highest_irq = ffo_table[master.IRR & ~master.IMR];
 805db6f:	0f b6 05 4a 84 0c 08 	movzbl 0x80c844a,%eax
 805db76:	0f b6 15 48 84 0c 08 	movzbl 0x80c8448,%edx
 805db7d:	f7 d0                	not    %eax
 805db7f:	21 d0                	and    %edx,%eax
 805db81:	0f b6 80 40 60 06 08 	movzbl 0x8066040(%eax),%eax
 805db88:	a2 4b 84 0c 08       	mov    %al,0x80c844b

	do_i8259();
 805db8d:	e8 0e fe ff ff       	call   805d9a0 <do_i8259>
	int n = intr_NO - IRQ_BASE;
	if(n < 8) {
		master.IRR &= ~MASK(n);
	}
	else {
		n -= 8;
 805db92:	8d 48 d8             	lea    -0x28(%eax),%ecx
		slave.IRR &= ~MASK(n);
 805db95:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
		master.IRR &= ~MASK(2);

		slave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];
 805db9a:	0f b6 15 46 84 0c 08 	movzbl 0x80c8446,%edx
		master.IRR &= ~MASK(n);
	}
	else {
		n -= 8;
		slave.IRR &= ~MASK(n);
		master.IRR &= ~MASK(2);
 805dba1:	80 25 48 84 0c 08 fb 	andb   $0xfb,0x80c8448
	if(n < 8) {
		master.IRR &= ~MASK(n);
	}
	else {
		n -= 8;
		slave.IRR &= ~MASK(n);
 805dba8:	d3 c0                	rol    %cl,%eax
 805dbaa:	22 05 44 84 0c 08    	and    0x80c8444,%al
		master.IRR &= ~MASK(2);

		slave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];
 805dbb0:	f7 d2                	not    %edx
	if(n < 8) {
		master.IRR &= ~MASK(n);
	}
	else {
		n -= 8;
		slave.IRR &= ~MASK(n);
 805dbb2:	a2 44 84 0c 08       	mov    %al,0x80c8444
		master.IRR &= ~MASK(2);

		slave.highest_irq = ffo_table[slave.IRR & ~slave.IMR];
 805dbb7:	0f b6 c0             	movzbl %al,%eax
 805dbba:	21 d0                	and    %edx,%eax
 805dbbc:	0f b6 80 40 60 06 08 	movzbl 0x8066040(%eax),%eax
 805dbc3:	a2 47 84 0c 08       	mov    %al,0x80c8447
 805dbc8:	eb a5                	jmp    805db6f <i8259_ack_intr+0x1f>
 805dbca:	66 90                	xchg   %ax,%ax
 805dbcc:	66 90                	xchg   %ax,%ax
 805dbce:	66 90                	xchg   %ax,%ax

0805dbd0 <i8042_io_handler>:
		newkey = true;
	}
}

void i8042_io_handler(ioaddr_t addr, size_t len, bool is_write) {
	if(!is_write) {
 805dbd0:	80 7c 24 0c 00       	cmpb   $0x0,0xc(%esp)
 805dbd5:	75 07                	jne    805dbde <i8042_io_handler+0xe>
		newkey = false;
 805dbd7:	c6 05 4c 84 0c 08 00 	movb   $0x0,0x80c844c
 805dbde:	f3 c3                	repz ret 

0805dbe0 <keyboard_intr>:
#define KEYBOARD_IRQ 1

static uint8_t *i8042_data_port_base;
static bool newkey;

void keyboard_intr(uint8_t scancode) {
 805dbe0:	83 ec 0c             	sub    $0xc,%esp
	if(nemu_state == RUNNING && newkey == false) {
 805dbe3:	83 3d 80 82 07 08 01 	cmpl   $0x1,0x8078280
#define KEYBOARD_IRQ 1

static uint8_t *i8042_data_port_base;
static bool newkey;

void keyboard_intr(uint8_t scancode) {
 805dbea:	8b 44 24 10          	mov    0x10(%esp),%eax
	if(nemu_state == RUNNING && newkey == false) {
 805dbee:	74 08                	je     805dbf8 <keyboard_intr+0x18>
		i8042_data_port_base[0] = scancode;
		i8259_raise_intr(KEYBOARD_IRQ);
		newkey = true;
	}
}
 805dbf0:	83 c4 0c             	add    $0xc,%esp
 805dbf3:	c3                   	ret    
 805dbf4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

static uint8_t *i8042_data_port_base;
static bool newkey;

void keyboard_intr(uint8_t scancode) {
	if(nemu_state == RUNNING && newkey == false) {
 805dbf8:	80 3d 4c 84 0c 08 00 	cmpb   $0x0,0x80c844c
 805dbff:	75 ef                	jne    805dbf0 <keyboard_intr+0x10>
		i8042_data_port_base[0] = scancode;
 805dc01:	8b 15 50 84 0c 08    	mov    0x80c8450,%edx
		i8259_raise_intr(KEYBOARD_IRQ);
 805dc07:	83 ec 0c             	sub    $0xc,%esp
static uint8_t *i8042_data_port_base;
static bool newkey;

void keyboard_intr(uint8_t scancode) {
	if(nemu_state == RUNNING && newkey == false) {
		i8042_data_port_base[0] = scancode;
 805dc0a:	88 02                	mov    %al,(%edx)
		i8259_raise_intr(KEYBOARD_IRQ);
 805dc0c:	6a 01                	push   $0x1
 805dc0e:	e8 9d fe ff ff       	call   805dab0 <i8259_raise_intr>
		newkey = true;
 805dc13:	83 c4 10             	add    $0x10,%esp
 805dc16:	c6 05 4c 84 0c 08 01 	movb   $0x1,0x80c844c
	}
}
 805dc1d:	83 c4 0c             	add    $0xc,%esp
 805dc20:	c3                   	ret    
 805dc21:	eb 0d                	jmp    805dc30 <init_i8042>
 805dc23:	90                   	nop
 805dc24:	90                   	nop
 805dc25:	90                   	nop
 805dc26:	90                   	nop
 805dc27:	90                   	nop
 805dc28:	90                   	nop
 805dc29:	90                   	nop
 805dc2a:	90                   	nop
 805dc2b:	90                   	nop
 805dc2c:	90                   	nop
 805dc2d:	90                   	nop
 805dc2e:	90                   	nop
 805dc2f:	90                   	nop

0805dc30 <init_i8042>:
	if(!is_write) {
		newkey = false;
	}
}

void init_i8042() {
 805dc30:	83 ec 10             	sub    $0x10,%esp
	i8042_data_port_base = add_pio_map(I8042_DATA_PORT, 1, i8042_io_handler);
 805dc33:	68 d0 db 05 08       	push   $0x805dbd0
 805dc38:	6a 01                	push   $0x1
 805dc3a:	6a 60                	push   $0x60
 805dc3c:	e8 9f fb ff ff       	call   805d7e0 <add_pio_map>
	newkey = false;
 805dc41:	c6 05 4c 84 0c 08 00 	movb   $0x0,0x80c844c
		newkey = false;
	}
}

void init_i8042() {
	i8042_data_port_base = add_pio_map(I8042_DATA_PORT, 1, i8042_io_handler);
 805dc48:	a3 50 84 0c 08       	mov    %eax,0x80c8450
	newkey = false;
}
 805dc4d:	83 c4 1c             	add    $0x1c,%esp
 805dc50:	c3                   	ret    
 805dc51:	66 90                	xchg   %ax,%ax
 805dc53:	66 90                	xchg   %ax,%ax
 805dc55:	66 90                	xchg   %ax,%ax
 805dc57:	66 90                	xchg   %ax,%ax
 805dc59:	66 90                	xchg   %ax,%ax
 805dc5b:	66 90                	xchg   %ax,%ax
 805dc5d:	66 90                	xchg   %ax,%ax
 805dc5f:	90                   	nop

0805dc60 <serial_io_handler>:
#define CH_OFFSET 0
#define LSR_OFFSET 5		/* line status register */

static uint8_t *serial_port_base;

void serial_io_handler(ioaddr_t addr, size_t len, bool is_write) {
 805dc60:	53                   	push   %ebx
 805dc61:	83 ec 08             	sub    $0x8,%esp
	if(is_write) {
 805dc64:	80 7c 24 18 00       	cmpb   $0x0,0x18(%esp)
#define CH_OFFSET 0
#define LSR_OFFSET 5		/* line status register */

static uint8_t *serial_port_base;

void serial_io_handler(ioaddr_t addr, size_t len, bool is_write) {
 805dc69:	8b 54 24 10          	mov    0x10(%esp),%edx
 805dc6d:	8b 44 24 14          	mov    0x14(%esp),%eax
	if(is_write) {
 805dc71:	74 0c                	je     805dc7f <serial_io_handler+0x1f>
		assert(len == 1);
 805dc73:	83 f8 01             	cmp    $0x1,%eax
 805dc76:	75 43                	jne    805dcbb <serial_io_handler+0x5b>
		if(addr == SERIAL_PORT + CH_OFFSET) {
 805dc78:	66 81 fa f8 03       	cmp    $0x3f8,%dx
 805dc7d:	74 09                	je     805dc88 <serial_io_handler+0x28>
			if(c == '\n') {
				fflush(stdout);
			}
		}
	}
}
 805dc7f:	83 c4 08             	add    $0x8,%esp
 805dc82:	5b                   	pop    %ebx
 805dc83:	c3                   	ret    
 805dc84:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi

void serial_io_handler(ioaddr_t addr, size_t len, bool is_write) {
	if(is_write) {
		assert(len == 1);
		if(addr == SERIAL_PORT + CH_OFFSET) {
			char c = serial_port_base[CH_OFFSET];
 805dc88:	a1 54 84 0c 08       	mov    0x80c8454,%eax
			/* We bind the serial port with the host stdout in NEMU. */
			putc(c, stdout);
 805dc8d:	83 ec 08             	sub    $0x8,%esp

void serial_io_handler(ioaddr_t addr, size_t len, bool is_write) {
	if(is_write) {
		assert(len == 1);
		if(addr == SERIAL_PORT + CH_OFFSET) {
			char c = serial_port_base[CH_OFFSET];
 805dc90:	0f be 00             	movsbl (%eax),%eax
			/* We bind the serial port with the host stdout in NEMU. */
			putc(c, stdout);
 805dc93:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805dc99:	50                   	push   %eax

void serial_io_handler(ioaddr_t addr, size_t len, bool is_write) {
	if(is_write) {
		assert(len == 1);
		if(addr == SERIAL_PORT + CH_OFFSET) {
			char c = serial_port_base[CH_OFFSET];
 805dc9a:	89 c3                	mov    %eax,%ebx
			/* We bind the serial port with the host stdout in NEMU. */
			putc(c, stdout);
 805dc9c:	e8 3f ad fe ff       	call   80489e0 <_IO_putc@plt>
			if(c == '\n') {
 805dca1:	83 c4 10             	add    $0x10,%esp
 805dca4:	80 fb 0a             	cmp    $0xa,%bl
 805dca7:	75 d6                	jne    805dc7f <serial_io_handler+0x1f>
				fflush(stdout);
 805dca9:	a1 20 5d 07 08       	mov    0x8075d20,%eax
 805dcae:	89 44 24 10          	mov    %eax,0x10(%esp)
			}
		}
	}
}
 805dcb2:	83 c4 08             	add    $0x8,%esp
 805dcb5:	5b                   	pop    %ebx
		if(addr == SERIAL_PORT + CH_OFFSET) {
			char c = serial_port_base[CH_OFFSET];
			/* We bind the serial port with the host stdout in NEMU. */
			putc(c, stdout);
			if(c == '\n') {
				fflush(stdout);
 805dcb6:	e9 a5 ac fe ff       	jmp    8048960 <fflush@plt>

static uint8_t *serial_port_base;

void serial_io_handler(ioaddr_t addr, size_t len, bool is_write) {
	if(is_write) {
		assert(len == 1);
 805dcbb:	68 62 61 06 08       	push   $0x8066162
 805dcc0:	6a 0e                	push   $0xe
 805dcc2:	68 40 61 06 08       	push   $0x8066140
 805dcc7:	68 59 61 06 08       	push   $0x8066159
 805dccc:	e8 df ae fe ff       	call   8048bb0 <__assert_fail@plt>
 805dcd1:	eb 0d                	jmp    805dce0 <init_serial>
 805dcd3:	90                   	nop
 805dcd4:	90                   	nop
 805dcd5:	90                   	nop
 805dcd6:	90                   	nop
 805dcd7:	90                   	nop
 805dcd8:	90                   	nop
 805dcd9:	90                   	nop
 805dcda:	90                   	nop
 805dcdb:	90                   	nop
 805dcdc:	90                   	nop
 805dcdd:	90                   	nop
 805dcde:	90                   	nop
 805dcdf:	90                   	nop

0805dce0 <init_serial>:
			}
		}
	}
}

void init_serial() {
 805dce0:	83 ec 10             	sub    $0x10,%esp
	serial_port_base = add_pio_map(SERIAL_PORT, 8, serial_io_handler);
 805dce3:	68 60 dc 05 08       	push   $0x805dc60
 805dce8:	6a 08                	push   $0x8
 805dcea:	68 f8 03 00 00       	push   $0x3f8
 805dcef:	e8 ec fa ff ff       	call   805d7e0 <add_pio_map>
 805dcf4:	a3 54 84 0c 08       	mov    %eax,0x80c8454
	serial_port_base[LSR_OFFSET] = 0x20; /* the status is always free */
 805dcf9:	c6 40 05 20          	movb   $0x20,0x5(%eax)
}
 805dcfd:	83 c4 1c             	add    $0x1c,%esp
 805dd00:	c3                   	ret    
 805dd01:	66 90                	xchg   %ax,%ax
 805dd03:	66 90                	xchg   %ax,%ax
 805dd05:	66 90                	xchg   %ax,%ax
 805dd07:	66 90                	xchg   %ax,%ax
 805dd09:	66 90                	xchg   %ax,%ax
 805dd0b:	66 90                	xchg   %ax,%ax
 805dd0d:	66 90                	xchg   %ax,%ax
 805dd0f:	90                   	nop

0805dd10 <ide_io_handler>:
static uint32_t sector, disk_idx;
static uint32_t byte_cnt;
static bool ide_write;
static FILE *disk_fp;

void ide_io_handler(ioaddr_t addr, size_t len, bool is_write) {
 805dd10:	83 ec 0c             	sub    $0xc,%esp
	assert(byte_cnt <= 512);
 805dd13:	81 3d 60 84 0c 08 00 	cmpl   $0x200,0x80c8460
 805dd1a:	02 00 00 
static uint32_t sector, disk_idx;
static uint32_t byte_cnt;
static bool ide_write;
static FILE *disk_fp;

void ide_io_handler(ioaddr_t addr, size_t len, bool is_write) {
 805dd1d:	8b 44 24 10          	mov    0x10(%esp),%eax
 805dd21:	8b 4c 24 14          	mov    0x14(%esp),%ecx
 805dd25:	8b 54 24 18          	mov    0x18(%esp),%edx
	assert(byte_cnt <= 512);
 805dd29:	0f 87 92 01 00 00    	ja     805dec1 <ide_io_handler+0x1b1>
	int ret;
	if(is_write) {
 805dd2f:	84 d2                	test   %dl,%dl
 805dd31:	74 6d                	je     805dda0 <ide_io_handler+0x90>
		if(addr - IDE_PORT == 0 && len == 4) {
 805dd33:	66 3d f0 01          	cmp    $0x1f0,%ax
 805dd37:	0f 85 c3 00 00 00    	jne    805de00 <ide_io_handler+0xf0>
 805dd3d:	83 f9 04             	cmp    $0x4,%ecx
 805dd40:	0f 85 ba 00 00 00    	jne    805de00 <ide_io_handler+0xf0>
			/* write 4 bytes data to disk */
			assert(ide_write);
 805dd46:	80 3d 5c 84 0c 08 00 	cmpb   $0x0,0x80c845c
 805dd4d:	0f 84 9a 01 00 00    	je     805deed <ide_io_handler+0x1dd>
			ret = fwrite(ide_port_base, 4, 1, disk_fp);
 805dd53:	ff 35 58 84 0c 08    	pushl  0x80c8458
 805dd59:	6a 01                	push   $0x1
 805dd5b:	6a 04                	push   $0x4
 805dd5d:	ff 35 70 84 0c 08    	pushl  0x80c8470
 805dd63:	e8 a8 ac fe ff       	call   8048a10 <fwrite@plt>
			assert(ret == 1);
 805dd68:	83 c4 10             	add    $0x10,%esp
 805dd6b:	83 f8 01             	cmp    $0x1,%eax
 805dd6e:	0f 85 8f 01 00 00    	jne    805df03 <ide_io_handler+0x1f3>
			/* read 4 bytes data from disk */
			assert(!ide_write);
			ret = fread(ide_port_base, 4, 1, disk_fp);
			assert(ret == 1 || feof(disk_fp));

			byte_cnt += 4;
 805dd74:	a1 60 84 0c 08       	mov    0x80c8460,%eax
 805dd79:	83 c0 04             	add    $0x4,%eax
			if(byte_cnt == 512) {
 805dd7c:	3d 00 02 00 00       	cmp    $0x200,%eax
			/* read 4 bytes data from disk */
			assert(!ide_write);
			ret = fread(ide_port_base, 4, 1, disk_fp);
			assert(ret == 1 || feof(disk_fp));

			byte_cnt += 4;
 805dd81:	a3 60 84 0c 08       	mov    %eax,0x80c8460
			if(byte_cnt == 512) {
 805dd86:	75 10                	jne    805dd98 <ide_io_handler+0x88>
				/* finish */
				ide_port_base[7] = 0x40;
 805dd88:	a1 70 84 0c 08       	mov    0x80c8470,%eax
 805dd8d:	c6 40 07 40          	movb   $0x40,0x7(%eax)
 805dd91:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			}
		}
	}
}
 805dd98:	83 c4 0c             	add    $0xc,%esp
 805dd9b:	c3                   	ret    
 805dd9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
				assert(0);
			}
		}
	}
	else {
		if(addr - IDE_PORT == 0 && len == 4) {
 805dda0:	66 3d f0 01          	cmp    $0x1f0,%ax
 805dda4:	75 f2                	jne    805dd98 <ide_io_handler+0x88>
 805dda6:	83 f9 04             	cmp    $0x4,%ecx
 805dda9:	75 ed                	jne    805dd98 <ide_io_handler+0x88>
			/* read 4 bytes data from disk */
			assert(!ide_write);
 805ddab:	80 3d 5c 84 0c 08 00 	cmpb   $0x0,0x80c845c
 805ddb2:	0f 85 1f 01 00 00    	jne    805ded7 <ide_io_handler+0x1c7>
			ret = fread(ide_port_base, 4, 1, disk_fp);
 805ddb8:	ff 35 58 84 0c 08    	pushl  0x80c8458
 805ddbe:	6a 01                	push   $0x1
 805ddc0:	6a 04                	push   $0x4
 805ddc2:	ff 35 70 84 0c 08    	pushl  0x80c8470
 805ddc8:	e8 63 ac fe ff       	call   8048a30 <fread@plt>
			assert(ret == 1 || feof(disk_fp));
 805ddcd:	83 c4 10             	add    $0x10,%esp
 805ddd0:	83 f8 01             	cmp    $0x1,%eax
 805ddd3:	74 9f                	je     805dd74 <ide_io_handler+0x64>
 805ddd5:	83 ec 0c             	sub    $0xc,%esp
 805ddd8:	ff 35 58 84 0c 08    	pushl  0x80c8458
 805ddde:	e8 9d ac fe ff       	call   8048a80 <feof@plt>
 805dde3:	83 c4 10             	add    $0x10,%esp
 805dde6:	85 c0                	test   %eax,%eax
 805dde8:	75 8a                	jne    805dd74 <ide_io_handler+0x64>
 805ddea:	68 f8 61 06 08       	push   $0x80661f8
 805ddef:	6a 4a                	push   $0x4a
 805ddf1:	68 74 61 06 08       	push   $0x8066174
 805ddf6:	68 a5 61 06 08       	push   $0x80661a5
 805ddfb:	e8 b0 ad fe ff       	call   8048bb0 <__assert_fail@plt>
			if(byte_cnt == 512) {
				/* finish */
				ide_port_base[7] = 0x40;
			}
		}
		else if(addr - IDE_PORT == 7) {
 805de00:	66 3d f7 01          	cmp    $0x1f7,%ax
 805de04:	75 92                	jne    805dd98 <ide_io_handler+0x88>
			if(ide_port_base[7] == 0x20 || ide_port_base[7] == 0x30) {
 805de06:	8b 15 70 84 0c 08    	mov    0x80c8470,%edx
 805de0c:	0f b6 42 07          	movzbl 0x7(%edx),%eax
 805de10:	89 c1                	mov    %eax,%ecx
 805de12:	83 e1 ef             	and    $0xffffffef,%ecx
 805de15:	80 f9 20             	cmp    $0x20,%cl
 805de18:	74 26                	je     805de40 <ide_io_handler+0x130>
				else {
					/* command: write to disk */
					ide_write = true;
				}
			}
			else if (ide_port_base[7] == 0xc8) {
 805de1a:	3c c8                	cmp    $0xc8,%al
 805de1c:	0f 84 76 ff ff ff    	je     805dd98 <ide_io_handler+0x88>
				/* Nothing to do here. The actual read operation is
				 * issued by write commands to the bus master register. */
			}
			else {
				/* not implemented command */
				assert(0);
 805de22:	68 f8 61 06 08       	push   $0x80661f8
 805de27:	6a 41                	push   $0x41
 805de29:	68 74 61 06 08       	push   $0x8066174
 805de2e:	68 1c ea 05 08       	push   $0x805ea1c
 805de33:	e8 78 ad fe ff       	call   8048bb0 <__assert_fail@plt>
 805de38:	90                   	nop
 805de39:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
			}
		}
		else if(addr - IDE_PORT == 7) {
			if(ide_port_base[7] == 0x20 || ide_port_base[7] == 0x30) {
				/* command: read/write */
				sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805de40:	0f b6 42 05          	movzbl 0x5(%edx),%eax
					| ide_port_base[4] << 8 | ide_port_base[3];
				disk_idx = sector << 9;
				fseek(disk_fp, disk_idx, SEEK_SET);
 805de44:	83 ec 04             	sub    $0x4,%esp
			}
		}
		else if(addr - IDE_PORT == 7) {
			if(ide_port_base[7] == 0x20 || ide_port_base[7] == 0x30) {
				/* command: read/write */
				sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805de47:	c1 e0 10             	shl    $0x10,%eax
 805de4a:	89 c1                	mov    %eax,%ecx
					| ide_port_base[4] << 8 | ide_port_base[3];
 805de4c:	0f b6 42 04          	movzbl 0x4(%edx),%eax
 805de50:	c1 e0 08             	shl    $0x8,%eax
 805de53:	09 c8                	or     %ecx,%eax
 805de55:	0f b6 4a 03          	movzbl 0x3(%edx),%ecx
			}
		}
		else if(addr - IDE_PORT == 7) {
			if(ide_port_base[7] == 0x20 || ide_port_base[7] == 0x30) {
				/* command: read/write */
				sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805de59:	0f b6 52 06          	movzbl 0x6(%edx),%edx
					| ide_port_base[4] << 8 | ide_port_base[3];
				disk_idx = sector << 9;
				fseek(disk_fp, disk_idx, SEEK_SET);
 805de5d:	6a 00                	push   $0x0
			}
		}
		else if(addr - IDE_PORT == 7) {
			if(ide_port_base[7] == 0x20 || ide_port_base[7] == 0x30) {
				/* command: read/write */
				sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805de5f:	83 e2 1f             	and    $0x1f,%edx
 805de62:	09 c8                	or     %ecx,%eax
 805de64:	c1 e2 18             	shl    $0x18,%edx
					| ide_port_base[4] << 8 | ide_port_base[3];
 805de67:	09 d0                	or     %edx,%eax
			}
		}
		else if(addr - IDE_PORT == 7) {
			if(ide_port_base[7] == 0x20 || ide_port_base[7] == 0x30) {
				/* command: read/write */
				sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805de69:	a3 68 84 0c 08       	mov    %eax,0x80c8468
					| ide_port_base[4] << 8 | ide_port_base[3];
				disk_idx = sector << 9;
 805de6e:	c1 e0 09             	shl    $0x9,%eax
				fseek(disk_fp, disk_idx, SEEK_SET);
 805de71:	50                   	push   %eax
 805de72:	ff 35 58 84 0c 08    	pushl  0x80c8458
		else if(addr - IDE_PORT == 7) {
			if(ide_port_base[7] == 0x20 || ide_port_base[7] == 0x30) {
				/* command: read/write */
				sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
					| ide_port_base[4] << 8 | ide_port_base[3];
				disk_idx = sector << 9;
 805de78:	a3 64 84 0c 08       	mov    %eax,0x80c8464
				fseek(disk_fp, disk_idx, SEEK_SET);
 805de7d:	e8 6e ab fe ff       	call   80489f0 <fseek@plt>

				byte_cnt = 0;

				if(ide_port_base[7] == 0x20) {
 805de82:	a1 70 84 0c 08       	mov    0x80c8470,%eax
 805de87:	83 c4 10             	add    $0x10,%esp
				sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
					| ide_port_base[4] << 8 | ide_port_base[3];
				disk_idx = sector << 9;
				fseek(disk_fp, disk_idx, SEEK_SET);

				byte_cnt = 0;
 805de8a:	c7 05 60 84 0c 08 00 	movl   $0x0,0x80c8460
 805de91:	00 00 00 

				if(ide_port_base[7] == 0x20) {
 805de94:	80 78 07 20          	cmpb   $0x20,0x7(%eax)
 805de98:	74 0c                	je     805dea6 <ide_io_handler+0x196>
					ide_port_base[7] = 0x40;
					i8259_raise_intr(IDE_IRQ);
				}
				else {
					/* command: write to disk */
					ide_write = true;
 805de9a:	c6 05 5c 84 0c 08 01 	movb   $0x1,0x80c845c
 805dea1:	e9 f2 fe ff ff       	jmp    805dd98 <ide_io_handler+0x88>
				byte_cnt = 0;

				if(ide_port_base[7] == 0x20) {
					/* command: read from disk */
					ide_write = false;
					ide_port_base[7] = 0x40;
 805dea6:	c6 40 07 40          	movb   $0x40,0x7(%eax)

				byte_cnt = 0;

				if(ide_port_base[7] == 0x20) {
					/* command: read from disk */
					ide_write = false;
 805deaa:	c6 05 5c 84 0c 08 00 	movb   $0x0,0x80c845c
					ide_port_base[7] = 0x40;
					i8259_raise_intr(IDE_IRQ);
 805deb1:	c7 44 24 10 0e 00 00 	movl   $0xe,0x10(%esp)
 805deb8:	00 
				/* finish */
				ide_port_base[7] = 0x40;
			}
		}
	}
}
 805deb9:	83 c4 0c             	add    $0xc,%esp

				if(ide_port_base[7] == 0x20) {
					/* command: read from disk */
					ide_write = false;
					ide_port_base[7] = 0x40;
					i8259_raise_intr(IDE_IRQ);
 805debc:	e9 ef fb ff ff       	jmp    805dab0 <i8259_raise_intr>
static uint32_t byte_cnt;
static bool ide_write;
static FILE *disk_fp;

void ide_io_handler(ioaddr_t addr, size_t len, bool is_write) {
	assert(byte_cnt <= 512);
 805dec1:	68 f8 61 06 08       	push   $0x80661f8
 805dec6:	6a 15                	push   $0x15
 805dec8:	68 74 61 06 08       	push   $0x8066174
 805decd:	68 8a 61 06 08       	push   $0x806618a
 805ded2:	e8 d9 ac fe ff       	call   8048bb0 <__assert_fail@plt>
		}
	}
	else {
		if(addr - IDE_PORT == 0 && len == 4) {
			/* read 4 bytes data from disk */
			assert(!ide_write);
 805ded7:	68 f8 61 06 08       	push   $0x80661f8
 805dedc:	6a 48                	push   $0x48
 805dede:	68 74 61 06 08       	push   $0x8066174
 805dee3:	68 9a 61 06 08       	push   $0x806619a
 805dee8:	e8 c3 ac fe ff       	call   8048bb0 <__assert_fail@plt>
	assert(byte_cnt <= 512);
	int ret;
	if(is_write) {
		if(addr - IDE_PORT == 0 && len == 4) {
			/* write 4 bytes data to disk */
			assert(ide_write);
 805deed:	68 f8 61 06 08       	push   $0x80661f8
 805def2:	6a 1a                	push   $0x1a
 805def4:	68 74 61 06 08       	push   $0x8066174
 805def9:	68 9b 61 06 08       	push   $0x806619b
 805defe:	e8 ad ac fe ff       	call   8048bb0 <__assert_fail@plt>
			ret = fwrite(ide_port_base, 4, 1, disk_fp);
			assert(ret == 1);
 805df03:	68 f8 61 06 08       	push   $0x80661f8
 805df08:	6a 1c                	push   $0x1c
 805df0a:	68 74 61 06 08       	push   $0x8066174
 805df0f:	68 e8 e8 05 08       	push   $0x805e8e8
 805df14:	e8 97 ac fe ff       	call   8048bb0 <__assert_fail@plt>
 805df19:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi

0805df20 <bmr_io_handler>:
			}
		}
	}
}

void bmr_io_handler(ioaddr_t addr, size_t len, bool is_write) {
 805df20:	56                   	push   %esi
 805df21:	53                   	push   %ebx
 805df22:	83 ec 04             	sub    $0x4,%esp
	int ret;
	if(is_write) {
		if(addr - BMR_PORT == 0) {
 805df25:	80 7c 24 18 00       	cmpb   $0x0,0x18(%esp)
			}
		}
	}
}

void bmr_io_handler(ioaddr_t addr, size_t len, bool is_write) {
 805df2a:	8b 44 24 10          	mov    0x10(%esp),%eax
	int ret;
	if(is_write) {
		if(addr - BMR_PORT == 0) {
 805df2e:	0f 84 e4 00 00 00    	je     805e018 <bmr_io_handler+0xf8>
 805df34:	66 3d 40 c0          	cmp    $0xc040,%ax
 805df38:	0f 85 da 00 00 00    	jne    805e018 <bmr_io_handler+0xf8>
			if(bmr_base[0] & 0x1) {
 805df3e:	a1 6c 84 0c 08       	mov    0x80c846c,%eax
 805df43:	0f b6 10             	movzbl (%eax),%edx
 805df46:	f6 c2 01             	test   $0x1,%dl
 805df49:	0f 84 c9 00 00 00    	je     805e018 <bmr_io_handler+0xf8>
				/* DMA start command */
				if(bmr_base[0] & 0x8) {
 805df4f:	83 e2 08             	and    $0x8,%edx
 805df52:	0f 84 c6 00 00 00    	je     805e01e <bmr_io_handler+0xfe>
					/* DMA read */

					/* the address of Physical Region Descriptor Table */
					hwaddr_t prdt_addr = *(uint32_t *)(bmr_base + 4);
 805df58:	8b 58 04             	mov    0x4(%eax),%ebx

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
 805df5b:	83 ec 08             	sub    $0x8,%esp
 805df5e:	6a 04                	push   $0x4
 805df60:	53                   	push   %ebx
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
 805df61:	83 c3 04             	add    $0x4,%ebx
					/* DMA read */

					/* the address of Physical Region Descriptor Table */
					hwaddr_t prdt_addr = *(uint32_t *)(bmr_base + 4);

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
 805df64:	e8 67 cf fe ff       	call   804aed0 <hwaddr_read>
 805df69:	89 c6                	mov    %eax,%esi
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
 805df6b:	58                   	pop    %eax
 805df6c:	5a                   	pop    %edx
 805df6d:	6a 04                	push   $0x4
 805df6f:	53                   	push   %ebx
 805df70:	e8 5b cf fe ff       	call   804aed0 <hwaddr_read>
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805df75:	8b 0d 70 84 0c 08    	mov    0x80c8470,%ecx

					/* the address of Physical Region Descriptor Table */
					hwaddr_t prdt_addr = *(uint32_t *)(bmr_base + 4);

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
 805df7b:	89 c3                	mov    %eax,%ebx
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
						| ide_port_base[4] << 8 | ide_port_base[3];
					disk_idx = sector << 9;
					fseek(disk_fp, disk_idx, SEEK_SET);
 805df7d:	83 c4 0c             	add    $0xc,%esp

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805df80:	0f b6 51 05          	movzbl 0x5(%ecx),%edx
						| ide_port_base[4] << 8 | ide_port_base[3];
 805df84:	0f b6 41 04          	movzbl 0x4(%ecx),%eax

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805df88:	c1 e2 10             	shl    $0x10,%edx
						| ide_port_base[4] << 8 | ide_port_base[3];
 805df8b:	c1 e0 08             	shl    $0x8,%eax
 805df8e:	09 c2                	or     %eax,%edx
 805df90:	0f b6 41 03          	movzbl 0x3(%ecx),%eax

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805df94:	0f b6 49 06          	movzbl 0x6(%ecx),%ecx
						| ide_port_base[4] << 8 | ide_port_base[3];
					disk_idx = sector << 9;
					fseek(disk_fp, disk_idx, SEEK_SET);
 805df98:	6a 00                	push   $0x0

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805df9a:	83 e1 1f             	and    $0x1f,%ecx
 805df9d:	09 c2                	or     %eax,%edx
 805df9f:	c1 e1 18             	shl    $0x18,%ecx
						| ide_port_base[4] << 8 | ide_port_base[3];
 805dfa2:	09 ca                	or     %ecx,%edx

					hwaddr_t addr = hwaddr_read(prdt_addr, 4);
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
 805dfa4:	89 15 68 84 0c 08    	mov    %edx,0x80c8468
						| ide_port_base[4] << 8 | ide_port_base[3];
					disk_idx = sector << 9;
 805dfaa:	c1 e2 09             	shl    $0x9,%edx
					fseek(disk_fp, disk_idx, SEEK_SET);
 805dfad:	52                   	push   %edx
 805dfae:	ff 35 58 84 0c 08    	pushl  0x80c8458
					uint32_t hi_entry = hwaddr_read(prdt_addr + 4, 4);
					uint16_t byte_cnt = hi_entry & 0xffff;

					sector = (ide_port_base[6] & 0x1f) << 24 | ide_port_base[5] << 16
						| ide_port_base[4] << 8 | ide_port_base[3];
					disk_idx = sector << 9;
 805dfb4:	89 15 64 84 0c 08    	mov    %edx,0x80c8464
					fseek(disk_fp, disk_idx, SEEK_SET);
 805dfba:	e8 31 aa fe ff       	call   80489f0 <fseek@plt>

					ret = fread((void *)hwa_to_va(addr), byte_cnt, 1, disk_fp);
 805dfbf:	03 35 c8 52 07 08    	add    0x80752c8,%esi
 805dfc5:	0f b7 c3             	movzwl %bx,%eax
 805dfc8:	ff 35 58 84 0c 08    	pushl  0x80c8458
 805dfce:	6a 01                	push   $0x1
 805dfd0:	50                   	push   %eax
 805dfd1:	56                   	push   %esi
 805dfd2:	e8 59 aa fe ff       	call   8048a30 <fread@plt>
					assert(ret == 1 || feof(disk_fp));
 805dfd7:	83 c4 20             	add    $0x20,%esp
 805dfda:	83 f8 01             	cmp    $0x1,%eax
 805dfdd:	74 15                	je     805dff4 <bmr_io_handler+0xd4>
 805dfdf:	83 ec 0c             	sub    $0xc,%esp
 805dfe2:	ff 35 58 84 0c 08    	pushl  0x80c8458
 805dfe8:	e8 93 aa fe ff       	call   8048a80 <feof@plt>
 805dfed:	83 c4 10             	add    $0x10,%esp
 805dff0:	85 c0                	test   %eax,%eax
 805dff2:	74 56                	je     805e04a <bmr_io_handler+0x12a>

					/* We only implement PRDT of single entry. */
					assert(hi_entry & 0x80000000);
 805dff4:	85 db                	test   %ebx,%ebx
 805dff6:	79 3c                	jns    805e034 <bmr_io_handler+0x114>

					/* finish */
					ide_port_base[7] = 0x40;
 805dff8:	a1 70 84 0c 08       	mov    0x80c8470,%eax
 805dffd:	c6 40 07 40          	movb   $0x40,0x7(%eax)
					i8259_raise_intr(IDE_IRQ);
 805e001:	c7 44 24 10 0e 00 00 	movl   $0xe,0x10(%esp)
 805e008:	00 
					assert(0);
				}
			}
		}
	}
}
 805e009:	83 c4 04             	add    $0x4,%esp
 805e00c:	5b                   	pop    %ebx
 805e00d:	5e                   	pop    %esi
					/* We only implement PRDT of single entry. */
					assert(hi_entry & 0x80000000);

					/* finish */
					ide_port_base[7] = 0x40;
					i8259_raise_intr(IDE_IRQ);
 805e00e:	e9 9d fa ff ff       	jmp    805dab0 <i8259_raise_intr>
 805e013:	90                   	nop
 805e014:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
					assert(0);
				}
			}
		}
	}
}
 805e018:	83 c4 04             	add    $0x4,%esp
 805e01b:	5b                   	pop    %ebx
 805e01c:	5e                   	pop    %esi
 805e01d:	c3                   	ret    
					ide_port_base[7] = 0x40;
					i8259_raise_intr(IDE_IRQ);
				}
				else {
					/* DMA write is not implemented */
					assert(0);
 805e01e:	68 e9 61 06 08       	push   $0x80661e9
 805e023:	6a 76                	push   $0x76
 805e025:	68 74 61 06 08       	push   $0x8066174
 805e02a:	68 1c ea 05 08       	push   $0x805ea1c
 805e02f:	e8 7c ab fe ff       	call   8048bb0 <__assert_fail@plt>

					ret = fread((void *)hwa_to_va(addr), byte_cnt, 1, disk_fp);
					assert(ret == 1 || feof(disk_fp));

					/* We only implement PRDT of single entry. */
					assert(hi_entry & 0x80000000);
 805e034:	68 e9 61 06 08       	push   $0x80661e9
 805e039:	6a 6e                	push   $0x6e
 805e03b:	68 74 61 06 08       	push   $0x8066174
 805e040:	68 bf 61 06 08       	push   $0x80661bf
 805e045:	e8 66 ab fe ff       	call   8048bb0 <__assert_fail@plt>
						| ide_port_base[4] << 8 | ide_port_base[3];
					disk_idx = sector << 9;
					fseek(disk_fp, disk_idx, SEEK_SET);

					ret = fread((void *)hwa_to_va(addr), byte_cnt, 1, disk_fp);
					assert(ret == 1 || feof(disk_fp));
 805e04a:	68 e9 61 06 08       	push   $0x80661e9
 805e04f:	6a 6b                	push   $0x6b
 805e051:	68 74 61 06 08       	push   $0x8066174
 805e056:	68 a5 61 06 08       	push   $0x80661a5
 805e05b:	e8 50 ab fe ff       	call   8048bb0 <__assert_fail@plt>

0805e060 <init_ide>:
			}
		}
	}
}

void init_ide() {
 805e060:	83 ec 10             	sub    $0x10,%esp
	ide_port_base = add_pio_map(IDE_PORT, 8, ide_io_handler);
 805e063:	68 10 dd 05 08       	push   $0x805dd10
 805e068:	6a 08                	push   $0x8
 805e06a:	68 f0 01 00 00       	push   $0x1f0
 805e06f:	e8 6c f7 ff ff       	call   805d7e0 <add_pio_map>
	ide_port_base[7] = 0x40;

	bmr_base = add_pio_map(BMR_PORT, 8, bmr_io_handler);
 805e074:	83 c4 0c             	add    $0xc,%esp
	}
}

void init_ide() {
	ide_port_base = add_pio_map(IDE_PORT, 8, ide_io_handler);
	ide_port_base[7] = 0x40;
 805e077:	c6 40 07 40          	movb   $0x40,0x7(%eax)
		}
	}
}

void init_ide() {
	ide_port_base = add_pio_map(IDE_PORT, 8, ide_io_handler);
 805e07b:	a3 70 84 0c 08       	mov    %eax,0x80c8470
	ide_port_base[7] = 0x40;

	bmr_base = add_pio_map(BMR_PORT, 8, bmr_io_handler);
 805e080:	68 20 df 05 08       	push   $0x805df20
 805e085:	6a 08                	push   $0x8
 805e087:	68 40 c0 00 00       	push   $0xc040
 805e08c:	e8 4f f7 ff ff       	call   805d7e0 <add_pio_map>
	bmr_base[0] = 0;
 805e091:	c6 00 00             	movb   $0x0,(%eax)

void init_ide() {
	ide_port_base = add_pio_map(IDE_PORT, 8, ide_io_handler);
	ide_port_base[7] = 0x40;

	bmr_base = add_pio_map(BMR_PORT, 8, bmr_io_handler);
 805e094:	a3 6c 84 0c 08       	mov    %eax,0x80c846c
	bmr_base[0] = 0;

	extern char *exec_file;
	disk_fp = fopen(exec_file, "r+");
 805e099:	5a                   	pop    %edx
 805e09a:	59                   	pop    %ecx
 805e09b:	68 d5 61 06 08       	push   $0x80661d5
 805e0a0:	ff 35 2c 5d 07 08    	pushl  0x8075d2c
 805e0a6:	e8 35 aa fe ff       	call   8048ae0 <fopen@plt>
	Assert(disk_fp, "Can not open '%s'", exec_file);
 805e0ab:	83 c4 10             	add    $0x10,%esp
 805e0ae:	85 c0                	test   %eax,%eax

	bmr_base = add_pio_map(BMR_PORT, 8, bmr_io_handler);
	bmr_base[0] = 0;

	extern char *exec_file;
	disk_fp = fopen(exec_file, "r+");
 805e0b0:	a3 58 84 0c 08       	mov    %eax,0x80c8458
	Assert(disk_fp, "Can not open '%s'", exec_file);
 805e0b5:	74 09                	je     805e0c0 <init_ide+0x60>
}
 805e0b7:	83 c4 0c             	add    $0xc,%esp
 805e0ba:	c3                   	ret    
 805e0bb:	90                   	nop
 805e0bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
	bmr_base = add_pio_map(BMR_PORT, 8, bmr_io_handler);
	bmr_base[0] = 0;

	extern char *exec_file;
	disk_fp = fopen(exec_file, "r+");
	Assert(disk_fp, "Can not open '%s'", exec_file);
 805e0c0:	83 ec 0c             	sub    $0xc,%esp
 805e0c3:	ff 35 20 5d 07 08    	pushl  0x8075d20
 805e0c9:	e8 92 a8 fe ff       	call   8048960 <fflush@plt>
 805e0ce:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805e0d4:	6a 07                	push   $0x7
 805e0d6:	6a 01                	push   $0x1
 805e0d8:	68 92 e8 05 08       	push   $0x805e892
 805e0dd:	e8 2e a9 fe ff       	call   8048a10 <fwrite@plt>
 805e0e2:	83 c4 1c             	add    $0x1c,%esp
 805e0e5:	ff 35 2c 5d 07 08    	pushl  0x8075d2c
 805e0eb:	68 d6 e8 05 08       	push   $0x805e8d6
 805e0f0:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805e0f6:	e8 c5 a9 fe ff       	call   8048ac0 <fprintf@plt>
 805e0fb:	ff 35 00 5d 07 08    	pushl  0x8075d00
 805e101:	6a 05                	push   $0x5
 805e103:	6a 01                	push   $0x1
 805e105:	68 42 f3 05 08       	push   $0x805f342
 805e10a:	e8 01 a9 fe ff       	call   8048a10 <fwrite@plt>
 805e10f:	a1 58 84 0c 08       	mov    0x80c8458,%eax
 805e114:	83 c4 20             	add    $0x20,%esp
 805e117:	85 c0                	test   %eax,%eax
 805e119:	75 9c                	jne    805e0b7 <init_ide+0x57>
 805e11b:	68 e0 61 06 08       	push   $0x80661e0
 805e120:	68 86 00 00 00       	push   $0x86
 805e125:	68 74 61 06 08       	push   $0x8066174
 805e12a:	68 d8 61 06 08       	push   $0x80661d8
 805e12f:	e8 7c aa fe ff       	call   8048bb0 <__assert_fail@plt>
 805e134:	66 90                	xchg   %ax,%ax
 805e136:	66 90                	xchg   %ax,%ax
 805e138:	66 90                	xchg   %ax,%ax
 805e13a:	66 90                	xchg   %ax,%ax
 805e13c:	66 90                	xchg   %ax,%ax
 805e13e:	66 90                	xchg   %ax,%ax

0805e140 <__divdi3>:
 805e140:	55                   	push   %ebp
 805e141:	57                   	push   %edi
 805e142:	56                   	push   %esi
 805e143:	83 ec 20             	sub    $0x20,%esp
 805e146:	8b 44 24 34          	mov    0x34(%esp),%eax
 805e14a:	8b 6c 24 30          	mov    0x30(%esp),%ebp
 805e14e:	8b 4c 24 3c          	mov    0x3c(%esp),%ecx
 805e152:	8b 7c 24 38          	mov    0x38(%esp),%edi
 805e156:	89 6c 24 08          	mov    %ebp,0x8(%esp)
 805e15a:	31 ed                	xor    %ebp,%ebp
 805e15c:	85 c0                	test   %eax,%eax
 805e15e:	89 ce                	mov    %ecx,%esi
 805e160:	89 44 24 0c          	mov    %eax,0xc(%esp)
 805e164:	0f 88 f6 00 00 00    	js     805e260 <__divdi3+0x120>
 805e16a:	85 f6                	test   %esi,%esi
 805e16c:	89 f8                	mov    %edi,%eax
 805e16e:	89 ca                	mov    %ecx,%edx
 805e170:	0f 88 da 00 00 00    	js     805e250 <__divdi3+0x110>
 805e176:	8b 74 24 08          	mov    0x8(%esp),%esi
 805e17a:	8b 7c 24 0c          	mov    0xc(%esp),%edi
 805e17e:	85 d2                	test   %edx,%edx
 805e180:	89 44 24 18          	mov    %eax,0x18(%esp)
 805e184:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 805e188:	89 74 24 1c          	mov    %esi,0x1c(%esp)
 805e18c:	89 fe                	mov    %edi,%esi
 805e18e:	89 c7                	mov    %eax,%edi
 805e190:	75 1e                	jne    805e1b0 <__divdi3+0x70>
 805e192:	39 f0                	cmp    %esi,%eax
 805e194:	0f 86 86 00 00 00    	jbe    805e220 <__divdi3+0xe0>
 805e19a:	8b 4c 24 1c          	mov    0x1c(%esp),%ecx
 805e19e:	89 f2                	mov    %esi,%edx
 805e1a0:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 805e1a7:	00 
 805e1a8:	89 c8                	mov    %ecx,%eax
 805e1aa:	f7 f7                	div    %edi
 805e1ac:	89 c1                	mov    %eax,%ecx
 805e1ae:	eb 0e                	jmp    805e1be <__divdi3+0x7e>
 805e1b0:	39 f2                	cmp    %esi,%edx
 805e1b2:	76 44                	jbe    805e1f8 <__divdi3+0xb8>
 805e1b4:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 805e1bb:	00 
 805e1bc:	31 c9                	xor    %ecx,%ecx
 805e1be:	31 c0                	xor    %eax,%eax
 805e1c0:	85 ed                	test   %ebp,%ebp
 805e1c2:	0f 95 c0             	setne  %al
 805e1c5:	31 d2                	xor    %edx,%edx
 805e1c7:	89 c7                	mov    %eax,%edi
 805e1c9:	89 d5                	mov    %edx,%ebp
 805e1cb:	f7 df                	neg    %edi
 805e1cd:	83 d5 00             	adc    $0x0,%ebp
 805e1d0:	89 7c 24 08          	mov    %edi,0x8(%esp)
 805e1d4:	33 4c 24 08          	xor    0x8(%esp),%ecx
 805e1d8:	f7 dd                	neg    %ebp
 805e1da:	89 6c 24 0c          	mov    %ebp,0xc(%esp)
 805e1de:	89 ce                	mov    %ecx,%esi
 805e1e0:	8b 4c 24 0c          	mov    0xc(%esp),%ecx
 805e1e4:	33 4c 24 14          	xor    0x14(%esp),%ecx
 805e1e8:	01 f0                	add    %esi,%eax
 805e1ea:	11 ca                	adc    %ecx,%edx
 805e1ec:	83 c4 20             	add    $0x20,%esp
 805e1ef:	5e                   	pop    %esi
 805e1f0:	5f                   	pop    %edi
 805e1f1:	5d                   	pop    %ebp
 805e1f2:	c3                   	ret    
 805e1f3:	90                   	nop
 805e1f4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805e1f8:	0f bd c2             	bsr    %edx,%eax
 805e1fb:	83 f0 1f             	xor    $0x1f,%eax
 805e1fe:	89 44 24 14          	mov    %eax,0x14(%esp)
 805e202:	75 7c                	jne    805e280 <__divdi3+0x140>
 805e204:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
 805e208:	39 7c 24 18          	cmp    %edi,0x18(%esp)
 805e20c:	76 06                	jbe    805e214 <__divdi3+0xd4>
 805e20e:	31 c9                	xor    %ecx,%ecx
 805e210:	39 f2                	cmp    %esi,%edx
 805e212:	73 aa                	jae    805e1be <__divdi3+0x7e>
 805e214:	b9 01 00 00 00       	mov    $0x1,%ecx
 805e219:	eb a3                	jmp    805e1be <__divdi3+0x7e>
 805e21b:	90                   	nop
 805e21c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805e220:	85 c0                	test   %eax,%eax
 805e222:	75 0b                	jne    805e22f <__divdi3+0xef>
 805e224:	b8 01 00 00 00       	mov    $0x1,%eax
 805e229:	31 d2                	xor    %edx,%edx
 805e22b:	f7 f7                	div    %edi
 805e22d:	89 c7                	mov    %eax,%edi
 805e22f:	89 f0                	mov    %esi,%eax
 805e231:	31 d2                	xor    %edx,%edx
 805e233:	f7 f7                	div    %edi
 805e235:	89 c6                	mov    %eax,%esi
 805e237:	89 c8                	mov    %ecx,%eax
 805e239:	89 74 24 14          	mov    %esi,0x14(%esp)
 805e23d:	f7 f7                	div    %edi
 805e23f:	89 c1                	mov    %eax,%ecx
 805e241:	e9 78 ff ff ff       	jmp    805e1be <__divdi3+0x7e>
 805e246:	8d 76 00             	lea    0x0(%esi),%esi
 805e249:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 805e250:	f7 d8                	neg    %eax
 805e252:	f7 d5                	not    %ebp
 805e254:	83 d2 00             	adc    $0x0,%edx
 805e257:	f7 da                	neg    %edx
 805e259:	e9 18 ff ff ff       	jmp    805e176 <__divdi3+0x36>
 805e25e:	66 90                	xchg   %ax,%ax
 805e260:	f7 5c 24 08          	negl   0x8(%esp)
 805e264:	bd ff ff ff ff       	mov    $0xffffffff,%ebp
 805e269:	83 54 24 0c 00       	adcl   $0x0,0xc(%esp)
 805e26e:	f7 5c 24 0c          	negl   0xc(%esp)
 805e272:	e9 f3 fe ff ff       	jmp    805e16a <__divdi3+0x2a>
 805e277:	89 f6                	mov    %esi,%esi
 805e279:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 805e280:	89 d7                	mov    %edx,%edi
 805e282:	8b 54 24 14          	mov    0x14(%esp),%edx
 805e286:	b8 20 00 00 00       	mov    $0x20,%eax
 805e28b:	29 d0                	sub    %edx,%eax
 805e28d:	89 d1                	mov    %edx,%ecx
 805e28f:	8b 54 24 18          	mov    0x18(%esp),%edx
 805e293:	d3 e7                	shl    %cl,%edi
 805e295:	89 c1                	mov    %eax,%ecx
 805e297:	d3 ea                	shr    %cl,%edx
 805e299:	89 d1                	mov    %edx,%ecx
 805e29b:	8b 54 24 18          	mov    0x18(%esp),%edx
 805e29f:	09 f9                	or     %edi,%ecx
 805e2a1:	8b 7c 24 14          	mov    0x14(%esp),%edi
 805e2a5:	89 4c 24 08          	mov    %ecx,0x8(%esp)
 805e2a9:	89 f9                	mov    %edi,%ecx
 805e2ab:	d3 e2                	shl    %cl,%edx
 805e2ad:	89 c1                	mov    %eax,%ecx
 805e2af:	89 54 24 18          	mov    %edx,0x18(%esp)
 805e2b3:	89 f2                	mov    %esi,%edx
 805e2b5:	d3 ea                	shr    %cl,%edx
 805e2b7:	89 f9                	mov    %edi,%ecx
 805e2b9:	8b 7c 24 1c          	mov    0x1c(%esp),%edi
 805e2bd:	d3 e6                	shl    %cl,%esi
 805e2bf:	89 c1                	mov    %eax,%ecx
 805e2c1:	d3 ef                	shr    %cl,%edi
 805e2c3:	09 fe                	or     %edi,%esi
 805e2c5:	89 f0                	mov    %esi,%eax
 805e2c7:	f7 74 24 08          	divl   0x8(%esp)
 805e2cb:	89 d6                	mov    %edx,%esi
 805e2cd:	89 c7                	mov    %eax,%edi
 805e2cf:	f7 64 24 18          	mull   0x18(%esp)
 805e2d3:	39 d6                	cmp    %edx,%esi
 805e2d5:	89 54 24 08          	mov    %edx,0x8(%esp)
 805e2d9:	72 25                	jb     805e300 <__divdi3+0x1c0>
 805e2db:	0f b6 4c 24 14       	movzbl 0x14(%esp),%ecx
 805e2e0:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 805e2e4:	d3 e2                	shl    %cl,%edx
 805e2e6:	39 c2                	cmp    %eax,%edx
 805e2e8:	73 06                	jae    805e2f0 <__divdi3+0x1b0>
 805e2ea:	3b 74 24 08          	cmp    0x8(%esp),%esi
 805e2ee:	74 10                	je     805e300 <__divdi3+0x1c0>
 805e2f0:	89 f9                	mov    %edi,%ecx
 805e2f2:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 805e2f9:	00 
 805e2fa:	e9 bf fe ff ff       	jmp    805e1be <__divdi3+0x7e>
 805e2ff:	90                   	nop
 805e300:	8d 4f ff             	lea    -0x1(%edi),%ecx
 805e303:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
 805e30a:	00 
 805e30b:	e9 ae fe ff ff       	jmp    805e1be <__divdi3+0x7e>

0805e310 <__moddi3>:
 805e310:	55                   	push   %ebp
 805e311:	57                   	push   %edi
 805e312:	56                   	push   %esi
 805e313:	83 ec 30             	sub    $0x30,%esp
 805e316:	8b 54 24 44          	mov    0x44(%esp),%edx
 805e31a:	8b 44 24 40          	mov    0x40(%esp),%eax
 805e31e:	8b 6c 24 48          	mov    0x48(%esp),%ebp
 805e322:	8b 4c 24 4c          	mov    0x4c(%esp),%ecx
 805e326:	85 d2                	test   %edx,%edx
 805e328:	0f 88 12 01 00 00    	js     805e440 <__moddi3+0x130>
 805e32e:	89 44 24 08          	mov    %eax,0x8(%esp)
 805e332:	89 54 24 0c          	mov    %edx,0xc(%esp)
 805e336:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
 805e33d:	00 
 805e33e:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 805e345:	00 
 805e346:	c7 44 24 20 00 00 00 	movl   $0x0,0x20(%esp)
 805e34d:	00 
 805e34e:	c7 44 24 24 00 00 00 	movl   $0x0,0x24(%esp)
 805e355:	00 
 805e356:	89 c8                	mov    %ecx,%eax
 805e358:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
 805e35f:	00 
 805e360:	99                   	cltd   
 805e361:	89 d0                	mov    %edx,%eax
 805e363:	8b 54 24 0c          	mov    0xc(%esp),%edx
 805e367:	c1 e8 1f             	shr    $0x1f,%eax
 805e36a:	89 04 24             	mov    %eax,(%esp)
 805e36d:	8b 44 24 08          	mov    0x8(%esp),%eax
 805e371:	89 54 24 14          	mov    %edx,0x14(%esp)
 805e375:	8b 54 24 04          	mov    0x4(%esp),%edx
 805e379:	89 44 24 28          	mov    %eax,0x28(%esp)
 805e37d:	8b 04 24             	mov    (%esp),%eax
 805e380:	f7 d8                	neg    %eax
 805e382:	83 d2 00             	adc    $0x0,%edx
 805e385:	31 c5                	xor    %eax,%ebp
 805e387:	f7 da                	neg    %edx
 805e389:	89 e8                	mov    %ebp,%eax
 805e38b:	89 d5                	mov    %edx,%ebp
 805e38d:	31 cd                	xor    %ecx,%ebp
 805e38f:	03 04 24             	add    (%esp),%eax
 805e392:	89 ea                	mov    %ebp,%edx
 805e394:	13 54 24 04          	adc    0x4(%esp),%edx
 805e398:	89 04 24             	mov    %eax,(%esp)
 805e39b:	89 c5                	mov    %eax,%ebp
 805e39d:	89 c7                	mov    %eax,%edi
 805e39f:	89 d1                	mov    %edx,%ecx
 805e3a1:	89 c2                	mov    %eax,%edx
 805e3a3:	8b 44 24 14          	mov    0x14(%esp),%eax
 805e3a7:	89 ce                	mov    %ecx,%esi
 805e3a9:	89 4c 24 04          	mov    %ecx,0x4(%esp)
 805e3ad:	8b 4c 24 08          	mov    0x8(%esp),%ecx
 805e3b1:	85 f6                	test   %esi,%esi
 805e3b3:	75 1b                	jne    805e3d0 <__moddi3+0xc0>
 805e3b5:	39 c2                	cmp    %eax,%edx
 805e3b7:	76 67                	jbe    805e420 <__moddi3+0x110>
 805e3b9:	8b 44 24 28          	mov    0x28(%esp),%eax
 805e3bd:	8b 54 24 14          	mov    0x14(%esp),%edx
 805e3c1:	f7 34 24             	divl   (%esp)
 805e3c4:	31 c0                	xor    %eax,%eax
 805e3c6:	eb 16                	jmp    805e3de <__moddi3+0xce>
 805e3c8:	90                   	nop
 805e3c9:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805e3d0:	3b 74 24 14          	cmp    0x14(%esp),%esi
 805e3d4:	76 2a                	jbe    805e400 <__moddi3+0xf0>
 805e3d6:	8b 54 24 08          	mov    0x8(%esp),%edx
 805e3da:	8b 44 24 14          	mov    0x14(%esp),%eax
 805e3de:	8b 4c 24 20          	mov    0x20(%esp),%ecx
 805e3e2:	31 d1                	xor    %edx,%ecx
 805e3e4:	8b 54 24 1c          	mov    0x1c(%esp),%edx
 805e3e8:	89 ce                	mov    %ecx,%esi
 805e3ea:	8b 4c 24 24          	mov    0x24(%esp),%ecx
 805e3ee:	31 c1                	xor    %eax,%ecx
 805e3f0:	8b 44 24 18          	mov    0x18(%esp),%eax
 805e3f4:	01 f0                	add    %esi,%eax
 805e3f6:	11 ca                	adc    %ecx,%edx
 805e3f8:	83 c4 30             	add    $0x30,%esp
 805e3fb:	5e                   	pop    %esi
 805e3fc:	5f                   	pop    %edi
 805e3fd:	5d                   	pop    %ebp
 805e3fe:	c3                   	ret    
 805e3ff:	90                   	nop
 805e400:	0f bd fe             	bsr    %esi,%edi
 805e403:	83 f7 1f             	xor    $0x1f,%edi
 805e406:	75 70                	jne    805e478 <__moddi3+0x168>
 805e408:	39 ca                	cmp    %ecx,%edx
 805e40a:	0f 86 00 01 00 00    	jbe    805e510 <__moddi3+0x200>
 805e410:	3b 74 24 14          	cmp    0x14(%esp),%esi
 805e414:	0f 82 f6 00 00 00    	jb     805e510 <__moddi3+0x200>
 805e41a:	89 ca                	mov    %ecx,%edx
 805e41c:	eb c0                	jmp    805e3de <__moddi3+0xce>
 805e41e:	66 90                	xchg   %ax,%ax
 805e420:	85 d2                	test   %edx,%edx
 805e422:	75 0b                	jne    805e42f <__moddi3+0x11f>
 805e424:	b8 01 00 00 00       	mov    $0x1,%eax
 805e429:	31 d2                	xor    %edx,%edx
 805e42b:	f7 f5                	div    %ebp
 805e42d:	89 c7                	mov    %eax,%edi
 805e42f:	8b 44 24 14          	mov    0x14(%esp),%eax
 805e433:	31 d2                	xor    %edx,%edx
 805e435:	f7 f7                	div    %edi
 805e437:	89 c8                	mov    %ecx,%eax
 805e439:	f7 f7                	div    %edi
 805e43b:	31 c0                	xor    %eax,%eax
 805e43d:	eb 9f                	jmp    805e3de <__moddi3+0xce>
 805e43f:	90                   	nop
 805e440:	f7 d8                	neg    %eax
 805e442:	c7 44 24 18 01 00 00 	movl   $0x1,0x18(%esp)
 805e449:	00 
 805e44a:	c7 44 24 1c 00 00 00 	movl   $0x0,0x1c(%esp)
 805e451:	00 
 805e452:	83 d2 00             	adc    $0x0,%edx
 805e455:	89 44 24 08          	mov    %eax,0x8(%esp)
 805e459:	c7 44 24 20 ff ff ff 	movl   $0xffffffff,0x20(%esp)
 805e460:	ff 
 805e461:	f7 da                	neg    %edx
 805e463:	c7 44 24 24 ff ff ff 	movl   $0xffffffff,0x24(%esp)
 805e46a:	ff 
 805e46b:	89 54 24 0c          	mov    %edx,0xc(%esp)
 805e46f:	e9 e2 fe ff ff       	jmp    805e356 <__moddi3+0x46>
 805e474:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805e478:	b8 20 00 00 00       	mov    $0x20,%eax
 805e47d:	89 f9                	mov    %edi,%ecx
 805e47f:	29 f8                	sub    %edi,%eax
 805e481:	d3 e6                	shl    %cl,%esi
 805e483:	89 c2                	mov    %eax,%edx
 805e485:	89 44 24 2c          	mov    %eax,0x2c(%esp)
 805e489:	89 e8                	mov    %ebp,%eax
 805e48b:	89 d1                	mov    %edx,%ecx
 805e48d:	d3 e8                	shr    %cl,%eax
 805e48f:	89 f9                	mov    %edi,%ecx
 805e491:	09 f0                	or     %esi,%eax
 805e493:	d3 e5                	shl    %cl,%ebp
 805e495:	89 d1                	mov    %edx,%ecx
 805e497:	89 04 24             	mov    %eax,(%esp)
 805e49a:	8b 44 24 14          	mov    0x14(%esp),%eax
 805e49e:	89 6c 24 08          	mov    %ebp,0x8(%esp)
 805e4a2:	89 d5                	mov    %edx,%ebp
 805e4a4:	89 c6                	mov    %eax,%esi
 805e4a6:	89 c2                	mov    %eax,%edx
 805e4a8:	8b 44 24 28          	mov    0x28(%esp),%eax
 805e4ac:	d3 ee                	shr    %cl,%esi
 805e4ae:	89 f9                	mov    %edi,%ecx
 805e4b0:	d3 e2                	shl    %cl,%edx
 805e4b2:	89 e9                	mov    %ebp,%ecx
 805e4b4:	d3 e8                	shr    %cl,%eax
 805e4b6:	89 f9                	mov    %edi,%ecx
 805e4b8:	09 d0                	or     %edx,%eax
 805e4ba:	8b 54 24 28          	mov    0x28(%esp),%edx
 805e4be:	d3 e2                	shl    %cl,%edx
 805e4c0:	89 54 24 14          	mov    %edx,0x14(%esp)
 805e4c4:	89 f2                	mov    %esi,%edx
 805e4c6:	f7 34 24             	divl   (%esp)
 805e4c9:	89 d1                	mov    %edx,%ecx
 805e4cb:	f7 64 24 08          	mull   0x8(%esp)
 805e4cf:	39 d1                	cmp    %edx,%ecx
 805e4d1:	89 c5                	mov    %eax,%ebp
 805e4d3:	89 d6                	mov    %edx,%esi
 805e4d5:	72 0a                	jb     805e4e1 <__moddi3+0x1d1>
 805e4d7:	39 44 24 14          	cmp    %eax,0x14(%esp)
 805e4db:	73 0f                	jae    805e4ec <__moddi3+0x1dc>
 805e4dd:	39 d1                	cmp    %edx,%ecx
 805e4df:	75 0b                	jne    805e4ec <__moddi3+0x1dc>
 805e4e1:	89 d6                	mov    %edx,%esi
 805e4e3:	89 c5                	mov    %eax,%ebp
 805e4e5:	2b 6c 24 08          	sub    0x8(%esp),%ebp
 805e4e9:	1b 34 24             	sbb    (%esp),%esi
 805e4ec:	89 c8                	mov    %ecx,%eax
 805e4ee:	89 f9                	mov    %edi,%ecx
 805e4f0:	8b 54 24 14          	mov    0x14(%esp),%edx
 805e4f4:	29 ea                	sub    %ebp,%edx
 805e4f6:	19 f0                	sbb    %esi,%eax
 805e4f8:	d3 ea                	shr    %cl,%edx
 805e4fa:	0f b6 4c 24 2c       	movzbl 0x2c(%esp),%ecx
 805e4ff:	89 c6                	mov    %eax,%esi
 805e501:	d3 e6                	shl    %cl,%esi
 805e503:	89 f9                	mov    %edi,%ecx
 805e505:	09 f2                	or     %esi,%edx
 805e507:	d3 e8                	shr    %cl,%eax
 805e509:	e9 d0 fe ff ff       	jmp    805e3de <__moddi3+0xce>
 805e50e:	66 90                	xchg   %ax,%ax
 805e510:	8b 44 24 14          	mov    0x14(%esp),%eax
 805e514:	2b 0c 24             	sub    (%esp),%ecx
 805e517:	1b 44 24 04          	sbb    0x4(%esp),%eax
 805e51b:	89 ca                	mov    %ecx,%edx
 805e51d:	e9 bc fe ff ff       	jmp    805e3de <__moddi3+0xce>
 805e522:	66 90                	xchg   %ax,%ax
 805e524:	66 90                	xchg   %ax,%ax
 805e526:	66 90                	xchg   %ax,%ax
 805e528:	66 90                	xchg   %ax,%ax
 805e52a:	66 90                	xchg   %ax,%ax
 805e52c:	66 90                	xchg   %ax,%ax
 805e52e:	66 90                	xchg   %ax,%ax

0805e530 <__udivdi3>:
 805e530:	55                   	push   %ebp
 805e531:	57                   	push   %edi
 805e532:	56                   	push   %esi
 805e533:	83 ec 10             	sub    $0x10,%esp
 805e536:	8b 54 24 2c          	mov    0x2c(%esp),%edx
 805e53a:	8b 7c 24 20          	mov    0x20(%esp),%edi
 805e53e:	8b 74 24 24          	mov    0x24(%esp),%esi
 805e542:	8b 4c 24 28          	mov    0x28(%esp),%ecx
 805e546:	85 d2                	test   %edx,%edx
 805e548:	89 7c 24 04          	mov    %edi,0x4(%esp)
 805e54c:	89 34 24             	mov    %esi,(%esp)
 805e54f:	89 c8                	mov    %ecx,%eax
 805e551:	75 35                	jne    805e588 <__udivdi3+0x58>
 805e553:	39 f1                	cmp    %esi,%ecx
 805e555:	0f 87 bd 00 00 00    	ja     805e618 <__udivdi3+0xe8>
 805e55b:	85 c9                	test   %ecx,%ecx
 805e55d:	89 cd                	mov    %ecx,%ebp
 805e55f:	75 0b                	jne    805e56c <__udivdi3+0x3c>
 805e561:	b8 01 00 00 00       	mov    $0x1,%eax
 805e566:	31 d2                	xor    %edx,%edx
 805e568:	f7 f1                	div    %ecx
 805e56a:	89 c5                	mov    %eax,%ebp
 805e56c:	89 f0                	mov    %esi,%eax
 805e56e:	31 d2                	xor    %edx,%edx
 805e570:	f7 f5                	div    %ebp
 805e572:	89 c6                	mov    %eax,%esi
 805e574:	89 f8                	mov    %edi,%eax
 805e576:	f7 f5                	div    %ebp
 805e578:	89 f2                	mov    %esi,%edx
 805e57a:	83 c4 10             	add    $0x10,%esp
 805e57d:	5e                   	pop    %esi
 805e57e:	5f                   	pop    %edi
 805e57f:	5d                   	pop    %ebp
 805e580:	c3                   	ret    
 805e581:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805e588:	3b 14 24             	cmp    (%esp),%edx
 805e58b:	77 7b                	ja     805e608 <__udivdi3+0xd8>
 805e58d:	0f bd f2             	bsr    %edx,%esi
 805e590:	83 f6 1f             	xor    $0x1f,%esi
 805e593:	0f 84 97 00 00 00    	je     805e630 <__udivdi3+0x100>
 805e599:	bd 20 00 00 00       	mov    $0x20,%ebp
 805e59e:	89 d7                	mov    %edx,%edi
 805e5a0:	89 f1                	mov    %esi,%ecx
 805e5a2:	29 f5                	sub    %esi,%ebp
 805e5a4:	d3 e7                	shl    %cl,%edi
 805e5a6:	89 c2                	mov    %eax,%edx
 805e5a8:	89 e9                	mov    %ebp,%ecx
 805e5aa:	d3 ea                	shr    %cl,%edx
 805e5ac:	89 f1                	mov    %esi,%ecx
 805e5ae:	09 fa                	or     %edi,%edx
 805e5b0:	8b 3c 24             	mov    (%esp),%edi
 805e5b3:	d3 e0                	shl    %cl,%eax
 805e5b5:	89 54 24 08          	mov    %edx,0x8(%esp)
 805e5b9:	89 e9                	mov    %ebp,%ecx
 805e5bb:	89 44 24 0c          	mov    %eax,0xc(%esp)
 805e5bf:	8b 44 24 04          	mov    0x4(%esp),%eax
 805e5c3:	89 fa                	mov    %edi,%edx
 805e5c5:	d3 ea                	shr    %cl,%edx
 805e5c7:	89 f1                	mov    %esi,%ecx
 805e5c9:	d3 e7                	shl    %cl,%edi
 805e5cb:	89 e9                	mov    %ebp,%ecx
 805e5cd:	d3 e8                	shr    %cl,%eax
 805e5cf:	09 c7                	or     %eax,%edi
 805e5d1:	89 f8                	mov    %edi,%eax
 805e5d3:	f7 74 24 08          	divl   0x8(%esp)
 805e5d7:	89 d5                	mov    %edx,%ebp
 805e5d9:	89 c7                	mov    %eax,%edi
 805e5db:	f7 64 24 0c          	mull   0xc(%esp)
 805e5df:	39 d5                	cmp    %edx,%ebp
 805e5e1:	89 14 24             	mov    %edx,(%esp)
 805e5e4:	72 11                	jb     805e5f7 <__udivdi3+0xc7>
 805e5e6:	8b 54 24 04          	mov    0x4(%esp),%edx
 805e5ea:	89 f1                	mov    %esi,%ecx
 805e5ec:	d3 e2                	shl    %cl,%edx
 805e5ee:	39 c2                	cmp    %eax,%edx
 805e5f0:	73 5e                	jae    805e650 <__udivdi3+0x120>
 805e5f2:	3b 2c 24             	cmp    (%esp),%ebp
 805e5f5:	75 59                	jne    805e650 <__udivdi3+0x120>
 805e5f7:	8d 47 ff             	lea    -0x1(%edi),%eax
 805e5fa:	31 f6                	xor    %esi,%esi
 805e5fc:	89 f2                	mov    %esi,%edx
 805e5fe:	83 c4 10             	add    $0x10,%esp
 805e601:	5e                   	pop    %esi
 805e602:	5f                   	pop    %edi
 805e603:	5d                   	pop    %ebp
 805e604:	c3                   	ret    
 805e605:	8d 76 00             	lea    0x0(%esi),%esi
 805e608:	31 f6                	xor    %esi,%esi
 805e60a:	31 c0                	xor    %eax,%eax
 805e60c:	89 f2                	mov    %esi,%edx
 805e60e:	83 c4 10             	add    $0x10,%esp
 805e611:	5e                   	pop    %esi
 805e612:	5f                   	pop    %edi
 805e613:	5d                   	pop    %ebp
 805e614:	c3                   	ret    
 805e615:	8d 76 00             	lea    0x0(%esi),%esi
 805e618:	89 f2                	mov    %esi,%edx
 805e61a:	31 f6                	xor    %esi,%esi
 805e61c:	89 f8                	mov    %edi,%eax
 805e61e:	f7 f1                	div    %ecx
 805e620:	89 f2                	mov    %esi,%edx
 805e622:	83 c4 10             	add    $0x10,%esp
 805e625:	5e                   	pop    %esi
 805e626:	5f                   	pop    %edi
 805e627:	5d                   	pop    %ebp
 805e628:	c3                   	ret    
 805e629:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
 805e630:	3b 4c 24 04          	cmp    0x4(%esp),%ecx
 805e634:	76 0b                	jbe    805e641 <__udivdi3+0x111>
 805e636:	31 c0                	xor    %eax,%eax
 805e638:	3b 14 24             	cmp    (%esp),%edx
 805e63b:	0f 83 37 ff ff ff    	jae    805e578 <__udivdi3+0x48>
 805e641:	b8 01 00 00 00       	mov    $0x1,%eax
 805e646:	e9 2d ff ff ff       	jmp    805e578 <__udivdi3+0x48>
 805e64b:	90                   	nop
 805e64c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805e650:	89 f8                	mov    %edi,%eax
 805e652:	31 f6                	xor    %esi,%esi
 805e654:	e9 1f ff ff ff       	jmp    805e578 <__udivdi3+0x48>
 805e659:	66 90                	xchg   %ax,%ax
 805e65b:	66 90                	xchg   %ax,%ax
 805e65d:	66 90                	xchg   %ax,%ax
 805e65f:	90                   	nop

0805e660 <__umoddi3>:
 805e660:	55                   	push   %ebp
 805e661:	57                   	push   %edi
 805e662:	56                   	push   %esi
 805e663:	83 ec 20             	sub    $0x20,%esp
 805e666:	8b 44 24 34          	mov    0x34(%esp),%eax
 805e66a:	8b 4c 24 30          	mov    0x30(%esp),%ecx
 805e66e:	8b 7c 24 38          	mov    0x38(%esp),%edi
 805e672:	89 c6                	mov    %eax,%esi
 805e674:	89 44 24 10          	mov    %eax,0x10(%esp)
 805e678:	8b 44 24 3c          	mov    0x3c(%esp),%eax
 805e67c:	89 4c 24 1c          	mov    %ecx,0x1c(%esp)
 805e680:	89 7c 24 0c          	mov    %edi,0xc(%esp)
 805e684:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 805e688:	89 74 24 18          	mov    %esi,0x18(%esp)
 805e68c:	85 c0                	test   %eax,%eax
 805e68e:	89 c2                	mov    %eax,%edx
 805e690:	75 1e                	jne    805e6b0 <__umoddi3+0x50>
 805e692:	39 f7                	cmp    %esi,%edi
 805e694:	76 52                	jbe    805e6e8 <__umoddi3+0x88>
 805e696:	89 c8                	mov    %ecx,%eax
 805e698:	89 f2                	mov    %esi,%edx
 805e69a:	f7 f7                	div    %edi
 805e69c:	89 d0                	mov    %edx,%eax
 805e69e:	31 d2                	xor    %edx,%edx
 805e6a0:	83 c4 20             	add    $0x20,%esp
 805e6a3:	5e                   	pop    %esi
 805e6a4:	5f                   	pop    %edi
 805e6a5:	5d                   	pop    %ebp
 805e6a6:	c3                   	ret    
 805e6a7:	89 f6                	mov    %esi,%esi
 805e6a9:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 805e6b0:	39 f0                	cmp    %esi,%eax
 805e6b2:	77 5c                	ja     805e710 <__umoddi3+0xb0>
 805e6b4:	0f bd e8             	bsr    %eax,%ebp
 805e6b7:	83 f5 1f             	xor    $0x1f,%ebp
 805e6ba:	75 64                	jne    805e720 <__umoddi3+0xc0>
 805e6bc:	8b 6c 24 14          	mov    0x14(%esp),%ebp
 805e6c0:	39 6c 24 0c          	cmp    %ebp,0xc(%esp)
 805e6c4:	0f 86 f6 00 00 00    	jbe    805e7c0 <__umoddi3+0x160>
 805e6ca:	3b 44 24 18          	cmp    0x18(%esp),%eax
 805e6ce:	0f 82 ec 00 00 00    	jb     805e7c0 <__umoddi3+0x160>
 805e6d4:	8b 44 24 14          	mov    0x14(%esp),%eax
 805e6d8:	8b 54 24 18          	mov    0x18(%esp),%edx
 805e6dc:	83 c4 20             	add    $0x20,%esp
 805e6df:	5e                   	pop    %esi
 805e6e0:	5f                   	pop    %edi
 805e6e1:	5d                   	pop    %ebp
 805e6e2:	c3                   	ret    
 805e6e3:	90                   	nop
 805e6e4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805e6e8:	85 ff                	test   %edi,%edi
 805e6ea:	89 fd                	mov    %edi,%ebp
 805e6ec:	75 0b                	jne    805e6f9 <__umoddi3+0x99>
 805e6ee:	b8 01 00 00 00       	mov    $0x1,%eax
 805e6f3:	31 d2                	xor    %edx,%edx
 805e6f5:	f7 f7                	div    %edi
 805e6f7:	89 c5                	mov    %eax,%ebp
 805e6f9:	8b 44 24 10          	mov    0x10(%esp),%eax
 805e6fd:	31 d2                	xor    %edx,%edx
 805e6ff:	f7 f5                	div    %ebp
 805e701:	89 c8                	mov    %ecx,%eax
 805e703:	f7 f5                	div    %ebp
 805e705:	eb 95                	jmp    805e69c <__umoddi3+0x3c>
 805e707:	89 f6                	mov    %esi,%esi
 805e709:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
 805e710:	89 c8                	mov    %ecx,%eax
 805e712:	89 f2                	mov    %esi,%edx
 805e714:	83 c4 20             	add    $0x20,%esp
 805e717:	5e                   	pop    %esi
 805e718:	5f                   	pop    %edi
 805e719:	5d                   	pop    %ebp
 805e71a:	c3                   	ret    
 805e71b:	90                   	nop
 805e71c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
 805e720:	b8 20 00 00 00       	mov    $0x20,%eax
 805e725:	89 e9                	mov    %ebp,%ecx
 805e727:	29 e8                	sub    %ebp,%eax
 805e729:	d3 e2                	shl    %cl,%edx
 805e72b:	89 c7                	mov    %eax,%edi
 805e72d:	89 44 24 18          	mov    %eax,0x18(%esp)
 805e731:	8b 44 24 0c          	mov    0xc(%esp),%eax
 805e735:	89 f9                	mov    %edi,%ecx
 805e737:	d3 e8                	shr    %cl,%eax
 805e739:	89 c1                	mov    %eax,%ecx
 805e73b:	8b 44 24 0c          	mov    0xc(%esp),%eax
 805e73f:	09 d1                	or     %edx,%ecx
 805e741:	89 fa                	mov    %edi,%edx
 805e743:	89 4c 24 10          	mov    %ecx,0x10(%esp)
 805e747:	89 e9                	mov    %ebp,%ecx
 805e749:	d3 e0                	shl    %cl,%eax
 805e74b:	89 f9                	mov    %edi,%ecx
 805e74d:	89 44 24 0c          	mov    %eax,0xc(%esp)
 805e751:	89 f0                	mov    %esi,%eax
 805e753:	d3 e8                	shr    %cl,%eax
 805e755:	89 e9                	mov    %ebp,%ecx
 805e757:	89 c7                	mov    %eax,%edi
 805e759:	8b 44 24 1c          	mov    0x1c(%esp),%eax
 805e75d:	d3 e6                	shl    %cl,%esi
 805e75f:	89 d1                	mov    %edx,%ecx
 805e761:	89 fa                	mov    %edi,%edx
 805e763:	d3 e8                	shr    %cl,%eax
 805e765:	89 e9                	mov    %ebp,%ecx
 805e767:	09 f0                	or     %esi,%eax
 805e769:	8b 74 24 1c          	mov    0x1c(%esp),%esi
 805e76d:	f7 74 24 10          	divl   0x10(%esp)
 805e771:	d3 e6                	shl    %cl,%esi
 805e773:	89 d1                	mov    %edx,%ecx
 805e775:	f7 64 24 0c          	mull   0xc(%esp)
 805e779:	39 d1                	cmp    %edx,%ecx
 805e77b:	89 74 24 14          	mov    %esi,0x14(%esp)
 805e77f:	89 d7                	mov    %edx,%edi
 805e781:	89 c6                	mov    %eax,%esi
 805e783:	72 0a                	jb     805e78f <__umoddi3+0x12f>
 805e785:	39 44 24 14          	cmp    %eax,0x14(%esp)
 805e789:	73 10                	jae    805e79b <__umoddi3+0x13b>
 805e78b:	39 d1                	cmp    %edx,%ecx
 805e78d:	75 0c                	jne    805e79b <__umoddi3+0x13b>
 805e78f:	89 d7                	mov    %edx,%edi
 805e791:	89 c6                	mov    %eax,%esi
 805e793:	2b 74 24 0c          	sub    0xc(%esp),%esi
 805e797:	1b 7c 24 10          	sbb    0x10(%esp),%edi
 805e79b:	89 ca                	mov    %ecx,%edx
 805e79d:	89 e9                	mov    %ebp,%ecx
 805e79f:	8b 44 24 14          	mov    0x14(%esp),%eax
 805e7a3:	29 f0                	sub    %esi,%eax
 805e7a5:	19 fa                	sbb    %edi,%edx
 805e7a7:	d3 e8                	shr    %cl,%eax
 805e7a9:	0f b6 4c 24 18       	movzbl 0x18(%esp),%ecx
 805e7ae:	89 d7                	mov    %edx,%edi
 805e7b0:	d3 e7                	shl    %cl,%edi
 805e7b2:	89 e9                	mov    %ebp,%ecx
 805e7b4:	09 f8                	or     %edi,%eax
 805e7b6:	d3 ea                	shr    %cl,%edx
 805e7b8:	83 c4 20             	add    $0x20,%esp
 805e7bb:	5e                   	pop    %esi
 805e7bc:	5f                   	pop    %edi
 805e7bd:	5d                   	pop    %ebp
 805e7be:	c3                   	ret    
 805e7bf:	90                   	nop
 805e7c0:	8b 74 24 10          	mov    0x10(%esp),%esi
 805e7c4:	29 f9                	sub    %edi,%ecx
 805e7c6:	19 c6                	sbb    %eax,%esi
 805e7c8:	89 4c 24 14          	mov    %ecx,0x14(%esp)
 805e7cc:	89 74 24 18          	mov    %esi,0x18(%esp)
 805e7d0:	e9 ff fe ff ff       	jmp    805e6d4 <__umoddi3+0x74>
 805e7d5:	66 90                	xchg   %ax,%ax
 805e7d7:	66 90                	xchg   %ax,%ax
 805e7d9:	66 90                	xchg   %ax,%ax
 805e7db:	66 90                	xchg   %ax,%ax
 805e7dd:	66 90                	xchg   %ax,%ax
 805e7df:	90                   	nop

0805e7e0 <__libc_csu_init>:
 805e7e0:	55                   	push   %ebp
 805e7e1:	57                   	push   %edi
 805e7e2:	31 ff                	xor    %edi,%edi
 805e7e4:	56                   	push   %esi
 805e7e5:	53                   	push   %ebx
 805e7e6:	e8 b5 a4 fe ff       	call   8048ca0 <__x86.get_pc_thunk.bx>
 805e7eb:	81 c3 0d 6a 01 00    	add    $0x16a0d,%ebx
 805e7f1:	83 ec 1c             	sub    $0x1c,%esp
 805e7f4:	8b 6c 24 30          	mov    0x30(%esp),%ebp
 805e7f8:	8d b3 04 ff ff ff    	lea    -0xfc(%ebx),%esi
 805e7fe:	e8 01 a1 fe ff       	call   8048904 <_init>
 805e803:	8d 83 00 ff ff ff    	lea    -0x100(%ebx),%eax
 805e809:	29 c6                	sub    %eax,%esi
 805e80b:	c1 fe 02             	sar    $0x2,%esi
 805e80e:	85 f6                	test   %esi,%esi
 805e810:	74 27                	je     805e839 <__libc_csu_init+0x59>
 805e812:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
 805e818:	8b 44 24 38          	mov    0x38(%esp),%eax
 805e81c:	89 2c 24             	mov    %ebp,(%esp)
 805e81f:	89 44 24 08          	mov    %eax,0x8(%esp)
 805e823:	8b 44 24 34          	mov    0x34(%esp),%eax
 805e827:	89 44 24 04          	mov    %eax,0x4(%esp)
 805e82b:	ff 94 bb 00 ff ff ff 	call   *-0x100(%ebx,%edi,4)
 805e832:	83 c7 01             	add    $0x1,%edi
 805e835:	39 f7                	cmp    %esi,%edi
 805e837:	75 df                	jne    805e818 <__libc_csu_init+0x38>
 805e839:	83 c4 1c             	add    $0x1c,%esp
 805e83c:	5b                   	pop    %ebx
 805e83d:	5e                   	pop    %esi
 805e83e:	5f                   	pop    %edi
 805e83f:	5d                   	pop    %ebp
 805e840:	c3                   	ret    
 805e841:	eb 0d                	jmp    805e850 <__libc_csu_fini>
 805e843:	90                   	nop
 805e844:	90                   	nop
 805e845:	90                   	nop
 805e846:	90                   	nop
 805e847:	90                   	nop
 805e848:	90                   	nop
 805e849:	90                   	nop
 805e84a:	90                   	nop
 805e84b:	90                   	nop
 805e84c:	90                   	nop
 805e84d:	90                   	nop
 805e84e:	90                   	nop
 805e84f:	90                   	nop

0805e850 <__libc_csu_fini>:
 805e850:	f3 c3                	repz ret 

Disassembly of section .fini:

0805e854 <_fini>:
 805e854:	53                   	push   %ebx
 805e855:	83 ec 08             	sub    $0x8,%esp
 805e858:	e8 43 a4 fe ff       	call   8048ca0 <__x86.get_pc_thunk.bx>
 805e85d:	81 c3 9b 69 01 00    	add    $0x1699b,%ebx
 805e863:	83 c4 08             	add    $0x8,%esp
 805e866:	5b                   	pop    %ebx
 805e867:	c3                   	ret    
